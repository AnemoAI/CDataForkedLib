# Начало работы с командной строкой Linux и оболочкой



# Введение 
Представьте, что вы только что запустили новое задание в качестве системного администратора (sysadmin) в Northwind, компании высокочастотного трейдинга (HFT), в которой на клиентских компьютерах работает Windows, а на серверах — Linux. Компьютеры — это кровеносная система компании, и вам нужны дополнительные сведения об управлении окнами Linux. Пришло время освоить новые навыки!

Bash — это стандартный скриптовый язык оболочки для Linux. Давайте познакомимся с основами Bash, начиная с синтаксиса и наиболее распространенных команд, таких как ls и cat.

# Цели обучения
Изучив этот модуль, вы сможете:
+ Что такое оболочки и краткое описание Bash
+ Сведения о синтаксисе команд Bash
+ Самые важные команды Bash, такие как ls, cat и ps
+ Использование операторов ввода-вывода для перенаправления входных и выходных данных
+ Порядок обновления операционной системы сервера
+ Порядок поиска и завершения посторонних процессов
+ Использование Bash для фильтрации выходных данных Azure CLI

# Что такое Bash?

Bash — это важный инструмент для управления компьютерами Linux. Это имя представляет собой сокращение от "Bourne Again Shell".

Оболочка — это программа, которая приказывает операционной системе выполнять действия. Вы можете вводить команды в консоли на своем компьютере и выполнять их напрямую или использовать скрипты для выполнения пакетов команд. Оболочки, такие как PowerShell и Bash, предоставляют системным администраторам мощность и четкость, необходимую для точной настройки управления компьютерами, за которые они отвечают.

Существуют и другие оболочки Linux, в том числе `csh` и `zsh`, но `Bash` стала стандартом для Linux. Это связано с тем, что Bash совместим с первой серьезной оболочкой Unix, оболочкой Борна, также известной как `sh`. `Bash` включает лучшие функции своих предшественников. Но `Bash` также обладает некоторыми собственными функциями, в том числе встроенными командами и возможностью вызова внешних программ.

Одной из причин успеха оболочки `Bash` является ее простота. `Bash`, как и остальная часть Linux, построена на принципах проектирования Unix. Как резюмировал Питер Салус в своей книге Четверть века Unix, в Unix воплощены три "главных замысла":
+ Программы делают что-то одно и делают это хорошо
+ Программы работают вместе
+ Программы используют текстовые потоки в качестве универсального интерфейса

Последняя часть — ключ к пониманию принципов работы Bash. В Unix и Linux все является файлами. Это означает, что вы можете использовать одни и те же команды, не думая о том, поступает ли поток ввода-вывода с клавиатуры, из файла на диске, сокета, канала или от другого абстрактного источника ввода-вывода.

Давайте познакомимся с основами Bash, начиная с синтаксиса и наиболее распространенных команд, таких как ls и cat.

# Основные сведения о Bash

Изучение Bash начинается с изучения синтаксиса Bash. Изучив синтаксис, вы сможете использовать его при выполнении любой команды Bash.

Полный синтаксис команды Bash:

```bash
command [options] [arguments]
```

Bash обрабатывает первую найденную строку как команду. В следующей команде используется команда Bash `ls` (от "list" — "список") для вывода содержимого текущего рабочего каталога:

```bash
ls
```

Команды Bash часто дополняются аргументами. Например, в команде `ls` можно указать имя пути, чтобы вывести содержимое другого каталога:

```bash
ls /etc
```

Большинство команд Bash имеют параметры, позволяющие изменить порядок их работы. Эти параметры, также называемые флагами, предоставляют командам уточняющие указания. Например, файлы и каталоги, имена которых начинаются с точки, скрыты от пользователя и не отображаются командой `ls`. Однако в команде `ls` можно включить флаг `-a` (от "all" — "все"), чтобы просмотреть все объекты в целевом каталоге:

```bash
ls -al /etc
```

Bash отличается лаконичностью. Иногда просто поражает (и является особым предметом гордости среди любителей Bash), как много можно достичь с помощью всего одной команды.

## Справка

С разными командами можно (или нужно) использовать разные параметры и аргументы. Поэтому для удобства документация Bash встроена в операционную систему. Справка всегда рядом с командой. Чтобы узнать о параметрах для команды, используйте команду `man` (от "manual" — "руководство"). Например, чтобы просмотреть все параметры для команды `mkdir` ("make directory"), введите следующее:

```bash
man mkdir
```

Команда `man` станет вашим лучшим другом при изучении Bash. С помощью `man` вы сможете найти всю информацию, необходимую для понимания принципов работы любой команды.

Большинство команд Bash и Linux поддерживают параметр `--help`. С его помощью можно получить описание синтаксиса и параметров команды. Например, введите `mkdir --help`. Результат будет выглядеть примерно следующим образом:

``` bash
Usage: mkdir [OPTION]... DIRECTORY...
Create the DIRECTORY(ies), if they do not already exist.
    
Mandatory arguments to long options are mandatory for short options too.
  -m, --mode=MODE   set file mode (as in chmod), not a=rwx - umask
  -p, --parents     no error if existing, make parent directories as needed
  -v, --verbose     print a message for each created directory
  -Z                   set SELinux security context of each created directory
                         to the default type
      --context[=CTX]  like -Z, or if CTX is specified then set the SELinux
                         or SMACK security context to CTX
      --help     display this help and exit
      --version  output version information and exit
    
GNU coreutils online help: <http://www.gnu.org/software/coreutils/>
Report mkdir translation bugs to <http://translationproject.org/team/>
Full documentation at: <http://www.gnu.org/software/coreutils/mkdir>
or available locally via: info '(coreutils) mkdir invocation'
```

Справка, полученная таким способом, обычно более краткая, чем справка, полученная с помощью команды `man`.

## Использование подстановочных знаков
Подстановочные знаки — это символы, представляющие один или несколько символов в командах Bash. Самый распространенный подстановочный знак — звездочка. Она представляет отсутствие символов или последовательность символов. Предположим, что в текущем каталоге содержится несколько сотен файлов изображений, но вы хотите увидеть только PNG-файлы, т. е. файлы, имена которых оканчиваются на .png. Вы можете получить список только таких файлов с помощью следующей команды:

```bash
ls *.png
```

![01](/Materials/Bash/Pictures/01_01.PNG)

Теперь предположим, что текущий каталог содержит также и JPEG-файлы. Некоторые заканчиваются на `.jpg`, другие — на `.jpeg`. Вот один из способов составления списка всех JPEG-файлов:

```bash
ls *.jpg *.jpeg
```

А вот другой способ:

```bash
ls *.jp*g
```

Подстановочный знак `*` представляет от `0` до любого числа символов, но подстановочный знак `?` представляет один символ. Если в текущем каталоге содержатся файлы с именами 0001. jpg, 0002. jpg и т. д. до 0009. jpg, следующая команда выведет все эти файлы:

```bash
ls 000?.jpg
```

Для фильтрации выходных данных с помощью подстановочных знаков вы также можете использовать квадратные скобки, которые обозначают группы символов. Следующая команда выводит список всех файлов в текущем каталоге, в именах которых содержится точка и сразу следом за ней строчная буква J или P. Эта команда выведет список всех файлов с расширениями .jpg, .jpeg и .png, но не файлы с расширением .gif:

```bash
ls *.[jp]*
```

В Linux учитывается регистр имен файлов и команд, которые с ними работают. Таким образом, чтобы вывести список всех файлов в текущем каталоге, в именах которых содержится точка и сразу следом за ней прописная или строчная буква J или P, необходимо использовать следующую команду:

```bash
ls *.[jpJP]*
```

Выражения в квадратных скобках могут представлять диапазоны символов. Например, следующая команда выводит список всех файлов в текущем каталоге, имена которых начинаются со строчной буквы:

```bash
ls [a-z]*
```

Эта команда, наоборот, выводит список всех файлов в текущем каталоге, имена которых начинаются с прописной буквы:

```bash
ls [A-Z]*
```

И, наконец, эта команда выводит список всех файлов в текущем каталоге, имена которых начинаются со строчной или прописной буквы:

```bash
ls [a-zA-Z]*
```

Исходя из всего вышесказанного, сможете ли вы догадаться, что будут делать следующие команды?

```bash
ls [0-9]*
ls *[0-9]*
ls *[0-9]
```

Если вам нужно использовать один из подстановочных знаков в качестве обычного символа, сделайте его литералом или escape-символом, добавив обратную косую черту. Например, если по каким-то причинам в имени файла содержится звездочка (то, что никогда не следует делать преднамеренно), можно найти этот файл с помощью следующей команды.

```bash
$ ls *\**
```

# Команды и операторы Bash

В каждом языке оболочки имеются свои наиболее используемые команды. Давайте начнем создание вашей системы команд Bash с изучения самых распространенных команд.

## Команды Bash

Рассмотрим распространенные команды Bash и способы их использования.

### Команда ls
Команда ls выводит содержимое текущего каталога или каталога, указанного в аргументе. Эта команда без аргументов выдает список всех файлов и подкаталогов текущего каталога:

```Bash
ls
```

Файлы и каталоги, имена которых начинаются с точки, по умолчанию скрыты. Чтобы включить их в список каталога, используйте флаг `-a`:

```Bash
ls -a
```

Чтобы получить больше сведений о файлах и подкаталогах в текущем каталоге, используйте флаг `-l`:

```Bash
ls -l
```

Ниже приведен пример выходных данных из каталога, содержащего несколько JPEG-файлов и PNG-файлов, а также подкаталог с именем __gifs__.

```bash
-rw-rw-r-- 1 azureuser azureuser  473774 Jun 13 15:38 0001.png
-rw-rw-r-- 1 azureuser azureuser 1557965 Jun 13 14:43 0002.jpg
-rw-rw-r-- 1 azureuser azureuser  473774 Mar 26 09:21 0003.png
-rw-rw-r-- 1 azureuser azureuser 4193680 Jun 13 09:40 0004.jpg
-rw-rw-r-- 1 azureuser azureuser  423325 Jun 10 12:53 0005.jpg
-rw-rw-r-- 1 azureuser azureuser 2278001 Jun 12 04:21 0006.jpg
-rw-rw-r-- 1 azureuser azureuser 1220517 Jun 13 14:44 0007.jpg
drwxrwxr-x 2 azureuser azureuser    4096 Jun 13 20:16 gifs
```
В каждой строке предоставлены более подробные сведения о соответствующем файле или каталоге. Эти сведения включают назначенные разрешения, владельца, размер в байтах, время последнего изменения, а также имя файла или каталога.

### Команда cat
Предположим, вам нужно увидеть, что находится внутри файла. Для этого можно использовать команду cat. Результаты этой команды вряд ли будут иметь особый смысл, если это не текстовый файл. Следующая команда отображает содержимое файла os-release, который находится в каталоге /etc:

```Bash
cat /etc/os-release
```

Это полезная команда, так как в ее результатах указывается, какой дистрибутив Linux вы используете:

```bash
NAME="Ubuntu"
VERSION="18.04.2 LTS (Bionic Beaver)"
ID=ubuntu
ID_LIKE=debian
PRETTY_NAME="Ubuntu 18.04.2 LTS"
VERSION_ID="18.04"
HOME_URL="https://www.ubuntu.com/"
SUPPORT_URL="https://help.ubuntu.com/"
BUG_REPORT_URL="https://bugs.launchpad.net/ubuntu/"
PRIVACY_POLICY_URL="https://www.ubuntu.com/legal/terms-and-policies/privacy-policy"
VERSION_CODENAME=bionic
UBUNTU_CODENAME=bionic
```

Каталог `/etc` — это особый каталог в Linux. В нем содержатся файлы конфигурации системы. Не следует удалять файлы из этого каталога, если вы не знаете точно, что делаете.

### Команда sudo
Некоторые команды Bash может выполнять только привилегированный пользователь — системный администратор или суперпользователь. При попытке выполнить одну из этих команд без достаточных привилегий произойдет сбой. Например, только пользователи, вошедшие в качестве суперпользователя, могут использовать команду `cat` для вывода содержимого файла `/etc/at.deny`:

```Bash
cat /etc/at.deny
```

`at.deny` — это специальный файл, который определяет, кто может использовать другие команды Bash, чтобы отправлять задания для последующего выполнения.

Не следует работать от имени привилегированного пользователя большую часть времени, так как это слишком опасно. Чтобы выполнить команду, для которой требуются права администратора, без входа в качестве суперпользователя, укажите sudo перед этой командой:

```Bash
sudo cat /etc/at.deny
```

`sudo` расшифровывается как "superuser do" (выполнить от имени суперпользователя). Используя sudo, вы сообщаете оболочке, что для этой одной команды действуете с правами привилегированного пользователя.

### Команды cd, mkdir и rmdir
Команда cd означает "change directory" (изменить каталог). Ее действие полностью соответствует имени: она изменяет текущий каталог на другой. С ее помощью вы можете перемещаться из одного каталога в другой, как с помощью ее аналога в Windows. Следующая команда перемещает из текущего каталога в его подкаталог с именем orders:

```Bash
cd orders
```

Чтобы перейти в каталог уровнем выше, укажите `..` в качестве имени каталога:

```Bash
cd ..
```

Эта команда выполняет перемещение в домашний каталог — тот, где вы оказываетесь при изначальном входе в систему:

```Bash
cd ~
```

С помощью команды `mkdir` можно создавать каталоги. Следующая команда создает подкаталог с именем `orders` в текущем рабочем каталоге:

```Bash
mkdir orders
```

Если вы хотите одной командой создать подкаталог и в нем еще один подкаталог, используйте флаг `--parents`:

```Bash
mkdir --parents orders/2019
```

Команда `rmdir` удаляет каталог, но только если он пустой. Для удаления непустых каталогов можно использовать команду `rm`.

### Команда rm
Команда `rm` — сокращение от "remove" (удалить). И, как следует из названия, `rm` удаляет файлы. Так, следующая команда ликвидирует файл 0001.jpg:

```Bash
rm 0001.jpg
```

А эта команда удаляет все файлы текущего каталога:

```Bash
rm *
```

При использовании `rm` будьте внимательны. Это опасная команда.

Выполняя команду `rm` с флагом `-i`, вы сможете подумать перед удалением:

```Bash
rm -i *
```

Привыкните включать флаг `-i` в каждую команду `rm`, и вы можете избежать одну из самых серьезных ошибок в Linux. Эта опасная команда `rm -rf /` удаляет каждый файл на всем диске. Она работает, рекурсивно удаляя все подкаталоги корневого каталога и их подкаталоги. Добавление флага `-f` (от "force" — принудительно) усугубляет проблему, подавляя запросы. Не делайте так.

Если требуется удалить непустой каталог с именем orders, можно использовать команду rm следующим образом:

```Bash
rm -r orders
```

Будет удален подкаталог orders со всем его содержимым, включая другие подкаталоги.

### Команда cp
С помощью команды cp вы можете не только файлы, но при желании и полные каталоги (с подкаталогами). Чтобы сделать копию файла 0001.jpg с именем 0002.jpg, выполните следующую команду:

```Bash
cp 0001.jpg 0002.jpg
```

Если файл 0002.jpg уже существует, Bash без предупреждения заменит его. Все замечательно, если именно это и требовалось, но совсем не так прекрасно, если вы не осознавали, что будет перезаписана старая версия.

К счастью, вы можете использовать флаг `-i` (от "interactive" — интерактивно), и Bash будет предупреждать вас перед удалением существующих файлов. Это гораздо безопаснее:

```Bash
cp -i 0001.jpg 0002.jpg
```

Конечно, вы можете использовать подстановочные знаки, чтобы копировать несколько файлов одновременно. Чтобы скопировать все файлы из текущего каталога в подкаталог с именем photos, выполните следующую команду:

```Bash
cp * photos
```

Чтобы скопировать все файлы из подкаталога с именем photos в подкаталог с именем images, выполните следующую команду:

```Bash
cp photos/* images
```

В данном случае предполагается, что каталог images уже существует. Если он еще не существует, его можно создать и скопировать содержимое каталога photos с помощью следующей команды:

```Bash
cp -r photos images
```
`-r` расшифровывается как "recursive" (рекурсивно) Дополнительное преимущество использования флага `-r` заключается в том, что если каталог `photos` содержит подкаталоги, они все тоже будут скопированы в каталог `images`.

### Команда ps
С помощью команды `ps` можно получить моментальный снимок всех процессов, выполняющихся в текущий момент. Выданная без аргументов, эта команда отображает все процессы оболочки, то есть немного. Совсем другое дело, если использовать флаг `-e`:

```Bash
ps -e
```

С помощью флага `-e` отображаются все выполняющиеся процессы, и обычно их много.

Чтобы получить более полное представление о том, какие процессы выполняются в системе, используйте флаг `-ef`:

```Bash
ps -ef
```

С помощью этого флага отображаются имена всех выполняющихся процессов, идентификаторы этих процессов (PID), идентификаторы (PID) их родителей (PPID) и время их запуска (STIME). Также показывается, к какому терминалу (TTY) они подключены, если таковой имеется, сколько времени ЦП они потребили (TIME) и их полные пути. Вот сокращенный пример:

```bash
UID         PID   PPID  C STIME TTY          TIME CMD
root          1      0  0 13:35 ?        00:00:03 /sbin/init
root          2      0  0 13:35 ?        00:00:00 [kthreadd]
root          3      2  0 13:35 ?        00:00:00 [rcu_gp]
root          4      2  0 13:35 ?        00:00:00 [rcu_par_gp]
root          5      2  0 13:35 ?        00:00:00 [kworker/0:0-cgr]
root          6      2  0 13:35 ?        00:00:00 [kworker/0:0H-kb]
root          8      2  0 13:35 ?        00:00:00 [mm_percpu_wq]
root          9      2  0 13:35 ?        00:00:01 [ksoftirqd/0]
root         10      2  0 13:35 ?        00:00:02 [rcu_sched]
```

Кроме того, вы можете найти в документации, что `ps` используется таким образом:

```Bash
ps aux
```
`ps aux` и `ps -ef` идентичны. Эта двойственность восходит к историческим различиям между системами POSIX Unix (одной из которых является Linux) и системами BSD Unix (наиболее распространенной из которых является macOS). В самом начале в POSIX использовался флаг -ef, а в BSD требовался флаг aux. В настоящее время оба семейства операционных систем принимают любой из этих форматов.

Это служит отличным примером, почему следует внимательно изучать все команды Linux в руководстве. Изучение Bash похоже на изучение английского в качестве второго языка. В правилах существует много исключений.

### Команда w
Пользователи приходят, пользователи уходят, а иногда появляются пользователи, которые вообще нежелательны. Когда сотрудник покидает компанию в поисках других возможностей, системный администратор обеспечивает, чтобы этот пользователь больше не мог войти в компьютерные системы компании. Также предполагается, что системные администраторы должны знать, кто вошел в систему, а кто нет.

Чтобы узнать, кто присутствует на ваших серверах, в Linux предусмотрена команда `w` (от "who" — "кто"). Она отображает информацию о пользователях, которые в текущий момент присутствуют в компьютерной системе, и действиях этих пользователей. Команда `w` показывает имена пользователей, их IP-адреса, время, когда они вошли в систему, процессы, которые они выполняют в текущий момент, и сколько времени эти процессы потребляют. Это ценный инструмент для системных администраторов.

## Операторы ввода-вывода Bash
В Linux можно выполнять самые разные действия, просто используя команды Bash и их многочисленные параметры. Но вы сможете сделать буквально все, объединяя команды с помощью операторов ввода-вывода:

+ `<`, чтобы использовать для ввода данных источник, отличный от клавиатуры;
+ `>`, чтобы направлять вывод данных в пункт назначения, отличный от экрана;
+ `>>`, чтобы сделать то же самое, но с добавлением данных вместо перезаписи;
+ `|`, чтобы путем конвейерной передачи направить выходные данные одной команды во входные данные для другой команды.

Предположим, что требуется получить список всего содержимого текущего каталога, но записать выходной результат в файл с именем listing.txt. Это можно сделать с помощью следующей команды:

```Bash
ls > listing.txt
```

Если файл listing.txt уже существует, он будет перезаписан. Если же вместо этого оператора использовать оператор `>>`, то выходной результат команды `ls` будет добавлен к содержимому файла listing.txt:

```Bash
ls >> listing.txt
```

Оператор конвейерной передачи имеет огромные возможности (и часто используется). Он перенаправляет вывод первой команды во ввод второй команды.

Предположим, что вы используете `cat` для отображения содержимого большого файла, но это содержимое прокручивается слишком быстро для чтения. Можно сделать вывод более управляемым путем передачи результатов в другую команду, такую как `more`. Следующая команда выводит список всех текущих выполняющихся процессов. Но после заполнения экрана вывод данных будет приостановлен, пока вы не нажмете ВВОД, чтобы отобразить следующую строку:

```Bash
ps -ef | more
```

Вы также можете передать выходные данные в команду `head`, чтобы увидеть только первые несколько строк:

```Bash
ps -ef | head
```

Или, например, вам нужно отфильтровать выходные данные, чтобы включить только те строки, в которых имеется слово "daemon". Один из способов сделать это — передать выходные данные из ps в очень удобный инструмент Linux `grep`:

```Bash
ps -ef | grep daemon
```

Результат будет выглядеть следующим образом:

```bash
azureus+  52463  50702  0 23:28 pts/0    00:00:00 grep --color=auto deamon
azureuser@bash-vm:~$ ps -ef | grep daemon
root        449      1  0 13:35 ?        00:00:17 /usr/lib/linux-tools/4.18.0-1018-azure/hv_kvp_daemon -n
root        988      1  0 13:35 ?        00:00:00 /usr/lib/accountsservice/accounts-daemon
message+   1002      1  0 13:35 ?        00:00:00 /usr/bin/dbus-daemon --system --address=systemd: --nofork --nopidfile --systemd-activation --syslog-only
daemon     1035      1  0 13:35 ?        00:00:00 /usr/sbin/atd -f
root       1037      1  0 13:35 ?        00:00:00 /usr/bin/python3 -u /usr/sbin/waagent -daemon
root       1039      1  0 13:35 ?        00:00:00 /usr/lib/linux-tools/4.18.0-1018-azure/hv_vss_daemon -n
azureus+  52477  50702  0 23:28 pts/0    00:00:00 grep --color=auto daemon
```

Кроме того, в качестве источника ввода можно использовать файлы. По умолчанию стандартный ввод осуществляется с клавиатуры, но его тоже можно перенаправить. Чтобы задать ввод входных данных из файла, а не с клавиатуры, используйте оператор <. Системные администраторы часто сталкиваются с такой задачей, как сортировка содержимого файла. Как видно из названия, команда sort сортирует текст в алфавитном порядке:

```Bash
sort < file.txt
```

Чтобы сохранить отсортированные результаты в новый файл, можно перенаправить ввод и вывод:

```Bash
sort < file.txt > sorted_file.txt
```

Операторы ввода-вывода можно использовать для объединения команд Linux в цепочку в соответствии с необходимостью. Рассмотрим следующую команду:

```Bash
cat file.txt | fmt | pr | lpr
```

Выходные данные команды `cat` передаются в команду `fmt`, выходные данные `fmt` передаются в `pr` и так далее. Команда `fmt` форматирует результаты в виде аккуратных абзацев. Команда `pr` разбивает результаты по страницам. И, наконец, команда `lpr` отправляет разбитые по страницам выходные данные на принтер. И все в одной строке!

# Упражнение. Знакомство с Bash

## Песочница

На своем компьютере Linux можно выполнять команды Bash локально. Если у вас есть доступ к серверам Linux, вы можете удаленно подключаться к ним и выполнять команды Bash там. Но никто не захочет экспериментировать с работающей производственной системой, особенно в первый день работы в Northwind.

В этом уроке вы будете использовать Azure Cloud Shell справа в качестве терминала Linux. Azure Cloud Shell — это оболочка, к которой можно получить доступ на портале Azure или по адресу https://shell.azure.com. Чтобы ее использовать, не нужно ничего устанавливать на ваш ПК или ноутбук.

## Знакомство с Cloud Shell

Для начала давайте попробуем исследовать Cloud Shell с помощью уже изученных нами команд Bash.

1. Получите список всех файлов и подкаталогов в текущем каталоге с помощью команды ls:

```Bash
ls
```

2. Результат должен выглядеть примерно так:

```bash
yourname@Azure:~$ ls
clouddrive
```

`clouddrive` — это подкаталог в текущем каталоге. Это подключенная общая папка, которая присутствует, если вы используете `Cloud Shell` в собственной учетной записи. Прямо сейчас вы используете эту оболочку в песочнице Microsoft Learn.

3. Но что же _является_ текущим каталогом? Давайте найдем его с помощью команды `pwd`. `pwd` расшифровывается как `print working directory` (вывести рабочий каталог). Она выводит полный путь к тому каталогу, в котором вы находитесь.

```Bash
pwd
```

4. Вы должны увидеть такие выходные данные:

```bash
yourname@Azure:~$ pwd
/home/yourname
```

Эти выходные данные означают, что вы находитесь в каталоге с именем ваше_имя, который находится в каталоге home в корне файловой системы Linux.

5. Наш текущий каталог выглядит пустым. Давайте воспользуемся флагом Bash, чтобы отобразить все скрытые файлы и каталоги и убедиться, что все правильно.

```Bash
ls -a
```

6. Ого! Эти выходные данные показали нам, что содержимое данного каталога гораздо больше, чем мы думали.

```bash
yourname@Azure:~$ ls -a
.  ..  .azure  .bash_history  .bash_logout  .bashrc  clouddrive  .profile  .tmux.conf  .viminfo
```

7. Что из себя представляют все эти файлы и подкаталоги? Часть из них — фоновые файлы, позволяющие Cloud Shell работать. Давайте рассмотрим некоторые другие.

+ `.` ссылается на текущий каталог, а `..` — на родительский каталог. Где бы вы ни находились, распечатав все скрытые файлы и каталоги, вы увидите выведенные . и ...
+ `.bash_history` — это специальный файл Bash, в котором хранятся все команды, введенные вами в оболочку. Bash запоминает журнал команд, что, как мы увидим позже, очень удобно.
+ `.bash_logout` — еще один специальный файл Bash, который считывается и запускается каждый раз, когда существует оболочка входа. Суперпользователи Linux могут изменять его для настройки среды.
+ `.bashrc` — важный файл конфигурации Bash, который запускается при каждом запуске новой оболочки. Если вы собираетесь открыть этот файл, чтобы просмотреть его, будьте внимательны при внесении изменений, так как они могут иметь непредвиденные последствия.

## Вызов журнала и автозавершение команд
При вводе сложных команд, подобных приведенной ниже, можно легко сделать ошибку.

```Bash
ls -a .azure/commands/202?*.log
```

Но в Bash предусмотрено несколько функций, которые помогут в таких случаях.

### Повторный вызов предыдущих команд
1. Попробуйте ввести следующую команду с опечаткой (203? вместо 202?):

```Bash
ls -a .azure/commands/203?*.log
```

2. Должен появиться следующий результат, показывающий, что файлов, соответствующих этому шаблону, нет:

```bash
ls: cannot access '.azure/commands/203?*.log': No such file or directory
```

3. Чтобы не вводить всю команду заново для исправления ошибки, можно повторно вызывать введенные ранее команды, используя клавиши со стрелкой вверх и стрелкой вниз. Попробуйте с помощью клавиши со стрелкой вверх вернуть неправильную команду. Затем с помощью клавиши со стрелкой влево исправьте команду, заменив последнюю цифру 3 на 2. Снова нажмите ВВОД, чтобы выполнить исправленную команду.

Нажимая клавишу со стрелкой вверх несколько раз, можно вернуться на несколько команд назад. Чтобы перейти к более поздним командам, используйте клавишу со стрелкой вниз.

4. Теперь вы должны увидеть примерно следующий результат. Он позволяет убедиться, что команда сработала правильно и вы получили список файлов, соответствующих указанному шаблону.

```bash
.azure/commands/2020-01-29.21-56-35.login.103.log
.azure/commands/2020-01-29.21-56-38.account_set.112.log
```

### Автозавершение
Предположим, вам нужно прочитать содержимое одного из только что найденных файлов. Для вывода содержимого файла на экран можно использовать команду `cat` (сокращение от "catenate").

1. С этой командой следует использовать полное имя файла, например:

```Bash
cat .azure/commands/2020-01-29.21-56-35.login.103.log
```

2. В этом случае приходится вводить много символов, и вероятность ошибки очень велика. Но вы можете воспользоваться функцией элементарного автозавершения Bash, и за вас будет выполнена большая часть работы. Попробуйте ввести:

```Bash
cat .a
```

Затем нажмите клавишу Tab. Что происходит?

3. В команде должна появиться остальная часть слова "azure/":

```Bash
cat .azure/
```

4. Продолжайте вводить начала слов и используйте клавишу Tab для автозавершения. Помните, что в случае неоднозначности Bash ничего не заполнит. Чтобы вывести все файлы и каталоги по указанному пути, которые соответствуют уже введенным буквам, можно дважды нажать клавишу Tab.

Продолжайте, пока не появится реальный файл .log в каталоге команд. Затем нажмите ВВОД, чтобы с помощью команды cat вывести его содержимое на экран. Оно должно выглядеть примерно следующим образом:

```bash
CMD-LOG-LINE-BEGIN 103 | 2020-01-29 21:56:35,426 | INFO | az_command_data_logger | command args: login --identity
CMD-LOG-LINE-BEGIN 103 | 2020-01-29 21:56:37,604 | INFO | az_command_data_logger | exit code: 0
```

Учтите, что если вы уже ввели неверную букву, Bash не сможет правильно угадать, какую букву вы хотели ввести.

### Использование man
Мы только что использовали команду `cat`, но вы еще мало о ней знаете. С помощью команды man можно получить больше информации о команде `cat`.

Чтобы узнать больше о команде `cat` и ее использовании, введите следующую команду:

```Bash
man cat
```

Да, вы ввели в оболочку "man cat". Команды Bash могут быть и понятными, и забавными!

Вы должны увидеть такие выходные данные:

```bash

CAT(1)                                       User Commands                                       CAT(1)

NAME
       cat - concatenate files and print on the standard output

SYNOPSIS
       cat [OPTION]... [FILE]...

DESCRIPTION
       Concatenate FILE(s) to standard output.

       With no FILE, or when FILE is -, read standard input.

       -A, --show-all
              equivalent to -vET

       -b, --number-nonblank
              number nonempty output lines, overrides -n

       -e     equivalent to -vE

...
```

3. Для прокрутки страницы руководства используйте стрелки вверх и вниз, а для выхода введите `q`.

### Изменение каталогов
Давайте попробуем еще одну базовую команду Bash: `cd`.

При использовании оболочки вы всегда находитесь в каталоге — так же, как в папке на ПК или Mac. Чтобы изменить папку, используйте команду cd (change directory — изменить каталог).

Это просто, но давайте немного поупражняемся.

1. Сначала введите следующую команду, чтобы убедиться, что вы находитесь в правильном месте:

```Bash
cd ~
```

Эта команда переместит вас обратно в специальный домашний каталог в оболочке, если вы находились в другом месте.

Повторите проверку, выполнив команду pwd еще раз:

```Bash
pwd
```

Вы должны увидеть такие выходные данные:

```bash
/home/yourname
```

`~` — еще один специальный символ в Bash, который ссылается на этот домашний каталог. Вы можете использовать `~` для ссылки на расположение /home/ваше_имя, в каком бы каталоге в оболочке вы ни находились.

Давайте перейдем в каталог, где хранятся файлы журнала (где мы были раньше):

```Bash
cd .azure/commands/
```

Введите полную команду самостоятельно или используйте клавишу `Tab` для автозавершения.

Теперь строка, в которой вводятся команды, должна выглядеть иначе и показывать, где в оболочке вы находитесь:

```bash
yourname@Azure:~/.azure/commands$
```

Попробуйте использовать специальный синтаксис `..`, чтобы переместиться на один каталог выше:

```Bash
cd ..
```

Теперь вы должны находиться на один уровень выше в структуре каталогов, и командная строка должна выглядеть следующим образом:

```bash
yourname@Azure:~/.azure$
```

Отлично! Вы сделали первые шаги на пути к званию эксперта Bash. Продолжайте обучение.

# Проверьте свои знания

1. В какой каталог вы переключитесь, введя команду Bash cd .? 

- [] В мой специальный "домашний" каталог
- [] В родительский каталог
- [] В первый подкаталог в алфавитном порядке
- [x] Я не переключусь в другой каталог

__Помните, что в Unix . ссылается на текущий каталог. При изменении каталогов (cd) на текущий каталог каталоги не изменяются вообще!__

# Упражнение. Завершение неправильно функционирующего процесса

Компьютеры неидеальны. Рано или поздно что-нибудь пойдет не так. Вот почему так важна работа системного администратора — он должен находить и устранять системные проблемы.

Допустим, что приложение `Python` вызывает проблемы. Возможно, оно потребляет слишком много времени ЦП или перестало отвечать. В любом случае вы хотите остановить это приложение. Чтобы определить процесс или приложение, можно использовать команды `ps` и `grep`. Затем можно остановить его с помощью команды `kill`. Давайте попробуем сделать это на вашей виртуальной машине `Linux`.

## Запуск неправильно функционирующего процесса
Если вы собираетесь завершить процесс, вам нужен процесс, который необходимо завершить. Давайте создадим такой процесс.

1. Вернитесь в домашний каталог, введя следующую команду:

```Bash
cd ~
```

2. В Azure Cloud Shell введите следующую команду, чтобы запустить редактор Linux vi:

```Bash
vi bad.py
```

`vi` — широко распространенный текстовый редактор, унаследованный Linux от Unix. Хотите вы этого или нет, но пользователь Bash должен знать основы vi.

3. Нажмите клавишу i, чтобы перевести vi в режим вставки. Затем введите следующую программу Python:

```Python
i = 0
while i == 0:
    pass
```

Эта программа при ее запуске выполняется в бесконечном цикле — и, конечно, вы не захотите, чтобы она работала на вашем сервере.

4. Нажмите клавишу `Esc`, чтобы выйти из режима вставки. Затем введите следующую команду и нажмите клавишу ВВОД, чтобы сохранить программу и выйти из редактора vi:

```bash
:wq
```

Не забудьте добавить двоеточие в начало команды. Что касается самой команды, то w означает "write" (записать), а q означает "quit" (выйти).

5. Теперь с помощью следующей команды запустите программу, чтобы она выполнялась в фоновом режиме:

```Bash
python3 bad.py &
```

Не забудьте указать амперсанд `&` в конце команды. Иначе вы не вернетесь в командную строку Bash. В Bash амперсанд выполняет команду и возвращает вас в командную строку, даже если команда не завершила выполнение.

Хотя это не бросается в глаза, но bad.py теперь работает в фоновом режиме и отбирает циклы ЦП у других процессов. Давайте внимательнее взглянем на то, что происходит.

## Завершение процесса
Для завершения процесса необходимо имя или идентификатор процесса. Для этого служит команда ps.

1. Для обновления памяти команда `ps -ef` выводит список всех запущенных процессов и отображает большое количество сведений о каждом из них. Используйте следующую команду, чтобы вывести список всех запущенных процессов и отфильтровать результаты, оставив только строки, содержащие "python":

```Bash
ps -ef | grep python
```

Результат должен выглядеть примерно следующим образом:

```bash
yourname+    342    254 99 23:34 pts/1    00:00:31 python3 bad.py
yourname+    344    254  0 23:35 pts/1    00:00:00 grep --color=auto python
```

Из этого листинга видно, что `bad.py` потребляет 99 процентов времени ЦП сервера. Программа оправдывает свое название.

Команда `kill` завершает выполняющийся процесс по его идентификатору. (Связанная команда с именем `killall` убивает процесс на основе имени процесса.) При вызове `kill` необходимо решить, какой "сигнал" следует использовать для убийства процесса. Список типов сигналов можно отобразить с помощью следующей команды:

```Bash
kill -l
```

Если вы завершаете процесс управляющей программы, который работает в фоновом режиме и предоставляет жизненно важные службы для операционной системы, то, возможно, придется завершить и сразу же перезапустить его. Для этого можно использовать сигнал `SIGHUP`.

В данном примере требуется завершить процесс без его перезапуска. Поэтому вам нужно использовать сигнал `SIGKILL`, который соответствует номеру 9. Для этого извлеките идентификатор процесса `bad.py` из выходных данных `ps -ef` (во втором столбце) и завершите процесс с помощью следующей команды. Замените `PROCESS_ID` на идентификатор процесса.

```Bash
kill -9 PROCESS_ID
```

Эту же команду можно также ввести в виде `kill -s SIGKILL PROCESS_ID`. Использовать имя или номер сигнала — на ваше усмотрение.

4. В завершение снова выполните `ps`, чтобы убедиться, что `bad.py` больше не работает.

Команды `ps` и `kill` также часто используются для выявления и завершения "процессов-зомби" — дочерних процессов, которые оставляют плохо написанные программы.

# Упражнение. Использование Bash и grep для фильтрации выходных данных CLI

До сих пор вы выполняли команды Bash сами по себе. Однако Bash проявляет всю свою мощь в сочетании с другими инструментами, поэтому давайте попробуем использовать Bash для фильтрации выходных данных из Azure CLI.

1. Допустим, вы хотите увидеть актуальный список размеров виртуальных машин, доступных в западном регионе Azure. Это можно сделать с помощью следующей команды:

```Bash
az vm list-sizes --location westus --output table
```

2. В результате вы должны увидеть длинный список типов виртуальных машин. Чтобы сократить список и оставить в нем только виртуальные машины нужного размера, можно использовать `grep` — универсальную программу сопоставления шаблонов в Linux. Чтобы найти размеры DS, которые часто выбираются для задач обработки и анализа данных, используйте следующую команду:

```Bash
az vm list-sizes --location westus --output table | grep DS
```

Эта команда передает выходные данные команды az в grep, которая отбрасывает строки, не содержащие строку "DS".

3. Однако виртуальных машин все еще много. Вы знаете, что виртуальные машины DS V2 являются самыми современными. Давайте настроим команду grep, чтобы использовать более сложное регулярное выражение:

```Bash
az vm list-sizes --location westus --output table | grep DS.*_v2
```

Эта команда отфильтровывает строки, которые не соответствуют регулярному выражению `DS.*_v2`. Вы можете узнать некоторые символы в этом выражении — мы рассматривали подстановочные знаки в предыдущем уроке. В регулярных выражениях широко используются подстановочные знаки.

__Регулярные выражения__ — тема из другого модуля, но они очень подходят для создания скриптов Bash.

При использовании Bash существенно упрощается работа с другими командами `CLI`. А так как работа системного администратора никогда не кончается, пригодятся все средства, позволяющие уменьшить рабочую нагрузку.

# Проверка знаний

1. Какая из следующих команд записывает в файл список процессов, связанных с пользователем scottgu? 

+ [] cat | grep scottgu > processes.txt
+ [] cat > grep scottgu | processes.txt
+ [x] ps -ef | grep scottgu > processes.txt<br>
Правильно! Команда `ps -ef` выводит список всех выполняющихся процессов. Команда `grep` выполняет поиск шаблонов в каждом файле.

2. Какую из следующих команд, вызываемых с помощью параметра -r, можно использовать для удаления подкаталога, который не является пустым? 
+ [x] rm<br>
Правильно! Команда `rm -r` используется для удаления подкаталога и всего, что в нем находится.
+ [] rmdir
+ [] destroy

3. Какая из следующих команд объединяет содержимое файлов foo.txt и bar.txt в новый файл с именем foobar.txt? 
+ []concat foo.txt bar.txt > foobar.txt
+ []cat foo.txt bar.txt | foobar.txt
+ [x]cat foo.txt bar.txt > foobar.txt<br>
Правильно! Команда `cat` сцепляет два файла, заданные в качестве аргументов, а затем команда `>` записывает эти данные в файл.

4. Команда sudo используется, чтобы: 
+ [x] Выполнять команды с более высоким уровнем привилегий<br>
Правильно! Используйте sudo для выполнения команд с более высоким уровнем привилегий.
+ [] Запускать программу и выполнять ее в фоновом режиме
+ [] Запретить удаление системных файлов пользователями, не являющимися администраторами

5. Какое из следующих утверждений истинно для команды `python3 app.py &`? 
+ []Она запускает app.py после создания точки восстановления в системе
+ [x]Она запускает app.py и сразу же возвращается в командную строку<br>
Правильно! Команда python3 app.py & запускает app.py и немедленно возвращается в командную строку.
+ []Она запускает app.py, но только если этот файл находится в каталоге /etc

# Сводка

В этом модуле вы ознакомились с основными принципами использования Bash. В частности, вы:
+ узнали, что такое оболочка и что такое Bash;
+ ознакомились со структурой команд Bash;
+ изучили основные команды Bash, такие как `ls`, `cat` и `ps`;
+ узнали, как использовать операторы ввода-вывода в командах Bash для перенаправления ввода и вывода;
+ узнали, как находить и завершать посторонние процессы;
+ узнали, как использовать Bash для фильтрации выходных данных из другого средства CLI.

Но с помощью Bash можно делать гораздо больше. Мы привыкли использовать Bash как способ взаимодействия с нашей оболочкой, но вы можете применять изученные команды (и многие другие) для полноценного программирования в Bash. Следующие ресурсы помогут вам освоить Bash на более высоком уровне.
+ [Введение в Bash от Университета Лойола Мэримаунт](https://cs.lmu.edu/~ray/notes/bash/)
+ [Академия Bash](https://guide.bash.academy/)
+ [Руководство по Bash для начинающих](http://tldp.org/LDP/Bash-Beginners-Guide/html/index.html)
+ [Изучение оболочки](http://linuxcommand.org/lc3_learning_the_shell.php)
+ [Введение в Bash для студентов-химиков](https://erastova.files.wordpress.com/2019/09/introbash.pptx)
