# Использование оболочки UNIX для первичной обработки данных журнала

# Введение

Вам когда-нибудь приходилось преобразовывать данные из одного формата в другой? 
__Преобразование данных__ — это стандартная задача разработчиков. Если вы пытаетесь извлечь информацию из журналов или входящих потоков, вам часто приходится работать с необработанными данными и преобразовывать их, чтобы привести в подходящий формат.

В этом модуле вы узнаете, как выполнять первичную обработку (преобразование) данных с помощью оболочки UNIX. Вы ознакомитесь с распространенными инструментами и основами регулярных выражений.

# Цели обучения
В этом модуле рассматриваются следующие задачи:
+ Выполнение базовой проверки файлов с помощью таких команд, как `head`, `tail`, `wc`, `nl` и `sort`.
+ С помощью команды `cat` можно создавать, добавлять, отображать и объединять файлы.
+ Напишите и используйте простые регулярные выражения для сопоставления текстовых шаблонов. (Это только общее введение в регулярные выражения.)
+ Используйте вместе с регулярным выражением команду grep для поиска в файлах или содержимое stdin для сопоставления шаблонов.
+ Для базовых преобразований текста во входных потоках используйте sed и регулярное выражение.
+ Использование каналов и фильтров для первичной обработки данных.

## Необходимые компоненты
+ Базовое представление о командной строке и основных командах оболочки

# Выполнение проверки файлов в оболочке UNIX
Вам когда-нибудь приходилось переводить данные из одного формата в другой? Скорее всего, да, или вы еще столкнетесь с этим в будущем. Этот процесс называется _первичной обработкой данных_ и является распространенной задачей разработчиков. Чтобы научиться выполнять первичную обработку данных, нам нужны файлы данных для работы.

Разработчикам часто приходится извлекать данные из журналов. В этом модуле мы будем использовать журналы НАСА и командную строку. Чтобы приступить к работе, необходимо загрузить наборы данных в среду песочницы.

## Получение наборов данных НАСА

Для выполнения упражнений в этом модуле необходимо загрузить наборы данных НАСА.

1. С помощью команды mkdir создайте новый каталог с именем data.

```Bash
mkdir data
```

2. С помощью команды `wget` скачайте набор данных журнала в каталог данных:

```Bash
wget -P data/ https://raw.githubusercontent.com/MicrosoftDocs/mslearn-data-wrangling-shell/main/NASA-logs-1995.txt
```

3. Используйте команду `wget` еще раз, чтобы скачать набор данных `software-API` в каталог данных:

```Bash
wget -P data/ https://raw.githubusercontent.com/MicrosoftDocs/mslearn-data-wrangling-shell/main/NASA-software-API.txt
```
Ниже показан пример результатов выполнения команды `wget`:

```bash
--2022-06-09 06:19:13--  https://raw.githubusercontent.com/MicrosoftDocs/mslearn-data-wrangling-shell/main/NASA-software-API.txt
Resolving raw.githubusercontent.com (raw.githubusercontent.com)... 185.199.108.133, 185.199.109.133, 185.199.110.133, ...
Connecting to raw.githubusercontent.com (raw.githubusercontent.com)|185.199.108.133|:443... connected.
HTTP request sent, awaiting response... 200 OK
Length: 81115 (79K) [text/plain]
Saving to: ‘data/NASA-software-API.txt’

NASA-software-API.txt          100%[==========================================================>]  79.21K  --.-KB/s    in 0.001s  

2022-06-09 06:19:13 (69.6 MB/s) - ‘data/NASA-software-API.txt’ saved [81115/81115]
```

4. Перейдите в новый каталог с помощью команды `cd`:

```Bash
cd data
```

Убедитесь, что у вас есть нужные файлы, с помощью команды `ls`:

```Bash
ls
```

Должны отобразиться два файла: `NASA-software-API.txt` и `NASA-logs-1995.txt`.

Первый файл, `NASA-software-API.txt`, представляет собой открытый набор данных, в котором перечислено все программное обеспечение, используемое в НАСА. Дополнительные сведения об исходном наборе данных см. в разделе [API программного обеспечения НАСА с открытым кодом и общие ресурсы](https://data.nasa.gov/Management-Operations/NASA-Open-Source-And-General-Resource-Software-API/4tfb-za6v). Второй набор данных содержит все зарегистрированные запросы к серверу Космического центра Кеннеди.

## Просмотр содержимого файлов
Вспомним, что в UNIX по умолчанию терминал имеет три потока: входной поток и два потока вывода. Входной поток называется `stdin` для стандартного ввода и сопоставляется с клавиатурой. Стандартный поток вывода, или `stdout`, обычно выводится на экран терминала или может использоваться другой программой или процессом. Другой поток вывода, `stderr`, в основном используется для отчетов о состоянии и обычно выводится в терминале, например `stdout`.

Зачем мы вспомнили об этом? В следующих уроках мы будем говорить о программах и фильтрах, а также о стандартных входных и выходных потоках. Вам лучше знать о том, как связаны эти элементы. Вы все поймете по мере изучения модуля.

Прежде чем перейти к первичной обработке данных, нужно выполнить базовую проверку файлов. Так мы получим представление о том, как выглядят необработанные данные.

### Команды head и tail
Команды `head` и `tail` используются для просмотра верхней (головной) или нижней (заключительной) части файла. По умолчанию обе команды отображают 10 строк содержимого. Если нужно отобразить больше или меньше строк, можно использовать флаг `-n`, чтобы указать число строк, выводимых в `stdout`.

Мы будем использовать команды `tail` и `head` для вывода последних и первых пяти строк файла `NASA-software-API.txt` соответственно.

Введите команду `tail` с флагом `-n`, чтобы отобразить последние пять строк в файле:

```Bash
tail -n 5  NASA-software-API.txt
```

Выходные данные должны выглядеть следующим образом.

```bash
SSC-00393 SSC 2013-05-17T00:00:00.000 "General Public" "Software Suite to Support In-Flight Characterization of Remote Sensing Systems"
SSC-00424 SSC 2013-09-06T00:00:00.000 "General Public" "SSC Site Status Mobile Application"
GSC-14732-1 GSFC 2004-06-09T00:00:00.000 "Open Source" "Tool For Interactive Plotting, Sonification, And 3D Orbit Display (TIPSOD)"
GSC-14730-1 GSFC 2004-06-09T00:00:00.000 "Open Source" "Space Physics Data Facility Web Services"
GSC-14726-1 GSFC 2004-06-09T00:00:00.000 "Open Source" "Earth Observing System (EOS) Clearinghouse (ECHO)"
```

Введите команду head с флагом -n, чтобы отобразить первые пять строк в файле:

```Bash
head -n 5 NASA-software-API.txt
```

Выходные данные должны выглядеть следующим образом.

```bash
ARC-14136-1 ARC 2001-10-19T00:00:00.000 "Academic Worldwide" "Adaptive Relevance-Learning Software Component (ARNIE)"
ARC-14293-1 ARC 2005-09-19T00:00:00.000 "Open Source" "Genetic Graphs (JavaGenes)"
ARC-14297-1 ARC 2003-11-06T00:00:00.000 "General US" "Automated Domain Decomposition Software, PEGASUS Version 5.0"
ARC-14379-1 ARC 2002-03-27T00:00:00.000 "General US" "Man-machine Integration Design And Analysis System (MIDAS)"
ARC-14400-1 ARC 2001-01-29T00:00:00.000 "General US" "PLOT3D Version 4.0"
```

### Фильтр `nl`
Фильтр `nl` считывает строки из файлов или из `stdin`. Выходные данные выводятся в `stdout`. По умолчанию фильтр `nl` подсчитывает строки в файле и использует символы табуляции для отделения номера строки от текста.

Введите фильтр `nl` с флагом `-s`, чтобы использовать знак равенства (=) в качестве разделителя:

```Bash
nl -s = NASA-software-API.txt
```

Выходные данные должны содержать каждую строку в файле и заканчиваться следующими строками:

```bash
...
697=SSC-00424 SSC 2013-09-06T00:00:00.000 "General Public" "SSC Site Status Mobile Application"
698=GSC-14732-1 GSFC 2004-06-09T00:00:00.000 "Open Source" "Tool For Interactive Plotting, Sonification, And 3D Orbit Display (TIPSOD)"
699=GSC-14730-1 GSFC 2004-06-09T00:00:00.000 "Open Source" "Space Physics Data Facility Web Services"
700=GSC-14726-1 GSFC 2004-06-09T00:00:00.000 "Open Source" "Earth Observing System (EOS) Clearinghouse (ECHO)"
```

Фильтр `nl` содержит флаги, позволяющие изменить значение приращения (`-i`), формат нумерации (`ln`, `rn`, `rz`) или начальный номер (`-v`).

### Команда `wc`
Команда подсчета слов `wc` подсчитывает количество строк, слов (разделенных пробелами) и символов в файле или из `stdin`. Выходные данные выводятся в `stdout` и разделяются символами табуляции.

1. Используйте команду `wc` для просмотра числа строк, слов и символов в файле `NASA-software-API.txt`:

```Bash
wc NASA-software-API.txt
```

Выходные данные должны выглядеть следующим образом.

```bash
  703   8917   81115   NASA-software-API.txt
```

В выходных данных можно увидеть, что файл содержит $703$ строки, $8917$ слов и $81 115$ символов. Повторно проверьте выходные данные предыдущей команды (`nl`). Мы видим, что последняя выведенная строка:


>700=GSC-14726-1 GSFC 2004-06-09T00:00:00.000 "Open Source" "Earth Observing System (EOS) Clearinghouse (ECHO)"


Обратите внимание, что индекс этой строки равен `700`, а не `703` (`700=GSC...`). Почему?

Значение индекса `700` объясняется тем, что по умолчанию команда `nl` не считает пустые строки.

Попробуйте выполнить команду `nl` повторно, на этот раз с флагом параметра `-b` a, чтобы подсчитать все строки, включая пустые:

```Bash
nl -b a NASA-software-API.txt
```

Последняя строка выходных данных должна быть следующей.

```bash
...
703  GSC-14726-1 GSFC 2004-06-09T00:00:00.000 "Open Source" "Earth Observing System (EOS) Clearinghouse (ECHO)"
```

Теперь значение индекса соответствует количеству строк, подсчитанных с помощью команды `wc`, — `703`.

# Базовая обработка файлов с помощью команды cat

Здесь будет использоваться команда `cat` для вывода, создания и сцепления файлов. Эта команда полезна при выполнении сложной первичной обработки данных.

Команда `cat` является одной из самых основных и полезных команд для работы с файлами. 

Она включает три основные функции для текстовых файлов:
+ отображение содержимого,
+ создание новых файлов,
+ объединение копий.

## Отображение содержимого
Команда `cat` чаще всего используется для чтения содержимого файлов. Местом назначения потока вывода по умолчанию, который также называется стандартным потоком вывода или `stdout`, является экран монитора. Чтобы отобразить содержимое файла, необходимо ввести `cat <filename>`.

+ Выполните команду `cat`, чтобы отобразить содержимое файла `NASA-software-API.txt`:

```Bash
cat NASA-software-API.txt
```

Выходные данные должны содержать каждую строку в файле и заканчиваться следующими строками:

```bash
...
SSC-00424 SSC 2013-09-06T00:00:00.000 "General Public" "SSC Site Status Mobile Application"
GSC-14732-1 GSFC 2004-06-09T00:00:00.000 "Open Source" "Tool For Interactive Plotting, Sonification, And 3D Orbit Display (TIPSOD)"
GSC-14730-1 GSFC 2004-06-09T00:00:00.000 "Open Source" "Space Physics Data Facility Web Services"
GSC-14726-1 GSFC 2004-06-09T00:00:00.000 "Open Source" "Earth Observing System (EOS) Clear
```

## Создание файлов
Создавать файлы можно с помощью команды `cat`. Использовать эту команду для небольших файлов часто проще, чем текстовый редактор или редактор `vi` (сокращение от visual).

Давайте создадим новые файлы путем перенаправления стандартного потока вывода команды `cat` с помощью оператора перенаправления потока вывода (`>`), за которым следует имя создаваемого файла. После добавления текста нажмите клавиши `CTRL+D`, чтобы вернуться к подсказке.

1. Выполните команду `cat` с оператором "больше" (`>`) и именем создаваемого файла, например `file1`:

```Bash
cat > file1
```

2. Добавьте приведенный ниже текст и нажмите клавишу ВВОД, чтобы переместить курсор на новую строку.

```Bash
NASA headquarters
```

3. Нажмите клавиши CTRL+D, чтобы завершить действие объединения и восстановить запрос.

4. Чтобы добавить в файл строку без перезаписи существующего содержимого, используйте оператор «двойной знак "больше"» (>>) с командой cat:

```Bash
cat >> file1
```

5. Добавьте приведенный ниже текст и нажмите клавишу ВВОД, чтобы переместить курсор на новую строку.

```Bash
Goddard Space Flight Center
```

6. Нажмите клавиши `CTRL+D`, чтобы завершить действие объединения и восстановить запрос.

7. Если выполнить команду `ls`, новый файл отобразится в каталоге:

```bash
file1   NASA-logs-1995.txt   NASA-software-API.txt
```
8. Используйте базовую команду cat, чтобы отобразить содержимое обновленного файла:

```Bash
cat file1
```

Вы должны увидеть следующий результат:

```bash
NASA headquarters
Goddard Space Flight Center
```

## Сцепление файлов
Третий вариант использования команды `cat` — сцепление копий содержимого файлов. Поскольку сцепление происходит только с копиями, эта операция не влияет на исходные файлы.

1. Выполните следующую команду, чтобы объединить две копии `file1` в `stdout`:

```Bash
cat file1 file1
```

Выходные данные должны выглядеть примерно так:

```bash
NASA headquarters
Goddard Space Flight Center
NASA headquarters
Goddard Space Flight Center
```

2. Если вы выполните команду `ls` сейчас, вы заметите, что новый файл не добавлен в каталог:

```bash
file1   NASA-logs-1995.txt   NASA-software-API.txt
```
Содержимое каждого файла отображено в `stdout` начиная с новой строки, в том порядке, в котором имена файлов отображаются в команде. Также можно перенаправить результат объединения в файл.

3. Выполните команду `cat` с оператором "больше" (`>`), чтобы сохранить выходные данные в новом файле, например `file2`:

```Bash
cat file1 file1 > file2
```

4. Изучите содержимое нового файла:

```Bash
cat file2
```

Выходные данные должны выглядеть так:

```bash
NASA headquarters
Goddard Space Flight Center
NASA headquarters
Goddard Space Flight Center
```
5. Если выполнить команду ls снова, новый файл отобразится в каталоге:

```bash
file1   files2   NASA-logs-1995.txt   NASA-software-API.txt
```

# Общие сведения о регулярных выражениях

В этом уроке вы ознакомитесь с регулярными выражениями. Регулярные выражения удобно использовать для сопоставления текстовых шаблонов. Они также используются разработчиками и специалистами по обработке и анализу данных.

Регулярные выражения (regex) невероятно полезны, и, скорее всего, вы уже сталкивались с ними. Этот эзотерический мини-язык помогает в сложном сопоставлении шаблонов и поначалу может выглядеть непонятным. Однако регулярные выражения можно найти в большинстве текстовых редакторов, языков и инструментов, например в Python, SQL, Go, Scala и многих других. Их определенно стоит изучить.

Поместите в закладки онлайн-инструмент [Regular Expressions 101](https://regex101.com/), чтобы тестировать регулярное выражение на основе текстовых входных данных.

## Литералы и специальные символы
Вкратце, регулярное выражение представляет собой доступный способ определения шаблона символов и в основном используется для идентификации шаблона, интеллектуального анализа текста или проверки входных данных. Указанный шаблон может быть широким или конкретным и читается строго слева направо. Входные данные регулярного выражения всегда являются текстовой строкой.

Большинство символов (буквенные и числовые) не имеют специальных функций и буквально соответствуют этому символу. Регулярное выражение `SSH` совпадает только со строкой `"SSH"`. Если входная строка содержит текст `"ZSH"`, шаблон регулярного выражения не найдет совпадения.

Если вы завершили предыдущий урок, у вас уже есть образец открытого набора данных НАСА. Мы будем использовать этот набор данных, чтобы выполнить сопоставление шаблонов с регулярным выражением в песочнице Azure Cloud Shell.

1. С помощью команды code откройте файл NASA-software-API.txt в редакторе Cloud Shell:

```bash
code NASA-software-API.txt
```

Файл откроется во встроенном редакторе над запросом Cloud Shell.

2. Откройте поле поиска для встроенного редактора:
    + Щелкните мышью в любом месте в окне редактора.
    + Нажмите клавиши CTRL+F (в Windows или Linux) или Cmd+F (в macOS). <br>
    Во встроенном редакторе откроется поле поиска.
3. Щелкните значок регулярного выражения (.*), чтобы включить поиск по шаблону регулярного выражения для файла в редакторе:

![Screenshot showing the Cloud Shell search box and regex option selected.](/Materials/Bash/Pictures/02_01.png)

4. В поле поиска введите строку Open Source.

Если включен параметр регулярного выражения, Cloud Shell выделяет все экземпляры содержимого, соответствующего введенной строке. Число совпадений отображается в поле поиска.

![Screenshot showing Cloud Shell search results in a text file.](/Materials/Bash/Pictures/02_02.png)

Вы можете использовать значки со стрелками влево (назад) и вправо (далее) в поле поиска, чтобы просмотреть каждое совпадение в файле.

Может показаться, что этот метод не отличается от любых других вариантов использования поля поиска. Преимущества регулярных выражений проявятся при поиске с использованием специальных символов, диапазонов и привязок.

## Сопоставление символов и диапазоны

Итак, вы узнали, что регулярное выражение можно использовать для буквального сопоставления символов. Предположим, вам нужно найти версии программного обеспечения, указанные в файле. Вы хотите найти версии в формате типа `"v1`."

Вы знаете, что все версии должны начинаться с буквы "`v`". Оставшуюся часть строки поиска можно заключить в квадратные скобки: `[]`. Квадратные скобки означают "любой символ в этом списке". Чтобы найти версии, начинающиеся с цифры от 1 до 5, можно выполнить поиск по регулярному выражению `v[12345]`.

Давайте попробуем использовать этот тип шаблона регулярного выражения в файле `NASA-software-API.txt file`.

1. В поле поиска введите `ARC-14[456]`, чтобы найти текст, содержащий слово "`ARC-14`", за которым следует цифра 4, 5 или 6.

Вы должны получить 12 результатов.

2. Используйте значки со стрелками влево и вправо в поле поиска, чтобы просмотреть каждое совпадение в файле.

Использовать такое регулярное выражение, как в этом примере, просто, поскольку в содержимом есть только три цифры для поиска (4, 5, 6). Но как выполнить сопоставление по всему алфавиту или многим цифрам, не вводя каждый символ отдельно?

Можно определить последовательный диапазон букв или цифр. Для всех цифр можно создать диапазон: `[0-9]`. Для строчных букв можно использовать диапазон `[a-z]`.

Давайте найдем все вхождения слова "ARC-14", за которым следует любая цифра.

+ В поле поиска введите ARC-14[0-9], чтобы найти текст, содержащий слово "ARC-14", за которым следует любая цифра.<br>
Вы должны получить 22 результата.<br>
Вот некоторые строки в файле, которые соответствуют этому шаблону:

```bash
ARC-14293-1 ARC 2005-09-19T00:00:00.000 "Open Source" "Genetic Graphs (JavaGenes)"
...
ARC-14400-1 ARC 2001-01-29T00:00:00.000 "General US" "PLOT3D Version 4.0"
...
ARC-14837-1GS ARC 1999-07-13T00:00:00.000 "General US" "FOMOCO Utilities "
...
ARC-14932-1 ARC 2005-01-12T00:00:00.000 "Open Source" "Mission Simulation Toolkit (MST)"
```

## Подстановочные знаки
__Точка__ (`.`) — это символ специального типа, называемый _подстановочным знаком_. Он может использоваться для обозначения любого символа, например букв, цифр, пробелов, символов новой строки, знаков препинания и знаков. Например, чтобы найти все сочетания трех символов, которые начинаются с буквы "g" и заканчиваются буквой "t", нужно использовать регулярное выражение `g.t`.

Распространенный шаблон, используемый в регулярных выражениях, — точка, за которой следует звездочка (`.*`). Этот синтаксис регулярного выражения позволяет сопоставить любой символ ноль или более раз.

Давайте попробуем использовать этот шаблон регулярного выражения с подстановочными знаками, чтобы найти текст, содержащий слово "NASA", за которым следует любой другой символ.

+ В поле поиска введите NASA.*, чтобы найти соответствующий текст.<br>
Вы должны получить 26 результатов.<br>
Вот некоторые строки в файле, которые соответствуют этому шаблону:

```bash
NASA Root Cause Analysis Tool
...
NASA's Moderate Resolution Imaging Spectrometer (MODIS)-Combined Ocean Color
...
NASA, Average-Passage Multistage Turbomachinery Flow Field Analysis Code
...
NASA -  Average Passage Flow Solver)
...
NASA/NESSUS 6.2c Probabilistic Structural Analysis Software
```

## Привязки
__Привязка__ — это сопоставление последовательностей, отображаемых в определенной части строки символов или слове. Существует два типа привязок:
+ __Начало строки__. Используйте символ курсора (`^`), если шаблон поиска должен считать последовательность символов совпадением только в том случае, если соответствующая часть отображается в начале строки.
+ __Конец строки__. Используйте символ доллара (`$`), если шаблон поиска должен считать последовательность символов совпадением только в том случае, если соответствующая часть отображается в конце строки.

Теперь можно написать регулярное выражение, которое будет сопоставлять числа в начале строки (`^[0-9]`) или в конце строки (`[0-9]$`).

Давайте попробуем использовать шаблоны привязки регулярного выражения для поиска совпадений, где "A" является первым или последним символом во введенной строке.

1. В поле поиска введите `^[A-G]`, чтобы найти текст, начинающийся с букв A–G.<br>
Вы должны получить 258 результатов.
2. Введите `[A-G]$`, чтобы найти текст, заканчивающийся буквами A–G.

Вы получите три результата:

```bash
LAR-16939-GS LaRC 2000-11-07T00:00:00.000 "General Public" DeMAID1m.sea
...
GSC-16207-1 GSFC 2011-04-12T00:00:00.000 "Open Source" "Goddard Mission Services Evolution Center Architecture Application Programming Interface (GMSEC
...
LEW-16018-1 GRC 2003-01-05T00:00:00.000 "General US" CARES/LIFE
```

## Экранирование символов

Предположим, нам нужно найти строки, в которых точка (`.`) является последним символом. Мы знаем, что знак доллара (`$`) является привязкой конца строки, поэтому в поле поиска можно ввести `.$`. Но это регулярное выражение не вернет совпадения, которые мы ищем. Как мы обсуждали ранее, точка (`.`) соответствует любому отдельному символу. Поскольку каждая строка заканчивается символом, в результатах возвращается каждая строка.

Как запретить специальному символу выполнять функцию в регулярном выражении, если мы хотим найти этот конкретный символ? Обратная косая черта (`\`) используется для экранирования символа, который требуется найти. Чтобы найти строки, в которых точка (`.`) является последним символом, мы используем выражение `\.$`.

Давайте попробуем использовать `escape`-символ в поисковом запросе с использованием регулярного выражения в файле НАСА.

1. В поле поиска введите `\.$`, чтобы найти текст, заканчивающийся точкой (`.`).<br>
Вы получите ноль результатов. Ни одна строка в этом файле не заканчивается точкой.
2. В поле поиска введите `\*\*`, чтобы найти вхождения двойной звездочки (`**`) в файле.

Шаблону поиска соответствует одна строка в файле:

```bash
LLEW-17324-1 GRC 2001-01-05T00:00:00.000 "General US" "CANCELLED ** Same As LEW-16855-1 (APNASA -  Average Passage Flow Solver)"
```

## Памятка по регулярным выражениям

В этом уроке вы кратко познакомились с регулярными выражениями и вариантами их использования. С помощью регулярных выражений можно создать множество других сложных шаблонов. Вам поможет памятка по регулярным выражениям.

Регулярное выражение | Определение
-|-
`^` | Соответствует началу строки.
`$` | Соответствует концу строки.
`.` | Соответствует любому символу.
`\s` | Соответствует пробелу.
`\S` | Соответствует любому символу, не являющемуся пробелом.
`*` | Повторяет символ ноль или более раз.
`*?` | Повторяет символ ноль или более раз (нежадное сопоставление).
`+` | Повторяет символ один или более раз.
`+?` | Повторяет символ один или более раз (нежадное сопоставление).
`[aeiou]` | Соответствует одному символу из указанного набора.
`[^XYZ]` | Соответствует одному символу, не входящему в указанный набор.
`[a-z0-9]` | Набор символов может включать диапазон.
`(` | Указывает, откуда следует начинать извлечение строк.
`)` | Указывает, где следует закончить извлечение строк.

Дополнительные сведения о Visual Studio Code и регулярных выражениях см. в [документации по Visual Studio Code](https://learn.microsoft.com/ru-ru/visualstudio/ide/using-regular-expressions-in-visual-studio).

# Использование команды grep для сопоставления регулярных выражений

Итак, вы узнали об основных принципах проверки файлов и регулярных выражений. В этом уроке мы расскажем о команде `grep` для поиска определенных файлов или команду `stdin` для поиска шаблонов, соответствующих регулярному выражению. Как и другие команды, которые мы видели ранее, команда `grep` имеет много флагов для управления потоком вывода и его поведением.

## Базовое использование
Давайте начнем с базового использования команды. Общий синтаксис `grep` имеет вид `grep 'pattern' [file_to_search]`, где значение шаблона заключено в символы апострофа (`'`).

Чтобы найти все строки в файле с шаблоном `*.novo.d`k, мы укажем регулярное выражение следующим образом:
+ Начните с символа звездочки (`*`) для поиска строк, соответствующих любому символу, ноль и более раз.
+ После символа звездочки добавьте строку `.novo.dk`. В этом примере точка (`.`) является литеральной и не используется в качестве подстановочного знака.
+ Используйте `escape`-символ обратной косой черты (`\`) для специальных символов в шаблоне: звездочка и точка.

## Использование grep для файла
Мы будем искать все строки в файле `NASA-logs-1995.txt`, которые содержат шаблон `grep'*.novo.dk'`.

1. Сначала закройте редактор Cloud Shell, чтобы в терминале было достаточно места для просмотра выходных данных команды.<br>
    Закрыть редактор можно двумя способами:
    + Нажмите клавиши `CTRL+Q`.
    + Нажмите кнопку с многоточием (`...`) и выберите Закрыть редактор.

![Screenshot showing the Close Editor option on the ellipsis context menu.](/Materials/Bash/Pictures/02_03.png)

2. Выполните команду `grep`, чтобы сопоставить регулярное выражение `\*\.novo\.dk` в файле:

```bash
grep '\*\.novo\.dk' NASA-logs-1995.txt
```

Вот несколько первых строк выходных данных:

```bash
...
***.novo.dk 807951981 GET /shuttle/countdown/video/livevideo2.gif 200 69067
***.novo.dk 807952044 GET /htbin/cdt_clock.pl 200 543
***.novo.dk 807952060 GET /shuttle/countdown/lps/fr.html 200 1879
***.novo.dk 807952078 GET /shuttle/countdown/lps/fr.gif 200 30232
***.novo.dk 807952102 GET /shuttle/countdown/lps/back.gif 200 1289
```

## Использование grep для нескольких файлов
Можно также передать несколько файлов команде `grep`.

Давайте найдем все вхождения слова "NASA" в обоих файлах наборов данных НАСА. На этот раз мы ожидаем гораздо больше результатов, поэтому вместо просмотра всех результатов мы укажем команде сообщить, сколько строк соответствует шаблону. Чтобы выполнить подсчет и создать отчет, мы передадим команде `grep` флаг `-c`.

Выполните следующую команду grep для двух файлов наборов данных:

```Bash
grep -c 'NASA' NASA-logs-1995.txt NASA-software-API.txt
```

Вы должны увидеть следующий результат:

```bash
NASA-logs-1995.txt:17277
NASA-software-API.txt:26
```

В наборе данных журнала содержится 17 277 вхождений "NASA", а в наборе данных API — 26 вхождений.

## Флаги grep
Команда `grep` очень эффективна. С ее помощью можно сопоставлять сложные регулярные выражения и настраивать поток вывода в зависимости от потребностей. Запомните несколько полезных флагов.

Флаг | Определение
-|-
`grep -c` | Подсчитывает количество строк, соответствующих шаблону (эквивалентно `grep 'pattern' file | wc -l`).
`grep -n` | Указывает номер строки и соответствующий шаблон.
`grep -i` | Разрешает соответствие, не учитывающее регистр.
`grep -w` | Ищет сопоставление по целому слову.
`grep -H` | Включает имена файлов (полезно, если вы выполняете поиск по нескольким файлам).
`grep -m <max number lines>` | Ограничивает количество отображаемых совпадений. Чтобы ограничить отображение только первыми четырьмя совпадениями, используйте `-m4`.

# Общие сведения о редакторе потоков

Редактор потоков (`sed`) — это полезный инструмент для анализа и обработки текста. Его можно использовать для преобразований текста, поступающего из стандартного входного потока или файла. Средство `sed` изменяет текст построчно и не в интерактивном режиме. Таким образом, вы сами принимаете решения при вызове команды. Эти направления выполняются автоматически. Благодаря этой возможности `sed` является мощным и быстрым средством для преобразования текста.

## Базовое использование
Средство `sed` работает с текстом из `stdin` или из файла. Такое поведение позволяет отправлять выходные данные другой команды непосредственно в средство `sed` для редактирования. Вы также можете работать с ранее созданным или измененным файлом.

Помните, что команда `sed` по умолчанию выводит все данные в `stdout`. Если вы хотите сохранить измененный текст, необходимо перенаправить выходные данные с помощью оператора перенаправления (`>`), как мы делали с командой `cat`.

Базовое использование `sed` — `sed [options] commands [file-to-edit]`.

+ Попробуйте выполнить эту базовую команду `sed` с файлом `NASA-software-API.txt`:

```Bash
sed '' NASA-software-API.txt
```

Команда выводит содержимое файла в `stdout` так же, как и команда `cat`. Одинарными кавычками помечены инструкции по редактированию для команды `sed`. В этом случае мы не передали инструкции по редактированию, поэтому команда вывела каждую строку, полученную в терминале.

Средство `sed` может работать с входными данными из `stdin`, а не с файлами, а также позволяет сохранять выходные данные из команды.

## Подстановка текста с помощью sed
Подстановка текста — это, пожалуй, самый известный вариант использования средства `sed`. Как мы узнали ранее, команда `sed` может искать тестовые шаблоны с помощью регулярных выражений. Но средство также может заменить совпадающий текст другим.

Общий синтаксис подстановки текста — `sed s'/old_text/new_text/'`, где `s` — это инструкция по редактированию, которая означает подстановку, а символы косой черты (`/`) отделяют текст, используемый в подстановке.

Представим, что у вас есть URL-адрес `https://www.nasa.gov/about/sites/index.html` и вы хотите заменить часть `index.html` URL-адреса текстом `home`.

+ Эту замену можно выполнить с помощью следующей команды `sed`:

```Bash
echo "https://www.nasa.gov/about/sites/index.html" | sed s'/index.html/home/'
```

В потоке вывода отображается измененный URL-адрес.

```bash
https://www.nasa.gov/about/sites/home
```

Давайте попробуем выполнить некоторые операции подстановки с содержимым в файле `NASA-software-API.txt`.

Мы заменим все вхождения сокращения "NASA" полным названием "National Aerospace Agency". Прежде чем сделать подстановку, мы получим количество вхождений сокращения "NASA". После запуска средства sed мы проверим количество, чтобы убедиться в замене всех вхождений.

1. Откройте файл `NASA-software-API.txt` в редакторе Cloud Shell:

```Bash
code NASA-software-API.txt
```

2. Откройте поле поиска для интегрированного редактора и введите строку NASA.

Результат в поле поиска показывает 27 совпадений для сокращения "NASA".

![02](/Materials/Bash/Pictures/02_04.PNG)

3. Теперь выполните команду `sed`, чтобы выполнить замену:

```Bash
sed 's/NASA/National Aerospace Agency/' NASA-software-API.txt
```

Обратите внимание, что подстановка выполняется для всех совпадений для "NASA", но команда выводит все строки файла в терминал (`stdout`). Это поведение используется по умолчанию для инструмента `sed`.

Чтобы вывести только строки, в которых была применена замена, можно использовать флаг `-n`. Мы также передадим параметр `p` в инструкциях по редактированию, чтобы отключить автоматический вывод.

Выполните команду `sed` еще раз и выведите только те строки, в которых применяется замена шаблона:

```Bash
sed -n 's/NASA/National Aerospace Agency/p' NASA-software-API.txt
```

На этот раз мы видим меньше выходных данных, так как мы использовали флаг `-n` и параметр `p`.

## Запись в файл
Одним из самых распространенных способов использования средства `sed` является регистрация результатов синтаксического анализа или операции редактирования. В предыдущих примерах мы были ограничены в нашей способности проверять результаты команды. Мы могли видеть только выходные данные команды, отображаемые в терминале.

Существует еще один флаг, который можно использовать после третьего разделителя в команде `sed` для разрешения этой проблемы. Флаг w позволяет указывать файл для получения измененных данных из команды.

Попробуем выполнить предыдущую команду еще раз. На этот раз мы запишем все содержимое, измененное командой `sed`, в новый файл.

1. Выполните команду `sed`, чтобы вывести только замененные строки, и отправьте измененные данные в новый файл, например `NASA-replaced.txt`:

```Bash
sed -n 's/NASA/National Aerospace Agency/w NASA-replaced.txt' NASA-software-API.txt
```

2. Выполните `ls`, чтобы просмотреть новый файл в каталоге.

```bash
file1    file2    NASA-logs-1995.txt    NASA-replaced.txt    NASA-software-API.txt
```

3. Откройте новый файл в редакторе Cloud Shell.

В новом файле должно появиться 26 строк содержимого.

## Задача
Если вы используете поле поиска для поиска строки "NASA" в новом файле, вы заметите одно оставшееся вхождение сокращения. Наш вызов к команде `sed` сделал только 26 подстановок.

Одна строка в файле `NASA-software-API.txt` имела два вхождения сокращения "NASA". Наш вызов к команде `sed` успешно заменил только первое вхождение. Второе вхождение "NASA" присутствует в термине "NASAViz".

Можете ли вы воспользоваться рассмотренными командами, чтобы сделать такую последнюю замену?

```bash
sed -n 's/NASA/National Aerospace Agency/w NASA-replaced-2.txt' NASA-replaced.txt
```
## Использование фильтров и каналов

Вы уже узнали команды для проверки файлов, научились искать совпадения с помощью регулярных выражений и как работать с редактором потоков.

Мы обсудили, что такие команды, как `cat` и `grep`, отправляют выходные данные на экран монитора по умолчанию (`stdout`). Во многих случаях может быть полезно перенаправить эти выходные данные в другой файл с помощью оператора "больше чем" (`>`) или в другую программу, которая преобразует данные для дальнейшей обработки. В UNIX мы называем этот тип перенаправления [фильтром](http://www.linfo.org/filters.html).

Возможно, вы уже догадываетесь, что можно создать конвейер команд путем объединения нескольких фильтров. Чтобы создать такое сочетание, мы используем символ вертикальной черты (`|`) для формирования [каналов](http://www.linfo.org/pipes.html). Каналы — это тип перенаправления, который позволяет отправлять выходные данные одной программы (или фильтра) другой программе для дальнейшей обработки.

Канал часто используется для объединения потоков stdout и stderr и отображения выходных данных в терминале. Еще один способ использования каналов и фильтров — сохранение результатов команд в файле для изучения проблем со сборкой.

Рассмотрим несколько примеров каналов и фильтров, используя команды, которые вы изучили в предыдущих уроках.

1. Воспользуйтесь символом вертикальной черты, чтобы добавить номера строк в выходные данные из команды cat:

```Bash
cat NASA-software-API.txt | nl
```

Команда `nl` добавляет номера строк в выходные данные. Обратите внимание, что последняя строка имеет номер 700:

```bash
...
698  GSC-14732-1 GSFC 2004-06-09T00:00:00.000 "Open Source" "Tool For Interactive Plotting, Sonification, And 3D Orbit Display (TIPSOD)"
699  GSC-14730-1 GSFC 2004-06-09T00:00:00.000 "Open Source" "Space Physics Data Facility Web Services"
700  GSC-14726-1 GSFC 2004-06-09T00:00:00.000 "Open Source" "Earth Observing System (EOS) Clearinghouse (ECHO)"
```

2. Подсчитайте количество строк во всех TXT-файлах в каталоге и отсортируйте выходные данные по возрастанию с помощью канала:

```Bash
wc -l  *.txt | sort -n
```

Команда `wc` подсчитывает количество строк в содержимом. Команда `sort` представляет выходные данные в указанном порядке сортировки. Обратите внимание на подстановочный знак "звездочка" (`*`) во входном потоке `*.txt`, который указывает, что `all files that end in .txt`.

В каталоге __data__ находится три текстовых (.txt) файла. Команда `sort` отображает три текстовых файла в порядке возрастания в соответствии с количеством строк в каждом файле. После списка файлов команда `wc` отображает общее количество строк для всех проверенных файлов.

```bash
    26 NASA-replaced.txt
   703 NASA-software-API.txt
200000 NASA-logs-1995.txt
200729 total
```

3. Выполните ту же команду и добавьте второй символ вертикальной черты, чтобы отобразить только первую строку выходных данных:

```Bash
wc -l  *.txt | sort -n | head -n 1
```

Команда `head` отображает указанное количество строк в содержимом, начиная с верхней части потока или файла.

В этом примере отображается только первая строка выходных данных:

```bash
    26 NASA-replaced.txt
```

4. Используйте каналы для нумерования строк в выходных данных, отображения только первых пяти строк и сортировки выходных данных в обратном порядке:

```Bash
nl -s = NASA-replaced.txt | head -n 5 | sort -r
```

![02](/Materials/Bash/Pictures/02_05.PNG)

Появятся следующие выходные данные.

```bash
5=ARC-16054-1 ARC 2007-09-28T00:00:00.000 "Open Source" "National Aerospace Agency VisionWorkbench Version 1.2"
4=ARC-15761-1A ARC 2012-06-04T00:00:00.000 "Open Source" "National Aerospace Agency Vision Workbench (VW) v3 "
3=ARC-15166-1A ARC 2008-05-02T00:00:00.000 "Open Source" "National Aerospace Agency World Wind Java (WWJ) Software Development Kit (SDK) & 
2=ARC-15166-1 ARC 2004-01-12T00:00:00.000 "Open Source" "National Aerospace Agency WorldWind Interactive 3D Virtual Globe Software"
1=ARC-15150-1 ARC 2005-05-23T00:00:00.000 "General Public" "National Aerospace Agency Task Load Index (TLX)"
```

Вы можете попробовать вариант этого примера с использованием команды `cat` и трех символов вертикальной черты:

```Bash
cat NASA-replaced.txt | nl | head -n 5 | sort -r
```

Вы заметили разницу в выходных данных?

5. Создайте сложный конвейер, использующий фильтр команд `sed`:
+ Воспользуйтесь командой `grep`, чтобы найти первые 10 строк, содержащих сокращение "NASA" в файле `NASA-logs-1995.txt`.
+ Отсортируйте выходные данные в обратном порядке.
+ Замените сокращение "NASA" полным названием "National Aerospace Agency", для чего нужно реплицировать действие, которое мы выполнили в предыдущем уроке, с помощью команды `grep`.
```Bash
grep -m10 'NASA' NASA-logs-1995.txt | sort -r | sed -n s'/NASA/National Aerospace Agency/p'
```

Появятся следующие выходные данные.

```bash
***.novo.dk 807951864 GET /images/National Aerospace Agency-logosmall.gif 200 786
***.novo.dk 805465157 GET /images/National Aerospace Agency-logosmall.gif 200 786
***.novo.dk 805465054 GET /images/National Aerospace Agency-logosmall.gif 200 786
01-dynamic-c.wokingham.luna.net 809570230 GET /images/National Aerospace Agency-logosmall.gif 304 0
01-dynamic-c.wokingham.luna.net 806878949 GET /images/National Aerospace Agency-logosmall.gif 304 0
01-dynamic-c.wokingham.luna.net 805378672 GET /images/National Aerospace Agency-logosmall.gif 200 786
007.thegap.com 807996997 GET /images/National Aerospace Agency-logosmall.gif 200 786
007.thegap.com 806532057 GET /images/National Aerospace Agency-logosmall.gif 200 786
007.thegap.com 805072932 GET /images/National Aerospace Agency-logosmall.gif 200 786
007.thegap.com 805065766 GET /images/National Aerospace Agency-logosmall.gif 200 786
```

В этих примерах показано, как можно создать множество различных конвейеров, используя всего несколько команд.

## Проверка команд и средств

В этом модуле мы кратко рассмотрели различные виды средств и команд. Этого введения должно быть достаточно для того, чтобы приступить к первичной обработке данных в оболочке UNIX.

Ниже приведена сводка по командам и средствам, которые мы рассмотрели:
+ Команда `cat` позволяет отображать, объединять и добавлять файлы.
+ Каналы (`|`) отправляют выходные данные одной команды в качестве входных данных другой команды.
+ Фильтр принимает входные данные от одной команды, выполняет обработку и предоставляет выходные данные.
+ Регулярные выражения (`regex`) применяются для сопоставления шаблонов и могут использоваться другими командами и инструментами, такими как `sed` и `grep`.
+ Команду `grep` можно использовать для поиска строк и значений в текстовом файле.
+ Одно из наиболее распространенных применений — передача через `grep`.
+ Наиболее распространенным использованием редактора потоков (`sed`) является подстановка текста.

## Проверка знаний

1. В текущем каталоге мы хотим найти три файла с наименьшим числом строк. Какая команда сработает? 

+ [] wc -l * > sort -n > head -n 3
+ [] wc -l * | sort -n | head -n 1-3
+ [x] wc -l * | sort -n | head -n 3 <br>
Правильно. Эта команда выведет число строк в файле, отсортирует выходные данные по возрастанию (чисел) и отобразит первые три строки.
+ [] wc -l * | head -n 3 | sort -n

2. Что соответствует регулярному выражению Fr[ea]nc[eh]? 
+ [x] French, France, Frence, Franch <br>
Правильно. Регулярное выражение с такой конструкцией будет соответствовать написанию с ошибкой, например Frence и Franch.
+ [] Frenche, Franceh, Frenceh, Franche
+ [] France, French
+ [] Freanceh, Fraenche

3. Параметр -v для команды grep инвертирует сопоставление шаблонов, чтобы выводить только строки, которые не соответствуют шаблону. Какая из следующих команд найдет все файлы в каталоге /data, имена которых заканчиваются на s.txt, но не содержат строку net? Примеры: shuttles.txt или software.txt, но не planets.txt. 

+ [] find data -name *s.txt | grep -v net
+ [x] grep -v 'net' $(find data -name '*s.txt')<br>
Неправильно. Эта команда ищет в содержимом файлов строки, не соответствующие значению net, но не рассматривает имена файлов.
+ [] find data -name '*s.txt' | grep -v net<br>
Правильно. Если поместить выражение соответствия в кавычки, оболочка не будет расширять его, поэтому оно будет передано команде поиска.
+ [] Нет подходящих вариантов.

4. Предположим, что необходимо удалить обработанные файлы данных и сохранить только необработанные файлы и скрипт обработки, чтобы сэкономить место. Необработанные файлы заканчиваются на .dat, а обработанные — на .txt. Какое из следующих решений приведет к удалению всех обработанных файлов данных и только их? 
+ [] rm ?.txt
+ [x] rm *.txt<br>
Правильно. Это выражение удалит все файлы, заканчивающиеся на .txt.
+ [] rm * .txt
+ [] rm *.*

## Сводка

В этом модуле вы ознакомились с некоторыми инструментами и командами, которые можно использовать в оболочке UNIX для преобразования данных из одного формата в другой.

Сначала вы узнали о командах `head`, `tail`, `wc` и `nl`. С помощью этих команд можно выполнить быструю проверку текстовых файлов и получить более полное представление о необработанных данных. Затем вы ознакомились с командой `cat`. Эта команда позволяет просматривать содержимое файлов. Ее также можно использовать для создания новых файлов путем добавления или объединения содержимого файлов.

Затем вы рассмотрели основы регулярных выражений (`regex`). Регулярные выражения удобны для сопоставления шаблонов и могут использоваться в IDE и в командной строке с другими фильтрами и командами.

Затем вы узнали о `sed` и `grep`, которые можно использовать для поиска и замены шаблонов в текстовых потоках и файлах.

Наконец, вы узнали о каналах и перенаправлении потоков вывода. Использование каналов позволяет объединить все команды и фильтры, изученные в предыдущих уроках, для создания конвейеров обработки данных.

Теперь у вас должно быть хорошее представление о том, что делают эти команды и как их использовать для эффективного преобразования данных из оболочки UNIX.

### Ресурсы
+ [Фильтры](http://www.linfo.org/filters.html)
+ [Каналы](http://www.linfo.org/pipes.html)
+ [Введение в регулярные выражения](https://regex101.com/)
+ [Команды оболочки UNIX](https://www.educba.com/unix-shell-commands/)
+ [Команды оболочки UNIX (и Linux)](https://www.geeksforgeeks.org/essential-linuxunix-commands/)
+ [Документация по Visual Studio Code](https://learn.microsoft.com/ru-ru/visualstudio/ide/using-regular-expressions-in-visual-studio)

### Команды и фильтры
+ [Команда cat](https://www.techonthenet.com/unix/basic/cat.php)
+ [Команда grep](https://www.techonthenet.com/unix/basic/grep.php)
+ [Команда head](https://www.tutorialspoint.com/unix_commands/head.htm)
+ [Команда mkdir и другие основные команды UNIX](https://www.techonthenet.com/unix/basic/mkdir.php)
+ [Фильтр nl](https://www.geeksforgeeks.org/nl-command-in-linux-with-examples/)
+ [Команда sed](https://www.educba.com/sed-command-in-unix/)
+ [Команда sort](https://www.tutorialspoint.com/unix_commands/sort.htm)
+ [Команды stderr, stdin и stdout](https://www.howtogeek.com/435903/what-are-stdin-stdout-and-stderr-on-linux/)
+ [Команда tail](https://www.tutorialspoint.com/unix_commands/tail.htm)
+ [Команда wc](https://www.tutorialspoint.com/unix_commands/wc.htm)
+ [Команда wget](https://www.tutorialspoint.com/unix_commands/wget.htm)