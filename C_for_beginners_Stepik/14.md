#  Динамическая память

## Чтение чисел и текста

[Видео](https://youtu.be/W9UR_60rjWY)


### Уже знаем
Мы не задумывались раньше, что происходит с памятью, когда мы объявляем переменные и как эта память освобождается, когда время жизни переменной заканчивается.

```c
#include <stdio.h>


int foo(int k)                      // выделяется память для переменной k
{
    int x = 7;                      // выделяется память для переменной x
    int a[5] = {-1, 2, -3, 4, -5};  // выделяется память для переменной a
    int * p = a+2;                  // выделяется память для переменной p


    return x + a[k] + p[0];
    // освобождается память, занятая переменными k, x, a, p
}


int main()
{
    int b;                          // выделяется память для переменной b
    b = foo(0);
    b += foo(2);
    printf("%d\n", b);


    return 0;
    // освобождается память, занятая переменной b
}
```

Программа неявно выделяет и освобождает память. Кроме неявной автоматической работы с памятью, можно выделять память и освобождать её с помощью стандартных функций языка Си.

Это нужно, если:
+ в программе используются нестандартные структуры данных, например, нужна треугольная матрица, а не прямоугольная;
+ во время работы программы нужно изменить размер массива (пришло больше данных);
+ нужно вернуть из функции указатель на локальную переменную (она автоматически уничтожается при выходе из функции);
+ размер массива определяется на этапе выполнения программы, а не компиляции.

### Чтение последовательности чисел, n задано и ограничено
В задачах обычно последовательность чисел задается так: "Дано n, далее n чисел". Например:

```
5
2 -3 16 31 -10
```

Будем дважды печатать последовательность. Для этого сохраним её в массиве.

Если в условии задачи n ограничено n<1000, то задачу можно решить без динамической памяти. Объявив массив из 1000 элементов.

До стандарта С99 размер массива должен был задаваться на этапе компиляции.

```c
#include <stdio.h>
#define N 1000                  // ограничение на размер массива


// печатает первые n элементов массива a
void print_arr(int a[], int n)
{
    for(int i = 0; i < n; i++)
        printf("%d ", a[i]);
    printf("\n");
}
int main()
{
    int a[N];                   // массив, размер задаем на этапе компиляции
    int n;                      // сколько чисел дано


    scanf("%d", &n);            // дано n
    for(int i = 0; i < n; i++)
        scanf("%d", a+i);       // вместо a+i можете писать &a[i]


    print_arr(a, n);
    print_arr(a, n);


    return 0;
}
```

### В условии задачи не сказано чем ограничено n
То есть на этапе компиляции мы не знаем, массив какого размера объявлять. Только при конкретном запуске программы (во время ее выполнения, runtime) указывается сколько будет чисел.

__Начиная с С99 можно определять длину массива на этапе выполнения__. На проверяющих серверах [ejudge МФТИ](https://stepik.org/lesson/308220/step/3) это запрещено.

Приведем часть кода. Заметьте, сначала считываем n, потом объявляем массив a[n].

```c
int n;              // сколько чисел дано
scanf("%d", &n);    // прочитали n
int a[n];           // объявили массив, размер n задаем на этапе выполнения программы


for(int i = 0; i < n; i++)
    scanf("%d", a+i);
```

То же самое можно записать через функции `malloc` и `free`:

```c
int n;                                  // сколько чисел дано
scanf("%d", &n);                        // прочитали n
int * a = malloc(n * sizeof(int));      // сами выделили динамическую память для
                                        // для n * sizeof(int) байт,
                                        // на эту память указывает переменная a


for(int i = 0; i < n; i++)
    scanf("%d", a+i);                   // работаем с этой памятью, как с обычным массивом


print_arr(a, n);
print_arr(a, n);


free(a);                                // сами освободили память после использования
```

Для работы `malloc` и `free` нужно подключить `stdlib.h`

+ `void * malloc (size_t size);`
    + выделить `size` байт памяти,
    + возвращает указатель на выделенную память.
+ `void free (void *ptr);`
    + освободить память, на которую указывает `ptr`

### n не задано, но ограничено
Если n не дано, а задана только последовательность чисел, то читаем все числа, используя scanf

Если известно, что чисел не больше, например, 100, то объявим массив int a[100] и будем читать в него.

```c
#include <stdio.h>


// печатает первые n элементов массива a
void print_arr(int a[], int n)
{
    for(int i = 0; i < n; i++)
        printf("%d ", a[i]);
    printf("\n");
}
int main()
{
    int a[100];                 // массив, размер задаем на этапе компиляции


    int i;                      // читаем числа, пока они есть
    for(i = 0; 1 == scanf("%d", &a[i]); i++)
        ;
    int n = i;                  // количество элементов в массиве


    print_arr(a, n);
    print_arr(a, n);


    return 0;
}
```

### n не задано и не ограничено
Если до запуска программы нельзя ничего сказать о количестве чисел, то неизвестно какого размера объявить массив.
+ Сначала массив пустой, память не выделена.
+ Пока есть числа на входе:
    + выделим столько памяти, чтобы появилось место под новое число,
    + запишем в массив новое число.
Размер массива будет расти на каждой итерации цикла.

```c
a = realloc(a, (i+1)*sizeof(int));
```

+ выделяет память размером `(i+1)*sizeof(int)` байт,
    + для хранения первого числа нужно записать число в `a[0]` а памяти выделить для `1*sizeof(int)`, то есть при `i=0` пишем в `a[i]`, а выделяем память `(i+1)*sizeof(int)` байт,
+ копирует данные из старой памяти в новую,
+ освобождает старую память.

```c
#include <stdio.h>
#include <stdlib.h>


// печатает первые n элементов массива a
void print_arr(int a[], int n)
{
    for(int i = 0; i < n; i++)
        printf("%d ", a[i]);
    printf("\n");
}
int main()
{
    int * a = NULL;             // указатель указывает на NULL


    int x;                      // читаем числа, пока они есть
    int i;                      // количество прочитанных чисел
    for(i = 0; 1 == scanf("%d", &x); i++){
        a = realloc(a, (i+1)*sizeof(int));
        a[i] = x;
    }


    print_arr(a, i);
    print_arr(a, i);


    // освобождаем выделенную память
    free(a);


    return 0;
}
```

После того, как массив перестал быть нужен, надо освободить выделенную под него память функцией `free`.

### Выделение памяти под строку
Сделаем копию строки, выделив для нее память.

Исходная строка может или располагаться в массиве, или задаваться через указатель.

![14](/C_for_beginners_Stepik/Pictures/11_02.png)

В результате получится указатель `dst`, который указывает на выделенную функцией `malloc` память.

```c
char * dst = malloc(1+strlen(s1));  // +1 для хранения \0
strcpy(dst, s1);
```

То же самое делает стандартная функция `strdup`:

```c
char * dst = strdup(s1);
```

### Чтение слова с выделением динамической памяти
Этот материал уже был раньше

Можно читать по слову (слово - это последовательность непробельных символов). Опция `%ms` неявно вызывает `malloc`. И требует явного вызова `free`, когда память перестанет быть нужной.

```c
#include <stdio.h>
#include <stdlib.h>


int main()
{
    char *s = NULL;                 // указатель, в него будет записываться адрес выделяемой памяти


    while(1 == scanf("%ms", &s)) {  // неявный вызов malloc, обратите внимание &s
        printf("<%s>\n", s);        // используем прочитанное слово


        free(s);                    // освобождаем память после использования, чтобы не было утечек
    }
    return 0;
}
```

Обратите внимание на a1 :

```c
char a1[100];
scanf("%99s", a1);       // a1 типа char *, с контролем переполнения
```

и на &a2:

```c
char * a2 = NULL;
scanf("%ms", &a2);      // &a2 типа char **, выделяеся динамическая память
// ...                  используем прочитанное слово
free(a2);               // освобождаем память после использования
```

### Чтение строки с выделением динамической памяти

```c
#include <stdio.h>


ssize_t getline(char **lineptr, size_t *n, FILE *stream);
ssize_t getdelim(char **lineptr, size_t *n, int delim, FILE *stream);
```

Функция `getline` считывает из потока `stream` строку, сохраняя ее в памяти по адресу `*lineptr` размером `n` байтов.


```c
#include <stdio.h>
#include <stdlib.h>


int main(void)
{
        FILE * fp;
        char * line = NULL;
        size_t len = 0;
        ssize_t read;
        fp = fopen("/etc/motd", "r");
        if (fp == NULL)
                exit(EXIT_FAILURE);
        while ((read = getline(&line, &len, fp)) != -1) {
                printf("Retrieved line of length %zu :\n", read);
                printf("%s", line);
        }
        if (line)
                free(line);
        return EXIT_SUCCESS;
}
```

Функция изначально была расширением `GNU` и была внесена в стандарт `POSIX.1-2008`.

Как это работает?

+ `getline` считывает строку в `*lineptr`
    + буфер завершается `null`;
    + если во входном потоке был `\n`, то он тоже попадает в буфер; если в последней строке наступил конец файла и не было `\n`, то в буфер `\n` не запишется;
+ при необходимости для `*lineptr` делается `realloc`, новые значения размера буфера записываются в `n`;
+ `getline` работает как `getdelim` с разделителем `\n`, если нужно указать другой разделитель, используйте аргумент `delim` функции `getdelim`;
обе функции возвращают количество считанных символов (с учетом разделителя, если он был), но без учета `null`.
    + При ошибке возвращается -1.