#  Динамическая память

## Чтение чисел и текста

[Видео](https://youtu.be/W9UR_60rjWY)


### Уже знаем
Мы не задумывались раньше, что происходит с памятью, когда мы объявляем переменные и как эта память освобождается, когда время жизни переменной заканчивается.

```c
#include <stdio.h>


int foo(int k)                      // выделяется память для переменной k
{
    int x = 7;                      // выделяется память для переменной x
    int a[5] = {-1, 2, -3, 4, -5};  // выделяется память для переменной a
    int * p = a+2;                  // выделяется память для переменной p


    return x + a[k] + p[0];
    // освобождается память, занятая переменными k, x, a, p
}


int main()
{
    int b;                          // выделяется память для переменной b
    b = foo(0);
    b += foo(2);
    printf("%d\n", b);


    return 0;
    // освобождается память, занятая переменной b
}
```

Программа неявно выделяет и освобождает память. Кроме неявной автоматической работы с памятью, можно выделять память и освобождать её с помощью стандартных функций языка Си.

Это нужно, если:
+ в программе используются нестандартные структуры данных, например, нужна треугольная матрица, а не прямоугольная;
+ во время работы программы нужно изменить размер массива (пришло больше данных);
+ нужно вернуть из функции указатель на локальную переменную (она автоматически уничтожается при выходе из функции);
+ размер массива определяется на этапе выполнения программы, а не компиляции.

### Чтение последовательности чисел, n задано и ограничено
В задачах обычно последовательность чисел задается так: "Дано n, далее n чисел". Например:

```
5
2 -3 16 31 -10
```

Будем дважды печатать последовательность. Для этого сохраним её в массиве.

Если в условии задачи n ограничено n<1000, то задачу можно решить без динамической памяти. Объявив массив из 1000 элементов.

До стандарта С99 размер массива должен был задаваться на этапе компиляции.

```c
#include <stdio.h>
#define N 1000                  // ограничение на размер массива


// печатает первые n элементов массива a
void print_arr(int a[], int n)
{
    for(int i = 0; i < n; i++)
        printf("%d ", a[i]);
    printf("\n");
}
int main()
{
    int a[N];                   // массив, размер задаем на этапе компиляции
    int n;                      // сколько чисел дано


    scanf("%d", &n);            // дано n
    for(int i = 0; i < n; i++)
        scanf("%d", a+i);       // вместо a+i можете писать &a[i]


    print_arr(a, n);
    print_arr(a, n);


    return 0;
}
```

### В условии задачи не сказано чем ограничено n
То есть на этапе компиляции мы не знаем, массив какого размера объявлять. Только при конкретном запуске программы (во время ее выполнения, runtime) указывается сколько будет чисел.

__Начиная с С99 можно определять длину массива на этапе выполнения__. На проверяющих серверах [ejudge МФТИ](https://stepik.org/lesson/308220/step/3) это запрещено.

Приведем часть кода. Заметьте, сначала считываем n, потом объявляем массив a[n].

```c
int n;              // сколько чисел дано
scanf("%d", &n);    // прочитали n
int a[n];           // объявили массив, размер n задаем на этапе выполнения программы


for(int i = 0; i < n; i++)
    scanf("%d", a+i);
```

То же самое можно записать через функции `malloc` и `free`:

```c
int n;                                  // сколько чисел дано
scanf("%d", &n);                        // прочитали n
int * a = malloc(n * sizeof(int));      // сами выделили динамическую память для
                                        // для n * sizeof(int) байт,
                                        // на эту память указывает переменная a


for(int i = 0; i < n; i++)
    scanf("%d", a+i);                   // работаем с этой памятью, как с обычным массивом


print_arr(a, n);
print_arr(a, n);


free(a);                                // сами освободили память после использования
```

Для работы `malloc` и `free` нужно подключить `stdlib.h`

+ `void * malloc (size_t size);`
    + выделить `size` байт памяти,
    + возвращает указатель на выделенную память.
+ `void free (void *ptr);`
    + освободить память, на которую указывает `ptr`

### n не задано, но ограничено
Если n не дано, а задана только последовательность чисел, то читаем все числа, используя scanf

Если известно, что чисел не больше, например, 100, то объявим массив int a[100] и будем читать в него.

```c
#include <stdio.h>


// печатает первые n элементов массива a
void print_arr(int a[], int n)
{
    for(int i = 0; i < n; i++)
        printf("%d ", a[i]);
    printf("\n");
}
int main()
{
    int a[100];                 // массив, размер задаем на этапе компиляции


    int i;                      // читаем числа, пока они есть
    for(i = 0; 1 == scanf("%d", &a[i]); i++)
        ;
    int n = i;                  // количество элементов в массиве


    print_arr(a, n);
    print_arr(a, n);


    return 0;
}
```

### n не задано и не ограничено
Если до запуска программы нельзя ничего сказать о количестве чисел, то неизвестно какого размера объявить массив.
+ Сначала массив пустой, память не выделена.
+ Пока есть числа на входе:
    + выделим столько памяти, чтобы появилось место под новое число,
    + запишем в массив новое число.
Размер массива будет расти на каждой итерации цикла.

```c
a = realloc(a, (i+1)*sizeof(int));
```

+ выделяет память размером `(i+1)*sizeof(int)` байт,
    + для хранения первого числа нужно записать число в `a[0]` а памяти выделить для `1*sizeof(int)`, то есть при `i=0` пишем в `a[i]`, а выделяем память `(i+1)*sizeof(int)` байт,
+ копирует данные из старой памяти в новую,
+ освобождает старую память.

```c
#include <stdio.h>
#include <stdlib.h>


// печатает первые n элементов массива a
void print_arr(int a[], int n)
{
    for(int i = 0; i < n; i++)
        printf("%d ", a[i]);
    printf("\n");
}
int main()
{
    int * a = NULL;             // указатель указывает на NULL


    int x;                      // читаем числа, пока они есть
    int i;                      // количество прочитанных чисел
    for(i = 0; 1 == scanf("%d", &x); i++){
        a = realloc(a, (i+1)*sizeof(int));
        a[i] = x;
    }


    print_arr(a, i);
    print_arr(a, i);


    // освобождаем выделенную память
    free(a);


    return 0;
}
```

После того, как массив перестал быть нужен, надо освободить выделенную под него память функцией `free`.

### Выделение памяти под строку
Сделаем копию строки, выделив для нее память.

Исходная строка может или располагаться в массиве, или задаваться через указатель.

![14](/C_for_beginners_Stepik/Pictures/11_02.png)

В результате получится указатель `dst`, который указывает на выделенную функцией `malloc` память.

```c
char * dst = malloc(1+strlen(s1));  // +1 для хранения \0
strcpy(dst, s1);
```

То же самое делает стандартная функция `strdup`:

```c
char * dst = strdup(s1);
```

### Чтение слова с выделением динамической памяти
Этот материал уже был раньше

Можно читать по слову (слово - это последовательность непробельных символов). Опция `%ms` неявно вызывает `malloc`. И требует явного вызова `free`, когда память перестанет быть нужной.

```c
#include <stdio.h>
#include <stdlib.h>


int main()
{
    char *s = NULL;                 // указатель, в него будет записываться адрес выделяемой памяти


    while(1 == scanf("%ms", &s)) {  // неявный вызов malloc, обратите внимание &s
        printf("<%s>\n", s);        // используем прочитанное слово


        free(s);                    // освобождаем память после использования, чтобы не было утечек
    }
    return 0;
}
```

Обратите внимание на a1 :

```c
char a1[100];
scanf("%99s", a1);       // a1 типа char *, с контролем переполнения
```

и на &a2:

```c
char * a2 = NULL;
scanf("%ms", &a2);      // &a2 типа char **, выделяеся динамическая память
// ...                  используем прочитанное слово
free(a2);               // освобождаем память после использования
```

### Чтение строки с выделением динамической памяти

```c
#include <stdio.h>


ssize_t getline(char **lineptr, size_t *n, FILE *stream);
ssize_t getdelim(char **lineptr, size_t *n, int delim, FILE *stream);
```

Функция `getline` считывает из потока `stream` строку, сохраняя ее в памяти по адресу `*lineptr` размером `n` байтов.


```c
#include <stdio.h>
#include <stdlib.h>


int main(void)
{
        FILE * fp;
        char * line = NULL;
        size_t len = 0;
        ssize_t read;
        fp = fopen("/etc/motd", "r");
        if (fp == NULL)
                exit(EXIT_FAILURE);
        while ((read = getline(&line, &len, fp)) != -1) {
                printf("Retrieved line of length %zu :\n", read);
                printf("%s", line);
        }
        if (line)
                free(line);
        return EXIT_SUCCESS;
}
```

Функция изначально была расширением `GNU` и была внесена в стандарт `POSIX.1-2008`.

Как это работает?

+ `getline` считывает строку в `*lineptr`
    + буфер завершается `null`;
    + если во входном потоке был `\n`, то он тоже попадает в буфер; если в последней строке наступил конец файла и не было `\n`, то в буфер `\n` не запишется;
+ при необходимости для `*lineptr` делается `realloc`, новые значения размера буфера записываются в `n`;
+ `getline` работает как `getdelim` с разделителем `\n`, если нужно указать другой разделитель, используйте аргумент `delim` функции `getdelim`;
обе функции возвращают количество считанных символов (с учетом разделителя, если он был), но без учета `null`.
    + При ошибке возвращается -1.

##  malloc, realloc, free

### Функции работы с памятью
#### Выделение и освобождение памяти `stdlib.h`
+ `void * malloc (size_t size);`
    + выделяет память размером `size` байт
    + возвращает указатель на выделенную память или `NULL` в случае ошибки
+ `void * calloc (size_t nmemb, size_t size);`
    + выделяет память размером `nmemb*size`
    + __заполняет память 0__
    + возвращает указатель на выделенную память или NULL в случае ошибки
+ `void free (void *ptr);`
    + освобождает память, на которую указывает `ptr` (начало динамически выделенной памяти)
    + `free(NULL)` ничего не делает
+ `void * realloc (void *ptr, size_t size);`
    + выделяет память размером `size` байт
    + копирует данные из памяти, на которую указывает `ptr` в новую память
    + освобождает старую память
    + возвращает указатель на выделенную память или `NULL` в случае ошибки
    + при `ptr=NULL` работает как `malloc`
#### Копирование и заполнение данными `string.h`
+ `void * memcpy (void *dst, const void *src, size_t n);`
    + копировать `n` байт из `src` в `dst`
    + возвращает указатель на `dst`
    + нельзя использовать на перекрывающихся участках памяти
+ `void * memmove (void *dst, const void *src, size_t n);`
    + копировать `n` байт из `src` в `dst`
    + возвращает указатель на `dst`
    + можно использовать на перекрывающихся участках памяти, так как сначала идет копирование `src` во временный дополнительный массив, а потом из него в `dst`.
+ `void * memset (void *s, int c, size_t n);`
    + заполнить `n` байт числом `с`, начиная с адреса `s`

### `malloc` и `calloc`
Разница между `malloc` (memory allocation) и `calloc` (cell allocation) в аргументах. И `calloc` гарантированно заполнит память нулями.

Массив из 10 int:

```c
int a1[10];                          // без использования динамической памяти
int * a2 = malloc(10 * sizeof(int)); // malloc, сколько байт
int * a3 = calloc(10, sizeof(int));  // calloc, сколько ячеек, размер одной ячейки
```

Когда использовать `calloc`? Только если нужно обязательно заполнить массив нулями.

Если в массив читают данные, то лишнюю работу делать не нужно.

Если на контрольной у вас чтение неинициализированной памяти (частая ошибка), попробуйте вместо `malloc` использовать `calloc`. Если ошибка ушла и она последняя, порадуйтесь и решайте следующую задачу. Вы не исправили ошибку. Вы ее "закопали". В домашней работе лучше найдите, почему вы читаете неинициализированный участок памяти (выход за границы массива или забыли проинициализировать).

### `free`
+ Указатель на начало динамически выделенной памяти.
```c
int * a = malloc(10 * sizeof(int));
free(a);                            // OK
free(a+2);                          // Ошибка, не на начало выделенной памяти
```

+ Кто память выделял, тот и освобождает:

```c
int b[5];
free(b);                            // Ошибка, b не динамически выделенная память
free(NULL) ничего не делает
free(ptr); free(ptr); - неопределенное поведение (undefined behaviour)
```

Поэтому, если переменную `ptr` дальше используют в коде, пишите:

```c
free(ptr);
ptr = NULL;     // гарантия, что следующий free(ptr) не приведет к ошибке
```

### Обработка ошибок
В коммерческом программировании обязательно нужно обрабатывать ошибки, которые могут вернуть функции.

Текстовый редактор открывает новый документ. Может не хватить памяти, так как новый документ большой. Если программа просто "упадет", будет плохо. Лучше, если будет сообщение "невозможно открыть документ, не хватает памяти" и дальше можно будет закрыть и сохранить другие документы.

Для этого нужно обрабатывать ошибки:

```c
char * a = malloc(size);
if (a == NULL) {
    // обработка ошибок, пишем диагностику, сохраняем открытые документы
}
```

В курсе мы будем в примерах и задачах продолжать писать "по-студенчески", без обработки ошибок.

### `realloc`
Ошибка при `realloc` может привести к потере старых данных:

```c
char * a = strdup("Hello");     // a указывает на копию с "Hello"
a = realloc(a, 10);             // если ошибка, то a стало NULL,
                                // ничто не указывает на старую память, мы ее потеряли

```
Пишем безопасный код. Используем переменные `ptr` (старая память) и `new_ptr` (новая память):

```c
new_ptr = realloc(ptr, new_size);
if (new_ptr == NULL) {
    // обработка ошибок, быть может с выходом; старая память в переменной ptr
}
ptr = new_ptr;
```

### Работа с памятью "под капотом"
Считается, что чем реже вызываем функции `malloc`, `calloc` и `realloc`, тем быстрее работает программа. Потому что выделение памяти "тяжелая" функция. Так ли это на самом деле?

Выделением и освобождением памяти занимается менеджер памяти. Чтобы понять какая память свободная, а какая занятая, он поддерживает таблицу выделенной памяти, в которой есть колонки
+ адрес начала выделенной памяти,
+ сколько нужно было выделить памяти,
+ сколько реально выделено памяти.

В компьютере удобно память выделять блоками, обычно блок 1Кб или 4Кб (или другой размер, но не 1 байт!), поэтому может быть выделено больше памяти, чем требовалось.

Допустим, размер выделяемого блока кратен 1Кб, и были вызовы:

```c
int * a = malloc(4);
int * b = malloc(1024);
int * c = malloc(4000);
```

Пусть в таблице появились записи:

адрес | запрошено байт | выделено байт
-|-|-
0xfa0000 | 4 | 1024
0xff0000 | 1024 | 1024
0xfb0000 | 4000 | 4096
Заметим, что этот вызов не приведет к реальному перевыделению памяти, только к изменению записи в таблице:

a = realloc(a, 12);
таблица изменится:

адрес	запрошено байт	выделено байт
0xfa0000	12	1024
0xff0000	1024	1024
0xfb0000	4000	4096
а вызов

a = realloc(a, 1200);
приведет к освобождению 1024 байт памяти по адресу 0xfa0000 и выделению по какому-то другому адресу, ибо начиная с адреса 0xfb0000 (то есть через 1024 байт) память уже выделена.

Заметим, что как в случает обычных массивов, так и в случае динамического выделения памяти, память выделяется единым куском.

free - это удаление строки в таблице выделенной памяти. Очевидно, что эта память должна быть в таблице (освобождается только динамически выделенная память) и адрес должен точно совпадать с указанным в столбце адрес.