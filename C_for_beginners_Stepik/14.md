#  Динамическая память

## Чтение чисел и текста

[Видео](https://youtu.be/W9UR_60rjWY)


### Уже знаем
Мы не задумывались раньше, что происходит с памятью, когда мы объявляем переменные и как эта память освобождается, когда время жизни переменной заканчивается.

```c
#include <stdio.h>


int foo(int k)                      // выделяется память для переменной k
{
    int x = 7;                      // выделяется память для переменной x
    int a[5] = {-1, 2, -3, 4, -5};  // выделяется память для переменной a
    int * p = a+2;                  // выделяется память для переменной p


    return x + a[k] + p[0];
    // освобождается память, занятая переменными k, x, a, p
}


int main()
{
    int b;                          // выделяется память для переменной b
    b = foo(0);
    b += foo(2);
    printf("%d\n", b);


    return 0;
    // освобождается память, занятая переменной b
}
```

Программа неявно выделяет и освобождает память. Кроме неявной автоматической работы с памятью, можно выделять память и освобождать её с помощью стандартных функций языка Си.

Это нужно, если:
+ в программе используются нестандартные структуры данных, например, нужна треугольная матрица, а не прямоугольная;
+ во время работы программы нужно изменить размер массива (пришло больше данных);
+ нужно вернуть из функции указатель на локальную переменную (она автоматически уничтожается при выходе из функции);
+ размер массива определяется на этапе выполнения программы, а не компиляции.

### Чтение последовательности чисел, n задано и ограничено
В задачах обычно последовательность чисел задается так: "Дано n, далее n чисел". Например:

```
5
2 -3 16 31 -10
```

Будем дважды печатать последовательность. Для этого сохраним её в массиве.

Если в условии задачи n ограничено n<1000, то задачу можно решить без динамической памяти. Объявив массив из 1000 элементов.

До стандарта С99 размер массива должен был задаваться на этапе компиляции.

```c
#include <stdio.h>
#define N 1000                  // ограничение на размер массива


// печатает первые n элементов массива a
void print_arr(int a[], int n)
{
    for(int i = 0; i < n; i++)
        printf("%d ", a[i]);
    printf("\n");
}
int main()
{
    int a[N];                   // массив, размер задаем на этапе компиляции
    int n;                      // сколько чисел дано


    scanf("%d", &n);            // дано n
    for(int i = 0; i < n; i++)
        scanf("%d", a+i);       // вместо a+i можете писать &a[i]


    print_arr(a, n);
    print_arr(a, n);


    return 0;
}
```

### В условии задачи не сказано чем ограничено n
То есть на этапе компиляции мы не знаем, массив какого размера объявлять. Только при конкретном запуске программы (во время ее выполнения, runtime) указывается сколько будет чисел.

__Начиная с С99 можно определять длину массива на этапе выполнения__. На проверяющих серверах [ejudge МФТИ](https://stepik.org/lesson/308220/step/3) это запрещено.

Приведем часть кода. Заметьте, сначала считываем n, потом объявляем массив a[n].

```c
int n;              // сколько чисел дано
scanf("%d", &n);    // прочитали n
int a[n];           // объявили массив, размер n задаем на этапе выполнения программы


for(int i = 0; i < n; i++)
    scanf("%d", a+i);
```

То же самое можно записать через функции `malloc` и `free`:

```c
int n;                                  // сколько чисел дано
scanf("%d", &n);                        // прочитали n
int * a = malloc(n * sizeof(int));      // сами выделили динамическую память для
                                        // для n * sizeof(int) байт,
                                        // на эту память указывает переменная a


for(int i = 0; i < n; i++)
    scanf("%d", a+i);                   // работаем с этой памятью, как с обычным массивом


print_arr(a, n);
print_arr(a, n);


free(a);                                // сами освободили память после использования
```

Для работы `malloc` и `free` нужно подключить `stdlib.h`

+ `void * malloc (size_t size);`
    + выделить `size` байт памяти,
    + возвращает указатель на выделенную память.
+ `void free (void *ptr);`
    + освободить память, на которую указывает `ptr`

### n не задано, но ограничено
Если n не дано, а задана только последовательность чисел, то читаем все числа, используя scanf

Если известно, что чисел не больше, например, 100, то объявим массив int a[100] и будем читать в него.

```c
#include <stdio.h>


// печатает первые n элементов массива a
void print_arr(int a[], int n)
{
    for(int i = 0; i < n; i++)
        printf("%d ", a[i]);
    printf("\n");
}
int main()
{
    int a[100];                 // массив, размер задаем на этапе компиляции


    int i;                      // читаем числа, пока они есть
    for(i = 0; 1 == scanf("%d", &a[i]); i++)
        ;
    int n = i;                  // количество элементов в массиве


    print_arr(a, n);
    print_arr(a, n);


    return 0;
}
```

### n не задано и не ограничено
Если до запуска программы нельзя ничего сказать о количестве чисел, то неизвестно какого размера объявить массив.
+ Сначала массив пустой, память не выделена.
+ Пока есть числа на входе:
    + выделим столько памяти, чтобы появилось место под новое число,
    + запишем в массив новое число.
Размер массива будет расти на каждой итерации цикла.

```c
a = realloc(a, (i+1)*sizeof(int));
```

+ выделяет память размером `(i+1)*sizeof(int)` байт,
    + для хранения первого числа нужно записать число в `a[0]` а памяти выделить для `1*sizeof(int)`, то есть при `i=0` пишем в `a[i]`, а выделяем память `(i+1)*sizeof(int)` байт,
+ копирует данные из старой памяти в новую,
+ освобождает старую память.

```c
#include <stdio.h>
#include <stdlib.h>


// печатает первые n элементов массива a
void print_arr(int a[], int n)
{
    for(int i = 0; i < n; i++)
        printf("%d ", a[i]);
    printf("\n");
}
int main()
{
    int * a = NULL;             // указатель указывает на NULL


    int x;                      // читаем числа, пока они есть
    int i;                      // количество прочитанных чисел
    for(i = 0; 1 == scanf("%d", &x); i++){
        a = realloc(a, (i+1)*sizeof(int));
        a[i] = x;
    }


    print_arr(a, i);
    print_arr(a, i);


    // освобождаем выделенную память
    free(a);


    return 0;
}
```

После того, как массив перестал быть нужен, надо освободить выделенную под него память функцией `free`.

### Выделение памяти под строку
Сделаем копию строки, выделив для нее память.

Исходная строка может или располагаться в массиве, или задаваться через указатель.

![14](/C_for_beginners_Stepik/Pictures/11_02.png)

В результате получится указатель `dst`, который указывает на выделенную функцией `malloc` память.

```c
char * dst = malloc(1+strlen(s1));  // +1 для хранения \0
strcpy(dst, s1);
```

То же самое делает стандартная функция `strdup`:

```c
char * dst = strdup(s1);
```

### Чтение слова с выделением динамической памяти
Этот материал уже был раньше

Можно читать по слову (слово - это последовательность непробельных символов). Опция `%ms` неявно вызывает `malloc`. И требует явного вызова `free`, когда память перестанет быть нужной.

```c
#include <stdio.h>
#include <stdlib.h>


int main()
{
    char *s = NULL;                 // указатель, в него будет записываться адрес выделяемой памяти


    while(1 == scanf("%ms", &s)) {  // неявный вызов malloc, обратите внимание &s
        printf("<%s>\n", s);        // используем прочитанное слово


        free(s);                    // освобождаем память после использования, чтобы не было утечек
    }
    return 0;
}
```

Обратите внимание на a1 :

```c
char a1[100];
scanf("%99s", a1);       // a1 типа char *, с контролем переполнения
```

и на &a2:

```c
char * a2 = NULL;
scanf("%ms", &a2);      // &a2 типа char **, выделяеся динамическая память
// ...                  используем прочитанное слово
free(a2);               // освобождаем память после использования
```

### Чтение строки с выделением динамической памяти

```c
#include <stdio.h>


ssize_t getline(char **lineptr, size_t *n, FILE *stream);
ssize_t getdelim(char **lineptr, size_t *n, int delim, FILE *stream);
```

Функция `getline` считывает из потока `stream` строку, сохраняя ее в памяти по адресу `*lineptr` размером `n` байтов.


```c
#include <stdio.h>
#include <stdlib.h>


int main(void)
{
        FILE * fp;
        char * line = NULL;
        size_t len = 0;
        ssize_t read;
        fp = fopen("/etc/motd", "r");
        if (fp == NULL)
                exit(EXIT_FAILURE);
        while ((read = getline(&line, &len, fp)) != -1) {
                printf("Retrieved line of length %zu :\n", read);
                printf("%s", line);
        }
        if (line)
                free(line);
        return EXIT_SUCCESS;
}
```

Функция изначально была расширением `GNU` и была внесена в стандарт `POSIX.1-2008`.

Как это работает?

+ `getline` считывает строку в `*lineptr`
    + буфер завершается `null`;
    + если во входном потоке был `\n`, то он тоже попадает в буфер; если в последней строке наступил конец файла и не было `\n`, то в буфер `\n` не запишется;
+ при необходимости для `*lineptr` делается `realloc`, новые значения размера буфера записываются в `n`;
+ `getline` работает как `getdelim` с разделителем `\n`, если нужно указать другой разделитель, используйте аргумент `delim` функции `getdelim`;
обе функции возвращают количество считанных символов (с учетом разделителя, если он был), но без учета `null`.
    + При ошибке возвращается -1.

##  malloc, realloc, free

### Функции работы с памятью
#### Выделение и освобождение памяти `stdlib.h`
+ `void * malloc (size_t size);`
    + выделяет память размером `size` байт
    + возвращает указатель на выделенную память или `NULL` в случае ошибки
+ `void * calloc (size_t nmemb, size_t size);`
    + выделяет память размером `nmemb*size`
    + __заполняет память 0__
    + возвращает указатель на выделенную память или NULL в случае ошибки
+ `void free (void *ptr);`
    + освобождает память, на которую указывает `ptr` (начало динамически выделенной памяти)
    + `free(NULL)` ничего не делает
+ `void * realloc (void *ptr, size_t size);`
    + выделяет память размером `size` байт
    + копирует данные из памяти, на которую указывает `ptr` в новую память
    + освобождает старую память
    + возвращает указатель на выделенную память или `NULL` в случае ошибки
    + при `ptr=NULL` работает как `malloc`
#### Копирование и заполнение данными `string.h`
+ `void * memcpy (void *dst, const void *src, size_t n);`
    + копировать `n` байт из `src` в `dst`
    + возвращает указатель на `dst`
    + нельзя использовать на перекрывающихся участках памяти
+ `void * memmove (void *dst, const void *src, size_t n);`
    + копировать `n` байт из `src` в `dst`
    + возвращает указатель на `dst`
    + можно использовать на перекрывающихся участках памяти, так как сначала идет копирование `src` во временный дополнительный массив, а потом из него в `dst`.
+ `void * memset (void *s, int c, size_t n);`
    + заполнить `n` байт числом `с`, начиная с адреса `s`

### `malloc` и `calloc`
Разница между `malloc` (memory allocation) и `calloc` (cell allocation) в аргументах. И `calloc` гарантированно заполнит память нулями.

Массив из 10 int:

```c
int a1[10];                          // без использования динамической памяти
int * a2 = malloc(10 * sizeof(int)); // malloc, сколько байт
int * a3 = calloc(10, sizeof(int));  // calloc, сколько ячеек, размер одной ячейки
```

Когда использовать `calloc`? Только если нужно обязательно заполнить массив нулями.

Если в массив читают данные, то лишнюю работу делать не нужно.

Если на контрольной у вас чтение неинициализированной памяти (частая ошибка), попробуйте вместо `malloc` использовать `calloc`. Если ошибка ушла и она последняя, порадуйтесь и решайте следующую задачу. Вы не исправили ошибку. Вы ее "закопали". В домашней работе лучше найдите, почему вы читаете неинициализированный участок памяти (выход за границы массива или забыли проинициализировать).

### `free`
+ Указатель на начало динамически выделенной памяти.
```c
int * a = malloc(10 * sizeof(int));
free(a);                            // OK
free(a+2);                          // Ошибка, не на начало выделенной памяти
```

+ Кто память выделял, тот и освобождает:

```c
int b[5];
free(b);                            // Ошибка, b не динамически выделенная память
free(NULL) ничего не делает
free(ptr); free(ptr); - неопределенное поведение (undefined behaviour)
```

Поэтому, если переменную `ptr` дальше используют в коде, пишите:

```c
free(ptr);
ptr = NULL;     // гарантия, что следующий free(ptr) не приведет к ошибке
```

### Обработка ошибок
В коммерческом программировании обязательно нужно обрабатывать ошибки, которые могут вернуть функции.

Текстовый редактор открывает новый документ. Может не хватить памяти, так как новый документ большой. Если программа просто "упадет", будет плохо. Лучше, если будет сообщение "невозможно открыть документ, не хватает памяти" и дальше можно будет закрыть и сохранить другие документы.

Для этого нужно обрабатывать ошибки:

```c
char * a = malloc(size);
if (a == NULL) {
    // обработка ошибок, пишем диагностику, сохраняем открытые документы
}
```

В курсе мы будем в примерах и задачах продолжать писать "по-студенчески", без обработки ошибок.

### `realloc`
Ошибка при `realloc` может привести к потере старых данных:

```c
char * a = strdup("Hello");     // a указывает на копию с "Hello"
a = realloc(a, 10);             // если ошибка, то a стало NULL,
                                // ничто не указывает на старую память, мы ее потеряли

```
Пишем безопасный код. Используем переменные `ptr` (старая память) и `new_ptr` (новая память):

```c
new_ptr = realloc(ptr, new_size);
if (new_ptr == NULL) {
    // обработка ошибок, быть может с выходом; старая память в переменной ptr
}
ptr = new_ptr;
```

### Работа с памятью "под капотом"
Считается, что чем реже вызываем функции `malloc`, `calloc` и `realloc`, тем быстрее работает программа. Потому что выделение памяти "тяжелая" функция. Так ли это на самом деле?

Выделением и освобождением памяти занимается менеджер памяти. Чтобы понять какая память свободная, а какая занятая, он поддерживает таблицу выделенной памяти, в которой есть колонки
+ адрес начала выделенной памяти,
+ сколько нужно было выделить памяти,
+ сколько реально выделено памяти.

В компьютере удобно память выделять блоками, обычно блок 1Кб или 4Кб (или другой размер, но не 1 байт!), поэтому может быть выделено больше памяти, чем требовалось.

Допустим, размер выделяемого блока кратен 1Кб, и были вызовы:

```c
int * a = malloc(4);
int * b = malloc(1024);
int * c = malloc(4000);
```

Пусть в таблице появились записи:

адрес | запрошено байт | выделено байт
-|-|-
0xfa0000 | 4 | 1024
0xff0000 | 1024 | 1024
0xfb0000 | 4000 | 4096

Заметим, что этот вызов не приведет к реальному перевыделению памяти, только к изменению записи в таблице:

```c
a = realloc(a, 12);
```

таблица изменится:

адрес | запрошено байт | выделено байт
-|-|-
0xfa0000 | 12 | 1024
0xff0000 | 1024 | 1024
0xfb0000 | 4000 | 4096

а вызов

```c
a = realloc(a, 1200);
```

приведет к освобождению `1024` байт памяти по адресу `0xfa0000` и выделению по какому-то другому адресу, ибо начиная с адреса `0xfb0000` (то есть через `1024` байт) память уже выделена.

Заметим, что как в случает обычных массивов, так и в случае динамического выделения памяти, память выделяется единым куском.

`free` - это удаление строки в таблице выделенной памяти. Очевидно, что эта память должна быть в таблице (освобождается только динамически выделенная память) и адрес должен точно совпадать с указанным в столбце адрес.

### void * в Си и С++
В Си автоматически преобразуются указатели к и из `void *`. Не нужно писать преобразование типов, так работает:

```c
char * a = malloc(6);   // из void * к char *
a = realloc(a, 12);     // из char * к void *
```

В Си, если написано явное преобразование типа, то "что-то пошло не так". Обычно оно не нужно.

В С++ типы не преобразуются автоматически. Поэтому, при компиляции этого кода компилятором С++ будут ошибки и нужно писать с явным преобразованием типа:

```c
char * a = (char *)malloc(6);         // из void * к char *
a = (char*)realloc((void*)a, 12);     // из char * к void *
```

В С++ `malloc`, `calloc`, `realloc` не используют. В С++ используют операторы `new` и `delete`:

```cpp
int * a = new int[10];  // это С++
delete [] a;            // это С++
```

### Взял? Верни! (философия освобождения)
Обязательно ли освобождать память с помощью `free`, если до этого вы ее выделили? Ведь операционная система после завершения программы освобождает занятую этой программой память.

Мы рекомендуем это делать и все задачи этого курса требуют явного освобождения. Почему?

Давным-давно на работе у нас упал сервер. Это ненормально, но бывает. Через две недели он упал ещё раз. И ещё. Мы не могли предсказать, когда он упадет. Сервер захватывал все больше памяти, не освобождал ее и в какой-то момент память заканчивалась и сервер падал.

Не получалось гарантированно воспроизвести проблему "делай А, В, С и на D сервер упадет". Неизвестно где была проблема, чтобы ее можно было найти и починить.

Тестеры научились укладывать сервер гарантированно раз в неделю, раз в три дня. Но это было недостаточно для поиска "где не работает". За прошедшее время было написано много кода и ошибка могла быть в любой строчке.

Мы проверили разные профили активности пользователей на сервере и обнаружили, что чем больше мелких картинок запрашивает пользователь, тем быстрее падает сервер. Проблема была локализована с точностью до модуля. После этого можно было уже смотреть код и пытаться найти проблему методом пристального взгляда.

Как оказалось, одна из давно работающих утилит (маленьких программ) была интегрирована внутрь модуля. Мы выиграли в производительности, но, как оказалось, она захватывала память, но не освобождала её. Утилита прекрасно работала, потому что после каждого запуска память освобождалась операционной системой.

Когда этот код стал вызываться не как отдельная программа, а как отдельная функция, вся программа (сервер) не прекращал свою работу и память не освобождалась.

Автор утилиты (написано давно) написал работающий код. Этот код был интегрирован другим программистом. При интеграции кода программист не обязан разбираться в том коде, который он встраивает в систему. Он должен сделать так, чтобы этот код вызывался и делал то же, что и раньше, например, запаковывал мелкие изображение в одно (с теми же ошибками, он не должен ковыряться в этом коде и править ошибки!)

Получается, что все писали хорошо, а сервер падает.

Поэтому пишите надежно, можно в "олимпиадном программировании" не освободить память, если решение прошло. Но не надо так писать в домашних работах и в дальнейшей работе.

В наших контрольных без `free` тоже писать нельзя. Решение не засчитают.

### Системы проверки работы с памятью
Метод пристального взгляда на код хорош, но лучше пользоваться специальными инструментами, которые помогают проверять как код работает с динамической памятью.
+ valgrind
+ address sanitizer

В курсе рассказывается как использовать [valgrind](https://youtu.be/YX0s4ltwSU8) для проверки.

### str_bomb5_mem Замена подстроки в строке
Вы [уже решали](/C_for_beginners_Stepik/11.md#str_bomb5-заменим-все-бомбы) эту задачу, но без выделения динамической памяти.

Напечатать текст, заменив все подстроки `bomb` на `watermelon`.

Для замены подстроки напишите функцию

```c
char * replace (const char * src);
```

которая выделяет память для новой строки, копирует туда src, заменяя bomb на watermelon и возвращает получившуюся строку.

В проверяющую систему пошлите только реализацию функции `replace`.

Проверить функцию можно так:

```c
#include <stdio.h>
#include <stdlib.h>

#define N 1000

int main()
{
    char s[N];   // нужно объявить переменную - место для читаемой строки
    char * d;    // указатель на динамический массив, память еще не выделена

    while (NULL != fgets(s, N, stdin)) {  // пока можем прочитать строку
        d = replace(s);                   // тут память выделяем
        printf("+++%s+++\n", d);
        free(d);                          // тут память освобождаем
    }
    return 0;
}
```

```c
char* replace(const char* src) {
    const char* from = "bomb";
    const char* to = "watermelon";

    size_t len = strlen(from);

    char *p, *s, *dst;
    dst = malloc(strlen(src) * 3);
    dst[0] = '\0';
    p = (char*)src;
    while (NULL != (s = strstr(p, from))) {
        strncat(dst, p, s - p);
        strcat(dst, to);
        p = s + len;
    }
    strcat(dst, p);
    return dst;
}
```

Чтобы сократить количество realloc, захватим сначала памяти столько, как если бы строка состояла из одних бомб.<br>
Это называется оценка сверху на количество требуемой памяти.<br>
В конце функции сделаем realloc по фактическому количеству занимаемой памяти.<br>

Никогда не пишите так: `strlen(src)*25/10`, потому что если поменяется условие задачи, вы можете упустить из виду, что эти числа связаны с длиной строк "bomb" и "watermelon".

Кто первый напишет правильную формулу для выделяемой памяти, если мы меняем строку длины `len_from` на строку длины `len_to`?

```c
char * replace(const char * src)
{
    char * from = "bomb";
    char * to = "watermelon";
    char * dst = malloc((strlen(src)*25/10 + 2)*sizeof(char));    // оценка сверху по количеству бомб
    
    size_t len = strlen(from);
    
    char * p, *s;
    
    dst[0] = '\0';
    p = src;
    while( NULL != (s = strstr(p, from)) ) {
        strncat(dst, p, s-p);
        strcat(dst, to);
        p = s + len;
    }
    strcat(dst, p);
    dst = realloc(dst, (strlen(dst)+1)*sizeof(char));            // точное количество занимаемой памяти
    
    return dst;
}
```

## Динамический двумерный массив. `malloc(n*m*sizeof(Data))`

[Видео](https://youtu.be/UExqk4Xe7Q8)

### Хранение двухмерных массивов в Си

Пусть нужно работать с матрицей

![14](/C_for_beginners_Stepik/Pictures/14_01.png)

В Си будем хранить матрицу как двухмерный массив:

```c
int a[3][4] = {
    {1, 2, 3, 4},
    {11, 12, 13, 14},
    {21, 22, 23, 24}
};
```

Представим память, как последовательность ячеек. У каждой ячейки свой номер (адрес). Двухмерный массив в памяти хранится построчно:

![14](/C_for_beginners_Stepik/Pictures/14_02.png)

Это легко проверить. Напечатаем адрес каждой ячейки `a[i][j]` по формату `%p` (печать адреса в шестнадцатеричном виде):

```c
for(int i = 0; i < 3; i++)
    for(int j = 0; j < 4; j++)
        printf("a[%d][%d] = %d at %p\n", i, j, a[i][j], &a[i][j]);
```

### Динамическая копия
Казалось бы, если массив a хранится как

![14](/C_for_beginners_Stepik/Pictures/14_02.png)

То аналогично выделим динамическую память и откопируем содержимое матрицы:

![14](/C_for_beginners_Stepik/Pictures/14_03.png)

```c
int a[3][4];                            // исходный массив
int * a1 = malloc(3 * 4 * sizeof(int)); // выделили память
memcpy(a1, a, 3 * 4 * sizeof(int));     // скопировали содержимое массива а в а1
```

Все замечательно, но мы привыкли, что к динамически выделенной памяти мы обращаемся так же, как и к "обычному массиву".
+ a[i][j] - работает
+ a1[i][j] - НЕ работает, так как a1[i] типа int и к этому выражению уже не применим оператор []

```c
for(int i = 0; i < 3; i++)
    for(int j = 0; j < 4; j++)
        printf("a[%d][%d] = %d at %p\n", i, j, a[i][j], &a[i][j]);  // ошибка!
```

Для обращению к $a_{ij}$ нужно писать функцию или макрос `get(int * a, int i, int j, int ncol)`, где обязательно нужно указать размер одной строки, чтобы мы вычислили `*(a + i*ncol + j)`

То есть работать можно, но неудобно. Попробуем выделить память так, чтобы можно было обращаться a1[i][j].

## Динамический двумерный массив. Классический.

[Видео](https://youtu.be/-9aycE-B6zY)

### Что хотим?
Давайте сделаем копию `b` двухмерного массива

```c
int a[3][4];
```

так, чтобы можно было обращаться `b[i][j]` к элементу массива.

Если `b[i][j]` типа `int`, то `b[i]` типа `int *`

`b[0]`, `b[1]` и `b[2]` должны быть типа `int *` (указатель на `int`, "инт звезда", как говорят программисты), то есть `b` - это массив из `3` элементов, каждый элемент типа `int *` и содержит указатель на выделенную для хранения `1` строки память.

![14](/C_for_beginners_Stepik/Pictures/14_04.png)

Переменная `b` содержит указатель на массив элементов типа `int *` (указателей на `int`), то есть должна быть типа `int **` ("указатель на указатель на `int`" напишут в книгах, а программисты скажут "инт две звезды").

### Выделение памяти и копирование данных

Пошагово разберем и нарисуем как происходит выделение памяти. Программирование с динамической памятью - это много рисования на листке бумаги. Каждый раз сначала нарисуйте, что вы хотите получить, а потом пошагово переводите рисунок в код.

```c
int ** b;
```

Объявлена переменная `b` и для этой переменной память выделяет не динамическая. Изначально этот указатель никуда не указывает!

![14](/C_for_beginners_Stepik/Pictures/14_05.png)

Выделим динамически память для `3` указателей:

```c
int ** b = malloc(3 * sizeof(int*));    // обратите внимание на sizeof
```

![14](/C_for_beginners_Stepik/Pictures/14_06.png)

Переменная `b` указывает на этот массив указателей. Она содержит адрес его начала (пусть это число `100`).

Выделим динамическую память для строк матрицы. `3` строки, выделяем в цикле. В каждой строке `4` числа типа `int`.

```c
for(int i = 0; i < 3; i++)
    b[i] = malloc(4 * sizeof(int));     // обратите внимание на sizeof
```

Получим матрицу с данными:

![14](/C_for_beginners_Stepik/Pictures/14_07.png)

Обращаться к элементу матрицы можно b[i][j].

### Общий код

![14](/C_for_beginners_Stepik/Pictures/14_04.png)

```c
// исходная матрица
int a[3][4] = {
    {1, 2, 3, 4},
    {11, 12, 13, 14},
    {21, 22, 23, 24}
};


// выделяем память под ее копию
int ** b = malloc(3 * sizeof(int*));        // голубой массив указателей
for(int i = 0; i < 3; i++) {
    b[i] = malloc(4 * sizeof(int));         // выделяем память для чисел
    memcpy(b[i], a[i], 4 * sizeof(int));    // и сразу копируем
}


// печатаем матрицу
for(int i = 0; i < 3; i++) {
    for(int j = 0; j < 4; j++) {
        printf("%d ", b[i][j]);
    }
    printf("\n");
}


// освобождаем память, в обратном порядке
for(int i = 0; i < 3; i++)
    free(b[i]);
free(b);
```

### Плюсы и минусы
Мы изучили классическую схему выделения памяти для копирования двухмерного массива. Она приведена во многих учебниках по Си, С++, Java и другим языкам программирования.
+ Плюсы:
    + с матрицой можно работать, как с обычнным двухмерным, обращаясь к элементу b[i][j]
+ Минусы:
    + если матрица небольшая, а реальное выделение памяти идет блоками, то фактически занимается гораздо больше памяти, чем нужно
    + при вычислении на соседних строках памяти, они могут располагаться в памяти далеко друг от друга, что замедляет вычисления

Дальше мы рассмотрим модификацию "в один `malloc`" классического способа выделения памяти, когда остаются плюсы и исчезают минусы.

## Динамический двумерный массив в один malloc. Интеллектуальный.

[Видео](https://youtu.be/vK2QpvEnaVs)

### Память - это просто последовательность байт

Мы выделяли память в один malloc так:

![14](/C_for_beginners_Stepik/Pictures/14_03.png)

И были проблемы с доступом через оператор `[]` к `a[i][j]`.

Чтобы решить эту проблему, мы выделили дополнительную память под массив с элементами `b[0]`, `b[1]`, `b[2]`:

![14](/C_for_beginners_Stepik/Pictures/14_04.png)

Соединим эти два подхода. Память - это просто память, `malloc` выделяет последовательность байт одним куском и как мы будем трактовать эту область памяти зависит только от нашего желания, если оно не противоречит синтаксису языка.

Добавим перед куском с данными кусок с указателями:

![14](/C_for_beginners_Stepik/Pictures/14_08.png)

Сначала в памяти будут идти значения `b[0]`, `b[1]`, `b[2]` (типа `int *`), потом сразу же начнутся значения `b[0][0]`, `b[0][1]`, `b[0][2]`, `b[0][3]`, `b[1][0]`, `b[1][1]` до `b[2][3]`.

### Пишем код
После того, как мы нарисовали архитектуру на листке бумаги, начинаем писать код.

![14](/C_for_beginners_Stepik/Pictures/14_08.png)

В начале этой памяти будет лежать `b[0]` типа `int *`, то есть указатель на эту память `b` должен иметь тип `int **` ("указатель на указатель на `int`" или "инт две звезды").

```c
int ** b;
```

Память нужно выделить под 3 указателя и 12 чисел матрицы.

```c
int ** b = malloc(3 * sizeof(int*) + 3*4*sizeof(int));
```

Если бы у нас были только указатели `int *`, то у нас были бы ячейки `b[0]`, `b[1]`, `b[2]`, `b[3]`, `b[4]` и так далее. Указатель на ячейку после `b[2]` будет `&b[3]` или `b+3`.

Допустим, память выделилась начиная с адреса `100`, размер `int` 4 байта, а указателя 8 байт. В этом случае после первых трех указателей, адрес будет 100 + 3*8 = 124.

![14](/C_for_beginners_Stepik/Pictures/14_09.png)

Запишем адрес `124` в переменную `p`. Это адрес начала чисел матрицы. Будем использовать указатель `p` для адресации по числам матрицы. Числа типа `int`, значит указатель типа `int *`.

```c
int * p = (int*)(b + 3);    // или (int*) &b[3], то есть 124
```

Это число `124`, адрес начала первой строки матрицы, мы должны записать в `b[0]`

```c
b[0] = p;   // b[0] указывает на первую строку матрицы,
            // можно обращаться b[0][0], b[0][1] и так далее
```

По сути, `p` это `&b[0][0]`, указатель на начало первой строки. Указатель на начало второй строки (он же конец первой строки) должен указывать на адрес 140, то есть на 4 элемента типа `int` дальше, то есть `&b[0][4]`, то есть на `p+4`.

Не будем дальше утомлять себя арифметикой, передвинем p в начало второй строки чисел и запишем полученный адрес в `b[1]`.

```c
p = p + 4;  // p встал в конец первой (и начало второй) строки данных
b[1] = p;   // b[1] содержит адрес начала второй строки данных
```

Аналогично передвинем `p` еще раз и заполним куда указывает `b[2]`:

```c
p = p + 4;  // p встал в конец второй (и начало последней) строки данных
b[2] = p;   // b[2] содержит адрес начала последней строки данных
```

![14](/C_for_beginners_Stepik/Pictures/14_10.png)

### Общий код

![14](/C_for_beginners_Stepik/Pictures/14_09.png)

```c
// исходная матрица
int a[3][4] = {
    {1, 2, 3, 4},
    {11, 12, 13, 14},
    {21, 22, 23, 24}
};


// выделяем память под ее копию
int ** b = malloc(3 * sizeof(int*) + 3*4*sizeof(int));


// заполняем значение адресов b[i], чтобы можно было обращаться b[i][j]
int * p;
p = (int*)(b + 3);      // указатель на начало строки данных
b[0] = p;               // b[0] указывает на первую строку матрицы,
                        // можно обращаться b[0][0], b[0][1] и так далее


p = p + 4;              // p встал в конец первой (и начало второй) строки данных
b[1] = p;               // b[1] содержит адрес начала второй строки данных


p = p + 4;              // p встал в конец второй (и начало последней) строки данных
b[2] = p;               // b[2] содержит адрес начала последней строки данных


// копируем данные из массива а, все 12 чисел
memcpy(b[0], a, 3*4*sizeof(int));


// печатаем матрицу
for(int i = 0; i < 3; i++){
    for(int j = 0; j < 4; j++){
        printf("%d ", b[i][j]);
    }
    printf("\n");
}


// освобождаем всю память, был 1 malloc, значит тут 1 free
free(b);
```

## Длинная арифметика. Теперь с динамической памятью.

[Видео](https://youtu.be/lKtedmlTDCA)

### Большие числа
Вспомним, как мы работали с большими числами, которые больше, чем самый большой целочисленный тип.

Число $147$ это $7 \cdot 10^0 + 4 \cdot 10^1 + 1 \cdot 10^2$.

Можно представить любое число $a$ как $a_0 \cdot 10^0 + a_1 \cdot 10^1 + a_2 \cdot 10^2$

Будем хранить коэффициенты $a_0, a_1, a_2$ в массиве a как `a[0]`, `a[1]`, `a[2]`. И будем в n хранить максимальную степень 10 в разложении числа по степеням 10.

Объединим массив `a` и поле `n` в структуру `Decimal`, так как они описывают одно и то же число. Чисел в программе может быть много, поэтому лучше их объединить в структуру. Например, мы захотим посчитать `50` число Фибоначчи.

![14](/C_for_beginners_Stepik/Pictures/14_11.png)

```c
#define N 100
typedef struct {
    char a[N];       // number is a[0]*10^0 + a[1]*10^1 + ..+ a[n]*10^n
    unsigned int n;  // наибольшая степень десяти
}Decimal;
```

Числа можно задавать сразу при объявлении переменных:

```c
Decimal x = {{7, 4, 1}, 2};     // число 147
Decimal zero = {{0}, 0};        // число 0
```

В числе 147 количество цифр 3, максимальная степень 10 будет 2. В поле n храним 2. Можно хранить количество цифр, но мы договорились, что в нашей реализации функции печати мы ожидаем именно максимальную степень 10.

Мы написали функции [elong_print](/C_for_beginners_Stepik/08.md#elong_print-печать-длинного-числа) и [elong_add](/C_for_beginners_Stepik/08.md#elong_add-сложение-больших-чисел) для печати числа и сложения двух чисел. [elong_set](/C_for_beginners_Stepik/11.md#elong_set-задаем-большие-числа) преобразовывала строку в длинное число.

`void elong_print(Decimal x);` - передается копия структуры со всем массивом, очень тяжелый вызов функции.

Лучше передавать указатель на такую "тяжелую" структуру `void elong_print(Decimal * px);`

Аналогично, можно написать функции преобразования из `int` в `Decimal`. Это опять передача копии большого массива из функции:

```c
Decimal elong_set_int(unsigned int x);
// использование:
// Decimal x = elong_set_int(147);
```

Лучше написать функцию так, чтобы передавать только указатель на структуру:

```c
void elong_set_int(Decimal * dst, unsigned int x);
// использование:
// Decimal x;
// elong_set_int(&x, 147);  заполняем переменную х значениями для числа 147
```

### Добавим динамическую память
При фиксированном размере массива у нас не использовалась память, если числа были короткие и мы все равно были ограничены числом $10^{100} − 1$.

![14](/C_for_beginners_Stepik/Pictures/14_11.png)

Если в структуре хранить вместо массива указатель на динамический массив, то мы сэкономим память и уберем ограничение сверху на длину в 100 цифр.

```c
typedef struct {
    char * a;        // number is a[0]*10^0 + a[1]*10^1 + ..+ a[n]*10^n
    unsigned int n;  // наибольшая степень десяти
}Decimal;
```

Количество цифр в массиве `n+1`. Но при реализации функций `elong_set_int` или умножения, не хочется много раз увеличивать размер динамически выделенной памяти на `+1` `char`. Разумнее было бы сразу выделить много байт, если не хватит, то выделить больше, а если не все использовалось, то выделить меньше. Поэтому введем в структуру поле `size` - сколько выделено памяти (в количестве элементов массива `a`).

```c
typedef struct {
    char * a;        // number is a[0]*10^0 + a[1]*10^1 + ..+ a[n]*10^n
    unsigned int n;  // наибольшая степень десяти
    size_t  size;    // размер массива a
}Decimal;
```

![14](/C_for_beginners_Stepik/Pictures/14_12.png)

По картинке напишем код:

```c
Decimal x;
x.n = 2;
x.size = 8;
x.a = malloc(x.size);
x.a[0] = 7;
x.a[1] = 4;
x.a[2] = 1;


Decimal * px = &x;
```

Разумно написать функцию, которая выполнит те же действия:

```c
Decimal x;              // выделена память под переменную х (фиолетовый прямоугольник)
elong_set_int(&x, 147); // внутри вызывается минимум 1 malloc (желтый массив с цифрами)
```

Реализация функции:

```c
void elong_set_int(Decimal * px, unsigned int number) {
    if (number == 0){       // 0*10**0
        px->size = 1;
        px->n = 0;
        px->a = malloc(px->size);
        px->a[0] = 0;
        return;
    }

    // number точно меньше 10 в 100, выделим память с запасом
    px->size = 100;
    px->a = malloc(px->size);

    for(px->n = 0; number > 0; px->n++) {
        px->a[px->n] = number % 10;
        number /= 10;
    }
    px->n --;

    // выделим памяти точно под хранение числа
    px->size = px->n + 1;
    px->a = realloc(px->a, px->size);
}
```

Сразу же напишем функцию, которая освобождает память

```c
void elong_destroy(Decimal * px) {
    free(px->a);        // освобождаем желтый массив с цифрами
}
```

Проверка кода (запускаем с valgrind):

```c
int main() {
    Decimal x;
    elong_set_int(&x, 147);
    elong_print(&x);
    elong_check(&x);
    elong_destroy(&x);


    elong_set_int(&x, 654321);
    elong_print(&x);
    elong_check(&x);
    elong_destroy(&x);


    elong_set_int(&x, 7);
    elong_print(&x);
    elong_check(&x);
    elong_destroy(&x);


    elong_set_int(&x, 0);
    elong_print(&x);
    elong_check(&x);
    elong_destroy(&x);


    return 0;
}
```

Функция [elong_print](/C_for_beginners_Stepik/08.md#elong_print-печать-длинного-числа) аналогична той, что вы писали для длинного числа фиксированной длины.

Функция `elong_check` проверяет, что во всех значащих ячейках массива лежат числа от `0` до `9` включительно. Рекомендуем реализовать эти функции самостоятельно и запустить пример.

### elong_add2 Сложение чисел

Для хранения больших чисел объявили структуру

```c
typedef struct {
    char * a;           // number is a[0]*10^0 + a[1]*10^1 + ..+ a[n]*10^n
    unsigned int n;     // наибольшая степень десяти
    unsigned int size;  // размер выделенной динамической памяти в а
}Decimal;
```

Ноль должен быть представлен как $0 \cdot 10^0$

Реализуйте функцию сложения чисел `a` и `b`, которая возвращает сумму чисел.

```c
void elong_add (const Decimal * a, const Decimal * b, Decimal * res);
```

В проверяющую систему посылать только реализацию требуемой функции.

```c
int main(){
    Decimal a;
    Decimal b;
    Decimal res;

    elong_set_int(&a, 147);    // 147
    elong_set_int(&b, 13);     // 13

    elong_add(&a, &b, &res);   // res = a+b = 147+13 = 160

    elong_print(res);          // print 160

    elong_destroy(&a);
    elong_destroy(&b);
    elong_destroy(&res);

    return 0;
}
```

```c
void elong_add(const Decimal* a, const Decimal* b, Decimal* res) {
    if (a->n == 0 && a->a[0] == 0 && b->a[0] == 0 && b->n == 0) {  // 0*10**0
        res->size = 1;
        res->n = 0;
        res->a = malloc(res->size);
        res->a[0] = 0;
        return;
    }

    res->size = 101;
    res->a = malloc(res->size);

    unsigned int over = 0, n;

    n = (a->n >= b->n ? a->n : b->n);

    for (unsigned int i = 0; i <= n + 1; i++) {
        unsigned int result = (i <= a->n ? a->a[i] : 0) + (i <= b->n ? b->a[i] : 0) + over;
        res->a[i] = result % 10;
        over = result / 10;
    }
    res->n = n + res->a[n + 1];
    res->size = res->n + 1;
    res->a = realloc(res->a, res->size);
}
```

И весь код:

```c
void elong_add(const Decimal* a, const Decimal* b, Decimal* res) {
    if (a->n == 0 && a->a[0] == 0 && b->a[0] == 0 && b->n == 0) {  // 0*10**0
        res->size = 1;
        res->n = 0;
        res->a = malloc(res->size);
        res->a[0] = 0;
        return;
    }

    res->size = 101;
    res->a = malloc(res->size);

    unsigned int over = 0, n;

    n = (a->n >= b->n ? a->n : b->n);

    for (unsigned int i = 0; i <= n + 1; i++) {
        unsigned int result = (i <= a->n ? a->a[i] : 0) + (i <= b->n ? b->a[i] : 0) + over;
        res->a[i] = result % 10;
        over = result / 10;
    }
    res->n = n + res->a[n + 1];
    res->size = res->n + 1;
    res->a = realloc(res->a, res->size);
}
```

Мы постарались сделать минимальные изменения в предыдущем решении.

```c
void elong_add(const Decimal* p1, const Decimal* p2, Decimal* res) {
    // в a число длиннее или такой же длины
    const Decimal* a;
    const Decimal* b;
    if (p1->n > p2->n) {
        a = p1;
        b = p2;
    } else {
        b = p1;
        a = p2;
    }

    // считаем пока, что res по длине будет равно a
    res->size = a->n + 1;
    res->a = malloc(res->size * sizeof(char));

    int i, x;
    int e;  // переносим 1 или 0 в следующий разряд
    for (i = 0, e = 0; i <= a->n; i++) {
        if (i <= b->n)
            x = e + a->a[i] + b->a[i];
        else
            x = e + a->a[i];
        res->a[i] = x % 10;
        e = x / 10;
    }
    // если res длиннее a, то нужно больше памяти
    if (e > 0) {
        res->a = realloc(res->a, (i + 1) * sizeof(char));
        res->a[i] = e;
        res->n = i;
    } else
        res->n = i - 1;

    res->size = res->n + 1;
    // res->a = realloc(res->a, (res->size)*sizeof(char));
}
```

### Decimal * elong_set_int(unsigned int number)
Можно написать функцию `elong_set_int` так, чтобы она принимала один аргумент - число и возвращала указатель на структуру. Тогда и `elong_add` стоит переписать в похожем стиле. Использование:

```c
Decimal * a = elong_set_int(147);
Decimal * b = elong_set_int(13);
Decimal * res = elong_add(a, b);
elong_print(res);
```

В случае структуры `Decimal` выигрыш небольшой. Но для структуры, которая описывает работу с файлами FILE, выигрыш заметный, ибо в структуре около 100 полей. Поэтому функция открытия файла `FILE * fopen(const char * path, const char * mode);`

Функция должна вернуть `px`, который указывает на структуру. Нельзя вернуть из функции указатель на локальную в этой функции переменную. Эта переменная после выхода из функции будет "разрушена". Можно вернуть указатель на выделенную динамическую память и вне функции, потом её использовать и в конце концов освободить.

![14](/C_for_beginners_Stepik/Pictures/14_12.png)

В функции `elong_set_int` объявлена переменная `px`. Её значение вернем из функции. То есть к выделению памяти для массива данных (желтого) добавится ещё одно выделение памяти для структуры ("большой ящик", фиолетовый прямоугольник).

Реализация функции:

```c
Decimal * elong_set_int(unsigned int number) {
    // сначала выделим память под саму структуру (фиолетовый прямоугольник)
    Decimal * px = malloc(sizeof(Decimal));


    if (number == 0){       // 0*10**0
        px->size = 1;
        px->n = 0;
        px->a = malloc(px->size);
        px->a[0] = 0;
        return px;
    }


    // number точно меньше 10 в 100, выделим память с запасом
    px->size = 100;
    px->a = malloc(px->size);




    for(px->n = 0; number > 0; px->n++){
        px->a[px->n] = number % 10;
        number /= 10;
    }
    px->n --;


    // выделим памяти точно под хранение числа
    px->size = px->n + 1;
    px->a = realloc(px->a, px->size);
    return px;
}
```

Сразу же напишем функцию, которая освобождает память, заметим, освобождаем память в обратном порядке.

```c
void elong_destroy(Decimal * px) {
    free(px->a);        // освобождаем желтый массив с цифрами
    free(px);           // освобождаем фиолетовый прямогольник, саму структуру
}
```

Проверка кода (запускаем с valgrind):

```c
int main() {
    Decimal * x;
    x = elong_set_int(147);
    elong_print(x);
    elong_check(x);
    elong_destroy(x);


    x = elong_set_int(654321);
    elong_print(x);
    elong_check(x);
    elong_destroy(x);


    x = elong_set_int(7);
    elong_print(x);
    elong_check(x);
    elong_destroy(x);


    x = elong_set_int(0);
    elong_print(x);
    elong_check(x);
    elong_destroy(x);


    return 0;
}
```

### elong_add3 Сложение чисел
Для хранения больших чисел объявили структуру

```c
typedef struct {
    char * a;           // number is a[0]*10^0 + a[1]*10^1 + ..+ a[n]*10^n
    unsigned int n;     // наибольшая степень десяти
    unsigned int size;  // размер выделенной динамической памяти в а
}Decimal;
```

Ноль должен быть представлен как $0⋅10^0$

Реализуйте функцию сложения чисел `a` и `b`, которая возвращает сумму чисел.

```c
Decimal * elong_add (const Decimal * a, const Decimal * b);
```

В проверяющую систему посылать только реализацию требуемой функции.

```c
int main(){
    Decimal * a;
    Decimal * b;
    Decimal * res;

    a = elong_set_int(147);    // 147
    b = elong_set_int(13);     // 13

    res = elong_add(a, b);     // res = a+b = 147+13 = 160

    elong_print(res);          // print 160

    elong_destroy(a);
    elong_destroy(b);
    elong_destroy(res);

    return 0;
}
```

Весь код:

```c
#include <stdio.h>
#include <stdlib.h>

#define N 100
typedef struct {
    char* a;            // number is a[0]*10^0 + a[1]*10^1 + ..+ a[n]*10^n
    unsigned int n;     // наибольшая степень десяти
    unsigned int size;  // размер выделенной динамической памяти в а
} Decimal;

Decimal* elong_add(const Decimal* a, const Decimal* b) {
    Decimal* res = malloc(sizeof(Decimal));

    if (a->n == 0 && a->a[0] == 0 && b->a[0] == 0 && b->n == 0) {  // 0*10**0
        res->size = 1;
        res->n = 0;
        res->a = malloc(res->size);
        res->a[0] = 0;
        return res;
    }

    res->size = 101;
    res->a = malloc(res->size);

    unsigned int over = 0, n;

    n = (a->n >= b->n ? a->n : b->n);

    for (unsigned int i = 0; i <= n + 1; i++) {
        unsigned int result = (i <= a->n ? a->a[i] : 0) + (i <= b->n ? b->a[i] : 0) + over;
        res->a[i] = result % 10;
        over = result / 10;
    }
    res->n = n + res->a[n + 1];
    res->size = res->n + 1;
    res->a = realloc(res->a, res->size);
    return res;
}

Decimal* elong_set_int(unsigned int number) {
    // сначала выделим память под саму структуру (фиолетовый прямоугольник)
    Decimal* px = malloc(sizeof(Decimal));

    if (number == 0) {  // 0*10**0
        px->size = 1;
        px->n = 0;
        px->a = malloc(px->size);
        px->a[0] = 0;
        return px;
    }

    // number точно меньше 10 в 100, выделим память с запасом
    px->size = 100;
    px->a = malloc(px->size);

    for (px->n = 0; number > 0; px->n++) {
        px->a[px->n] = number % 10;
        number /= 10;
    }
    px->n--;

    // выделим памяти точно под хранение числа
    px->size = px->n + 1;
    px->a = realloc(px->a, px->size);
    return px;
}

void elong_destroy(Decimal* px) {
    free(px->a);  // освобождаем желтый массив с цифрами
    free(px);  // освобождаем фиолетовый прямогольник, саму структуру
}

void elong_print(const Decimal* x) {
    for (unsigned int i = 0; i <= x->n; i++) {
        printf("%d", x->a[x->n - i]);
    }
}

int main() {
    Decimal* a;
    Decimal* b;
    Decimal* res;

    a = elong_set_int(147);  // 147
    b = elong_set_int(13);   // 13

    res = elong_add(a, b);  // res = a+b = 147+13 = 160

    elong_print(res);  // print 160

    elong_destroy(a);
    elong_destroy(b);
    elong_destroy(res);

    return 0;
}
```

### toLongN Длинные числа по основанию 100
Реализовывать длинную арифметику можно по-разному. Например, можно хранить числа в строках.

Не обязательно использовать основание 10. Это удобно для человека, но очень неэкономно по памяти. В 1 байте хранятся числа от 0 до 9, для них хватит 4 бит. Экономнее хранить числа по основанию 256, но такую задачу тяжело отлаживать студентам. Решим компромиссную задачу.
+ возьмем основание 100,
+ добавим хранение знака числа (положительные и отрицательные числа),
+ в поле n будем хранить количество ячеек с данными.

Дана строка цифр длинной не более 200 символов. В начале строки может стоять не цифровой символ: "+" или "-". Если строка начинается с цифры или символа "+" - это положительное число. Если строка начинается с символа "-" - число отрицательное.

Для хранения и представления числа используется структура:

```c
typedef struct{
    char *dig;  // массив для хранения числа:
                // a[0] * 100^0 + a[1] * 100^1 + .. + a[n - 1] * 100^(n-1)
    int n;      // размер числа в разрядах
    char sign;  // знак числа
} LongN;
```

Число записывается по основанию `100`. При этом младшие разряды числа записываются в начало массива, а старшие - в конец.

Для положительных чисел и нуля, знак `sign` записывается как `0`, для отрицательных - как `1`.

Размер числа `n` записывается как количество разрядов числа по основанию `100`. Например, для числа `12345`, n=3;

Написать функцию `LongN getLongN(char * s)`, которая преобразует данную строку в длинное число.

Пример использования функции:

```c
LongN x = getLongN("123456789012345");
```

Посылать в проверяющую систему только реализацию требуемой функции.

Советуем для отладки все же написать функцию `main`, функции печати и освобождения памяти. Их посылать не нужно. Они нужны только для отладки функции `getLongN`.


```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define N 101

typedef struct {
    char* dig;  // массив для хранения числа:
                // a[0] * 100^0 + a[1] * 100^1 + .. + a[n - 1] * 100^(n-1)
    int n;      // размер числа в разрядах
    char sign;  // для положительных чисел и нуля, знак sign записывается как 0, для отрицательных - как 1
} LongN;

LongN* getLongN(char* s) {
    // сначала выделим память под саму структуру (фиолетовый прямоугольник)
    LongN* px = malloc(sizeof(LongN));

    px->sign = 0;

    if (s[0] == '0') {  // 0*10**0
        px->n = 0;
        px->dig = malloc(px->n + 1);
        px->dig[0] = 0;
        return px;
    }

    if (s[0] == '-') {
        px->sign = 1;
    }
    int len = strlen(s) - 1;
    int digits[N * 2] = {0};
    for (int i = 0; i <= len - px->sign; i++) {
        digits[i] = (s[len - i] - '0');
    }

    px->n = len - px->sign;
    px->dig = malloc(px->n);
    int j = 0;
    for (int i = 0; i <= len; i += 2, j++) {
        px->dig[j] = digits[i] + (i == len ? 0 : digits[i + 1]) * 10;
    }
    px->n = j - 1;
    // выделим памяти точно под хранение числа
    px->dig = realloc(px->dig, j);
    return px;
}

void longN_destroy(LongN* px) {
    free(px->dig);  // освобождаем желтый массив с цифрами
    free(px);  // освобождаем фиолетовый прямогольник, саму структуру
}

void longN_print(const LongN* x) {
    printf("%s", x->sign ? "- " : "+ ");

    for (int i = 0; i <= x->n; i++) {
        printf("%d ", x->dig[x->n - i]);
        // printf("\n");
    }
}

int main() {
    LongN* a;
    LongN* b;
    LongN* c;

    a = getLongN("1234000000000000000000000000000000000009");  // res = 0
    b = getLongN("0");                                         // res = 0
    c = getLongN("-123456789");                                // res = 0

    longN_print(a);  // print 0
    printf("\n");
    longN_print(b);  // print 0
    printf("\n");
    longN_print(c);  // print 0
    printf("\n");

    longN_destroy(a);
    longN_destroy(b);
    longN_destroy(c);

    return 0;
}
```