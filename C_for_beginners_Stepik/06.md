# Условные и логические операторы

[Видео](https://youtu.be/I-w0zPQLaYk)

## `if` и `else`

### Зачем нужны условные операторы
Решим задачу.

Через реку можно переплыть на лодке, которая вмещает K пассажиров. На берегу стоит N человек и хочет переправиться на другой берег. Сколько нужно сделать рейсов, чтобы переправить на другой берег всех людей? 1 рейс - это когда лодка плавает туда и обратно.

Чтобы решить задачу, можно придумать математическую формулу.

Придумайте формулу. Проверьте для разных значений N и К

Проще писать программу так, как думает обычный человек (не математик) :
+ вычислим количество рейсов лодки, когда она полная
+ если на берегу кто-то остался,
+ то добавим +1 рейс

```c
#include <stdio.h>


int main()
{
    int n,                 // пассажиров на берегу
        k,                 // пассажиров за один рейс может перевезти лодка
        reisov,            // количество рейсов
        ostalos;           // пассажиров в неполной лодке


    scanf("%d%d", &n, &k); // читаем n и k


    reisov = n / k;        // количество рейсов, когда лодка полная
    ostalos = n % k;       // сколько человек осталось после этого на берегу


    if (ostalos > 0) {     // если на берегу остались люди
        reisov += 1;       // добавить еще 1 рейс с неполной лодкой
        printf("Нужен дополнительный рейс\n");
    }


    printf ("%d\n", reisov); // напечатать количество рейсов
    return 0;
}
```

Как писать условный оператор if:

```c
if (условие)
    оператор   // выполняется только когда условие истинно
```

Если условие истинно, то выполняется оператор. Если ложно, то оператор не выполняется.

#### Что есть истина?

В языке С ложь (false) - это 0. Все остальное - истина (true).

__Части if__
+ if - ключевое слово.
+ условие пишем в круглых скобках ( )
+ команды пишем с отступом относительно ключевого слова if;
+ отступ в 1 табуляцию для каждого дополнительного уровня вложенности;
+ отступ одинаковый для одинакового уровня вложенности;
+ если нужно написать несколько оператор , то объединяем их в один блочный оператор, то есть пишем все операторы внутри фигурных скобок { и }
+ единственный оператор можно написать без { }, а можно поставить вокруг него { }
+ первое время пишите { } всегда, это поможет избежать ошибок, когда вы добавляете к операторам еще код, например, отладочную печать.
+ закрывающую фигурную скобку пишите под if (на прежнем уровне отступов)

### Сравнения в языке С

Математики пишут вместо слов "больше" и "меньше" специальные символы > и <.

Но на клавиатуре нет символа ≥. Его программисты пишут как >= ("больше или равно" - знак "больше" стоит перед знаком "равно", между этими знаками нельзя ставить пробел).

Как проверить, что х равно 2, если = - это оператор "присвоить"? Написать ==. Мы чаще присваиваем, чем проверяем равно или нет, поэтому "присвоить" - это один знак =, а "сравнить на равенство" - это 2 знака = подряд.

Знака ≠ тоже нет на клавиатуре. Его пишем как != ("отрицание равно").

В математике | В языке С | По-русски
-|-|-
`>` | > | больше
`≥` | >= | больше или равно
`<` | < | меньше
`≤` | <= | меньше или равно
`=` | == | равно
`≠` | != | не равно

### Блочный оператор
Нужно писать { } в операторе if или нет?

По определению после выражения в ( ) идет 1 оператор. Следующий оператор уже не относится к if.

```c
if (условие)
    оператор   // выполняется только когда условие истинно
```

Тогда в задаче если мы напишем в if отладочную печать, то она будет работать неправильно.

```c
#include <stdio.h>


int main()
{
    int n,                  // пассажиров на берегу
        k;                  // пассажиров за один рейс может перевезти лодка


    scanf("%d%d", &n, &k);  // читаем n и k


    int reisov = n / k;     // количество рейсов, когда лодка полная


    if (n %k > 0)           // если на берегу остались люди
        reisov += 1;        // добавить еще 1 рейс с неполной лодкой
        printf("Нужен дополнительный рейс\n");      // Ошибка! Печатается всегда!


    printf ("%d\n", reisov); // напечатать количество рейсов
    return 0;
}
```

Номер теста | Input | Output | Это правильно?
-|-|-|-
1 | 11 5 | Нужен дополнительный рейс 3 | Правильно
2 | 10 5 | Нужен дополнительный рейс 2 | Ответ правильный, отладочная печать неправильная

Заметим, что хотя мы поставили отступы так, что "Нужен дополнительный рейс" внутри if, на самом деле printf написан после условного оператора и поэтому печатается при любых значениях n и k.

Как сделать так, чтобы в if можно было написать много операторов? Объединить их в один блочный оператор.

Блочный оператор (один) - это операторы (один или много), написанные внутри { }.

```c
#include <stdio.h>


int main()
{
    int n,                  // пассажиров на берегу
        k;                  // пассажиров за один рейс может перевезти лодка


    scanf("%d%d", &n, &k);  // читаем n и k


    int reisov = n / k;     // количество рейсов, когда лодка полная


    if (n %k > 0) {         // если на берегу остались люди
        reisov += 1;        // добавить еще 1 рейс с неполной лодкой
        printf("Нужен дополнительный рейс\n");
    }
    printf ("%d\n", reisov); // напечатать количество рейсов
    return 0;
}
```

Номер теста | Input | Output | Это правильно?
-|-|-|-
1 | 11 5 | Нужен дополнительный рейс 3 | Правильно
2 | 10 5 | 2 | Правильно

### Использование в математике
Вычислим модуль числа, хранящийся в переменной x:

```c
if (x < 0)
    x = -x;

```

Так как оператор один, { } можно не ставить.
Отступ в 1 табуляцию показывает что код - внутри условного оператора.

__Что напечатает код?__<br>
Что напечатает эта часть кода (внутри main)

```c
int x = 8;
if (x > 4)
    printf("4");
if (x < 7)
    printf("7");
if (x == 8)
    printf("8");
```

```c
48
```

__Что напечатает код?__<br>
Что напечатает эта часть кода (внутри main)

```c
int x = 8;
if (x > 4) {
    printf("4");
    if (x > 9) {
        printf("9");
        if (x == 8) {
            printf("8");
        }
    }
}
```

```c
4
```

### `if` .. `else`
Иногда просто if не хватает. ЕСЛИ число x делится на 2 без остатка, то оно четное, ИНАЧЕ оно нечетное. Запишем эту мысль на языке С:

```c
if (x % 2 == 0)
    printf("четное\n");
else
    printf("нечетное\n");
```

Когда один и тот же признак (четность) может иметь 2 варианта (четное или нечетное), то пишем if .. else:

```c
if (условие)
    оператор_ДА
else
    оператор_НЕТ
```

Если условие - истина, то выполняется оператор_ДА, иначе (условие ложно) выполняется оператор_НЕТ.

### Что может пойти не так?
Попробуем написать код определения четности и нечетности числа по-другому. Попробуйте найти ошибку в этом коде. Сначала экспериментально, а потом выяснив, почему код работает именно так.

Напишите и заполните для этого таблицу с тестами.

```c
if (x % 2 == 1)
    printf("нечетное\n");
else
    printf("четное\n");
```

Напишем программу полностью и будем запускать ее для разных значений х. Результаты напишем в таблицу тестирования, куда занесем значения x, x/2 и x%2:

Тест | x | x/2 | x%2 | output | правильно?
-|-|-|-|-|-
1 | 8 | 4 | 0 | четное | да
2 | -8 | -4 | 0 | четное | да
3 | 7 | 3 | 1 | нечетное | да
4 | -7 | -3 | -1 | четное | НЕТ

Вывод: лучше переводите с русского на С почти дословно: "если число делится нацело на 2, то оно четное, иначе нечетное".

Найдите ошибки в этом коде (напишите и заполните таблицу тестирования):

```c
if (x % 2 == 0)
    printf("четное\n");
if (x % 2 == 1)
    printf("нечетное\n");
```

Так писать не надо. Это очень плохой код.

Если у вас признак или есть или нет, используйте if .. else.

Как вы думаете, в каком случае из этих двух ошибки проще найти и проще исправить?

### Множественный выбор
Напишем программу, которая определяет положительное число или отрицательное. Не забудем, что 0 - это ни положительное, ни отрицательное:

```c
if (x == 0) {
    printf("zero\n");
} else {
                        // блочный оператор может содержать любые операторы.
                        // Например if .. else
    if (x < 0) {
        printf("negative\n");
    } else {
        printf("positive\n");
    }
}
```

Читать такой код неудобно. И если у нас не 3 варианта, а больше, то отступов становится больше и код выходит за границы экрана.

В программировании на С есть такое правило: если вы поставили 4 отступа, скорее всего вы неправильно написали алгоритм.

Что делать? В случае, когда один и тот же признак имеет разные значения, принято ставить отступы по-другому:

```c
if (x == 0) {
    printf("zero\n");
} else if (x < 0) {
    printf("negative\n");
} else {
    printf("positive\n");
}
```

Операторы остались теми же. Изменились только отступы (на которые компилятор не обращает внимание).

То есть с точки зрения компилятора код не изменился.

В С нет никакого "оператора else if". Есть только рекомендaции по расстановке отступов в операторах if .. else.

### Порядок имеет значение
Что напечатает эта часть кода (в main)?


```c
int x = 7;


if (x >= 8)
    printf("отлично");
else if (x >= 3)
    printf("удовлетворительно");
else if (x >= 5)
    printf("хорошо");
else
    printf("неудовлетворительно");
```

```c
удовлетворительно
```

### Разные признаки
Если признаки разные (четность и знак числа), то их стоит писать в разных блоках if..else.

```c
// проверка четности
if (x % 2 == 0)
    printf("четное\n");
else
    printf("нечетное\n");


// проверка знака числа
if (x == 0) {
    printf("zero\n");
} else if (x < 0) {
    printf("negative\n");
} else {
    printf("positive\n");
}
```

## Логические операторы

### Сложные условия
Задача: проверить високосный год или нет. Год является високосным, если он делится на 4, но не делится на 100. Если год делится на 400, то он все равно високосный.

Напишем функцию, `int is_leap_year(int year)`, которая по аргументу `year` возвращает или истину, или ложь. Как ложь мы будем возвращать 0. А как истину договоримся возвращать 1.

Почему не возвращать в виде истины число -7 или 13? Помните, мы говорили о "магических числах" - в программах разрешены числа 0 и 1, все остальные числа должны быть объяснены в комментариях и написаны в виде именованных констант. Потому что любое число будет заставлять другого программиста, который читает ваш код задумываться: "Почему -7, почему не другое число, например 1? -7 что-то значит и я не обратил внимание, что в вызовах получим не 1?"

Ваш код не должен заставлять людей думать (лишний раз).

Напишем функцию:

```c
int is_leap_year(int year) {
    if (year % 400 == 0)
        return 1;
    else if (year % 100 == 0)
        return 0;
    else if (year % 4 == 0)
        return 1;
    else
        return 0;
}
```

Некоторые компиляторы выдадут вам предупреждение, что "функция, которая должна возвращать int, ничего не возвращает". Мы видим, что в любом случае вернется 0 или 1. Но компилятор - не искусственный интеллект. Он анализирует код, видит внутри функции if .. else. И не видит return в конце функции с типом возвращаемого значения int.

Сделаем компилятор счастливым.

Вариант 1: Напишем в конце последним оператором return 666; (любое число, главное, чтобы оно бросалось в глаза) и добавим коментарий "Этот код никогда не будет выполнен".

Не очень хорошо. Лишний код, магические числа, дополнительные комментарии.

Вариант 2: Конструкция

```c
if (условие)
    return N1;
else
    return N2;
```

будет вести себя точно так же, как и

```c
if (условие)
    return N1;

return N2;
```

Либо условие верно и мы выходим из функции со значением N1 в обоих случаях. После return жизни нет и нас не будет интересовать что написано дальше в функции.

Либо условие ложно, и тогда в первом случае выполняется оператор в else (return N2;), а во втором, так как внутрь if не заходим, будет выполнен следующий за if оператор. То есть тоже return N2;

Перепишем функцию:

```c
int is_leap_year(int year) {
    if (year % 400 == 0)
        return 1;
    if (year % 100 == 0)
        return 0;
    if (year % 4 == 0)
        return 1;


    return 0;
}
```

Можно ли в этой функции менять местами блоки if или функция станет работать неправильно?

### Поменяем местами
Студент написал:

```c
int is_leap_year(year)
{
    if (year % 100 == 0)
        return 0;
    else if (year % 4 == 0)
        return 1;
    else if (year % 400 == 0)   // потом
        return 777;
    return 0;
}
```

Что вернет при year=2000? __0__

### Логические операторы
Можно решить ту же задачу с високосным годом с помощью логических операторов.
+ `&&` - логическое И (AND, конъюнкция)
+ `||` - логическое ИЛИ (OR, дизъюнкция)
+ `!` - логическое отрицание (NOT)

Внимание: Два && и два || - это логические И и ИЛИ. Один & и | - это побитовые И и ИЛИ. Не путайте их.

Таблицы истинности для логического И и логического ИЛИ.

![06](/C_for_beginners_Stepik/Pictures/06_01.png)

`x && y` истина, только когда оба аргумента - истина. В остальных случаях - ложь.

В теории множеств конъюнкция - это пересечение множеств.

Я хочу выпить чай. У меня есть чашка воды x и пакет чая y. Могу выпить чай, только если у меня есть и чашка, и пакетик одновременно.

`x || y` ложь, только когда оба аргумента - ложь. В остальных случаях - истина.

В теории множеств дизъюнкция - это объединение множеств.

К чаю я хочу сладкого. У меня есть печенье (cookie) x и конфета y. Сладкое у меня будет, если есть печенье или конфета или и печенье и конфета. Хоть что-нибудь. Только если у меня нет ни печенья, ни конфеты, я сижу без сладкого.

`! x` - превращает ложь в истину и истину в ложь.

Инвертирование множества.

### Логические операторы и математические задачи
Диапазоны значений, записанные через логические операторы:

![06](/C_for_beginners_Stepik/Pictures/06_02.png)

![06](/C_for_beginners_Stepik/Pictures/06_03.png)

![06](/C_for_beginners_Stepik/Pictures/06_04.png)

![06](/C_for_beginners_Stepik/Pictures/06_05.png)

### Приоритет операторов
В выражении `2 + 7 * -3` самый высокий приоритет у унарного минуса (сначала выполнится операция `-3`, потом умножение `*`, в конце сложение `+`).
+ `!` - отрицание имеет самый высокий приоритет, как унарный минус.
+ `&&` - как умножение.
+ `||` - как сложение.
Порядок вычисления можно изменить с помощью скобок.

```c
(2 + 7)* -3 и (x < 2 || x > 12) && ! is_leap_year(y)
```

### Чему равно значение выражение
Столовая работает с 8 до 22 часов. Сейчас h часов.

Какая запись правильно проверяет, что сейчас столовая работает?

```c
8 <= h && h <= 22
```

### Чему равно значение выражения
Номер месяца | Месяц | Время года
-|-|-
1 | январь | зима
2 | февраль | зима
3 | март | весна
4 | апрель | весна
5 | май | весна
6 | июнь | лето
7 | июль | лето
8 | август | лето
9 | сентябрь | осень
10 | октябрь | осень
11 | ноябрь | осень
12 | декабрь | зима

Сейчас месяц номер m.

Какая запись правильно проверяет, что сейчас зима?

```c
! (2 < m && m < 12)
m == 1 || m == 2 || m == 12
```

### Порядок вычислений
Логические операторы - единственные, для которых жестко определен порядок вычислений (слева направо) при равном приоритете.

Кроме того, действует правило, что как только значение всего выражения можно определить, дальше не считаем.

То есть, если у нас есть выражение x && y, то: * сначала будет вычислено x * если оно 0 (ложь), то значение всего выражения уже ясно (тоже ложь) и y вычисляться не будет.

То, что функция возвращает, называют значением функции. А то, что функция при этом еще делает - побочным эффектом функции. Например, функция `scanf("%d", &x)` возвращает, сколько чисел она смогла прочитать. А ее "побочный эффект" - это чтение числа и запись его в переменную x.

Будем называть функцией-датчиком функцию, которая возвращает наличие какого-нибудь признака, например, что очередь пустая.

В условии мы связываем логическими операторами выражения сравнения и вызовы функций-датчиков. Не надо в условных выражениях писать функции с побочным эффектом. Пусть, `draw_star(10)` рисует звезду (побочный эффект) и возвращает 0, а `draw_table(3, 4)` рисует таблицу (еще один побочный эффект). Тогда `draw_star(10) && draw_table(3, 4)` будет рисовать звезду, но не станет рисовать таблицу. Ибо результат логического выражения уже ясен из первого операнда, и второй операнд не будет вычисляться, то есть функция `draw_table(3, 4)` не будет вызвана.

Иногда этим свойством логических операторов пользуются и получают вот такой код (вне условных операторов):


```c
// если стек не пустой, взять из него элемент:
! is_empty(stack) && ( x = pop(stack) );
```

Мы рекомендуем все же использовать более привычный стиль:

```c
if (!is_empty(stack))
    x = pop(stack);
```

### Значение выражений
Значение выражений сравнения и логических операторов - 0 (ложь) или 1 (истина).

Старайтесь не использовать это в своем коде. То есть не надо больше писать так:

```c
doz = !!(dig / 10) * ('A' + dig % 10) + ! (dig / 10) * (dig + '0');
```

Значение выражения присвоения - значение правой части, то есть выражение x = 5 (все целиком) имеет значение 5.

Рассмотрим, что будет выведено на печать:

```c
int x = 5;
if (x == 5)
    printf("AAA");
if (x = 3)
    printf("BBB");
if (x = 0)
    printf("ZZZ");
printf("%d\n", x);
```

+ x == 5 истино, то есть напечатается AAA
+ x = 3 (присвоение) имеет значение 3, то есть истина, напечатается BBB и переменная x теперь равна 3
+ x = 0 (присвоение) имеет значение 0, то есть ложь, ZZZ печататься НЕ будет, переменная x теперь равна 0

Итого, `AAABBB0`

### Принадлежит `[-25, 37)`
Напишите программу. Она читает целое число, печатает его и печатает YES, если число принадлежит `[-25, 37)`. Иначе печатает NO

```c
#include <stdio.h>

int main()
{
    int x;
    scanf("%d", &x);
    printf("%d ", x);

    printf("%s", (x >= -25 && x < 37) ? "YES": "NO");

    return 0;
}
```

### Принадлежит `(-∞; 37) U [146; ∞)`
Напишите программу. Она читает целое число, печатает его и печатает YES, если число принадлежит `(-∞; 37) U [146; ∞)`. Иначе печатает NO

```c
#include <stdio.h>

int main()
{
    int x;
    scanf("%d", &x);
    printf("%d ", x);

    printf("%s", (x >= 37 && x < 146) ? "NO": "YES");

    return 0;
}
```

## `switch`..`case`, `? :`

### switch case
Иногда выражение равно одной константе из нескольких (например, когда обрабатываем значение введенного символа). Чтобы не писать длинные if..else с перечислением констант, можно использовать оператор switch..case.

```c
switch(выражение) {
    case КОНСТАНТА_1:
        операторы_1
    case КОНСТАНТА_2:
        операторы_2
    case КОНСТАНТА_3:
        операторы_3
    // пишем столько case, сколько нужно


    // части default может не быть
    default:
        операторы_default
}
```

+ выражение и константы - целых типов.
+ работа оператора:
    + вычисляется выражение
    + один за другим сверху вниз значение выражения сравнивается с очередной константой_i в case. Если они равны, то управление переходит к операторы_i. И выполняются все операторы до конца switch.
    + если ни одна константа не подошла, и есть default, то управление переходит к операторы_default.
+ порядок выполнения операторов можно изменить, поставив оператор break - передать управление за пределы switch (закончить его).

Решим задачу. В переменной n дано число коров. Нужно напечатать число и слово "коров" в правильном падеже.

```c
switch ( n % 10 ) {
    case 1 :
        printf("%d корова", n);
        break;
    case 2 :
    case 4 : // константы в любом порядке
    case 3 :
        printf("%d коровы", n);
        break;
    default: // в конце, может не быть
        printf("%d коров", n);
}
// сюда передает управление break
```

Для каких n код работает неверно? Как его исправить?

### Потерянный break
Что будет, если n = 21 и мы не написали break в первом case 1?

```c
switch ( n % 10 ) {
    case 1 :
        printf("%d корова", n);
        // забыли написать break;
    case 2 :
    case 4 : // константы в любом порядке
    case 3 :
        printf("%d коровы", n);
        break;
    default: // в конце, может не быть
        printf("%d коров", n);
}
// сюда передает управление break
```

+ вычислится n % 10 (получим 1)
+ полученное выражение равно 1, значит управление передастся на операторы в case 1?
+ printf("%d корова", n); напечатает "21 корова"
+ пойдут выполняться операторы ниже, один за другим

```c
        printf("%d коровы", n);     // напечатает "21 коровы"
        break;                      // наконец выйдем  из switch
```

Итого:

```c
21 корова
21 коровы
```

Второе явно лишнее.

Иногда break не ставят специально. Например, мы хотели сделать что-то с 2, 3 и 4 коровами, а с 1 коровой мы хотим сделать то же самое, но еще и покрасить ее в розовый цвет. Тогда напишем:

```c
switch ( n % 10 ) {
    case 1 :
        красим_розовым();
        // дальше с коровой будут делать то же самое, 
        // что и с 2, 3 или 4 коровами, 
        // но розовой краски хватит только на 1 корову
    case 2 :
    case 4 : // константы в любом порядке
    case 3 :
        делаем_что_то_с_коровами();
        break;
    default: 
        printf("Слишком много коров\n");
}
// сюда передает управление break
```

В этом случае отсутствие break обязательно пишут комментарий, почему его нет в коде. Иначе мне захочется "исправить" код, поставив "забытый" break.

### ? : - тернарный оператор
У записи

```c
if ( x > 3 )
    z = x;
else
    z = 0;
```

Существует краткая форма через тернарный оператор:

```c
y = ( x > 3 ) ? x : 0 ;

(условие) ? значение_ДА : значение_НЕТ
```

+ вычисляется условие
+ если оно истино, то значение всего оператора равно значение_ДА
+ если условие ложно, то значение всего оператора равно значение_НЕТ

Примеры использования:

```c
printf ( x ? "YES" : "NO");
printf ("%s\n", x ? "YES" : "NO");
```

Вот так писать плохо, нарушается принцип "не заставляйте меня думать":

```c
x = c1 ? c2 ? 1 : 2 : c3 ? 3 : 4;
```
