# Условные и логические операторы

[Видео](https://youtu.be/I-w0zPQLaYk)

## `if` и `else`

### Зачем нужны условные операторы
Решим задачу.

Через реку можно переплыть на лодке, которая вмещает K пассажиров. На берегу стоит N человек и хочет переправиться на другой берег. Сколько нужно сделать рейсов, чтобы переправить на другой берег всех людей? 1 рейс - это когда лодка плавает туда и обратно.

Чтобы решить задачу, можно придумать математическую формулу.

Придумайте формулу. Проверьте для разных значений N и К

Проще писать программу так, как думает обычный человек (не математик) :
+ вычислим количество рейсов лодки, когда она полная
+ если на берегу кто-то остался,
+ то добавим +1 рейс

```c
#include <stdio.h>


int main()
{
    int n,                 // пассажиров на берегу
        k,                 // пассажиров за один рейс может перевезти лодка
        reisov,            // количество рейсов
        ostalos;           // пассажиров в неполной лодке


    scanf("%d%d", &n, &k); // читаем n и k


    reisov = n / k;        // количество рейсов, когда лодка полная
    ostalos = n % k;       // сколько человек осталось после этого на берегу


    if (ostalos > 0) {     // если на берегу остались люди
        reisov += 1;       // добавить еще 1 рейс с неполной лодкой
        printf("Нужен дополнительный рейс\n");
    }


    printf ("%d\n", reisov); // напечатать количество рейсов
    return 0;
}
```

Как писать условный оператор if:

```c
if (условие)
    оператор   // выполняется только когда условие истинно
```

Если условие истинно, то выполняется оператор. Если ложно, то оператор не выполняется.

#### Что есть истина?

В языке С ложь (false) - это 0. Все остальное - истина (true).

__Части if__
+ if - ключевое слово.
+ условие пишем в круглых скобках ( )
+ команды пишем с отступом относительно ключевого слова if;
+ отступ в 1 табуляцию для каждого дополнительного уровня вложенности;
+ отступ одинаковый для одинакового уровня вложенности;
+ если нужно написать несколько оператор , то объединяем их в один блочный оператор, то есть пишем все операторы внутри фигурных скобок { и }
+ единственный оператор можно написать без { }, а можно поставить вокруг него { }
+ первое время пишите { } всегда, это поможет избежать ошибок, когда вы добавляете к операторам еще код, например, отладочную печать.
+ закрывающую фигурную скобку пишите под if (на прежнем уровне отступов)

### Сравнения в языке С

Математики пишут вместо слов "больше" и "меньше" специальные символы > и <.

Но на клавиатуре нет символа ≥. Его программисты пишут как >= ("больше или равно" - знак "больше" стоит перед знаком "равно", между этими знаками нельзя ставить пробел).

Как проверить, что х равно 2, если = - это оператор "присвоить"? Написать ==. Мы чаще присваиваем, чем проверяем равно или нет, поэтому "присвоить" - это один знак =, а "сравнить на равенство" - это 2 знака = подряд.

Знака ≠ тоже нет на клавиатуре. Его пишем как != ("отрицание равно").

В математике | В языке С | По-русски
-|-|-
`>` | > | больше
`≥` | >= | больше или равно
`<` | < | меньше
`≤` | <= | меньше или равно
`=` | == | равно
`≠` | != | не равно

### Блочный оператор
Нужно писать { } в операторе if или нет?

По определению после выражения в ( ) идет 1 оператор. Следующий оператор уже не относится к if.

```c
if (условие)
    оператор   // выполняется только когда условие истинно
```

Тогда в задаче если мы напишем в if отладочную печать, то она будет работать неправильно.

```c
#include <stdio.h>


int main()
{
    int n,                  // пассажиров на берегу
        k;                  // пассажиров за один рейс может перевезти лодка


    scanf("%d%d", &n, &k);  // читаем n и k


    int reisov = n / k;     // количество рейсов, когда лодка полная


    if (n %k > 0)           // если на берегу остались люди
        reisov += 1;        // добавить еще 1 рейс с неполной лодкой
        printf("Нужен дополнительный рейс\n");      // Ошибка! Печатается всегда!


    printf ("%d\n", reisov); // напечатать количество рейсов
    return 0;
}
```

Номер теста | Input | Output | Это правильно?
-|-|-|-
1 | 11 5 | Нужен дополнительный рейс 3 | Правильно
2 | 10 5 | Нужен дополнительный рейс 2 | Ответ правильный, отладочная печать неправильная

Заметим, что хотя мы поставили отступы так, что "Нужен дополнительный рейс" внутри if, на самом деле printf написан после условного оператора и поэтому печатается при любых значениях n и k.

Как сделать так, чтобы в if можно было написать много операторов? Объединить их в один блочный оператор.

Блочный оператор (один) - это операторы (один или много), написанные внутри { }.

```c
#include <stdio.h>


int main()
{
    int n,                  // пассажиров на берегу
        k;                  // пассажиров за один рейс может перевезти лодка


    scanf("%d%d", &n, &k);  // читаем n и k


    int reisov = n / k;     // количество рейсов, когда лодка полная


    if (n %k > 0) {         // если на берегу остались люди
        reisov += 1;        // добавить еще 1 рейс с неполной лодкой
        printf("Нужен дополнительный рейс\n");
    }
    printf ("%d\n", reisov); // напечатать количество рейсов
    return 0;
}
```

Номер теста | Input | Output | Это правильно?
-|-|-|-
1 | 11 5 | Нужен дополнительный рейс 3 | Правильно
2 | 10 5 | 2 | Правильно

### Использование в математике
Вычислим модуль числа, хранящийся в переменной x:

```c
if (x < 0)
    x = -x;

```

Так как оператор один, { } можно не ставить.
Отступ в 1 табуляцию показывает что код - внутри условного оператора.

__Что напечатает код?__<br>
Что напечатает эта часть кода (внутри main)

```c
int x = 8;
if (x > 4)
    printf("4");
if (x < 7)
    printf("7");
if (x == 8)
    printf("8");
```

```c
48
```

__Что напечатает код?__<br>
Что напечатает эта часть кода (внутри main)

```c
int x = 8;
if (x > 4) {
    printf("4");
    if (x > 9) {
        printf("9");
        if (x == 8) {
            printf("8");
        }
    }
}
```

```c
4
```

### `if` .. `else`
Иногда просто if не хватает. ЕСЛИ число x делится на 2 без остатка, то оно четное, ИНАЧЕ оно нечетное. Запишем эту мысль на языке С:

```c
if (x % 2 == 0)
    printf("четное\n");
else
    printf("нечетное\n");
```

Когда один и тот же признак (четность) может иметь 2 варианта (четное или нечетное), то пишем if .. else:

```c
if (условие)
    оператор_ДА
else
    оператор_НЕТ
```

Если условие - истина, то выполняется оператор_ДА, иначе (условие ложно) выполняется оператор_НЕТ.

### Что может пойти не так?
Попробуем написать код определения четности и нечетности числа по-другому. Попробуйте найти ошибку в этом коде. Сначала экспериментально, а потом выяснив, почему код работает именно так.

Напишите и заполните для этого таблицу с тестами.

```c
if (x % 2 == 1)
    printf("нечетное\n");
else
    printf("четное\n");
```

Напишем программу полностью и будем запускать ее для разных значений х. Результаты напишем в таблицу тестирования, куда занесем значения x, x/2 и x%2:

Тест | x | x/2 | x%2 | output | правильно?
-|-|-|-|-|-
1 | 8 | 4 | 0 | четное | да
2 | -8 | -4 | 0 | четное | да
3 | 7 | 3 | 1 | нечетное | да
4 | -7 | -3 | -1 | четное | НЕТ

Вывод: лучше переводите с русского на С почти дословно: "если число делится нацело на 2, то оно четное, иначе нечетное".

Найдите ошибки в этом коде (напишите и заполните таблицу тестирования):

```c
if (x % 2 == 0)
    printf("четное\n");
if (x % 2 == 1)
    printf("нечетное\n");
```

Так писать не надо. Это очень плохой код.

Если у вас признак или есть или нет, используйте if .. else.

Как вы думаете, в каком случае из этих двух ошибки проще найти и проще исправить?

### Множественный выбор
Напишем программу, которая определяет положительное число или отрицательное. Не забудем, что 0 - это ни положительное, ни отрицательное:

```c
if (x == 0) {
    printf("zero\n");
} else {
                        // блочный оператор может содержать любые операторы.
                        // Например if .. else
    if (x < 0) {
        printf("negative\n");
    } else {
        printf("positive\n");
    }
}
```

Читать такой код неудобно. И если у нас не 3 варианта, а больше, то отступов становится больше и код выходит за границы экрана.

В программировании на С есть такое правило: если вы поставили 4 отступа, скорее всего вы неправильно написали алгоритм.

Что делать? В случае, когда один и тот же признак имеет разные значения, принято ставить отступы по-другому:

```c
if (x == 0) {
    printf("zero\n");
} else if (x < 0) {
    printf("negative\n");
} else {
    printf("positive\n");
}
```

Операторы остались теми же. Изменились только отступы (на которые компилятор не обращает внимание).

То есть с точки зрения компилятора код не изменился.

В С нет никакого "оператора else if". Есть только рекомендaции по расстановке отступов в операторах if .. else.

### Порядок имеет значение
Что напечатает эта часть кода (в main)?


```c
int x = 7;


if (x >= 8)
    printf("отлично");
else if (x >= 3)
    printf("удовлетворительно");
else if (x >= 5)
    printf("хорошо");
else
    printf("неудовлетворительно");
```

```c
удовлетворительно
```

### Разные признаки
Если признаки разные (четность и знак числа), то их стоит писать в разных блоках if..else.

```c
// проверка четности
if (x % 2 == 0)
    printf("четное\n");
else
    printf("нечетное\n");


// проверка знака числа
if (x == 0) {
    printf("zero\n");
} else if (x < 0) {
    printf("negative\n");
} else {
    printf("positive\n");
}
```

## 6.3 Логические операторы

### Сложные условия
Задача: проверить високосный год или нет. Год является високосным, если он делится на 4, но не делится на 100. Если год делится на 400, то он все равно високосный.

Напишем функцию, `int is_leap_year(int year)`, которая по аргументу `year` возвращает или истину, или ложь. Как ложь мы будем возвращать 0. А как истину договоримся возвращать 1.

Почему не возвращать в виде истины число -7 или 13? Помните, мы говорили о "магических числах" - в программах разрешены числа 0 и 1, все остальные числа должны быть объяснены в комментариях и написаны в виде именованных констант. Потому что любое число будет заставлять другого программиста, который читает ваш код задумываться: "Почему -7, почему не другое число, например 1? -7 что-то значит и я не обратил внимание, что в вызовах получим не 1?"

Ваш код не должен заставлять людей думать (лишний раз).

Напишем функцию:

```c
int is_leap_year(int year) {
    if (year % 400 == 0)
        return 1;
    else if (year % 100 == 0)
        return 0;
    else if (year % 4 == 0)
        return 1;
    else
        return 0;
}
```

Некоторые компиляторы выдадут вам предупреждение, что "функция, которая должна возвращать int, ничего не возвращает". Мы видим, что в любом случае вернется 0 или 1. Но компилятор - не искусственный интеллект. Он анализирует код, видит внутри функции if .. else. И не видит return в конце функции с типом возвращаемого значения int.

Сделаем компилятор счастливым.

Вариант 1: Напишем в конце последним оператором return 666; (любое число, главное, чтобы оно бросалось в глаза) и добавим коментарий "Этот код никогда не будет выполнен".

Не очень хорошо. Лишний код, магические числа, дополнительные комментарии.

Вариант 2: Конструкция

```c
if (условие)
    return N1;
else
    return N2;
```

будет вести себя точно так же, как и

```c
if (условие)
    return N1;

return N2;
```

Либо условие верно и мы выходим из функции со значением N1 в обоих случаях. После return жизни нет и нас не будет интересовать что написано дальше в функции.

Либо условие ложно, и тогда в первом случае выполняется оператор в else (return N2;), а во втором, так как внутрь if не заходим, будет выполнен следующий за if оператор. То есть тоже return N2;

Перепишем функцию:

```c
int is_leap_year(int year) {
    if (year % 400 == 0)
        return 1;
    if (year % 100 == 0)
        return 0;
    if (year % 4 == 0)
        return 1;


    return 0;
}
```

Можно ли в этой функции менять местами блоки if или функция станет работать неправильно?

### Поменяем местами
Студент написал:

```c
int is_leap_year(year)
{
    if (year % 100 == 0)
        return 0;
    else if (year % 4 == 0)
        return 1;
    else if (year % 400 == 0)   // потом
        return 777;
    return 0;
}
```

Что вернет при year=2000? __0__

### Логические операторы
Можно решить ту же задачу с високосным годом с помощью логических операторов.
+ `&&` - логическое И (AND, конъюнкция)
+ `||` - логическое ИЛИ (OR, дизъюнкция)
+ `!` - логическое отрицание (NOT)

Внимание: Два && и два || - это логические И и ИЛИ. Один & и | - это побитовые И и ИЛИ. Не путайте их.

Таблицы истинности для логического И и логического ИЛИ.

![06](/C_for_beginners_Stepik/Pictures/06_01.png)

`x && y` истина, только когда оба аргумента - истина. В остальных случаях - ложь.

В теории множеств конъюнкция - это пересечение множеств.

Я хочу выпить чай. У меня есть чашка воды x и пакет чая y. Могу выпить чай, только если у меня есть и чашка, и пакетик одновременно.

`x || y` ложь, только когда оба аргумента - ложь. В остальных случаях - истина.

В теории множеств дизъюнкция - это объединение множеств.

К чаю я хочу сладкого. У меня есть печенье (cookie) x и конфета y. Сладкое у меня будет, если есть печенье или конфета или и печенье и конфета. Хоть что-нибудь. Только если у меня нет ни печенья, ни конфеты, я сижу без сладкого.

`! x` - превращает ложь в истину и истину в ложь.

Инвертирование множества.

### Логические операторы и математические задачи
Диапазоны значений, записанные через логические операторы:

![06](/C_for_beginners_Stepik/Pictures/06_02.png)

![06](/C_for_beginners_Stepik/Pictures/06_03.png)

![06](/C_for_beginners_Stepik/Pictures/06_04.png)

![06](/C_for_beginners_Stepik/Pictures/06_05.png)

### Приоритет операторов
В выражении `2 + 7 * -3` самый высокий приоритет у унарного минуса (сначала выполнится операция `-3`, потом умножение `*`, в конце сложение `+`).
+ `!` - отрицание имеет самый высокий приоритет, как унарный минус.
+ `&&` - как умножение.
+ `||` - как сложение.
Порядок вычисления можно изменить с помощью скобок.

```c
(2 + 7)* -3 и (x < 2 || x > 12) && ! is_leap_year(y)
```

### Чему равно значение выражение
Столовая работает с 8 до 22 часов. Сейчас h часов.

Какая запись правильно проверяет, что сейчас столовая работает?

```c
8 <= h && h <= 22
```

### Чему равно значение выражения
Номер месяца | Месяц | Время года
-|-|-
1 | январь | зима
2 | февраль | зима
3 | март | весна
4 | апрель | весна
5 | май | весна
6 | июнь | лето
7 | июль | лето
8 | август | лето
9 | сентябрь | осень
10 | октябрь | осень
11 | ноябрь | осень
12 | декабрь | зима

Сейчас месяц номер m.

Какая запись правильно проверяет, что сейчас зима?

```c
! (2 < m && m < 12)
m == 1 || m == 2 || m == 12
```

### Порядок вычислений
Логические операторы - единственные, для которых жестко определен порядок вычислений (слева направо) при равном приоритете.

Кроме того, действует правило, что как только значение всего выражения можно определить, дальше не считаем.

То есть, если у нас есть выражение x && y, то: * сначала будет вычислено x * если оно 0 (ложь), то значение всего выражения уже ясно (тоже ложь) и y вычисляться не будет.

То, что функция возвращает, называют значением функции. А то, что функция при этом еще делает - побочным эффектом функции. Например, функция `scanf("%d", &x)` возвращает, сколько чисел она смогла прочитать. А ее "побочный эффект" - это чтение числа и запись его в переменную x.

Будем называть функцией-датчиком функцию, которая возвращает наличие какого-нибудь признака, например, что очередь пустая.

В условии мы связываем логическими операторами выражения сравнения и вызовы функций-датчиков. Не надо в условных выражениях писать функции с побочным эффектом. Пусть, `draw_star(10)` рисует звезду (побочный эффект) и возвращает 0, а `draw_table(3, 4)` рисует таблицу (еще один побочный эффект). Тогда `draw_star(10) && draw_table(3, 4)` будет рисовать звезду, но не станет рисовать таблицу. Ибо результат логического выражения уже ясен из первого операнда, и второй операнд не будет вычисляться, то есть функция `draw_table(3, 4)` не будет вызвана.

Иногда этим свойством логических операторов пользуются и получают вот такой код (вне условных операторов):


```c
// если стек не пустой, взять из него элемент:
! is_empty(stack) && ( x = pop(stack) );
```

Мы рекомендуем все же использовать более привычный стиль:

```c
if (!is_empty(stack))
    x = pop(stack);
```

### Значение выражений
Значение выражений сравнения и логических операторов - 0 (ложь) или 1 (истина).

Старайтесь не использовать это в своем коде. То есть не надо больше писать так:

```c
doz = !!(dig / 10) * ('A' + dig % 10) + ! (dig / 10) * (dig + '0');
```

Значение выражения присвоения - значение правой части, то есть выражение x = 5 (все целиком) имеет значение 5.

Рассмотрим, что будет выведено на печать:

```c
int x = 5;
if (x == 5)
    printf("AAA");
if (x = 3)
    printf("BBB");
if (x = 0)
    printf("ZZZ");
printf("%d\n", x);
```

+ x == 5 истино, то есть напечатается AAA
+ x = 3 (присвоение) имеет значение 3, то есть истина, напечатается BBB и переменная x теперь равна 3
+ x = 0 (присвоение) имеет значение 0, то есть ложь, ZZZ печататься НЕ будет, переменная x теперь равна 0

Итого, `AAABBB0`

### Принадлежит `[-25, 37)`
Напишите программу. Она читает целое число, печатает его и печатает YES, если число принадлежит `[-25, 37)`. Иначе печатает NO

```c
#include <stdio.h>

int main()
{
    int x;
    scanf("%d", &x);
    printf("%d ", x);

    printf("%s", (x >= -25 && x < 37) ? "YES": "NO");

    return 0;
}
```

### Принадлежит `(-∞; 37) U [146; ∞)`
Напишите программу. Она читает целое число, печатает его и печатает YES, если число принадлежит `(-∞; 37) U [146; ∞)`. Иначе печатает NO

```c
#include <stdio.h>

int main()
{
    int x;
    scanf("%d", &x);
    printf("%d ", x);

    printf("%s", (x >= 37 && x < 146) ? "NO": "YES");

    return 0;
}
```

## `switch`..`case`, `? :`

### switch case
Иногда выражение равно одной константе из нескольких (например, когда обрабатываем значение введенного символа). Чтобы не писать длинные if..else с перечислением констант, можно использовать оператор switch..case.

```c
switch(выражение) {
    case КОНСТАНТА_1:
        операторы_1
    case КОНСТАНТА_2:
        операторы_2
    case КОНСТАНТА_3:
        операторы_3
    // пишем столько case, сколько нужно


    // части default может не быть
    default:
        операторы_default
}
```

+ выражение и константы - целых типов.
+ работа оператора:
    + вычисляется выражение
    + один за другим сверху вниз значение выражения сравнивается с очередной константой_i в case. Если они равны, то управление переходит к операторы_i. И выполняются все операторы до конца switch.
    + если ни одна константа не подошла, и есть default, то управление переходит к операторы_default.
+ порядок выполнения операторов можно изменить, поставив оператор break - передать управление за пределы switch (закончить его).

Решим задачу. В переменной n дано число коров. Нужно напечатать число и слово "коров" в правильном падеже.

```c
switch ( n % 10 ) {
    case 1 :
        printf("%d корова", n);
        break;
    case 2 :
    case 4 : // константы в любом порядке
    case 3 :
        printf("%d коровы", n);
        break;
    default: // в конце, может не быть
        printf("%d коров", n);
}
// сюда передает управление break
```

Для каких n код работает неверно? Как его исправить?

### Потерянный break
Что будет, если n = 21 и мы не написали break в первом case 1?

```c
switch ( n % 10 ) {
    case 1 :
        printf("%d корова", n);
        // забыли написать break;
    case 2 :
    case 4 : // константы в любом порядке
    case 3 :
        printf("%d коровы", n);
        break;
    default: // в конце, может не быть
        printf("%d коров", n);
}
// сюда передает управление break
```

+ вычислится n % 10 (получим 1)
+ полученное выражение равно 1, значит управление передастся на операторы в case 1?
+ printf("%d корова", n); напечатает "21 корова"
+ пойдут выполняться операторы ниже, один за другим

```c
        printf("%d коровы", n);     // напечатает "21 коровы"
        break;                      // наконец выйдем  из switch
```

Итого:

```c
21 корова
21 коровы
```

Второе явно лишнее.

Иногда break не ставят специально. Например, мы хотели сделать что-то с 2, 3 и 4 коровами, а с 1 коровой мы хотим сделать то же самое, но еще и покрасить ее в розовый цвет. Тогда напишем:

```c
switch ( n % 10 ) {
    case 1 :
        красим_розовым();
        // дальше с коровой будут делать то же самое, 
        // что и с 2, 3 или 4 коровами, 
        // но розовой краски хватит только на 1 корову
    case 2 :
    case 4 : // константы в любом порядке
    case 3 :
        делаем_что_то_с_коровами();
        break;
    default: 
        printf("Слишком много коров\n");
}
// сюда передает управление break
```

В этом случае отсутствие break обязательно пишут комментарий, почему его нет в коде. Иначе мне захочется "исправить" код, поставив "забытый" break.

### ? : - тернарный оператор
У записи

```c
if ( x > 3 )
    z = x;
else
    z = 0;
```

Существует краткая форма через тернарный оператор:

```c
y = ( x > 3 ) ? x : 0 ;

(условие) ? значение_ДА : значение_НЕТ
```

+ вычисляется условие
+ если оно истино, то значение всего оператора равно значение_ДА
+ если условие ложно, то значение всего оператора равно значение_НЕТ

Примеры использования:

```c
printf ( x ? "YES" : "NO");
printf ("%s\n", x ? "YES" : "NO");
```

Вот так писать плохо, нарушается принцип "не заставляйте меня думать":

```c
x = c1 ? c2 ? 1 : 2 : c3 ? 3 : 4;
```

##  if - задачи для начинающих

### Сколько стоит обед?

![06](/C_for_beginners_Stepik/Pictures/06_06.png)

У студента есть n рублей.

Он хочет купить на обед в столовой 1 порцию риса за k_rice рублей и 2 салата за k_veg рублей каждый.

Дано: n k_rice k_veg через пробел на одной строке. Все числа целые.

Напечатайте:
+ Входные данные n k_rice k_veg через пробел на первой строке,
+ Вычислите и напечатайте, сколько стоит обед на второй строке.
+ Напечатайте YES, если студенту хватит денег на обед, на третьей строке.

Дано: n k_rice k_veg через пробел на одной строке.

```c
#include <stdio.h>

int main()
{
    int n, k_rice, k_veg, res;
    scanf("%d %d %d", &n, &k_rice, &k_veg);
    
    res = k_veg * 2 + k_rice;
    
    printf("%d %d %d\n", n, k_rice, k_veg);
    printf("%d\n%s", res, (n - res >= 0) ? "YES": "");

    return 0;
}
```

### if_1 - минимум из 2 чисел
Даны 2 целых числа.

Напечатайте числа через пробел.

Напечатайте минимальное из этих чисел на следующей строке.

```c
#include <stdio.h>

int main()
{
    int a, b;
    scanf("%d %d", &a, &b);
    
    printf("%d %d\n", a, b);
    printf("%d", a > b ? b: a);

    return 0;
}
```

### Сколько столов

![06](/C_for_beginners_Stepik/Pictures/06_07.png)

Из 4 ножек и 1 столешницы делают 1 стол.

Сколько столов можно сделать из N ножек и K столешниц?

![06](/C_for_beginners_Stepik/Pictures/06_08.png)

Даны числа N K на 1 строке через пробел.

Напечатать сколько из них можно сделать столов.

У кого в ответе будет 3.5 стола, будет сам сидеть за половиной стола в классе.

```c
#include <stdio.h>

int main()
{
    int a, b, res;
    scanf("%d %d", &a, &b);
    
    res = a / 4;

    printf("%d", res < b ? res : b);
    return 0;
}
```

### футбол-1
Матч Shan United - Yadanarbon окончился со счетом a:b.

Команда Shan United получает:

+ 2 очка, если победила (a > b)
+ 1 очко, если ничья (a = b)
+ 0 очков, если проиграла (a < b)

Дан счет матча. Напечатать счет матча и на следующей строке сколько очков получила команда Shan United.

```c
#include <stdio.h>

int main()
{
    int a, b, res = 0;
    scanf("%d : %d", &a, &b);
    
    res = 2 * (a > b) + (a == b);

    printf("%d:%d\n%d",a, b, res);
    return 0;
}
```

### футбол-2
1 период матча Shan United - Yadanarbon окончился со счетом a1:b1, второй со счетом a2:b2.

Голы за два периода складываются, получаются голы за весь матч. По счету матча определяется победитель.

Команда получает:
+ 2 очка, если победила (a > b)
+ 1 очко, если ничья (a = b)
+ 0 очков, если проиграла (a < b)

Дан счет первого и второго периодов.

Напечатать счет матча и на следующей строке сколько очков получила команда Shan United.

```c
#include <stdio.h>

int main() {
    int a1, b1, a2, b2, a, b, res = 0;
    scanf("%d : %d", &a1, &b1);
    scanf("%d : %d", &a2, &b2);
    
    a = a1 + a2;
    b = b1 + b2;
    res = 2 * (a > b) + (a == b);

    printf("%d:%d\n%d",a, b, res);
    return 0;
}
```

### if_m_log5 Сколько километров бежит участник соревнований?
На соревнованиях по бегу такие правила:
+ мальчики до 10 лет не участвуют в соревнованиях (бегут 0 км);
+ мальчики с 10 до 12 лет (включительно) бегут 3 км;
+ мальчики с 13 до 15 лет (включительно) бегут 5 км;
+ остальные участники бегут 10 км.
Участнику соревнований z лет.

Написать программу, которая печатает сколько км побежит участник.

```c
#include <stdio.h>

int main() {
    int z, res = 0;
    scanf("%d", &z);
    
    res = 3 * (z > 10) + 2 * (z >= 13) + 5 * (z > 15);

    printf("%d", res);
    return 0;
}
```

### if_rect Принадлежит ли точка области?
По данным x и y координатам точки напечатайте - принадлежит точка к указанной области (включая границы) или нет.

Если принадлежит, напечатайте YES, иначе напечатайте NO.

![06](/C_for_beginners_Stepik/Pictures/06_09.PNG)

```c
#include <stdio.h>

int main() {
    int res;
    float x, y;
    scanf("%f %f", &x, &y);
    
    res = ((-3 <= x && x <= 2) && (-4 <= y && y <= 6));

    printf("%s", res ? "YES" : "NO");
    return 0;
}
```

## `if` - обязательные задачи

### if_A Принадлежит ли точка области?
По данным x и y координатам точки напечатайте - принадлежит точка к указанной области (включая границы) или нет.

Если принадлежит, напечатайте YES, иначе напечатайте NO.

![05](/C_for_beginners_Stepik/Pictures/06_10.PNG)

```c
#include <stdio.h>

int main() {
    int res;
    float x, y;
    scanf("%f %f", &x, &y);
    
    res = ((y <= x + 3) && (y <= 3 - x) && (-2 <= y));

    printf("%s", res ? "YES" : "NO");
    return 0;
}
```

### if_7 Ладья

![06](/C_for_beginners_Stepik/Pictures/06_11.jpg)

В шахматах ладья (rook) ходит только по горизонтали или вертикали.

Координаты клетки записываются как буква столбца и номер строки. Например, g7 место белой ладьи.

Ход записывается как координаты откуда тире координаты куда. Ход черной ладьи будет записан как a4-f4.

Дан ход. Напечатайте ход и может ли ладья так ходить (YES) или нет (NO).

```c
#include <stdio.h>

int main() {
    int a, b, res;
    char x, y;
    scanf("%1c%1d-%1c%1d", &x, &a, &y, &b);
    
    res = (x == y) || (a == b);
    
    printf("%c%d-%c%d\n", x, a, y, b);
    printf("%s", res ? "YES" : "NO");
    return 0;
}
```

### sort2 2 числа по возрастанию
Напишите функцию, которая сортирует 2 числа по возрастанию.

```c
void sort2(int * a, int * b);
```

В проверяющую систему посылать только реализацию функции

Использование:

```c
#include <stdio.h>

void sort2(int * a, int * b);

int main()
{
    int x, y;
    scanf("%d%d", &x, &y);
    sort2(&x, &y);
    printf("%d %d\n", x, y);
    return 0;
}
```

```c
void sort2(int * a, int * b) {
    if (*a > *b) {
        int tmp = *a;
        *a = *b;
        *b = tmp;
    }
}
```

### sort3
Есть функция sort2 (скопируйте с предыдущей задачи).

Напишите функцию void `sort3(int * x, int * y, int * z)`, которая сортирует 3 числа по возрастанию.

Посылать только реализацию функций sort2 и sort3.

```c
#include <stdio.h>

void sort2(int * a, int * b);
void sort3(int * x, int * y, int * z);

int main()
{
    int x, y, z;
    scanf("%d%d%d", &x, &y, &z);
    sort3(&x, &y, &z);
    printf("%d %d %d\n", x, y, z);
    return 0;
}
```

```c
void sort2(int * a, int * b) {
    if (*a > *b) {
        int tmp = *a;
        *a = *b;
        *b = tmp;
    }
}
void sort3(int * x, int * y, int * z) {
    sort2(x, y);
    sort2(y, z);
    sort2(x, y);
}
```

### Холодильник и дверь
Нужно пронести холодильник в дверь. Размер двери w h сантиметров, размер холодильника a, b, c сантиметров.

Холодильник можно поворачивать и класть на бок.

Даны размеры двери через пробел на одной строке и размеры холодильника через пробел на другой строке.

Напечатайте YES, если холодильник можно пронести в дверь. Иначе напечатайте NO.

Читаем, что если ширина двери 60, то холодильник шириной 60 в него пройдет (если пройдет по высоте).

В дверь 80х180 холодильник 60х90х200 пройдет (YES). Надо развернуть так, чтобы в 80х180 проходило 60х90.

В дверь 80х180 холодильник 60х190х200 не пройдет (NO). Никак не повернуть, чтобы в 80х180 проходило 60х190.

```c
#include <stdio.h>

void sort2(int * a, int * b) {
    if (*a > *b) {
        int tmp = *a;
        *a = *b;
        *b = tmp;
    }
}
void sort3(int * x, int * y, int * z) {
    sort2(x, y);
    sort2(y, z);
    sort2(x, y);
}

int main() {
    int w, h, a, b, c, res;
    scanf("%d %d %d %d %d", &w, &h, &a, &b, &c);
    
    sort2(&w, &h);
    sort3(&a, &b, &c);
        
    res = (w >= a) && (h >= b);

    printf("%s", res ? "YES" : "NO");
    return 0;
}
```

### Тип треугольника
Даны стороны треугольника - целые числа.

Напишите функцию `triangle_len_type(a, b, c)`, где a, b, c - стороны треугольника.

Функция должна вернуть:
+ 2 - если треугольник равносторонний (все стороны одинаковой длины)
+ 1 - если треугольник равнобедренный (2 стороны одинаковые, третья другая)
+ 0 - все стороны разные
+ -1 - такой треугольник не может быть.

![06](/C_for_beginners_Stepik/Pictures/06_12.jpg)

```c
#include <stdio.h>

int triangle_len_type(a, b, c) {
    int res = 0;
    if ((c > a + b) || (a > c + b) || (b > a + c)) {
        res = -1;
    } else if ((a == b) && (b == c)) {
        res = 2;
    } else if ((a == b) || (b == c) || (a == c)) {
        res = 1;
    } 
    return res;
}
        
int main() {
    int a, b, c;
    scanf("%d%d%d", &a, &b, &c);  // в форматной строке лучше не ставить пробелы
    printf("%d", triangle_len_type(a, b, c));

    return 0;
}
```

### Делится на 3 или 5, но не на 15
Напишите программу, которая печатает YES, если число делится на 3 или 5, но не делится на 15. Иначе напечатайте NO.

Число | Напечатать | Почему
-|-|-
6 | YES | делится на 3
10 | YES | делится на 5
150 | NO | делится на 15
4 | NO | не делится ни на 3, ни на 5

```c
#include <stdio.h>

int main() {
    int a, res = 0;
    scanf("%d", &a);
    
    res = ((a % 3 == 0) || (a % 5 == 0)) * (a % 15);
    
    printf("%s", res ? "YES": "NO");

    return 0;
}
```

### struct_51 Наибольший по площади прямоугольник
Дана структура, описывающая прямоугольник со сторонами, параллельными осям координат. Реализуйте функцию, max, возвращающую больший по площади прямоугольник. Если два прямоугольника имеют равные площади, возвратите любой из них.

```c
struct Rect * max(struct Rect * pa, struct Rect * pb);
```

Структуры уже определены в программе:

```c
struct Point {
    int x;
    int y;
};
struct Rect {
    struct Point lt; // левая верхняя вершина
    struct Point rb; // правая нижняя вершина
};
```

Объявление структур и функцию main посылать НЕ нужно.

```c
struct Rect * max(struct Rect * pa, struct Rect * pb) {
    int s1, s2;
    
    s1 = (pa->lt.y - pa->rb.y) * (pa->rb.x - pa->lt.x);
    s2 = (pb->lt.y - pb->rb.y) * (pb->rb.x - pb->lt.x);
    
    if (s1 > s2) return pa;
    else return pb;
}
```

Функция area существенно упрощает код.<br>
Возвращаем указатель на больший прямоугольник.

```c
int area (struct Rect * p)
{
	return (p->lt.y - p->rb.y)*(p->rb.x - p->lt.x); 
}

struct Rect * max(struct Rect * pa, struct Rect * pb)
{
    int a = area(pa);
    int b = area(pb);
    return (a > b) ? pa : pb;
}
```

```c
int areaRect (struct Rect z){
    int h, w;
    h = abs(z.lt.x - z.rb.x);
    w = abs(z.lt.y - z.rb.y);
    return h * w;
}

struct Rect * max(struct Rect * pa, struct Rect * pb){
    if(areaRect(*pa) >= areaRect(*pb))
        return pa;
    else
        return pb;
}
```

### struct_4 Пересекаются ли прямоугольники?
Дана структура, описывающая прямоугольник со сторонами, параллельными осям координат. Реализуйте функцию, `is_crossed`, которая возвращает возвращающую 1, если два прямоугольника пересекаются и 0 в противном случае.

Если у двух прямоугольников общая хотя бы одна точка, эти прямоугольники пересекаются.

```c
int is_crossed(struct Rect a, struct Rect b);
```

Структуры уже определены в программе:

```c
struct Point {
    int x;
    int y;
};
struct Rect {
    struct Point lt; // левая верхняя вершина
    struct Point rb; // правая нижняя вершина
};
```

Объявление структур и функцию main посылать НЕ нужно.

```c
int min (int a, int b) {
    return a > b ? b : a;
}
int max (int a, int b) {
    return a > b ? a : b;
}
int is_crossed(struct Rect a, struct Rect b) {
    int left, top, right, bottom;
    //найдем возможные точки пересечения
    left = max(a.lt.x, b.lt.x);
    top = min(a.lt.y, b.lt.y);
    right = min(a.rb.x, b.rb.x);
    bottom = max(a.rb.y, b.rb.y);
    
    return ((right - left >= 0) && (top - bottom >= 0));
}
```

Проще написать когда прямоугольники НЕ пересекаются.

```c
int is_crossed(struct Rect a, struct Rect b) {
    if (a.lt.y < b.rb.y ||    // a ниже b
        b.lt.y < a.rb.y ||    // b ниже a
        a.lt.x > b.rb.x ||    // a правее b
        b.lt.x > a.rb.x)      // b правее a
        return 0;
    return 1;
}
```

### rect_intersect Пересечение прямоугольников
Дана структура, описывающая прямоугольник со сторонами, параллельными осям координат.

Реализуйте функцию, `intersection`, которая возвращает координаты точек прямоугольника, образованного в результате пересечения двух прямоугольников, которые гарантированно имеют хотя бы одну общую точку.

```c
struct Rect intersection(struct Rect a, struct Rect b);
```

Структуры уже определены в программе:

```c
struct Point {
    int x;
    int y;
};
struct Rect {
    struct Point lt; // левая верхняя вершина
    struct Point rb; // правая нижняя вершина
};
```

Объявление структур и функцию main посылать НЕ нужно.

Использование этой функции будет таким:

```c
if (is_crossed(a, b))
    res = intersection(a, b);
```

Функция ничего не должна печатать.

В тестах в выходных данных координаты трех прямоугольников - двух исходных и образованного в результате их пересечения.

```c
int min (int a, int b) {
    return a > b ? b : a;
}
int max (int a, int b) {
    return a > b ? a : b;
}
struct Rect intersection(struct Rect a, struct Rect b) {
    struct Rect res;

    res.lt.x = max(a.lt.x, b.lt.x);
    res.lt.y = min(a.lt.y, b.lt.y);
    res.rb.x = min(a.rb.x, b.rb.x);
    res.rb.y = max(a.rb.y, b.rb.y);
    
    return res;
}
```

### struct_seasons Времена года
Дата описывается структурой:

```c
typedef struct
{
    int yy; // год
    char mm; // месяц
    char dd; // день
}Data;
```

+ Зима начинается с 1 декабря и длится до последнего дня февраля,
+ весна начинается с 1 марта и длится до последнего дня (31) мая,
+ лето начинается с 1 июня и длится до 31 августа,
+ осень начинается с 1 сентября и длится до 30 ноября

Времена года описываются структурой

```c
typedef struct
{
    int yy; // год
    char season; // время года (зима - 0, весна - 1, лето - 2, осень - 3)
    int day; // день от начала текущего времени года
}Season;
```

YYYY-MM-DD | Формат сезонов | Комментарии
-|-|-
0010-12-03 | 0010-00-03 | Третий день зимы
0010-01-03 | 0010-00-34 | Третий день второго месяца зимы
0010-03-03 | 0010-01-03 | Третий день весны

Требуется написать следующие функции:

```c
// получает параметры даты с консоли (три целых числа через тире:
// YYYY-MM-DD)
// Например, 2020-12-13
Data getData();

// Печатает дату в формате: YYYY-MM-DD завершая переносом строки (\n)
void printData(Data);

// конвертирует дату в формат Season и возвращает это значение
// зима с 1 декабря по конец февраля, весна - с 1 марта по 31 мая, лето - с 1 июня по 31 августа,
// осень - с 1 сентября по 30 ноября
Season convToSeas(Data);

//  печать времени года в формате: YYYY-SS-DD (SS - номер времени года,
// DD - день от начала времени года, завершая переносом строки
void printSeas(Season);
```

Проверяющей системе отправлять только функции.

Функции проверяются так:

```c
int main()
{
    Data dat;
    Season seas;
    dat = getData();
    printData(dat);
    seas = convToSeas(dat);
    printSeas(seas);

    return 0;
}
```

```c
#include <stdio.h>

typedef struct {
    int yy;   // год
    char mm;  // месяц
    char dd;  // день
} Data;

typedef struct {
    int yy;       // год
    char season;  // время года (зима - 0, весна - 1, лето - 2, осень - 3)
    int day;      // день от начала текущего времени года
} Season;

Data getData() {
    Data input;
    printf("getData()");
    int m, d;
    scanf("%d-%d-%d", &input.yy, &m, &d);
    input.mm = m;
    input.dd = d;
    return input;
}
void printData(Data Data) {
    printf("printData()");
    printf("%04d-%02d-%02d\n", Data.yy, (int)Data.mm, (int)Data.dd);
}
Season convToSeas(Data Data) {
    printf("convToSeas(Data Data)");
    Season res;
    res.yy = Data.yy;
    switch (Data.mm) {
        case 12:  // зима
            res.day = Data.dd;
            res.season = 0;
            break;
        case 1:
            res.day = Data.dd + 31;
            res.season = 0;
            break;
        case 2:
            res.day = Data.dd + 62;
            res.season = 0;
            break;
        case 3:  // весна
            res.day = Data.dd;
            res.season = 1;
            break;
        case 4:
            res.day = Data.dd + 31;
            res.season = 1;
            break;
        case 5:
            res.day = Data.dd + 61;
            res.season = 1;
            break;
        case 6:  // лето
            res.day = Data.dd;
            res.season = 2;
            break;
        case 7:
            res.day = Data.dd + 30;
            res.season = 2;
            break;
        case 8:
            res.day = Data.dd + 61;
            res.season = 2;
            break;
        case 9:  // осень
            res.day = Data.dd;
            res.season = 3;
            break;
        case 10:
            res.day = Data.dd + 30;
            res.season = 3;
            break;
        case 11:
            res.day = Data.dd + 61;
            res.season = 3;
            break;
    }
    return res;
}

void printSeas(Season season) {
    printf("printSeas(Season season)");
    printf("%04d-%02d-%02d\n", season.yy, (int)season.season, (int)season.day);
}

int main() {
    Data dat;
    Season seas;
    dat = getData();
    printData(dat);
    seas = convToSeas(dat);
    printSeas(seas);

    return 0;
}
```

## `if` - задачи на "подумать"

### Зачем эти задачи
Программирование - это не только кодирование по техническому заданию от и до.

Программирование - это еще и умение логически мыслить и решать нестандартные задачи.

Если вы вольный слушатель курса, и вас интересует только синтаксис языка, можете пропустить эти головоломки для начальной школы.

Остальные могут подумать на досуге и найти очень простое решение для каждой задачи. Надеемся, они вам понравятся.

Рекомендуем не упираться рогом в эти задачи, а прочитать условие, подумать на досуге и воскликнув "Эврика" написать решение. Вполне нормально в это время решать темы дальше. Эти задачи - как сладкое к чаю. Можно оставить на десерт, а не набрасываться сразу с большой ложкой.

Особая благодарность Овсянниковой Татьяне Владимировне за эти задачи.

### Zif_11palochek 11 палочек
Два человека играют в игру.

На столе лежит n палочек. Ходят по очереди. За один ход каждый может взять от 1 до 3 палочек. Пропускать ход нельзя.

Проигрывает тот, кто берет со стола последнюю палочку.

Написать программу, которая вычисляет сколько палочек k нужно взять игроку, делающему первый ход, чтобы выиграть, если это возможно. Ваш противник в игре ошибок не делает.

__Использовать циклы и рекурсию в этой задаче нельзя!!__

Входные данные: одно целое положительное число $0<n<1000000$

Выходные данные: k. Eсли возможно сделать непроигрышный ход, то одно целое число $1 ≤ k ≤ 3$, если невозможно сделать такой ход , то печатает -1