# Условные и логические операторы

[Видео](https://youtu.be/I-w0zPQLaYk)

## `if` и `else`

### Зачем нужны условные операторы
Решим задачу.

Через реку можно переплыть на лодке, которая вмещает K пассажиров. На берегу стоит N человек и хочет переправиться на другой берег. Сколько нужно сделать рейсов, чтобы переправить на другой берег всех людей? 1 рейс - это когда лодка плавает туда и обратно.

Чтобы решить задачу, можно придумать математическую формулу.

Придумайте формулу. Проверьте для разных значений N и К

Проще писать программу так, как думает обычный человек (не математик) :
+ вычислим количество рейсов лодки, когда она полная
+ если на берегу кто-то остался,
+ то добавим +1 рейс

```c
#include <stdio.h>


int main()
{
    int n,                 // пассажиров на берегу
        k,                 // пассажиров за один рейс может перевезти лодка
        reisov,            // количество рейсов
        ostalos;           // пассажиров в неполной лодке


    scanf("%d%d", &n, &k); // читаем n и k


    reisov = n / k;        // количество рейсов, когда лодка полная
    ostalos = n % k;       // сколько человек осталось после этого на берегу


    if (ostalos > 0) {     // если на берегу остались люди
        reisov += 1;       // добавить еще 1 рейс с неполной лодкой
        printf("Нужен дополнительный рейс\n");
    }


    printf ("%d\n", reisov); // напечатать количество рейсов
    return 0;
}
```

Как писать условный оператор if:

```c
if (условие)
    оператор   // выполняется только когда условие истинно
```

Если условие истинно, то выполняется оператор. Если ложно, то оператор не выполняется.

#### Что есть истина?

В языке С ложь (false) - это 0. Все остальное - истина (true).

__Части if__
+ if - ключевое слово.
+ условие пишем в круглых скобках ( )
+ команды пишем с отступом относительно ключевого слова if;
+ отступ в 1 табуляцию для каждого дополнительного уровня вложенности;
+ отступ одинаковый для одинакового уровня вложенности;
+ если нужно написать несколько оператор , то объединяем их в один блочный оператор, то есть пишем все операторы внутри фигурных скобок { и }
+ единственный оператор можно написать без { }, а можно поставить вокруг него { }
+ первое время пишите { } всегда, это поможет избежать ошибок, когда вы добавляете к операторам еще код, например, отладочную печать.
+ закрывающую фигурную скобку пишите под if (на прежнем уровне отступов)

### Сравнения в языке С

Математики пишут вместо слов "больше" и "меньше" специальные символы > и <.

Но на клавиатуре нет символа ≥. Его программисты пишут как >= ("больше или равно" - знак "больше" стоит перед знаком "равно", между этими знаками нельзя ставить пробел).

Как проверить, что х равно 2, если = - это оператор "присвоить"? Написать ==. Мы чаще присваиваем, чем проверяем равно или нет, поэтому "присвоить" - это один знак =, а "сравнить на равенство" - это 2 знака = подряд.

Знака ≠ тоже нет на клавиатуре. Его пишем как != ("отрицание равно").

В математике | В языке С | По-русски
-|-|-
`>` | > | больше
`≥` | >= | больше или равно
`<` | < | меньше
`≤` | <= | меньше или равно
`=` | == | равно
`≠` | != | не равно

### Блочный оператор
Нужно писать { } в операторе if или нет?

По определению после выражения в ( ) идет 1 оператор. Следующий оператор уже не относится к if.

```c
if (условие)
    оператор   // выполняется только когда условие истинно
```

Тогда в задаче если мы напишем в if отладочную печать, то она будет работать неправильно.

```c
#include <stdio.h>


int main()
{
    int n,                  // пассажиров на берегу
        k;                  // пассажиров за один рейс может перевезти лодка


    scanf("%d%d", &n, &k);  // читаем n и k


    int reisov = n / k;     // количество рейсов, когда лодка полная


    if (n %k > 0)           // если на берегу остались люди
        reisov += 1;        // добавить еще 1 рейс с неполной лодкой
        printf("Нужен дополнительный рейс\n");      // Ошибка! Печатается всегда!


    printf ("%d\n", reisov); // напечатать количество рейсов
    return 0;
}
```

Номер теста | Input | Output | Это правильно?
-|-|-|-
1 | 11 5 | Нужен дополнительный рейс 3 | Правильно
2 | 10 5 | Нужен дополнительный рейс 2 | Ответ правильный, отладочная печать неправильная

Заметим, что хотя мы поставили отступы так, что "Нужен дополнительный рейс" внутри if, на самом деле printf написан после условного оператора и поэтому печатается при любых значениях n и k.

Как сделать так, чтобы в if можно было написать много операторов? Объединить их в один блочный оператор.

Блочный оператор (один) - это операторы (один или много), написанные внутри { }.

```c
#include <stdio.h>


int main()
{
    int n,                  // пассажиров на берегу
        k;                  // пассажиров за один рейс может перевезти лодка


    scanf("%d%d", &n, &k);  // читаем n и k


    int reisov = n / k;     // количество рейсов, когда лодка полная


    if (n %k > 0) {         // если на берегу остались люди
        reisov += 1;        // добавить еще 1 рейс с неполной лодкой
        printf("Нужен дополнительный рейс\n");
    }
    printf ("%d\n", reisov); // напечатать количество рейсов
    return 0;
}
```

Номер теста | Input | Output | Это правильно?
-|-|-|-
1 | 11 5 | Нужен дополнительный рейс 3 | Правильно
2 | 10 5 | 2 | Правильно

### Использование в математике
Вычислим модуль числа, хранящийся в переменной x:

```c
if (x < 0)
    x = -x;

```

Так как оператор один, { } можно не ставить.
Отступ в 1 табуляцию показывает что код - внутри условного оператора.

__Что напечатает код?__<br>
Что напечатает эта часть кода (внутри main)

```c
int x = 8;
if (x > 4)
    printf("4");
if (x < 7)
    printf("7");
if (x == 8)
    printf("8");
```

```c
48
```

__Что напечатает код?__<br>
Что напечатает эта часть кода (внутри main)

```c
int x = 8;
if (x > 4) {
    printf("4");
    if (x > 9) {
        printf("9");
        if (x == 8) {
            printf("8");
        }
    }
}
```

```c
4
```

### `if` .. `else`
Иногда просто if не хватает. ЕСЛИ число x делится на 2 без остатка, то оно четное, ИНАЧЕ оно нечетное. Запишем эту мысль на языке С:

```c
if (x % 2 == 0)
    printf("четное\n");
else
    printf("нечетное\n");
```

Когда один и тот же признак (четность) может иметь 2 варианта (четное или нечетное), то пишем if .. else:

```c
if (условие)
    оператор_ДА
else
    оператор_НЕТ
```

Если условие - истина, то выполняется оператор_ДА, иначе (условие ложно) выполняется оператор_НЕТ.

### Что может пойти не так?
Попробуем написать код определения четности и нечетности числа по-другому. Попробуйте найти ошибку в этом коде. Сначала экспериментально, а потом выяснив, почему код работает именно так.

Напишите и заполните для этого таблицу с тестами.

```c
if (x % 2 == 1)
    printf("нечетное\n");
else
    printf("четное\n");
```

Напишем программу полностью и будем запускать ее для разных значений х. Результаты напишем в таблицу тестирования, куда занесем значения x, x/2 и x%2:

Тест | x | x/2 | x%2 | output | правильно?
-|-|-|-|-|-
1 | 8 | 4 | 0 | четное | да
2 | -8 | -4 | 0 | четное | да
3 | 7 | 3 | 1 | нечетное | да
4 | -7 | -3 | -1 | четное | НЕТ

Вывод: лучше переводите с русского на С почти дословно: "если число делится нацело на 2, то оно четное, иначе нечетное".

Найдите ошибки в этом коде (напишите и заполните таблицу тестирования):

```c
if (x % 2 == 0)
    printf("четное\n");
if (x % 2 == 1)
    printf("нечетное\n");
```

Так писать не надо. Это очень плохой код.

Если у вас признак или есть или нет, используйте if .. else.

Как вы думаете, в каком случае из этих двух ошибки проще найти и проще исправить?

### Множественный выбор
Напишем программу, которая определяет положительное число или отрицательное. Не забудем, что 0 - это ни положительное, ни отрицательное:

```c
if (x == 0) {
    printf("zero\n");
} else {
                        // блочный оператор может содержать любые операторы.
                        // Например if .. else
    if (x < 0) {
        printf("negative\n");
    } else {
        printf("positive\n");
    }
}
```

Читать такой код неудобно. И если у нас не 3 варианта, а больше, то отступов становится больше и код выходит за границы экрана.

В программировании на С есть такое правило: если вы поставили 4 отступа, скорее всего вы неправильно написали алгоритм.

Что делать? В случае, когда один и тот же признак имеет разные значения, принято ставить отступы по-другому:

```c
if (x == 0) {
    printf("zero\n");
} else if (x < 0) {
    printf("negative\n");
} else {
    printf("positive\n");
}
```

Операторы остались теми же. Изменились только отступы (на которые компилятор не обращает внимание).

То есть с точки зрения компилятора код не изменился.

В С нет никакого "оператора else if". Есть только рекомендaции по расстановке отступов в операторах if .. else.

### Порядок имеет значение
Что напечатает эта часть кода (в main)?


```c
int x = 7;


if (x >= 8)
    printf("отлично");
else if (x >= 3)
    printf("удовлетворительно");
else if (x >= 5)
    printf("хорошо");
else
    printf("неудовлетворительно");
```

```c
удовлетворительно
```

### Разные признаки
Если признаки разные (четность и знак числа), то их стоит писать в разных блоках if..else.

```c
// проверка четности
if (x % 2 == 0)
    printf("четное\n");
else
    printf("нечетное\n");


// проверка знака числа
if (x == 0) {
    printf("zero\n");
} else if (x < 0) {
    printf("negative\n");
} else {
    printf("positive\n");
}
```

## Логические операторы

