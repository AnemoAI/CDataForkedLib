# Работа с битами

## Системы счисления

### Что изучаем
В этом разделе мы рассмотрим
+ как вообще можно записывать числа;
+ как представляются в компьютере целые числа, положительные и отрицательные;
+ сравним их с числами с плавающей точкой и поймем, почему 4.0/2.0 в компьютере может привести к 1.99999999999;
+ изучим операторы языка Си, которые работают с битами, это поможет нам компактнее хранить информацию.
+ немного поговорим об архитектуре компьютеров и перейдем к следующему курсу - написанию шаг за шагом и отладке большой программы [эмулятора компьютера PDP-11](https://stepik.org/course/65259)

[VIDEO](https://youtu.be/4iDpVe7gU04)

### Системы счисления. Начало

![18](/C_for_beginners_Stepik/Pictures/19_06.PNG)

Для записи чисел используются системы счисления. Это набор знаков и правила как их писать и читать (правила интерпретации).

Например, в рассказе о Шерлоке Холмсе "Плящущие человечки" была своя система записи чисел:

![18](/C_for_beginners_Stepik/Pictures/19_01.png)

Системы делятся на позиционные и непозиционные. В позиционных один и тот же знак означает разное число в зависимости от того, где он написан. Например, десятичная система. В числах `123` и `312` одинаковые знаки, но обозначают они разные суммы.

Римская система счисления - непозиционная.

### Римская система
Римские цифры обозначают сразу числа.

Римская цифра | Число
-|-
I | 1
V | 5
X | 10
L | 50
C | 100
D | 500
M | 1000

Их легко запомнить по фразе $М$ы $Д$арим $С$очные $Л$имоны, $Х$ватит $В$сем $И$ еще останется.


`MDCLXVI`

Как записать другие числа?
+ Повторяем числа. XXX - это число 30.
+ Складываем числа, если меньшее стоит за большим. VI - это 6.
+ Вычитаем числа, если меньшее стоит перед большим. IX - это 9.

`XXVII = 10 + 10 + 5 + 1 + 1 = 27`

`CXIX = 100 + 10 - 1 + 10 = 119`

Попробуйте сложить столбиком или вычесть в такой системе. Это неудобно. Еще неудобнее умножать и делить.

## `bin`, `oct`, `hex`

### Позиционные системы счисления

![18](/C_for_beginners_Stepik/Pictures/19_07.PNG)

Записывается цифрами. Что значит цифра зависит от ее места. Числа 123 и 321 - разные.

В десятичной системе счисления цифрами записывают коэффициенты степени числа 10.

$615=6 \cdot 10^2 + 1 \cdot 10^1 +5 \cdot 10^0$

Пусть у нас есть 3 клеточки, в каждой клеточке мы можем написать цифру. Какое самое большое число можно написать в этих клеточках?

Число 999. Для записи большего числа нужно больше клеточек.

Аналогично можно записать число в двоичной системе. Тогда цифры 0 и 1 - это коэффициенты степеней числа 2.

$1101_2 =1⋅2^3 +1⋅2^2 +0⋅2^1 +1⋅2^0 =1⋅8+1⋅4+0⋅2+1⋅1=13_{10}$

​Какое самое большое бинарное число можно записать в 3 клетках? 

$111_2 =7_{10}$. Больше записать нельзя. Возникнет переполнение (нет места для записи части числа).

В компьютерах чаще всего используется бинарная система счисления для хранения данных.

![18](/C_for_beginners_Stepik/Pictures/19_08.PNG)

### Разложение числа

![18](/C_for_beginners_Stepik/Pictures/19_09.PNG)

Чтобы быстро представлять чему равно 13 в бинарном виде, поймем, как мы разбираем по степеням 10 десятичные числа. Разберем число 147.

+ x = 147
+ пока x не 0
    + k = x % 10, последняя цифра
    + x = x / 10, оставшееся число без полученной цифры

```c
int x = 147;
while(x > 0) {
    printf("%d ", x % 10);
    x = x / 10;
    printf("x=%d\n", x);
}
```

напечатает

```
7 x=14
4 x=1
1 x=0
```

Получаем из коэффициентов при степенях 10 обратно число по формуле 
`x = x * 10 + k`

```c
char a[] = [1, 4, 7];
int x = 0;
for (int i = 0; i < 3; i++) {
    x = x * 10 + a[i];
    printf("a[%d]=%d x=%d\n", i, a[i], x);
}
```

напечатает

```
a[0]=1 x=1
a[1]=4 x=14
a[2]=7 x=147
```

__Этот принцип разборки и сборки числа работает для любой позиционной системы счисления.__ Если заменить 10 на основание этой системы (2 для бинарной, 8 для восьмеричной, 16 для шестнадцатеричной и так далее).

### Печать числа в бинарном виде
Дано число, которое поместится в `unsigned char`. Напечатайте его в бинарном виде шириной 8 символов с лидирующими нулями. Далее печатайте символ `end`, если он не 0.

Напишите для этого функцию `void print_bin(unsigned char x, char end);`

Посылать в проверяющую систему всю программу, вместе с функцией `main`.

```c
void print_bin(unsigned char x);

int main() {
    unsigned char x;
    scanf("%hhu", &x);      // hh используеся для указания, что работа с char

    print_bin(x, '\n');     // напечатать х и в конце напечатать \n

    return 0;
}
```

```c
#include <stdio.h>

void print_bin(int x) {
    int result = 0, n = 1;
    while (x > 0) {
        result += (x % 2) * n;
        x /= 2;
        n *= 10;
    }
    printf("%08d", result);
}

int main() {
    int x;
    scanf("%d", &x);  // hh используеся для указания, что работа с char

    print_bin(x);  // напечатать х и в конце напечатать \n

    return 0;
}
```

Для курсовой работы вы можете написать другие функции, которые печатают байт в бинарном виде:
+ `void print_bin(char * dst, unsigned char x);` // преобразование из числа х в строку dst 
+ `char * print_bin(unsigned char x);` // то же, но с выделением памяти

Но нам кажется, что при максимуме пользы породит минимум ошибок при использовании такая тупенькая функция как 
`void print_bin(unsigned char x, char end);`

```c
#include <stdio.h>

#define BYTESIZE 8        // считаем, что в байте 8 бит

void print_bin(unsigned char x, char end);

int main() {
    char x;
    scanf("%hhu", &x);      // hh используеся для указания, что работа с char
    
    print_bin(x, '\n');
    
    return 0;
}

void print_bin(unsigned char x, char end) {
    char a[BYTESIZE+1] = {};
    
    for(int i = BYTESIZE-1; x > 0 && i >= 0; i--) {
        a[i] = x % 2;
        x = x / 2;
    }
    for(int i = 0; i < BYTESIZE; i++)
        printf("%d", a[i]);
    if (end)
        printf("%c", end);
}
```

```c
#include <stdio.h>

void print_bin(unsigned char x, char end){
    unsigned char key = 0x80;
    do {
        printf((x & key) ? "1" : "0");
        key >>= 1;
    } while (key != 0);
    printf("%c", end);
}

int main() {
    unsigned char x;
    scanf("%hhu", &x);      // hh используеся для указания, что работа с char
    print_bin(x, '\n');     // напечатать х и в конце напечатать \n
    return 0;
}
```

```c
#include <stdio.h>
int main() { 
    for (int r=0,n,i=(scanf("%d",&n),8); n || (printf("%08d",r),0); r+=(n%2)*pow(10,8-i), n/=2, i--);
    return 0;
}
```

### Восьмеричная, шестнадцатеричная, двоично-десятичная и 36-ричная системы счисления

![18](/C_for_beginners_Stepik/Pictures/19_09.PNG)

Заметим, что в десятичной системе счисления цифры от 0 до 9 и нет цифры 10. 9+1=10

В __двоичной (бинарной)__ нет цифры 2. 1+1=10

Так же в __восьмеричной__ нет цифры 8. 7+1=10

В __шестнадцатеричной__ цифры обозначают числа от 0 до 15 (цифры "шестнадцать" нет). Для обозначения чисел 10, 11, 12, 13, 14, 15 используют латинские буквы a, b, c, d, e, f (маленькие или большие).

В __двоично-десятичной__ системе (коде) десятичные цифры 0..9 кодируются бинарной записью. Для записи числа 9 нужно 4 бинарных цифры 1001. Значит для записи всех остальных десятичных цифр будем использовать тоже 4 двоичных цифры.

Так десятичные числа от 0 до 15 представляются в других системах счисления.

Десятичная | Двоичная | Восьмеричная | Шестнадцатеричная | Двоично-десятичная
-|-|-|-|-
0 | 0000 | 0 | 0 | 0000
1 | 0001 | 1 | 1 | 0001
2 | 0010 | 2 | 2 | 0010
3 | 0011 | 3 | 3 | 0011
4 | 0100 | 4 | 4 | 0100
5 | 0101 | 5 | 5 | 0101
6 | 0110 | 6 | 6 | 0110
7 | 0111 | 7 | 7 | 0111
8 | 1000 | 10 | 8 | 1000
9 | 1001 | 11 | 9 | 1001
10 | 1010 | 12 | A | 0001 0000
11 | 1011 | 13 | B | 0001 0001
12 | 1100 | 14 | C | 0001 0010
13 | 1101 | 15 | D | 0001 0011
14 | 1110 | 16 | E | 0001 0100
15 | 1111 | 17 | F | 0001 0101

Когда вы вводите код активации программного обеспечения вида `A376BZZ5`, вы на самом деле вводите 36-ричное число. У него цифры - это арабские цифры от 0 до 9 и латинские буквы от A до Z.

### Из восьмеричной в десятичную
Какому числу в десятичной системе равно число число 20 в восьмеричной системе?

$20_8 =?_{10}$

$16$​

### Из десятичной в восьмеричную
Какому числу в восьмеричной системе равно число число 39 в десятичной системе?

$?_8 =39_{10}$

$47$​

### Из шестнадцатеричной в десятичную
Какому числу в десятичной системе равно число число 1A в шестнадцатеричной системе?

$1A_{16} =?_{10}$

$26$

### Из десятичной в шестнадцатеричную
Какому числу в шестнадцатеричной системе равно число число 45 в десятичной системе?

$?_{16} = 45_{10}$
​ 
Цифры пишите в верхнем регистре, то есть FF.

$2D$

### Из восьмеричной в бинарную
Напишите восьмеричное число 215 в бинарном виде.

Обратите внимание, что каждая восьмеричная цифра - это бинарное число из 3 цифр.

$10001101$

### Из бинарной в восьмеричную
Напишите бинарное число $11010100_2$ в восьмеричном виде.

$324_8$

### Из шестнадцатеричной в бинарную
Напишите шестнадцатеричное число $А3_{16}$ в бинарном виде.

Обратите внимание, что каждая шестнадцатеричная цифра - это бинарное число из 4 цифр.

$10100011_2$

### Из бинарной в шестнадцатеричную
Напишите бинарное число $11110100_2$ в шестнадцатеричном виде (буквы - большие латинские).

$F4_{16}$

### Из шестнадцатеричной в восьмеричную
Напишите шестнадцатеричное число DC в восьмеричном виде.

Рекомендуем перевести сначала в бинарную систему, потом в восьмеричную.

$334_8$

### Из восьмеричной в шестнадцатеричную
Напишите восьмеричное число $32_8$ в шестнадцатеричном виде (буквы - большие латинские).

$1A_{16}$

### Как облегчить жизнь
На каждом компьютере есть программа калькулятор. И в Windows, и в Linux.

В калькуляторе есть режим "программирование". Там удобно смотреть как число хранится в разных системах счисления.

![19](/C_for_beginners_Stepik/Pictures/19_02.png)

![19](/C_for_beginners_Stepik/Pictures/19_03.jpg)

## Представление целых чисел в бинарном виде

[VIDEO](https://youtu.be/4iDpVe7gU04)

### Переполнение
На хранение 1 числа в компьютере отводится фиксированное количество бит. Тип переменной в С определяет, сколько бит занимает эта переменная.

Когда результат операции не помещается в отведенных под него битах, возникает переполнение.

Пусть в компьютере тип int занимает 3 бита. Тогда в нем можно хранить числа от 
$000_2 =0_{10}$ $111_2 = 7_{10}$.

$7 + 1$ приведет к переполнению, в 3 битах останется 000, а "лишний" бит 1 потеряется. $7+1=0$, так как побитовое сложение с переносом 1 даст

```
  111   : 7
+ 001   : 1
 ----
 1000   : 0, так как 1 не помещается, останется 000
```

### Представление отрицательных чисел

![18](/C_for_beginners_Stepik/Pictures/19_10.PNG)

Как представлять целые отрицательные числа в бинарном виде?
+ `x + (-x) = 0` - определение отрицательных чисел
+ хочется быстро определять отрицательное число или нет, используя для этого 1 бит, который мы назовем знаковым битом.

Есть число 3, посмотрим, как можно представить -3.

### Прямой код представления отрицательных чисел
В старшем бите будем хранить или 0 (число НЕ отрицательное), или 1 (число отрицательное).

```
  0011  :  3
  1011  : -3  в прямом коде
```

В таком представлении трудно складывать побитово так, чтобы x + (-x) = 0. Сложение - основная операция в компьютере. Она должна быть реализована на уровне "железа". Сложный алгоритм - сложная схема "железа" - большой размер компьютера.

_Попробуйте придумать алгоритм сложения отрицательного и положительного числа в прямом коде_

Заметим, что в этом коде число ноль кодируется как +0 (00..00) и -0 (10..00).

### Обратный код представления отрицательных чисел
Алгоритм сложения положительного числа с отрицательным становится проще, если отрицательное число записать как побитовое отрицание положительного. То есть все 0 заменить на 1, а 1 на 0.

При этом знаковый бит показывает знак числа. 1 - отрицательное число.

Заметим, что в этом коде число ноль кодируется как +0 (00..00) и -0 (11..11). То есть 2 разных ноля.

### Дополнительный код представления отрицательных чисел
Сделаем алгоритм сложения еще проще. Будем сразу записывать отрицательное число в таком виде, чтобы в побитовом сложении с положительным получался 0 (с учетом переполнения).

```
   0011  :  3
+  ????  : -3
= 10000  : 0 в 4-битном числе, 1 хранить негде.
```

Подберем бинарное представление -3, чтобы оно удовлетворяло условию:

```
   0011  :  3
+  1101  : -3
= 10000  : 0 в 4-битном числе, 1 хранить негде.
```

__Дополнительным кодом__ представления отрицательных чисел называют такое, которое при побитовом сложении с соответствующим положительным числом дает 0 (с учетом переполнения).

### Формула вычисления дополнительного кода по положительному числу
Выведем формулу получения дополнительного кода из положительного числа.

Заметим, что сумма положительного числа и его побитового отрицания ~ (все 0 изменяются на 1, а 1 на 0), даст все единицы:

```
   0011  :  3
+  1100  : ~3
=  1111  : все единицы
```

Если к полученному числу 1111 прибавить 1, то получим 10000. Т.е. переполнение для 4-битных чисел.

__Для получения дополнительного кода нужно взять побитовое отрицание положительного числа и прибавить к нему 1__

```
   1111  :
+  0001  :
= 10000  : 0 в 4-битном числе, 1 хранить негде.
```

То есть -3 это 1100 + 1 = 1101

![18](/C_for_beginners_Stepik/Pictures/19_11.PNG)

### -5 в бинарном коде
Пусть у нас 4-битный компьютер. Как в нем представляется число -5 в дополнительном коде?

$1011$

### -1 в дополнительном коде
Пусть числа хранятся в N битах. Тогда 1 записывается как

0..0001 : N-1 нулей и 1 единица
С каким числом нужно сложить 1, чтобы получить 0?

```
   0..001  : 1 единица, остальные нули
+  1..111  : все 1, не зависимо от того, чему равно N
= 10..000  : 0 в N-битном числе, 1 хранить негде.
```

-1 - это все 1 в дополнительном коде.

## (char)x == 0xFF

### Запись и печать чисел
+ Константы в языке Си записываются:
    + 12 - в десятичной системе;
    + 012 - в восьмеричной системе (начинается с нуля);
    + 0x12 - в шестнадцатеричной системе (начинается с 0x);
    + бинарный тип в стандарте не поддерживается (возможно, появится в новом стандарте), в GNU extension можно использовать префикс 0b, например, 0b1011.

Все они имеют тип int.

#### Печать и чтение для разных систем счисления

Формат | тип | Система счисления
-|-|-
%d или %i | int | десятичное (decimal)
%o | unsigned int | восьмеричное (octal)
%x | unsigned int | шестнадцатеричное (hex)

Число в переменной ВСЕГДА хранится в БИНАРНОМ виде, `printf` его может печатать в разном виде, в зависимости от формата.

```c
int x;
scanf("%d", &x);                // введём число 13
printf("%d\n", x);              // напечатает число 13


unsigned int a;
scanf("%o", &a);                // введём число 13 (оно будет прочитано как восьмеричное)
printf("%o %d %x\n", a, a, a);  // 13 11 b


scanf("%x", &a);                // введём число 13 (оно будет прочитано как шестнадцатеричное)
printf("%o %d %x\n", a, a, a);  // 23 19 13
```

### Где больше?
В трех коробках 10, 012 и 0xA конфет. Где конфет больше?

Выберите один вариант из списка

+ [ ] 10
+ [ ] 012
+ [ ] 0xA
+ [x] Во всех коробках одинаковое количество конфет.

### Что будет выведено на печать?
Проверьте себя, как вы разобрались в материале.

Что будет выведено на печать и __почему__?

```c
char x = 0xFF;  // шестнадцатеричная константа
if (x == 0xFF)
    printf("Равно\n");
else
    printf("Не равно\n");
```

### Почему x не равно 0xFF
Разберем, что происходит в коде, предполагая, что у нас в 1 байте 8 бит и char занимает 1 байт:

```c
char x = 0xFF;  // шестнадцатеричная константа
if (x == 0xFF)
    printf("Равно\n");
else
    printf("Не равно\n");
```

+ x занимает 1 байт (8 бит).
+ 0xFF в бинарном виде 11111111.
+ то есть x состоит из всех 1, значит это число -1 в дополнительном коде.
+ константа 0xFF типа int. Пусть int будет 2 байта. Тогда в бинарном виде это 0000000011111111
+ при вычислении выражения x == 0xFF операнды разных типов, поэтому происходит автоматическое преобразование типа, значение переменной x преобразуется из char к int.
Хочется, чтобы k == -3 было верно, даже если

```c
char k = -3;
if (k == -3)
    printf("Что и ожидалось\n");
else
    printf("Математике в шоке\n");
```

То есть при автоматическом преобразовании из char в int положительное число должно остаться положительным, а отрицательное - отрицательным.
+ в выражении x == 0xFF значение переменной x остается -1, но уже типа int, то есть 2 байта 1111111111111111
+ очевидно, что число 1111111111111111 (значение x, преобразованное в тип int) не равно 0000000011111111 (0xFF).

На рисунке показан этот процесс. Зеленые биты содержат 1, красные 0.

![19](/C_for_beginners_Stepik/Pictures/19_04.png)

### Диапазон знаковых чисел
Рассмотрим компьютер, у которого на хранение каждого целого числа отведено 3 бита. То есть в бинарном виде он может хранить числа от 000 до 111. 
$2^3 = 8$ разных чисел.

Если мы будем трактовать их как только положительные числа, то получим числа от 0 (000) до 7 (111).

Если будем считать, что числа со знаком, то получим числа от -4 до 3. Почему?

Половина чисел начинается с 1, то есть знаковый бит 1, то есть отрицательные.

В неотрицательной половине одно число 0 (000), остальные положительные. Положительных на 1 меньше, чем отрицательных (храним ноль).

![19](/C_for_beginners_Stepik/Pictures/19_05.png)

Если прибавлять к 0 по +1, то получим числа 1, 2, 3. На этом положительные числа закончились.

-1 - это все 1 в бинарном виде. -1 + 1 = 0 из-за переполнения.

По часовой стрелке прибавляется 1, против часовой стрелки - отнимается. На одном горизонтальном уровне одинаковые по модулю числа. -1 и 1, -2 и 2, -3 и 3.

Число 100 - отрицательное. 100 + 1 = 101, это -3. Значит 100 это число -4.

Заметим, что 011 + 1 = 100 то есть 3 + 1 = -4. Это __знаковое переполнение__. Аналогично, -4 - 1 = 3 тоже дает результат не того знака, то есть получаем __знаковое переполнение__.

### Переполнение - 1
В 4-битном компьютере к бинарному числу 0110 прибавили число 0101.

Есть ли переполнение? Отметьте все правильные ответы.

+ [ ] Никакого переполнения нет.
+ [ ] Есть переполнение.
+ [x] Есть знаковое переполнение.

### Переполнение - 2
В 4-битном компьютере к бинарному числу 1010 прибавили число 1001.

Есть ли переполнение? Отметьте все правильные ответы.

+ [ ] Никакого переполнения нет.
+ [x] Есть переполнение.
+ [x] Есть знаковое переполнение.

### Переполнение - 3
В 4-битном компьютере к бинарному числу 1111 прибавили число 1111.

Есть ли переполнение? Отметьте все правильные ответы.

+ [ ] Никакого переполнения нет.
+ [x] Есть переполнение.
+ [ ] Есть знаковое переполнение.

### Переполнение - 4
В 4-битном компьютере к бинарному числу 1001 прибавили число 0110.

Есть ли переполнение? Отметьте все правильные ответы.

+ [x] Никакого переполнения нет.
+ [ ] Есть переполнение.
+ [ ] Есть знаковое переполнение.

## 19.5 Побитовые операции

[VIDEO](https://youtu.be/niy4QNITig8)

Операции над битами называются побитовые операции. Они применяются только к целочисленным типам данных.

![18](/C_for_beginners_Stepik/Pictures/19_12.PNG)

Таблица всех побитовых операций. Подробно разберем каждую операцию на следующих шагах.

Знак | Операция | Пример | Результат
-|-|-|-
`&` | побитовое И (AND) | 5 & 6 | 4
`\|` | побитовое ИЛИ (OR) | 6 | 3 | 7
`^` | побитовое исключающее ИЛИ (XOR) | 6 ^ 3 | 5
`>>` | сдвиг вправо (на неотрицательное) | 7>>1 | 3
`<<` | сдвиг влево (на неотрицательное) | 7<<1 | 14

### Логические функции

Мы уже знаем [логические операции](/C_for_beginners_Stepik/06.md#логические-операторы) И (AND), ИЛИ (OR) и НЕ (NOT).

![18](/C_for_beginners_Stepik/Pictures/06_01.png)

+ И (AND) - одновременно - для чая мне нужна кружка И заварка, тогда у меня будет чай (истина), иначе чай я не получу (ложь). Это пересечение множеств ситуаций, когда у меня есть кружка и множеств ситуаций, когда у меня есть заварка.
+ ИЛИ (OR) - хоть что-нибудь - к чаю я хочу печенье ИЛИ конфету, я получу печенье, или конфету, или печенье с конфетой сразу. Это объединение множеств ситуаций, когда у меня есть печенье, с множеством ситуаций, когда у меня есть конфета.
+ НЕ (NOT) - отрицание - превращает ложь в истину и наоборот.
+ Исключающее ИЛИ (XOR, eXclusive OR) - есть или одно, или другое, но не оба сразу. Я буду пить кофе или чай (я не буду пить чай и кофе одновременно!)

Таблицы истинности для логических функций

AND | 0 | 1
-|-|-
0 | 0 | 0
1 | 0 | 1

OR | 0 | 1
-|-|-
0 | 0 | 1
1 | 1 | 1

XOR | 0 | 1
-|-|-
0 | 0 | 1
1 | 1 | 0

NOT | Результат
-|-
0 | 1
1 | 0

![18](/C_for_beginners_Stepik/Pictures/19_13.PNG)

![18](/C_for_beginners_Stepik/Pictures/19_14.PNG)

### Пример операции `|`
Таблица истинности для логической функции ИЛИ (OR)

OR | 0 | 1
-|-|-
0 | 0 | 1
1 | 1 | 1

+ x OR 1 даст в результате 1,
+ x OR 0 оставит x без изменения.

Рассмотрим работу побитового оператора `|` на примере `0xA | 4`. Разложим числа на коэффициенты при степенях `2`:

$2^3$ | $2^2$ | $2^1$ | $2^0$ | Число
-|-|-|-|-
8 | 4 | 2 | 1 | степени 2
1 | 0 | 1 | 0 | 0xA
0 | 1 | 0 | 0 | 4
1 | 1 | 1 | 0 | 0xA \| 4

Используют, если нужно установить 1 в нужных битах, не трогая значения остальных бит.

### Пример операции `&`
Таблица истинности для логической функции И (AND)

AND | 0 | 1
-|-|-
0 | 0 | 0
1 | 0 | 1

+ x AND 0 даст в результате 0,
+ x AND 1 оставит x без изменения.

Рассмотрим работу побитового оператора `&` на примере `0xA & 7`. Разложим числа на коэффициенты при степенях 2:

$2^3$ | $2^2$ | $2^1$ | $2^0$ | Число
-|-|-|-|-
8 | 4 | 2 | 1 | степени 2
1 | 0 | 1 | 0 | 0xA
0 | 1 | 1 | 1 | 7
0 | 0 | 1 | 0 | 0xA & 7

Используют, если нужно установить 0 в определенных битах, не трогая значения остальных бит.

Или обнулить значение ненужных бит числа 0xA, оставив только те биты, где в числе 7 были единицы. То есть $7_{10} = 0111_2$
​
как маска, закрывает (обнуляет) часть бит, оставляя только нужные биты. Программисты говорят "взять число 0xA по маске 7", получили 2.

### Пример операции `~`
Предположим, в переменной x = 0xA нужно обнулить последние 3 бита и оставить все остальные биты без изменения.

$2^3$ | $2^2$ | $2^1$ | $2^0$ | Число
-|-|-|-|-
8 | 4 | 2 | 1 | степени 2
1 | 0 | 1 | 0 | 0xA
1 | 0 | 0 | 0 | ?
1 | 0 | 0 | 0 | 0xA & ?

Как записать такую маску? Если `х` типа `char`, то маска `11111000`, а если тип `int`, то на некоторых компьютерах 2 байта, на некоторых 4, а где-то 8.

Вспомним про операцию побитовое отрицание `~`, она меняет в бите 0 на 1 и 1 на 0.

```
00000111 это число 7 (если int 1 байт)
11111000 это число ~7
```

Обнулим последние 3 бита переменной х любого целого типа с помощью выражения `x & ~7`.

### Пример операции ^
Таблица истинности для логической функции ИСКЛЮЧАЮЩЕЕ ИЛИ (XOR, exclusive OR)

XOR | 0 | 1
-|-|-
0 | 0 | 1
1 | 1 | 0

x XOR y дадут 1, если х и y разные.

Операция ^ - это НЕ возведение в степень, как в некоторых других языках. 
$5^3 = 125$, a 5^3 равно 6.

$2^3$ | $2^2$ | $2^1$ | $2^0$ | Число
-|-|-|-|-
8 | 4 | 2 | 1 | степени 2
0 | 1 | 0 | 1 | 5
0 | 0 | 1 | 1 | 3
0 | 1 | 1 | 0 | 5^3 это 6

XOR часто используется при обработке изображений.

### Разница между логическими и побитовыми операциями
В языке Си 0 - ложь, все остальное - истина.

__Логические операторы__

`&&`, `||` и `!` вычисляют результат от всего числа (все число трактуется как истина или ложь). Результат логического оператора 0 (ложь) или 1 (истина).

__Два `&&` или `||` в логических операторах.__

`5 && 3` равно 1, так как оба операнда истина, и результат истина. `5 && 6` истина, `5 && 0` ложь.

Побитовые И и ИЛИ обозначаются одним знаком `&` или `|`. 

Операция применяется к каждому биту операндов. Результат будет число того же типа, что и операнды. Если операнды разных типов, то они будут автоматически приведены к единому типу.

Рассмотрим как вычисляется `13 & 6`:

```
1101    это 13
0110    это 6
----
0100    это 4, результат 13&6
```

Пример 1<br>
Во время изучения логических операторов часто по ошибке пишут один знак вместо двух. Посмотрим, есть ли разница.

+ 13 и 6
    + `13 && 6` истина, то есть 1
    + `13 & 6` равно 4, что тоже истина.
+ 13 и 2
    + `13 && 2` истина, то есть 1
    + `13 & 2` равно 0, что ложь.

```
1101    это 13
0010    это 2
----
0000    это 0, результат 13&2
```

Пример 2<br>
`if (x < 3 && y < 5 | z < 7)` Что может пойти не так?

Нам повезло, приоритет у `<` выше, чем у `&&` или `|`.

Но приоритет `|` выше, чем у `&&`, то есть будет вычисляться `if (x < 3 && (y < 5 | z < 7))`, когда хотели написать `if ((x < 3 && y < 5) || z < 7)`

Пример 3<br>

Придумайте сами, когда `!` и `^` дадут в условии `if` одинаковый результат, и когда разный. Можете написать в комментарии к шагу свой пример.

### Побитовый сдвиг влево <<
Этот сдвиг `a<<n` иногда еще называют "побитовым умножением", потому что он эквивалентен умножению $a \cdot 2^n$.
+ `a` - только целочисленное
+ `n` - только целочисленное
    + при `n < 0` - неопределенное поведение (undefined behavior)

Посмотрим, почему называют "побитовым умножением". Рассмотрим `7 << 3`. Будем писать только младший байт (где от $2^7$ до $2^0$), в больших разрядах у нас одни нули.

$2^7$ | $2^6$ | $2^5$ | $2^4$ | $2^3$ | $2^2$ | $2^1$ | $2^0$ | Число
-|-|-|-|-|-|-|-|-
128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 | степени 2
0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 7
0 | 0 | 1 | 1 | 1 | 0 | 0 | 0 | 7 << 3 это 56

Чтобы получилось умножение на 2, мы дописываем справа нули.

$7 \cdot 2^3 = 7 \cdot 8 = 56$

__При сдвиге влево `<<` в конце всегда дописываются 0__

### Побитовый сдвиг вправо >>
Этот сдвиг `a>>n` иногда еще называют "побитовым делением", потому что он эквивалентен делению $a/2^n$ .
+ a - только целочисленное
+ n - только целочисленное
    + при `n < 0` - неопределенное поведение (undefined behavior)

__Сдвиг положительного числа, a > 0__

Посмотрим, почему называют "побитовым делением". Рассмотрим сдвиг положительного числа `56 >> 3`. Будем писать только младший байт (от $2^7$ до $2^0$), в больших разрядах у нас одни нули.

$2^7$ | $2^6$ | $2^5$ | $2^4$ | $2^3$ | $2^2$ | $2^1$ | $2^0$ | Число
-|-|-|-|-|-|-|-|-
128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 | степени 2
0 | 0 | 1 | 1 | 1 | 0 | 0 | 0 | 56
0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 56 >> 3 это 7
0 | 0 | 0 | 0 | 0 | 0 | 1 | 1 | 7 >> 1 это 3

Видим, что для положительных чисел, если дописать при сдвиге спереди нули, то результат эквивалентен делению на 2 в степени n.

$56 / 2^3 = 56 / 8 = 7$

$7 / 2^1 = 3$, так как целочисленное деление.

__Сдвиг отрицательного числа, a < 0__

Когда я делю отрицательное число на положительное я, как математик, хочу получить отрицательное число или 0.

Возьмем число -7 и вычислим `-7 >> 1`.

$2^7$ | $2^6$ | $2^5$ | $2^4$ | $2^3$ | $2^2$ | $2^1$ | $2^0$ | Число
-|-|-|-|-|-|-|-|-
128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 | степени 2
0 | 0 | 0 | 0 | 0 | 1 | 1 | 1 | 7
1 | 1 | 1 | 1 | 1 | 1 | 0 | 0 | -7
? | 1 | 1 | 1 | 1 | 1 | 1 | 0 | `-7 >> 1`

Что поставить спереди? Если поставить 0, то получим положительное число, -7/2 не надо делать положительным!

Значит, __ставим 1, чтобы результат остался отрицательным.__

При сдвиге на слишком большое n у нас получится -1, а не 0.

__Правила дополнения при сдвиге `>>`__

+ __Беззнаковое unsigned число всегда дополняется 0__
```c
unsigned int x;     // число всегда положительное
...
x = x >> 3;         // 0 спереди, ибо число всегда положительное
```
+ Знаковое число дополняется знаковым битом
    + положительное число спереди дополняется 0, `56 >> 3`
    + отрицательное число спереди дополняется 1, `-7 >> 1`

```c
int x;              // число всегда положительное или отрицателное
...
x = x >> 3;         // 0 спереди, если х положительное, и 1, если х отрицательное.
```

![19](/C_for_beginners_Stepik/Pictures/19_15.PNG)

## 19.6 Задача про битовые поля

[VIDEO](https://youtu.be/5N6fTa2dfQs)

### Храним данные в компактном виде
Пусть нужно написать систему хранения информации о всех гражданах государства. Граждан много, места для хранения информации мало. Нужно хранить ее компактно. Передавать по сети тоже в компактном виде.

Хранить нужно следующие характеристики:
+ пол: мужской или женский,
+ умный человек или не очень,
+ носит шляпу или нет,
+ носит брюки или юбку,
+ цвет волос,
+ цвет глаз.

Если отводить на каждую характеристику по 1 char, то в 1 бите для пола будет значимая информация (0 или 1), а другие биты не будут использованы. То есть информация хранится неэффективно.

Цвет волос или цвет глаз тоже можно описать несколькими дискретными значениями. Глаза голубые, зеленые, серые, темные. Волосы светлые (блонд), рыжие, русые, черные.

На хранение части признаков достаточно выделить по 1 биту, на другие по 2 бита. Потом мы будем развивать систему и добавлять признаки, но сейчас напишем пилотный проект для хранения этих признаков и работы с ними.

### Описание формата хранения данных
В одном байте закодирована следующая информация (от младших бит к старшим):

![19](/C_for_beginners_Stepik/Pictures/19_19.PNG)

Ширина (бит) | Признак | Возможные значения | Условные сокращения
-|-|-|-
1 | пол | 1 - male, 0 - female | ma, fe
1 | умный | 1 - clever, 0 - dummy | cl, du
1 | шляпа | 1 - hat, 0 - without hat | ha, nh
1 | брюки-юбка | 1 - trousers, 0 - skirt | tr, sk
2 | цвет волос | 00 - blonde, 01 - red, <br>10 - brown, 11 - black | bn, rd,<br>bw,bk
2 | цвет глаз | 00 - blue, 01 - green,<br>10 - gray, 11 - dark | bu, ge,<br>gy, da

Число 5 в байте кодирует такого человека:

![19](/C_for_beginners_Stepik/Pictures/19_16.png)

![19](/C_for_beginners_Stepik/Pictures/19_20.png)

+ пол=1, мужчина, ma
+ умный=0, не умный, du
+ шляпа=1, носит шляпу, ha
+ брюки=0, носит юбку, sk
+ волосы=00, блондин, bn
+ глаза=00, голубые, bu

>ma du ha tr bn bu

![19](/C_for_beginners_Stepik/Pictures/19_17.jpg)

Почти идеально, но вместо брюк должна быть юбка. Этот человек описывается как 00 00 1 1 0 1, то есть 13. При печати признаков будем начинать с пола (с младших разрядов):

5 - это про шотландцев, а не про Техас.

>ma du ha sk bn bu

![19](/C_for_beginners_Stepik/Pictures/19_18.jpg)

### API работы с системой

![19](/C_for_beginners_Stepik/Pictures/19_16.png)

При работе с таким форматом хранения данных нужно уметь выполнять следующие запросы:
+ Отвечать на вопросы:
    + Какой пол человека?
    + Это мужчина?
    + Это умный человек?
    + Этот человек носит шапку?
    + Это умная женщина?
+ Устанавливать одному признаку значение:
    + надеть шапку,
    + снять шапку.

И аналогичные для многобитных признаков:
+ У человека какие глаза?
+ У человека голубые глаза?
+ У него черные волосы.
+ Она блондинка.

При этом установка или опрос одного признака не должен менять остальные.

### Признак "пол"
Пусть у нас есть человек, он описан в переменной x типа char. Выясним, мужчина это или женщина. Для этого обнулим все биты, кроме последнего.

```
????????   x
00000001   GENDER
--------
0000000?   x & GENDER
```

Заметим, что можно проверить по-другому. Если x четное, то это женщина, при нечётном x будет мужчина.

Оставим проверки x%2 == 1 курсу вычислительной математики и будем дальше придерживаться побитовых операций.

```c
#define GENDER 1


if ((x & GENDER) == 1)
    printf("male\n");   // мужчина
else
    printf("female\n"); // женщина
```

Так как приоритет у `==` выше, чем у `&`, необходимы скобки.

### bit_1 Мужчина или женщина?
Дано 8-битное число в шестнадцатеричном виде.

Напечатайте условное обозначение, мужчина это `ma` или женщина `fe`.

Ширина (бит) | Признак | Возможные значения | Условные сокращения
-|-|-|-
1 | пол | 1 - male, 0 - female | ma, fe
1 | умный | 1 - clever, 0 - dummy | cl, du
1 | шляпа | 1 - hat, 0 - without hat | ha, nh
1 | брюки-юбка | 1 - trousers, 0 - skirt | tr, sk
2 | цвет волос | 00 - blonde, 01 - red, <br>10 - brown, 11 - black | bn, rd,<br>bw,bk
2 | цвет глаз | 00 - blue, 01 - green,<br>10 - gray, 11 - dark | bu, ge,<br>gy, da

```c
#include <math.h>
#include <stdio.h>

#define GENDER 1

int main() {
    unsigned int x;
    scanf("%x", &x);
    if ((x & GENDER) == 1)
        printf("ma\n");  // мужчина
    else
        printf("fe\n");  // женщина
    return 0;
}
```

```c
#define GENDER 1

int main()
{
    unsigned int x;
    scanf("%x", &x);
    
    printf("%s\n", x & GENDER ? "ma" : "fe");
    
    return 0;
}
```

### Умный или нет?
Аналогично можно определить, умный или нет.

![19](/C_for_beginners_Stepik/Pictures/19_16.png)

```c
????????   x
00000010   CLEVER
--------
000000?0   x & CLEVER
```

Код

```c
#define CLEVER 2


if ((x & CLEVER) == 2)
    printf("cl\n");     // умный
else
    printf("du\n");     // глупый
```

будет не самым умным решением. Даже если мы заменим условие на `if (x & CLEVER)`.

Представьте, что у нас описаны все признаки:

```c
#define GENDER  1
#define CLEVER  2
#define HAT     4
#define TROUSES 8
// и дальше начинаем вспоминать степени 2
```

Представим, что надо поменять формат. Шляпу написать в самом старшем бите, перед глазами. Все остальное сдвинуть. Потом добавятся еще признаки. Я не хочу помнить степени 2 до 64 включительно наизусть. Я не компьютер. Что делать?

Сведем задачу проверки умный или нет к предыдущей задаче проверки мужчина или женщина. Для этого сдвинем число х так, чтобы нужный признак оказался в самом младшем разряде.

```c
??????*?   x
???????*   x >> 1
00000001   1
--------
0000000*   x >> 1 & 1
```
Приоритет `>>` выше, чем у побитового И, скобки не нужны.

Аналогично, опишем константы без вычислений в уме чему равно 2 в 16 степени.

```c
#define GENDER  1
#define CLEVER  (1<<1)
#define HAT     (1<<2)
#define TROUSES (1<<3)
```

### bit_2 Есть шляпа?
Дано 8-битное число в шестнадцатеричном виде.

По входному числу выясните - носит человек шляпу или нет. Напечатайте ha - если носит шляпу, nh - если не носит.

Ширина (бит) | Признак | Возможные значения | Условные сокращения
-|-|-|-
1 | пол | 1 - male, 0 - female | ma, fe
1 | умный | 1 - clever, 0 - dummy | cl, du
1 | шляпа | 1 - hat, 0 - without hat | ha, nh
1 | брюки-юбка | 1 - trousers, 0 - skirt | tr, sk
2 | цвет волос | 00 - blonde, 01 - red, <br>10 - brown, 11 - black | bn, rd,<br>bw,bk
2 | цвет глаз | 00 - blue, 01 - green,<br>10 - gray, 11 - dark | bu, ge,<br>gy, da

```c
#include <math.h>
#include <stdio.h>

#define GENDER 1
#define CLEVER (1 << 1)
#define HAT (1 << 2)
#define TROUSES (1 << 3)

int main() {
    unsigned int x;
    scanf("%x", &x);
    if ((x & HAT) == HAT)
        printf("ha\n");  // носит шляпу
    else
        printf("nh\n");  // не носит шляпу
}
```

Видно, что нам нужно или хранить константы <br>
`#define HAT (1<<2)`<br>
и проверять `x & HAT`<br>
или хранить где-то сдвиги 2 и маски 1, тогда писать проверку как<br>
`x >> 2 & 1`<br>

```c
#define HAT (1<<2)

int main() {
    unsigned int x;
    scanf("%x", &x);
    
    printf("%s\n", x >> 2 & 1 ? "ha" : "nh");
    
    return 0;
}
```

```c
#include <stdio.h>
int main() {    
    for ( unsigned int x; scanf("%x", &x)==1; puts((char *[]){"nh","ha"}[x>>2 & 1]) );
    return 0;
}
```

```c
#include <stdio.h>
int main() {
    const unsigned char HAT = (1<<2);
    for (unsigned int x; scanf("%x ", &x)==1; puts((x & HAT) ? "ha" : "nh"));
    return 0;
}
```

### Какого цвета волосы?
Выясним, какого цвета волосы

![19](/C_for_beginners_Stepik/Pictures/19_16.png)

Для этого сдвинем число так, чтобы биты цвета волос стали самыми последними и обнулим все биты, кроме цвета волос по маске из бинарного числа 11.

```c
??**????   x
??????**   x >> 4
00000011   HAIR_MASK
--------
000000**   x >> 4 & HAIR_MASK
```

В результате получим одно из чисел: 0, 1, 2 или 3.

Подумайте, как можно компактно записать кодовые названия цвета волос bn, rd, bw, bk.


```c
#include <stdio.h>

int main() {
    unsigned int x;
    scanf("%x", &x);
    char * answer[] = {"bn", "rd", "bw", "bk"};
    printf("%s", answer[(x >> 4) & 3]);
}
```

```c
#include<stdio.h>

int main()
{
    unsigned x;
    scanf("%x", &x);
   
    switch(x >> 4 & 3)
    {
        case 0:
            printf("bn");
            break;
        case 1:
            printf("rd");
            break;
        case 2:
            printf("bw");
            break;
        case 3:
            printf("bk");
            break;
    }
    
    return 0;
}
```

### bit_4 Развернуть характеристику
Дано 8-битное число в шестнадцатеричном виде.

По входному числу напишите все характеристики человека (аббревиатурами) в порядке от младших бит к старшим.

Ширина (бит) | Признак | Возможные значения | Условные сокращения
-|-|-|-
1 | пол | 1 - male, 0 - female | ma, fe
1 | умный | 1 - clever, 0 - dummy | cl, du
1 | шляпа | 1 - hat, 0 - without hat | ha, nh
1 | брюки-юбка | 1 - trousers, 0 - skirt | tr, sk
2 | цвет волос | 00 - blonde, 01 - red, <br>10 - brown, 11 - black | bn, rd,<br>bw,bk
2 | цвет глаз | 00 - blue, 01 - green,<br>10 - gray, 11 - dark | bu, ge,<br>gy, da

Подсказка: не надо копировать код разбора каждого признака! Вы получите макаронину из кода.

Для всех признаков у вас условное сокращение находилось по почти одинаковому коду для всех признаков.

`name[x >> shift & mask]`

Объявите структуру для описания одного признака. В неё запишите все эти поля. Сделайте массив структур - как описывается один человек.

```c
#include <stdio.h>

int main() {
    unsigned int x;
    scanf("%x", &x);

    char* matrix[6][4] = {{"fe", "ma"},
                          {"du", "cl"},
                          {"nh", "ha"},
                          {"sk", "tr"},
                          {"bn", "rd", "bw", "bk"},
                          {"bu", "ge", "gy", "da"}};
    for (unsigned int i = 0; i < 4; i++) {
        printf("%s ", matrix[i][(x >> i) & 1]);
    }
    printf("%s ", matrix[4][((x >> 4) & 3)]);
    printf("%s ", matrix[5][((x >> 6) & 3)]);
}
```

Описание структуры формата отделено от собственно движка.
Изменять формат данных может не очень квалифицированный работник.

```c
#include <stdio.h>
struct Man {
    unsigned int shift;
    unsigned int mask;
    char * str[4];
};

int main ()
{
    struct Man dict [] = {
       {  0, 1, {"fe", "ma"}},
       {  1, 1, {"du", "cl"}},
       {  2, 1, {"nh", "ha"}},
       {  3, 1, {"sk", "tr"}},
       {  4, 3, {"bn", "rd", "bw", "bk"}},
       {  6, 3, {"bu", "ge", "gy", "da"}}
    };
    int i;
    unsigned int x;
    scanf("%x", &x);
    for (i = 0; i < sizeof(dict)/sizeof(dict[0]); i++)  {
        unsigned int shift = dict[i].shift;
        unsigned int mask = dict[i].mask;
        printf("%s ", dict[i].str[(x >> shift) & mask]);
    }
    printf("\n");
    return 0;
}
```

при решении этой задачки разобрался с union.

`unsigned char gender:1;` это битовые поля, после : указывается сколько бит будет использовать данная переменная.

```c
#include <stdio.h>

union {
    struct {
        unsigned char gender:1;
        unsigned char clever:1;
        unsigned char hat:1;
        unsigned char clothes:1;
        unsigned char hair_color:2;
        unsigned char eye_color:2;
    };
    unsigned char character;
} characteristics;

int main() {
    scanf("%hhx", &characteristics.character);
    printf("%s ", characteristics.gender ? "ma" : "fe");
    printf("%s ", characteristics.clever ? "cl" : "du");
    printf("%s ", characteristics.hat ? "ha" : "nh");
    printf("%s ", characteristics.clothes ? "tr" : "sk");
    char hair_color_value[][4] = {"bn", "rd", "bw", "bk"};
    printf("%s ", hair_color_value[characteristics.hair_color]);
    char eye_color_value[][4] = {"bu", "ge", "gy", "da"};
    printf("%s", eye_color_value[characteristics.eye_color]);
    
    return 0;
}
```

## 19.7 Изменение отдельных бит

### bit_rwx Права доступа
В UNIX-подобных операционных системах права доступа к файлам представляются в виде трехзначного восьмеричного числа.

Первая цифра - права доступа для владельца, вторая - для группы, третья - для всех остальных.

![19](/C_for_beginners_Stepik/Pictures/19_21.png)

Каждая из цифр, в свою очередь, может быть записана в виде трех двоичных разрядов, обозначающих право на чтение (r), запись (w) и исполнение (x), если они установлены в 1, и отсутствие соответствующего права, если они установлены в 0.

На вход даны права доступа к файлу в виде __восьмеричного__ числа. Выведите их в символьном виде: букву в случае наличия права и "-" (без кавычек) в случае его отсутствия.


Input | Output
-|-
777 | rwxrwxrwx
660 | rw-rw----
750 | rwxr-x---

Дополнительная информация по правам доступа в UNIX (к задаче не относится)
В командной строке Unix можете выполнить команду ls -l и посмотреть на права доступа ваших файлов. Первый символ означает тип файла, мы его в этой задаче не рассматриваем.

```bash
tatyderb@nearbird:/mnt/c/cyghome/work/ejudge/contests/c/bit/bit_4$ ls -l
total 8
-rw-rw---- 1 tatyderb tatyderb 2629 Dec 12  2019 bit_4.html
-rw-rw---- 1 tatyderb tatyderb  651 Dec 12  2019 bit_4_solution.c
drwxrwxr-x 1 tatyderb tatyderb  512 Dec 12  2019 tests
```

Права доступа к файлу можно сменить в командной стоке командой `chmod 750`, где число - это то самое восьмеричное число, которое дается на вход в задаче.

Подробнее рекомендуем читать на https://younglinux.info/bash/rwx