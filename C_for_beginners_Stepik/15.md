# Структуры данных. Стек

## Интерфейс и реализация. Стек

### Структура раздела
Дальше в курсе будет изучение структур данных: стека, очереди, деревьев, графов, хеш-таблиц. И их реализация.

Поэтому сначала в этом уроке поговорим о том, что такое структура данных, интерфейс и его реализация.

Потом рассмотрим, где может применяться стек при решении задач.

В конце реализуем стек на основе массива фиксированной длины, а потом - на основе динамического массива различными способами.

[Видео](https://youtu.be/65R5YMxrOzE)

### Интерфейс и реализация
Структура данных - способ хранения и работы с данными.

Интерфейс (`interface`) - что делает? - как можно работать с этими данными.

Программный интерфейс (`application programming interface, API`) - набор прототипов функций.

Реализация (`implementation`) - как устроена работа с данными.

Реализация программного интерфейса - это реализация функций, описанных в интерфейсе.

![15](/C_for_beginners_Stepik/Pictures/15_01.gif)

Разберем на примере. Если вам нужно узнать сколько сейчас времени, вы смотрите на часы. Часы предоставляют человеку интерфейс "узнать время", "установить время" и (не всегда) "завести часы".

Один и тот же интерфейс может быть реализован по-разному. Часы бывают механические и электронные, наручные и огромные установленные на зданиях, часы есть в компьютере, раньше для определения времени использовали солнечные часы, водяные часы, песочные часы, огненные часы.

Они делают одно и то же - определяли время. Но как они это делают - зависит от реализации. Выбор конкретных часов зависит от задачи. С какой точностью нужно определять время? Сколько места могут занимать часы? Есть ли электричество или батарейки или придется обходиться без них?

### Интерфейс стек
Стек - структура данных, в которой реализован принцип `LIFO` (`last input, first output`), последним пришел, первым ушел.

Пример стека - стопка тарелок или книг, детская пирамидка из колец, вагон метро в час пик. Тарелку можно поставить только на верх стопки и снять тоже - только верхнюю тарелку. Нельзя выдернуть тарелку из середины.

|||
-|-
![15](/C_for_beginners_Stepik/Pictures/15_02.jpg) | ![15](/C_for_beginners_Stepik/Pictures/15_03.png)

Основа интерфейса - это метод `push` (добавить элемент на вершину стека) и `pop` (удалить элемент с вершины стека).

![15](/C_for_beginners_Stepik/Pictures/15_04.png)

### Стек - стакан с красками
Пусть наш стек - это стакан, в который наливают `push` и выливают pop слой краски. Эти слои не смешиваются.

`top` - посмотреть на вершину стека и сказать, какая сверху краска, но не изменять содержимое стека. (`pop` - изменяет стек).

Введем дополнительные функции:

`is_empty` - проверить, что стек пуст. Из него нельзя достать краску. Ее там нет.

`is_full` - проверить, что стек (стакан) полный. В него больше не получится наливать краску (она прольется через край).

`draw` - нарисовать стакан.

`create` - создать (взять) стакан. Сначала стакан пустой.

Возьмем стакан и начнем наливать туда краски (`push`).

![15](/C_for_beginners_Stepik/Pictures/15_05.PNG)

Стакан полный. В него больше ничего нельзя налить до тех пор, пока не выльем хотя бы 1 слой. Иначе будет переполнение стека (`stack overflow`).

Начнем выливать из стакана функцией `pop`.

![15](/C_for_beginners_Stepik/Pictures/15_06.png)

Когда стек пустой из него нельзя сделать `pop` - нечего доставать, стек может испортиться.


##  Где нужен стек - корректная последовательность скобок

[Видео](https://youtu.be/O8VknoU9VCk)

### Правильная скобочная последовательность, один тип скобок
Последовательность из скобок называется правильной, если для ее каждой открывающей скобки есть парная закрывающая и наоборот.

Возьмем сначала пару скобок одного типа, например только круглые скобки ( и ).

Последовательность | Корректная?
-|-
(())(()()) | Да
()) | Нет, лишняя закрывающая
(() | Нет, лишняя открывающая
)( | Нет

Как определить корректная последовательность или нет?

Для одного типа скобок стек не нужен. Можно считать открывающие скобки и закрывающие. В конце количество открывающих и закрывающих должно быть равно и в любой момент закрывающих не должно быть больше.

### Правильная скобочная последовательность, несколько типов скобок
Добавим к скобкам `(` и `)` еще `<` и `>`.

Последовательность | Корректная?
-|-
(<>)<()<>> | Да
(<>()) | Да
<)(> | Нет
<(>) | Нет

Последний пример показывает, что счетчиками нам не обойтись. Придется придумать другой алгоритм.

```
Пока есть скобки
    если скобка открывающая
        положить ее в стек push
    если скобка закрывающая
        достать скобку из стека pop
        если достать не можем — плохо
        если эти скобки не пара — плохо
В конце проверить, что стек пустой
Последовательность корректная
```

Пусть очередной символ входной последовательности читается в переменную `с` (`current bracket`), а из стека достается в переменную `p` (`popped bracket`), то на разборе последовательности получим следующие значения переменных и содержимое стека:

Последовательность `(<><()>)`

c | p | стек после операции | что делали
-|-|-|-
`(` | | `(` | `c` открывающая, `push(c)`
`<` | | `(<` | `c` открывающая, `push(c)`
`>` | `<` | `(` | `c` закрывающая, `p = pop()`<br>`с` и `p` пара, идем дальше
`<` | `<` | `(<` | `c` открывающая, `push(c)`
`(` | `<` | `(<(` | `c` открывающая, `push(c)`
`)` | `(` | `(<` | `c` закрывающая, `p = pop()`<br>`с` и `p` пара, идем дальше
`>` | `<` | `(` | `c` закрывающая, `p = pop()` <br> `с` и `p` пара, идем дальше
`)` | `(` | стек пуст | `c` закрывающая, `p = pop()` <br> `с` и `p` пара, идем дальше
нет | `(` | стек пуст | последовательность закончилась,<br>стек пуст, значит<br>последовательность корректна

Последовательность `(<)>`

c | p | стек после операции | что делали
-|-|-|-
`(` | | `(` | `c` открывающая, `push(c)`
`<` | | `(<` | `c` открывающая, `push(c)`
`)` | `<` | `(` | `c` закрывающая, `p = pop()`<br>`с` и `p` НЕ пара.<br>СТОП, последовательность не корректна

### Реализация
Нужно написать задачу так, чтобы добавление еще одного типа скобок требовало добавления 2 символов, а не дописывания нескольких строк кода.

Для этого рекомендуем определить пары символов в специальных константах. Например,

```c
const char * begin = "(<{";     // открывающие скобки
const char * end   = ")>}";     // соответствующие им закрывающие скобки
```

или так:

```c
const char * bracket[] = {"()", "<>", "{}"};    // задаем сразу пары скобок
```

### Анализ трудозатрат на задачу
Предположим, это настоящая задача, которую ставит перед программистами менеджер. Ставит он ее поэтапно и ничего о том, как ее программировать менеджер не знает.

Сначала Иванову поручили написать код с одним типом скобок `()`. Иванов справился за 1 час.

Потом поручили Петрову добавить второй тип скобок `<>`. Менеджер дал на задачу `0.5` часа (потому что одна уже решена за `1` час и нужно добавить правки). Петров предупредил, что задача часа на `3` (потому что нужно выбросить код про счетчики, реализовать стек, написать решение на стеке), но он попытается успеть за `2`. Петров написал хороший код.

Дальше в систему добавили третий тип скобок `{}`. Дали эту задачу Сидорову (ибо Петров не уложился в сроки). Сидоров быстро нашел в коде Петрова одно место (там были комментарии!) и добавил скобки за `15` минут. Следующие скобки он добавлял почти мгновенно (`5-10` минут, не забываем про тестирование!)

Итого реально может быть такой расклад:
+ Иванов - успешно справился с простой задачей;
+ Петров - хороший программист: быстро написал сложную задачу, код хорошо читаемый и модифицируемый;
+ Сидоров - воспользовался хорошо написанным кодом Петрова, квалификация неизвестна, но умеет разбираться в хорошем коде.

С точки зрения менеджера:
+ Иванов - хороший программист; сказал 1 час - сделал за 1 час.
+ Петров - очень плохой программист, долго делал, затратил минимум в 8 раз больше времени, чем было нужно. Разбор ситуации показал, что он не смог воспользоваться кодом Иванова (страдает синдромом "только я могу писать хороший код, чужой код должен быть переписан").
+ Сидоров - самый лучший программист, сделал все очень быстро и продолжает быстро вносить необходимые правки.

_Уважаемые будущие менеджеры. Запомните этот пример. Иногда одинаковые правки "добавить обработку еще одной пары скобок" требуют совершенно разных изменений._

## Обратная польская запись - вычисление выражения

[Видео](https://youtu.be/qkYB7EylpK8)

### Инфиксная и постфиксная запись
Обычно для записи арифметических выражений используется инфиксная запись, когда оператор (сложения, вычитания, умножения, деления) стоит между операндами (числами).

Запись, когда сначала пишутся операнды, а потом оператор, называется постфиксной или обратной польской записью.

Инфиксная запись | Постфиксная запись
-|-
`2 + 3` | `2 3 +`
`2 + 3 * 4` | `2 3 4 * +`
`(2 + 3) * 4` | `2 3 + 4 *`
`(2 + 3) * (4 + 5)` | `2 3 + 4 5 + *`

_Заметим, что для указания порядка операций с разным приоритетом в постфиксной записи не нужны скобки._

### Вычисление выражения
Вычислим значение постфиксного выражения с помощью стека по алгоритму. Токен - это или оператор или операнд.

```
Пока есть токены
    если это операнд (число)
        положить в стек
    если это оператор
        извлечь из стека 2 операнда
        выполнить операцию
        результат положить в стек
```

В конце разбора в стеке должно быть одно число - результат выражения.

Можно проверить, корректно ли выражение в постфиксной записи. Если во время выполнения алгоритма возникли проблемы (стек пуст, а нужно сделать `pop` или стек содержит более 1 числа в конце выражения), то выражение не корректно.

Разберем выражение `1 2 + 3 4 + *`

![15](/C_for_beginners_Stepik/Pictures/15_07.png)

Число на вершине стека написано так.

Токен | Операция | Стек
-|-|-
`1` | положить в стек | `1`
`2` | положить в стек | `1` `2`
`+` | сложение | `3`
`3` | положить в стек | `3` `3`
`4` | положить в стек | `3` `3` `4`
`+` | сложение | `3` `7`
`*` | умножение | `21`

Результат `21` - на вершине стека.

Преобразование из инфиксной в постфиксную нотацию тоже делают с помощью 2 стеков.

## `git` - начало работы

[Видео](https://youtu.be/5Lu5-y3wwIU)

## stack - реализация на основе массива (print)

[Видео](https://youtu.be/vqW61ZtnUgE)

### struct Stack
Будем реализовывать стек на основе обычного (а не динамического) массива. Он будет фиксированного размера, зато очень простой.

Хранить в стеке пока будем целые числа. Чтобы можно было легко перейти с них на любые данные, определим тип `Data`:

```c
typedef int Data;
```

Данные хранить будем в массиве.

```c
#define N 8
Data a[N];
```

В массив можно положить `N` элементов. Пусть в стеке лежат числа 7, 4, 1, где 1 - верхушка стека.

```c
a[0]=7; a[1]=4; a[2]=1;
```

Нужна еще одна переменная, назовем `n`, чтобы хранить, сколько в массиве реально лежит данных. Хранить можно:
+ индекс последней заполненной ячейки (как в длинной арифметике, n=2)
+ индекс первой пустой ячейки, n=3
+ сколько элементов хранится в стеке, n=3

Выбрать можно любой вариант. Посмотрим, что мы храним в случае пустого стека. Добавление элемента в стек `+1` этой переменной:
+ индекс последней заполненной ячейки, `n=-1`
+ индекс первой пустой ячейки, `n=0`
+ сколько элементов хранится в стеке, `n=0`

Мне не нравится число `-1`. `n=0` кажется естественней. Тогда будем считать, что `n` - это или индекс первого пустого элемента, или количество элементов, хранящихся в стеке. Ее значение не может быть отрицательным и можно использовать `unsigned int`.

Если в задаче стеков будет несколько, то легко запутаться какая переменная хранит размер какого массива. Объединим массив и счетчик в одну структуру:

```c
#define N 8
typedef struct {
    Data a[N];      // место для данных
    unsigned int n; // сколько данных хранится
} Stack;
```

### Модель стека

![15](/C_for_beginners_Stepik/Pictures/15_08.png)

Сделаем стек как на рисунке и попробуем его напечатать.

```c
int main() {
    Stack stack = {{7, 4, 1}, 3};

    for(unsigned int i = 0; i < stack.n; i++)
        printf("%d ", stack.a[i]);
    printf("\n");

    return 0;
}
```

Или сделаем печать отдельной функцией `print`. В нее можно передавать саму структуру (данные не изменяются), но копировать целый массив в структуре тяжелее, чем передавать копию указателя на эту структуру. Поэтому будем передавать в функцию указатель на структуру.

На последнем шаге будем приводить полный файл:

```c
#include <stdio.h>

// нужно хранить другие данные в стеке?             
// Измени тип хранимых данных в одном месте.
typedef int Data;   

#define N 8
typedef struct {
    Data a[N];      // место для данных
    unsigned int n; // сколько данных хранится
} Stack;

// печать стека
void print(Stack * s) {
    for(unsigned int i = 0; i < s->n; i++)
        printf("%d ", s->a[i]);
    printf("\n");
}    

int main() {
    Stack stack = {{7, 4, 1}, 3};
    print(&stack);

    return 0;
}
```

### Инициализация пустого стека
Достаточно ли объявление стека для его хорошей работы или его нужно дополнительно подготовить?

Для проверки сделаем пустой стек и напечатаем его.

```c
Stack stack;
Stack * s = &stack;
for(unsigned int i = 0; i < s->n; i++)
    printf("%d ", s->a[i]);
printf("\n");
```

Если переменная `stack` локальная, то в ней хранится "мусор". В поле `n` может лежать любое число. Может `0` (нам повезло и все работает), может `135`, а может и `-66`.

Значит, чтобы стек был готов к работе, в поле `n` у него должен быть `0`. Напишем функцию инициализации стека. Так как содержимое структуры при этом изменяется, передавать нужно указатель на нее.

```c
void init(Stack * s) {
    s->n = 0;       // сначала стек пустой, в нем нет элементов
}
```

Уберем модель стека, оставим объявление стека и его инициализацию. При печати ничего не выводится, стек пуст.

```c
#include <stdio.h>

// нужно хранить другие данные в стеке?             
// Измени тип хранимых данных в одном месте.
typedef int Data;   

#define N 8
typedef struct {
    Data a[N];      // место для данных
    unsigned int n; // сколько данных хранится
} Stack;

// печать стека
void print(Stack * st) 
{
    for(unsigned int i = 0; i < st->n; i++) 
        printf("%d ", st->a[i]);
    printf("\n");
}

// инициализация стека
void init(Stack * st) {
    st->n = 0;
}    

int main() {
    Stack stack;            // создаем стек
    Stack * st = &stack;    // указатель на созданный стек

    init(st);
    print(st);              // ничего не печатается

    return 0;
}
```

## stack - реализация на основе массива (push, pop)

[Видео](https://youtu.be/jyJTthnEFBI)

### Тесты для push
Напишем сначала тесты для push. В комментариях к коду напишем, что должно быть напечатано.

```c
Stack stack;            // создаем стек
Stack * st = &stack;    // указатель на созданный стек

init(st);
print(st);              // ничего не печатается

push(st, 5);
print(st);      // 5
push(st, 17);
print(st);      // 5 17
push(st, -3);
print(st);      // 5 17 -3
```

### Реализация push
После этого напишем по вызову функции `push(st, -3)` ее прототип:

```c
void push(Stack * st, Data data);
```

Кладем данные на первое пустое место, увеличиваем счетчик хранящихся данных.

```c
void push(Stack * st, Data data) {
    st->a[st->n] = data;
    st->n ++;
}
```

Компилируем, запускаем, убеждаемся, что тесты проходят верно. Запускаем с valgrind. Убеждаемся, что ошибок нет.

### pop тесты
Сначала напишем тесты. В стеке числа `5, 17, -3`. Достанем их по-очереди, напишем в комментариях что ожидаем на печати:

```c
    Data d;
    d = pop(st);    // pop -3: 5 17
    printf("pop %d: ", d);
    print(st);

    d = pop(st);    // pop 17: 5
    printf("pop %d: ", d);
    print(st);

    d = pop(st);    // pop 5: 
    printf("pop %d: ", d);
    print(st);
```

### pop реализация
По вызову функции `d = pop(st);` напишем прототип функции

```c
Data pop(Stack * st);
```

и реализацию. Так как нужно вернуть данные, объявим переменную `res` того же типа, что и возвращаемое значение. В конце ее вернем.

В функции нужно вычислить значение верхушки стека, и уменьшить счетчик хранимых данных (этого достаточно для "удаления" элемента из стека).

```c
Data pop(Stack * st) {
    Data res = st->a[st->n - 1];
    st->n --;
    return res;
}
```

еще читабельнее:

```c
Data pop(Stack * st) {
    st->n --;
    Data res = st->a[st->n];
    return res;
}
```
и еще короче:

```c
Data pop(Stack * st) {
    return st->a[-- st->n];
}
```

### Итого

```c
#include <stdio.h>

// нужно хранить другие данные в стеке?             
// Измени тип хранимых данных в одном месте.
typedef int Data;   

#define N 8
typedef struct {
    Data a[N];      // место для данных
    unsigned int n; // сколько данных хранится
} Stack;

// печать стека
void print(Stack * st) 
{
    for(unsigned int i = 0; i < st->n; i++) 
        printf("%d ", st->a[i]);
    printf("\n");
}

// инициализация стека
void init(Stack * st) {
    st->n = 0;
}    

// добавить данные data в стек
void push(Stack * st, Data data) {
    st->a[st->n] = data;
    st->n ++;
}

// удалить данные с вершины стека, вернуть эти данные
Data pop(Stack * st) {
    return st->a[-- st->n];
}

int main()
{
    Stack stack;            // создаем стек
    Stack * st = &stack;    // указатель на созданный стек

    init(st);
    print(st);              // ничего не печатается

    // тесты для push
    push(st, 5);
    print(st);      // 5
    push(st, 17);
    print(st);      // 5 17
    push(st, -3);
    print(st);      // 5 17 -3


    // тесты для pop
    Data d;
    d = pop(st);    // pop -3: 5 17
    printf("pop %d: ", d);
    print(st);

    d = pop(st);    // pop 17: 5
    printf("pop %d: ", d);
    print(st);

    d = pop(st);    // pop 5: 
    printf("pop %d: ", d);
    print(st);

    return 0;
}
```

Результат запуска:

```
5
5 17
5 17 -3
pop -3: 5 17
pop 17: 5
pop 5:
```

## `stack` - реализация на основе массива (`is_empty`, `is_full`)

[Видео](https://youtu.be/I2CD9UBn6is)

### Тесты для is_empty
Функции `push` и `pop` не должны проверять, можно ли их вызывать. Это задача тех, кто их вызывает. Для проверок в API обеспечим функции `is_empty` (из стека нельзя доставать) и `is_full` (в стек нельзя класть).

Напишем тесты для функции, которая проверяет пустой стек или нет. Функция `is_empty` должна возвращать истину, если стек пустой, иначе возвращать ложь.

```c
    printf("empty: %s\n", is_empty(st) ? "YES" : "NO");     // YES
```

Вставим этот тест сразу после создания (YES), после добавления каждого элемента и после удаления (NO). Только после удаления всех элементов тест должен опять напечатать YES.

### Реализация `is_empty`
После этого напишем по вызову функции `is_empty(st)` ее прототип:

```c
int is_empty(Stack * st);
```

Реализация простая - нужно проверить, что счетчик данных 0.

```c
int is_empty(Stack * st) {
    return st->n == 0;
}
```

Не забываем запускать тесты после каждой реализованной функции.

### is_full тесты
Напишем тесты аналогично тестам на `is_empty`.

```c
printf("full: %s\n", is_full(st) ? "YES" : "NO");
```

Тесты напечатают `YES` только если заполнить весь массив. Можно добавить тестов на push. А можно изменить начальный размер массива, протестировать `is_full` и откатить изменения.

Это не очень хорошо, потому что мы можем забыть откатить изменения. Еще при этом не получится прогонять все тесты при добавлении новых функций (это называется регрессионное тестирование, мы дописывая новый код можем сломать старый).

`is_full` реализация
В стек нельзя положить, когда счетчик хранящихся данных равен размеру стека.

Можно написать так:

```c
int is_full(Stack * st) {
    return st->n == N;
}
```
но лучше вспомнить, как вычислить размер массива с помощью `sizeof`:

```c
int is_full(Stack * st) {
    return st->n == sizeof(st->a) / sizeof(st->a[0]);
}
```
### Итого

```c
#include <stdio.h>

// нужно хранить другие данные в стеке?
// Измени тип хранимых данных в одном месте.
typedef int Data;

#define N 3
typedef struct {
    Data a[N];      // место для данных
    unsigned int n; // сколько данных хранится
} Stack;

// печать стека
void print(Stack * st)
{
    for(unsigned int i = 0; i < st->n; i++)
        printf("%d ", st->a[i]);
    printf("\n");
}

// инициализация стека
void init(Stack * st) {
    st->n = 0;
}

// добавить данные data в стек
void push(Stack * st, Data data) {
    st->a[st->n] = data;
    st->n ++;
}

// удалить данные с вершины стека, вернуть эти данные
Data pop(Stack * st) {
    return st->a[-- st->n];
}

// проверить, что стек пустой, из него нельзя ничего достать
int is_empty(Stack * st) {
    return st->n == 0;
}

// проверить, что стек полон, в него нельзя ничего положить
int is_full(Stack * st) {
    return st->n == sizeof(st->a) / sizeof(st->a[0]);
}

int main() {
    Stack stack;            // создаем стек
    Stack * st = &stack;    // указатель на созданный стек

    init(st);
    printf("empty: %s\n", is_empty(st) ? "YES" : "NO"); // YES
    printf("full: %s\n", is_full(st) ? "YES" : "NO");   // NO
    print(st);              // ничего не печатается

    // тесты для push
    push(st, 5);
    print(st);      // 5
    push(st, 17);
    print(st);      // 5 17
    push(st, -3);
    print(st);      // 5 17 -3

    printf("empty: %s\n", is_empty(st) ? "YES" : "NO"); // NO
    printf("full: %s\n", is_full(st) ? "YES" : "NO");   // YES

    // тесты для pop
    Data d;
    d = pop(st);    // pop -3: 5 17
    printf("pop %d: ", d);
    print(st);

    d = pop(st);    // pop 17: 5
    printf("pop %d: ", d);
    print(st);

    d = pop(st);    // pop 5:
    printf("pop %d: ", d);
    print(st);

    printf("empty: %s\n", is_empty(st) ? "YES" : "NO"); // YES
    printf("full: %s\n", is_full(st) ? "YES" : "NO");   // NO

    return 0;
}
```

Результат запуска:

```
empty: YES
full: NO

5
5 17
5 17 -3
empty: NO
full: YES
pop -3: 5 17
pop 17: 5
pop 5:
empty: YES
full: NO
```

## stack - рефакторинг тестов

[Видео](https://youtu.be/zk8HoTRI4cE)

### Что в тестах плохо?

Сначала вернем значение N 8.

Чтобы написать тесты для стека с массивом из 8 элементов сейчас нужно копировать код тестов. Такой код трудно анализировать и быстро ответить на вопрос - точно ли 8 элементов добавляются и потом удаляются.

Разумно определить те числа, что мы кладем в стек, в отдельном массиве и потом `push` все числа из массива.

### Сворачиваем тесты `push` в цикл

Тесты функции `push` станут короче и понятнее:

```c
Data test[N] = {5, 17, -3, 0, 1, 2, 3, 4};
Data d;
for(int i = 0; i < N; i++) {
    d = test[i];
    printf("push %d :", d);
    push(st, d);
    print(st);      // 5
    printf("empty: %s\n", is_empty(st) ? "YES" : "NO");     // NO
}
```

Еще лучше параноидально проверить, что мы будем класть именно столько чисел, сколько может вместить стек:

```c
    Data test[] = {5, 17, -3, 0, 1, 2, 3, 4};
    // проверили, что чисел столько, сколько размер стека
    assert(sizeof(test) == sizeof(st->a));

```

Чтобы заработала проверка assert нужно не забыть

```c
#include <assert.h>
```

### Сворачиваем тесты на pop в цикл
Аналогично сделаем тесты на pop

```c
    // тесты для pop
    for(int i = 0; i < N; i++) {
        d = pop(st);
        printf("pop %d :", d);
        print(st);
    }
```

Очень много приходится проверять глазами - правильно ли печатают наши тесты. Тесты, которые сами проверяют свою правильность, называются автоматическими. Подумайте, как их можно написать.

### Итого

```c
#include <stdio.h>
#include <assert.h>

// нужно хранить другие данные в стеке?             
// Измени тип хранимых данных в одном месте.
typedef int Data;   

#define N 8
typedef struct {
    Data a[N];      // место для данных
    unsigned int n; // сколько данных хранится
} Stack;

// печать стека
void print(Stack * st) 
{
    for(unsigned int i = 0; i < st->n; i++) 
        printf("%d ", st->a[i]);
    printf("\n");
}

// инициализация стека
void init(Stack * st) {
    st->n = 0;
}    

// добавить данные data в стек
void push(Stack * st, Data data) {
    st->a[st->n] = data;
    st->n ++;
}

// удалить данные с вершины стека, вернуть эти данные
Data pop(Stack * st) {
    return st->a[-- st->n];
}

// проверить, что стек пустой, из него нельзя ничего достать
int is_empty(Stack * st) {
    return st->n == 0;
}

// проверить, что стек полон, в него нельзя ничего положить
int is_full(Stack * st) {
    return st->n == sizeof(st->a) / sizeof(st->a[0]);
}

int main()
{
    Stack stack;            // создаем стек
    Stack * st = &stack;    // указатель на созданный стек

    init(st);
    printf("empty: %s\n", is_empty(st) ? "YES" : "NO"); // YES
    printf("full: %s\n", is_full(st) ? "YES" : "NO");   // NO
    print(st);              // ничего не печатается

    Data test[] = {5, 17, -3, 0, 1, 2, 3, 4};
    // проверили, что чисел столько, сколько размер стека
    assert(sizeof(test) == sizeof(st->a));

    Data d;
    // тесты для push
    for(int i = 0; i < N; i++) {
        d = test[i];
        printf("push %d :", d);
        push(st, d);
        print(st);
        printf("empty: %s\n", is_empty(st) ? "YES" : "NO"); // NO
    }

    printf("full: %s\n", is_full(st) ? "YES" : "NO");   // YES

    // тесты для pop
    for(int i = 0; i < N; i++) {
        d = pop(st);
        printf("pop %d :", d);
        print(st);      // pop -3: 5 17
    }
    printf("empty: %s\n", is_empty(st) ? "YES" : "NO"); // YES
    printf("full: %s\n", is_full(st) ? "YES" : "NO");   // NO

    return 0;
}
```
напечатает:

```c
empty: YES
full: NO

push 5 :5
empty: NO
push 17 :5 17
empty: NO
push -3 :5 17 -3
empty: NO
push 0 :5 17 -3 0
empty: NO
push 1 :5 17 -3 0 1
empty: NO
push 2 :5 17 -3 0 1 2
empty: NO
push 3 :5 17 -3 0 1 2 3
empty: NO
push 4 :5 17 -3 0 1 2 3 4
empty: NO
full: YES
pop 4 :5 17 -3 0 1 2 3
pop 3 :5 17 -3 0 1 2
pop 2 :5 17 -3 0 1
pop 1 :5 17 -3 0
pop 0 :5 17 -3
pop -3 :5 17
pop 17 :5
pop 5 :
empty: YES
full: NO
```

### Стек на основе массива
Вы прочитали и разобрались в коде. Очень полезно после этого закрыть теорию, и повторить те же или чуть другие выкладки самим. Пока читаешь - все понятно, а как начинаешь писать сам, вылезают ошибки.

Реализуйте структуру данных "стек". Для этого при объявленной структуре

```c
#define N 8
typedef int Data;

typedef struct {
    Data a[N];      // место для данных
    unsigned int n; // сколько данных хранится
} Stack;
```

Реализуйте функции работы со стеком:

```c
void stack_init(Stack * s);
void stack_push(Stack * s, Data x);
Data stack_pop(Stack * s);
Data stack_get(Stack * s);
void stack_clear(Stack * s);
void stack_print(Stack * s);
int  stack_size(Stack * s);
int  stack_is_empty(Stack * s);
int  stack_is_full(Stack * s);
```

+ `void stack_init (Stack * s);` - необходимые действия для создания и инициализации стека. (Когда мы создаем локальную переменную, то она не инициализируется 0, т.е. в поле n может лежать любое число.)
+ `void stack_push (Stack * s, Data x);` - кладет число х в стек;
+ `Data stack_pop (Stack * s);` - достает одно число из стека и возвращает его
+ `Data stack_get (Stack * s);` - возвращает число, лежащее на верхушке стека, не изменяя состояния стека;
+ `void stack_clear (Stack * s);` - очищает стек (функция `stack_is_empty` должна вернуть `1`).
+ `void stack_print (Stack * s);` - распечатывает через пробел числа, лежащие в стеке. С самого первого до верхнего. В конце переводит строку.
+ `int stack_size (Stack * s);` - возвращает количество элементов, лежащих в стеке
+ `int stack_is_empty (Stack * s);` - возвращает `1` если стек пуст, иначе возвращает `0`.
+ `int stack_is_full (Stack * s);` - возвращает `1` если стек полон (в него нельзя добавлять данные, это приведет к переполнению), иначе возвращает `0`.

__Посылать ТОЛЬКО реализацию требуемых функций.__ `main` - не надо, определение структуры - не надо, прототипы функций - не надо.

_Цель задачи - приучиться разбивать задачу на этапы и отлаживать каждый этап._

Функция для тестирования кода (рекомендуем закомментировать почти все тесты, кроме первых строк, реализовать нужные для этих тестов функции, отладить их, потом откомментировать еще код для 1-2 функций и проверить для них, пока весь тест не заработает).

>откопировать сюда после отладки задачи

## stack на основе динамического массива

[Видео](https://youtu.be/_JsRngeD4kA)

### Что нужно изменить?
Стек на основе массива просто написать.

Не знаем заранее, какой размер массива нужен в задачах.

Если стек маленький, увеличим N. Если нужно много маленьких стеков, то память используется не эффективно при большом N.

Напишем стек, который сам расширяется при добавлении элементов.

Так же можно написать, чтобы он сам сужался при удалении многих элементов.

Сделаем стек на основе динамического массива.

### Структура стека на основе динамического массива
Так как захват памяти "тяжелая" операция, то постараемся найти баланс между эффективным использованием памяти и частотой вызова `realloc`.

Чтобы не делать на каждый `push` и `pop` `realloc`, будем, как в случае обычного массива, сразу захватывать память. Сколько уже выделено памяти запишем в поле `size`.

![15](/C_for_beginners_Stepik/Pictures/15_09.png)

```c
#define N 10

typedef int Data;
typedef struct {
    Data * a;           // указатель на динамически 
                        // выделенную память
    unsigned int n;     // сколько элементов хранится в стеке
    size_t size;        // на сколько элементов выделена память
} Stack;
```

Заметим, что `size` - это на сколько элементов массива (в штуках) выделена память, а не в `sizeof` и не в байтах.

### Изменение init
Некоторые функции не изменятся, например, `print` и `is_empty`. Посмотрим на остальные функции.

При инициализации стека теперь нужно разобраться с динамической памятью (выделить или написать так, чтобы `realloc` работал без ошибок).

Вариант 1. Сразу выделяем память в `init`:

```c
void init(Stack * st) {
    st->n = 0;
    st->size = N;
    st->a = malloc(st->size * sizeof(Data));
}
```

В этом случае можно передавать желаемый размер данных еще одним аргументом функции `init`.

Вариант 2. а указывает на `NULL`:

```c
void init(Stack * st) {
    st->n = 0;
    st->size = 0;
    st->a = NULL;
}
```

### push
В `push` нужно дописать код, который при попытке переполнить стек выделяет дополнительную память.

Как изменится функция `is_full`?

```c
void push(Stack * st, Data data) {
    if (is_full(st)) {
        // изменение размера можно написать в отдельной функции 
        // set_size(st, new_size)
        st->size += N;
        st->a = realloc(st->a, st->size * sizeof(Data));
    }
    st->a[st->n] = data;
    st->n ++;
}
```

Если стек полон, сколько нужно добавить памяти? Есть разные стратегии:
+ Всегда увеличивать на N элементов.
+ Всегда увеличивать в 2 раза (в 1.5, на треть и тп)

Выберите, какая вам больше нравится или придумайте свою. Оцените ее плюсы и минусы.

### pop
Аналогично можно улучшить `pop`, если уменьшать динамически выделенную память, когда в стеке становится слишком мало данных.

При реализации `pop` придерживайтесь той же стратегии изменения размера памяти, что и в `push`.

### Освобождение памяти
Если запустить тесты на valgrind, то увидим диагностику об утечке памяти. Мы пишем в коде `malloc` и `realloc`, но не пишем `free`.

Напишем функцию `clear` освобождения динамической памяти.

```c
void clear(Stack * st) {
    free(st->a);
    st->a = NULL;
    st->size = 0;
    st->n = 0;
}
```

Почему не обойтись одним `free`?

Во-первых, если кто-то после `clear` решит вновь добавлять данные, стек полностью готов к работе.

Во-вторых, если вызвать два раза подряд `clear`, то дважды вызванное `free` от одно и того же адреса приведет к падению программы, а `free(NULL)` будет работать корректно (ничего не делает, и не падает).

Заметим, что `clear` можно написать используя `init` (вариант 2):

```c
void clear(Stack * st) {
    free(st->a);
    init(st);
}
```

### create и destroy
Если начали выделять память динамически, то стоит создание стека полностью перенести в функцию `create`:

```c
Stack * st = create();
```

То есть выделять память не только под динамический массив (один `malloc`), но и под саму структуру `Stack` (еще один `malloc`):

```c
Stack * create() {
    Stack * st = malloc(sizeof(Stack));
    init(st);
    return st;
}
```
Тогда и `destroy` должен содержать такое же количество `free`:

```c
Stack * destroy(Stack * st) {
    if (st != NULL) {
        free(st->a);
        free(st);
    }
    return NULL;
}
```

Внимание, сначала освобождаем память, на которую указывает `st->a`, а потом только освобождаем память `st` (в которой записано поле `a`), а не наоборот.

Не стоит сначала сносить дом, а потом искать в нем на столе любимую чашку.

Почему возвращаем `Stack *`? Такой вызов функции можно сделать больше одного раза:

```c
st = destroy(st);
```

Иначе:

```c
destroy(st);    // OK
destroy(st);    // Segmentation fault
```

"Контрольный выстрел" не всегда делает лучше.

### stack_31 Стек на основе динамического массива
Повторение - мать учения. Попробуйте не подглядывая в теорию реализовать функции для работы со стеком.

Реализуйте структуру данных "стек", который бы был защищен от переполнения. Размер стека должен быть ограничен только размером доступной оперативной памяти.

```c
typedef int Data;

typedef struct {
    int n;
    int size;
    Data * a;
} Stack;
```

+ `a` - динамический массив, в котором храним данные стека,
+ `size` - размер выделенной памяти для данных стека (т.е. размер динамического массива `a` в ячейках, а не байтах).
+ `n` - номер первой пустой ячейки массива.

```c
Stack * stack_create(int size);
void stack_push(Stack * s, Data x);
Data stack_pop(Stack * s);
Data stack_get(Stack * s);
void stack_print(Stack * s);
int  stack_size(Stack * s);
int  stack_is_empty(Stack * s);
void stack_clear(Stack * s);
Stack * stack_destroy(Stack * s);
Stack * stack_create(int size);
```

+ `Stack * stack_create (int size);` - необходимые действия для создания и инициализации стека размером size ячеек. Теперь эта функция полностью создает и инициализирует стек. Заметьте, что у функции изменились аргументы и тип возвращаемого значения. Гарантируется, что в тестах она будет вызвана, и вызвана единственный раз перед дальнейшей работой со стеком.
+ `void stack_push (Stack * s, Data x);` - кладет число х в стек.
+ `Data stack_pop (Stack * s);` - достает одно число из стека и возвращает его.
+ `Data stack_get (Stack * s);` - возвращает число, лежащее на верхушке стека, не изменяя состояния стека.
+ `int stack_is_empty (Stack * s);` - возвращает 1, если стек пуст; 0 - в противном случае.
+ `void stack_print (Stack * s);` - распечатывает через пробел числа, лежащие в стеке. С самого первого до верхнего. В конце переводит строку.
+ `int stack_size (Stack * s);` - возвращает количество элементов, лежащих в стеке.
+ `void stack_clear (Stack * s);` - очищает стек, не разрушая его.
+ `Stack * stack_destroy (Stack * s);` - освобождает память. Всю память, занятую стеком, а не часть памяти. Возвращает NULL.

Посылать только реализацию функций.

Функцию `main`, объявление структуры и прототипы функций посылать НЕ нужно.

Пример кода (в комментариях написано что будет выведено на печать)

```c
void test0()
{
    Stack * sp = stack_create(3);

    printf("is_empty=%d\n", stack_is_empty(sp));    // is_empty=1
    printf("size=%d\n", stack_size(sp));            // size=0

    stack_push(sp, 5);
    stack_push(sp, 19);
    stack_push(sp, -2);
    stack_print(sp);                                // 5 19 -2

    stack_push(sp, 27);
    stack_print(sp);                                // 5 19 -2 27

    printf("is_empty=%d\n", stack_is_empty(sp));    // is_empty=0
    printf("size=%d\n", stack_size(sp));            // size=4

    x = stack_pop(sp);
    printf("x=%d\n", x);                            // x=27

    x = stack_pop(sp);
    printf("x=%d\n", x);                            // x=-2

    stack_print(sp);                                // 5 19

    while (!stack_is_empty(sp)) {
        x = stack_pop(sp);
        printf("x=%d\n", x);
        stack_print(sp);
    }
                                                    // x=19
                                                    // 5
                                                    // x=5
                                                    // пустая строка

    if (NULL == stack_destroy(sp))
        printf("end\n");                           // end
}
```

## stack на основе динамического массива (1 malloc)

[Видео](https://youtu.be/eDbDLyEkI8c)

### Как использовать память эффективнее
В классическом варианте стека на основе динамического массива захватываются 2 участка динамической памяти. Это разные участки. Обычно фактический размер выделенной памяти на каждый `malloc` кратен `1024`. То есть при большом количестве маленьких стеков, памяти будет захвачено существенно больше, чем нужно.

Один из вариантов - захватывать и память под структуру, и память под данные единым `malloc`. Переделаем для этого структуру.

![15](/C_for_beginners_Stepik/Pictures/15_10.png)

Поле `a` обязано быть самым последним. Его размер 1 (или 0, если мы включили GNU extension).

```c
typedef struct {
    unsigned int n;     // сколько элементов хранится в стеке
    size_t size;        // на сколько элементов выделена память
    Data a[1];          // обязано быть последним полем!!!
} Stack;
```

Есть массив `a`. `a[0]` - единственный "настоящий" элемент массива. Если мы выделили памяти больше, то к "излишку" памяти мы можем обратиться как `a[1]`, `a[2]` и так далее.

### create
Выделим при создании для данных память на N элементов:

```c
Stack * create() {
    Stack * st = malloc(sizeof(Stack) + N * sizeof(Data));
    st->size = N;
    st->n = 0;
    return st;
}
```

На самом деле память выделена для `N+1` данного, но я лучше потеряю несколько байт, чем буду усложнять код.

### push, pop
Заметим, что каждый перезахват памяти изменяет указатель на нее. То есть в функциях `push` и `pop` изменяется адрес начала стека, то есть нельзя в них просто передать копию `Stack * st`. Нужно или вернуть новое значение, используя

```c
st = push(st, d);   // st может указывать на новую область памяти
```

или, так как st изменяется, нужно передавать указатель на нее:

```c
push(&st, d);
```

Прототип должен быть:
```c
Stack * push(Stack * st, Data d);   // или вернуть новое значение
void push(Stack ** pst, Data d);    // или указатель на указатель на стек
```

Функция `pop` должна передавать значение `Data` вне функции. То есть или возвращать, или можно передавать в функцию `Data * pd` и по указателю заполнять значение.

```c
Data pop(Stack ** pst); // или возвращаем как обычно
Stack * pop(Stack * st, Data *pd);  // или значение сверху стека записываем по указателю pd
```

## Стек. Итоги

Часть 1 (теория)

[Видео](https://youtu.be/settbIgrmeM)

Часть 2 (реализация)

[Видео](https://youtu.be/Z9uJsF9xXz8)

### Структура данных стек

+ Стек - последний пришел, первый вышел. Стопка тарелок, пирамидка.
+ push - добавить элемент в стек.
+ pop - извлечь элемент из стека

### Разные варианты стеков
Стек на основе массива (не расширяем, не сужаем)

![15](/C_for_beginners_Stepik/Pictures/15_08.png)

Стек на основе динамического массива:

![15](/C_for_beginners_Stepik/Pictures/15_09.png)

Стек на основе динамического массива единой областью памяти:

![15](/C_for_beginners_Stepik/Pictures/15_10.png)

### Реализация стека на основе массива

```c
#include <stdio.h>
#include <assert.h>

// нужно хранить другие данные в стеке?             
// Измени тип хранимых данных в одном месте.
typedef int Data;   

#define N 8
typedef struct {
    Data a[N];      // место для данных
    unsigned int n; // сколько данных хранится
} Stack;

// печать стека
void print(Stack * st) 
{
    for(unsigned int i = 0; i < st->n; i++) 
        printf("%d ", st->a[i]);
    printf("\n");
}

// инициализация стека
void init(Stack * st) {
    st->n = 0;
}    

// добавить данные data в стек
void push(Stack * st, Data data) {
    st->a[st->n] = data;
    st->n ++;
}

// удалить данные с вершины стека, вернуть эти данные
Data pop(Stack * st) {
    return st->a[-- st->n];
}

// проверить, что стек пустой, из него нельзя ничего достать
int is_empty(Stack * st) {
    return st->n == 0;
}

// проверить, что стек полон, в него нельзя ничего положить
int is_full(Stack * st) {
    return st->n == sizeof(st->a) / sizeof(st->a[0]);
}

int main()
{
    Stack stack;            // создаем стек
    Stack * st = &stack;    // указатель на созданный стек

    init(st);
    printf("empty: %s\n", is_empty(st) ? "YES" : "NO"); // YES
    printf("full: %s\n", is_full(st) ? "YES" : "NO");   // NO
    print(st);              // ничего не печатается

    Data test[] = {5, 17, -3, 0, 1, 2, 3, 4};
    // проверили, что чисел столько, сколько размер стека
    assert(sizeof(test) == sizeof(st->a));

    Data d;
    // тесты для push
    for(int i = 0; i < N; i++) {
        d = test[i];
        printf("push %d :", d);
        push(st, d);
        print(st);
        printf("empty: %s\n", is_empty(st) ? "YES" : "NO"); // NO
    }

    printf("full: %s\n", is_full(st) ? "YES" : "NO");   // YES

    // тесты для pop
    for(int i = 0; i < N; i++) {
        d = pop(st);
        printf("pop %d :", d);
        print(st);      // pop -3: 5 17
    }
    printf("empty: %s\n", is_empty(st) ? "YES" : "NO"); // YES
    printf("full: %s\n", is_full(st) ? "YES" : "NO");   // NO

    return 0;
}
```

## Стек. Типичные ошибки

### `stack_1` стек на основе массива из 100 элементов
Если у вас не работает стек на основе обычного массива, прочитайте теорию еще раз.
+ [print + init](#stack---реализация-на-основе-массива-print)
+ [push + pop](#stack---реализация-на-основе-массива-push-pop)
+ [is empty, is full](#stack---реализация-на-основе-массива-is_empty-is_full)

### stack_31 - стек на основе динамического массива

#### Проблема 1. Не прочитал теорию
Надо прочитать или посмотреть.

#### Проблема 2. push не изменяет размер выделенной памяти
Взят push из предыдущей задачи. Это неправильно. Нужно проверять, не полон ли стек и если полон, увеличивать его размер. Используйте для этого realloc.

При этом иногда промахиваются на 1 ячейку стека. Проверьте себя. Пусть стек размера 0. Сколько вы хотели, чтобы было в вашем стеке после расширения и сколько ячеек стека получилось?

#### Проблема 3. size++
Стек написан так, что приходится делать realloc на каждый push. Выделение памяти - это длительная операция. Для увеличения скорости работы стека стоит делать ее пореже.

Если у вас стек выделяется ровно под то количество данных, которое сейчас там хранится, увеличивая в realloc ровно на 1 ячейку, то это не оптимально по времени работы.

Если увеличивать на 1, то хватит старого поля n. Если хотим писать быстрый код, то вводим дополнительное поле в структуру:
+ n - сколько элементов хранится в стеке,
+ size - для скольки элементов выделена память в стеке.

Если у вас всегда size равна n, то смысла в поле size нет.

Как увеличивать размер стека? Можно на фиксированное количество ячеек, например 10, или в 2 раза. Числа вы можете установить любые.

Все эти числа должны быть определены через #define

#### Проблема 4. Дублирование кода
Дублируется код добавления нового в push в случае расширения стека и без расширения стека.

Вынесите его "за скобки" (вне блока if .. else).

Возможно, у вас исчезнет блок else.

#### Может, поменять местами?
Если у вас код вида

```c
st->n++;
st->a[st->n - 1] = data;
```
может, лучше поменять строки местами и избавиться от -1?

```c
st->a[st->n] = data;
st->n++;
```
Можно написать и так:

```c
st->a[st->n++] = data;
```

### Парные скобки stack_skobki

Задачу стоит написать так, чтобы добавление новой пары скобок сводилось к добавлению `2` символов в код, а не к многим строкам кода. Меньше кода - меньше внесем ошибок. Через некоторое время мы забудем где именно нужно править код для новой пары.

Как задать пары скобок?

Вариант 1:
```c
const char * bra_open =  "({[<";
const char * bra_close = ")}]>";
```

Вариант 2:
```c
const char * bra[] = {"()", "{}", "[]", "<>", NULL};
```

`NULL` в конце, чтобы удобнее перебирать в цикле элементы массива, а не вычислять (или писать магические числа вида i < 4).

По одному варианту можно написать создание другого варианта. Поэтому рассмотрим вариант 1.

#### Это открывающая скобка?
Плохо (хотя код работает!):

```c
if ( c == '(' || c == '{' || c == '[' || c == '<')
```

Лучше:
```c
if (strchr(bra_open, c) != NULL)
```

#### `strstr` будет работать?

Вообще будет. Так - нет:

```c
char c = '}';   // на этом месте может быть любой вариант чтения символа


if (strstr(bra_open, &c) != NULL) // valgrind: invalid read
```

В `strstr` второй аргумент строка. Строка - это не просто "что-то типа `char *`". Строка должно заканчиваться `\0`. По этому символу все функции определяют конец строки. Нет признака конца строки, идем дальше и выходим за границы данных.

#### Это корректная пара скобок?
```c
char * p = strchr(bra_open, c);
```

В `p` или `NULL`, или указатель на скобку с. Вспомним адресную арифметику.


`char t = bra_open + 2` - t указатель на [.

`t - bra_open` - это 2.

#### while((c = getchar()) != EOF) - читаем по 1 символу

Не надо так. `getchar` - это медленно.

Используйте [getline](/C_for_beginners_Stepik/11.md#чтение-строки-с-выделением-динамической-памяти) и прочитайте сразу всю строку.

#### Если не скобка

При переборе строки у нас могут быть 3 ситуации:
+ открывающая скобка - кладем ее в стек.
+ закрывающая скобка - разбираемся, есть ли ей пара
+ не скобка

У нас в задаче можно сразу заканчивать алгоритм, если не скобка. Потому что в задаче мы гарантировали, что будут скобки без пробелов и прочих символов. Поэтому можно сразу завершать цикл, как только встретили не скобку.

В реальной жизни мы можем проверять скобки в арифметическом выражении, например, `[(2+3)*(4+5) + 10]/5`. Тогда нескобки стоит пропускать и идти по алгоритму дальше. Выходить при окончании строки (или когда нашли, что строка не корректная).

#### pop при пустом стеке
У вас еще нет проверки? Тогда строка `)(` или `()>` приводит к `pop` из пустого списка.

Не знаете есть эта проблема или нет? Вставьте в функцию `pop` отладочную печать, которая будет печатать поле `n`.

#### create + destroy
Если при создании или расширении стека вы выделяли память, то не забудьте освобождать ее при окончании работы алгоритма.

Если у вас в функции несколько `return`, то перед каждым память должна быть освобождена.

### Обратная польская запись
Задача сформулирована так, что самый простой вариант чтения и разбора должен работать. Числа однозначные.

Про магические числа "тип токена" и почему лучше enum

##  Стек. Задачи на использование

### stack_skobki Правильная скобочная последовательность - 2
Пусть скобочные структуры состоят из четырех различных пар скобок: `()` `[]` `{}` `<>` Открывающая и закрывающая скобки должны быть одного типа. Ваша задача - определить правильная ли скобочная структура.

Пустая последовательность является правильной. Если `A` – правильная, то последовательности `(A)`, `[A]`, `{A}`, `<A>` – правильные. Если `A` и `B` – правильные последовательности, то последовательность `AB` – правильная.

Входные данные
Последовательность указанных скобок без пробелов между ними.

Выходные данные
`YES` в случае если структура правильная и `NO`, если неправильная.

Последовательность | Правильная?
-|-
{) | NO
[({<>})] | YES
)( | NO
()() | YES
[(]) | NO

Автор: Малых Антон

https://stepik.org/lesson/657369/step/1?unit=654470

### stack_postfix Постфиксная запись
Решать одну задачу из двух, или эту, или следующую. На ваш выбор. Они одинаковые.

В постфиксной записи (или обратной польской записи) операция записывается после двух операндов. Например, сумма двух чисел A и B записывается как `A B +`. Запись `B C + D *` обозначает привычное нам `(B + C) * D`, а запись `A B C + D * +` означает `A + (B + C) * D`. Достоинство постфиксной записи в том, что она не требует скобок и дополнительных соглашений о приоритете операторов для своего чтения.

В единственной строке записано через пробелы выражение в постфиксной записи, содержащее однозначные числа и операции `+`, `-`, `*`. Запись оканчивается знаком равенства `=`.

Напечатать значение этого выражения.

https://stepik.org/lesson/657369/step/2?unit=654470

### stack_postfix_log Постфиксная запись логического выражения
В постфиксной записи (или обратной польской записи) операция записывается после двух операндов. Например, сумма двух чисел `A` и `B` записывается как `A B +`. Запись `B C + D *` обозначает привычное нам `(B + C) * D`, а запись `A B C + D * +` означает `A + (B + C) * D`. Достоинство постфиксной записи в том, что она не требует скобок и дополнительных соглашений о приоритете операторов для своего чтения.

Аналогично можно записать логическое выражение. `A!BC|D&|` означает `!A|(B|C)&D`, где логические функции записываются как `! (NO), & (AND), | (OR)`.

В единственной строке записано (без пробелов!) логическое выражение в постфиксной записи, содержащее числа `0` или `1` и операции `&`, `|`, `!`. Запись оканчивается знаком равенства `=`

Напечатать значение записанного выражения.