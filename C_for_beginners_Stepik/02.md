# Введение

## Содержание
+ [2.1 Что такое программирование](#21-что-такое-программирование)
    + [Представление данных в компьютере](#представление-данных-в-компьютере)
    + [Hello, world на языке Си](#hello-world-на-языке-си)
    + [Программирование](#программирование)
    + [Этапы сборки программы](#этапы-сборки-программы)
    + [Как собрать исполняемый модуль](#как-собрать-исполняемый-модуль)
+ [2.2 Файловая система Linux](#22-файловая-система-linux)
    + [Создадим файл hello.c с текстом программы](#создадим-файл-helloc-с-текстом-программы)
    + [Разница между путями Windows и Linux](#разница-между-путями-windows-и-linux)
    + [Абсолютный и относительный путь](#абсолютный-и-относительный-путь)
+ [2.3 Командная строка Linux](#23-командная-строка-linux)
    + [Команды](#команды)
        + [pwd - Print Working Directory](#pwd---print-working-directory)
        + [cd - Change directory](#cd---change-directory)
        + [ls - показать содержимое директории](#ls---показать-содержимое-директории)
        + [cat - показать содержимое файла](#cat---показать-содержимое-файла)
    + [Права доступа](#права-доступа)
+ [2.4 gcc](#24-gcc)
    + [Собрать программу](#собрать-программу)
    + [Запустить программу](#запустить-программу)
    + [Сделаем проще](#сделаем-проще)
    + [Сделаем надежнее](#сделаем-надежнее)
    

# 2.1 Что такое программирование

## Представление данных в компьютере
Компьютер всю информацию хранит в себе в виде чисел. Текст, музыка, изображения, видео - все закодировано в виде чисел.

Команды компьютера тоже числа. Других компьютер не понимает. Раньше программировали только в этих числах (машинных кодах). Программа «Hello, world!» для процессора архитектуры x86 (ОС MS DOS, вывод при помощи BIOS прерывания int 10h) в шестнадцатеричном представлении:

```c
BB 11 01 B9 0D 00 B4 0E 8A 07 43 CD 10 E2 F9 CD 20 48 65 6C 6C 6F 2C 20 57 6F 72 6C 64 21
```

Человек не компьютер. Ему сложно думать числами. Поэтому придумали язык ассемблера и написали программу-транслятор, который переводил с языка ассемблера в машинные коды. Ассемблер называют язык низкого уровня. Он ближе к компьютеру, чем к человеку.

Эта же программа "Hello, world!", но на языке ассемблера. После ; пишут комментарий. Комментарий не переводится в машинный код. Его писали для других людей, чтобы было понятно что делает код.

```c
XXXX:0100     mov     bx, 0111h       ; поместить в bx смещение строки HW
XXXX:0103     mov     cx, 000Dh       ; поместить в cx длину строки HW
XXXX:0106     mov     ah, 0Eh         ; поместить в ah номер функции прерывания 10h
XXXX:0108     mov     al, [bx]        ; поместить в al значение ячейки памяти, адрес которой находится в bx
XXXX:010A     inc     bx              ; перейти к следующему байту строки (увеличить смещение на 1)
XXXX:010B     int     10h             ; вызов прерывания 10h
XXXX:010D     loop    0108            ; уменьшить cx на 1 и, если результат≠0, то перейти по адресу 0108
XXXX:010F     int     20h             ; прерывание 20h: завершить программу
XXXX:0111 HW  db      'Hello, World!' ; строка, которую требуется напечатать
```

Чуть понятнее. mov от слова move, inc от слова increment. Программировать еще тяжело.

Над ассемблером пишут еще один язык, который ближе и понятнее человеку. Называют это язык высокого уровня. Язык С (читают "язык Си") - один из языков высокого уровня.

## Hello, world на языке Си

Программа, которая печатает Hello, world! на языке С. Потом разберем подробно что делает каждая строка.

```c
#include <stdio.h>              // использовать стандартные функции ввода-вывода


int main()                      // здесь начинается программа
{
    printf("Hello, world!\n");  // печать строки Hello, world!


    return 0;                   // конец программы
}
```

Уже почти простой английский язык. include (содержать в себе), main (главный), print (печатать), return (вернуть).

Эту программу переводят на язык машинных кодов специальной программой и полученный исполняемый модуль можно запустить (run, execute).

От // до конца строки расположен комментарий. Его не переводят. Он для человека. В комментариях мы будем писать объяснения что делает код.

## Программирование

__Программирование__ - это запись решения задачи на специальном формальном языке, который понимает компьютер, например Си. Вы переводите решение задачи с языка, на котором вы думаете (например, русского), на язык Си.

Вы уже знаете несколько языков и умеете переводить. Учили в школе английский, немецкий, французский или учили перед поступлением в институт русский. Любой язык программирования проще, чем русский или английский.

+ В языке программирования мало слов. Они называются ключевые слова.
+ Язык формальный. То есть строгие правила как писать на языке Си. Правил тоже мало. Никаких исключений из правил. Сравните с русским "после Ц пишется И, исключения: цып, цыпочка, цыпленок, цыган..."

[Шпаргалка по языку С на листе А4](https://stepik.org/media/attachments/lesson/308220/c_help1.pdf) - это все, что нужно выучить по языку за курс. Выглядит меньше, чем учебник по математике.

Ключевые слова языка Си

```c
auto  continue else   for  long     signed switch  void
break default  enum   goto register sizeof typedef while
case  do       extern if   return   static union
char  double   float  int  short    struct unsigned
```

## Этапы сборки программы

Рассмотрим, как из программы на языке Си, которая написана в файле `hello.c`, получается файл `hello.exe`.

Файл `hello.exe` можно запустить и он напечатает `Hello, world!`

![01](/C_for_beginners_Stepik/Pictures/01_01.svg)

__Preprocessor (препроцессор)__

Препроцессор (preprocessor) в файле `hello.c` выполняет свои директивы (команды).

+ Команды препроцессора - это поиск текста и замена его на другой текст.
+ `#include <stdio.h>` - команда препроцессора `include` и ее аргумент `<stdio.h>`.
    + Эта строка заменяется на содержимое файла stdio.h
+ Команды препроцессора начинаются с #.
+ Полученный текст можно читать (с трудом). Результат не хранят и обрабатывают дальше.

__Compiler (компилятор)__

Компилятор (compiler) переводит программу в объектный модуль (человеку трудно понять его текст). Обычно это файл с расширением `.o` на UNIX и `.obj` на Windows. Иногда данные не сохраняют в файл, а обрабатывают дальше.<br>
Большая программа может быть написана в нескольких `.c` файлах. Из одного `.c` получают один объектный модуль.

__Linker (редактор связей)__

+ Редактор связей (linker) связывает в единый исполняемый модуль все объектные модули и необходимые библиотеки.

Исполняемый модуль содержит машинные команды. Набор машинных команд зависит от архитектуры компьютера и операционной системы. hello.exe созданный в командной строке Unix не будет исполняться в командной строке Windows и наоборот.

В этом уроке мы уже будем использовать библиотеку math для вызова стандартных математических функций языка Си.

## Как собрать исполняемый модуль
Исполняемый модуль мы будем собирать в командной строке. Для этого научимся работать в ней.

# 2.2 Файловая система Linux

## Создадим файл hello.c с текстом программы

В текстовом редакторе или среде разработке, которые вы установили, создайте файл `hello.c` и сохраните его на диск. Запомните или запишите путь, где лежит файл.

Не знаете куда вы его положили? Обычно в любых редакторах или IDE в меню File (Файл) есть пункт Save As (Сохранить как). Сохраните куда вам нужно.

Удобнее, если в именах директорий по пути к файлу будут только латинские буквы и не будет пробелов.

Откопируйте или перепишите в файл текст программы, которая печатает Hello, world!:

```c
#include <stdio.h>              // использовать стандартные функции ввода-вывода


int main()                      // здесь начинается программа
{
    printf("Hello, world!\n");  // печать строки Hello, world!


    return 0;                   // конец программы
}
```

Цель:
+ запустить терминал,
+ перейти в директорию с этим файлом,
+ скомпилировать программу,
+ запустить полученный файл hello.exe.

Важно! Расширение файла должно быть .c (латинская буква c)

Например, я работаю в Windows и мой файл лежит в C:\work\stud\conline\1int\hello.c

Ваш файл может лежать в другом месте и называться по-другому.

Задание: Создайте файл с текстом программы. Запишите, где он находится.

## Разница между путями Windows и Linux

Путь в Windows: C:\work\stud\conline\1int\hello.c
+ есть диски C, D, и так далее, сколько установили. От диска начинается полный путь.
+ директории разделены \

Путь в Linux: /home/taty/conline/1int/hello.c
+ нет дисков, путь начинается от корня /
+ директории разделены /

Напоминаем, диск С Windows в wsl находится в /mnt/c

Фрагмент дерева директорий и файлов в Linux (WSL):

```c
/
├── bin
│   ├── cd
│   ├── ls
│   ├── pwd
│   ...
├── home
│   ├── tatyd                               <-- моя домашняя директория
│   ...
├── mnt
│   ├── c
│   │   ├── Users
│   │   │   ├── tatyd                       <-- я сейчас тут
│   │   │   └── другие директории и файлы
│   │   └── work
│   │       └── stud
│   │           └── conline
│   │               ├── 1int                <-- нужно перейти сюда
│   │               │   └── hello.c         <-- файл с текстом программы
│   │               ├── 2func
...
```

## Абсолютный и относительный путь

__Абсолютный путь__
+ В Linux начинается с /

Примеры абсолютного пути в Linux:
```
/home/taty/conline/1int/hello.c
/mnt/c/work/stud
```

В Windows с \ или с имени диска
Примеры абсолютного пути в Windows:

```
C:\work\stud\conline\1int\hello.c
\work\stud\conline\1int\hello.c
```

Относительный путь

Задается относительно текущей директории (мы в ней находимся).
+ .. - родительская директория (на 1 директорию вверх)
+ . - текущая директория

Примеры относительного пути в Linux:

```
hello.c
work
conline/1int/hello.c
./a.out
..
../../img
```

Примеры относительного пути в Windows:

```
hello.c
work
conline\1int\hello.c
.\a.exe
..
..\..\img
```

# 2.3 Командная строка Linux

## Команды

Команда | Что делает | Мнемоника | Сокращение от
-|-|-|-
pwd | печатает путь к текущей директории | где я? | print working directory
ls | печатает содержимое текущей директории | что тут? | list
cd директория | переходит в указанную директорию | иди на | change directory
cat файл | выводит на экран содержимое файла | покажи	

Рекомендуем на первой странице вашей тетради записывать команды Linux. Записывайте команды, которые мы выучим. Оставьте пустой лист. Туда будете записывать новые команды.

Применение этих команд покажем в видео и опишем далее


### pwd - Print Working Directory
Мы знаем куда идти, где лежит файл.

Пусть это в Windows C:\work\stud\conline\1int\hello.c, значит нужно идти в /mnt/c/work/stud/conline/1int/hello.c

Где мы сейчас?

Команда `pwd` печатает путь к текущей директории. Имя команды - это сокращение от print working directory.

В примерах $ - приглашение на ввод. Его не нужно писать.

Напишите в командной строке
```bash
$pwd
```

У меня напечатает.

```bash
/mnt/c/Users/tatyd
```

У вас будет другой путь.

Задание: запустите в терминале команду pwd

### cd - Change directory
Посмотрим куда идти:

```
/
├── mnt
│   ├── c
│   │   ├── Users
│   │   │   ├── tatyd                       <-- я сейчас тут
│   │   │   └── другие директории и файлы
│   │   └── work
│   │       └── stud
│   │           └── conline
│   │               ├── 1int                <-- нужно перейти сюда
│   │               │   └── hello.c         <-- файл с текстом программы
│   │               ├── 2func
```

Изменить текущую директорию можно командой cd путь

+ cd - команда,
+ её аргумент путь - куда перейти, путь может быть относительным или абсолютным.

Аргументы пишем через пробел. Между командой и аргументом тоже пробел.

Пойдем из /mnt/c/Users/tatyd в /mnt/c/work/stud/conline/1int. Изменяем 1 директорию. Проверяем где мы командой pwd

```bash
$pwd
/mnt/c/Users/tatyd
$cd ..
$pwd
/mnt/c/Users
$cd ..
$pwd
/mnt/c
$cd work/
$pwd
/mnt/c/work
$cd stud/
$pwd
/mnt/c/work/stud
```

Вместо этого можно было перейти по абсолютному пути

```bash
$cd /mnt/c/work/stud
```

или записать в относительный путь сразу несколько директорий:
```bash
$cd ../../work/stud
```

Если в пути есть пробелы, пишите путь в " или в ' кавычках. Или экранируйте пробел символом \

+ cd "/mnt/c/Users/Derbysheva Tatiana"
+ cd '/mnt/c/Users/Derbysheva Tatiana'
+ cd /mnt/c/Users/Derbysheva\ Tatiana

cd без аргумента переходит в домашнюю директорию пользователя

```bash
$cd
$pwd
/home/tatyd
```

Задание: попробуйте перейти в директорию с файлом hello.c

### ls - показать содержимое директории
Сложно запомнить где лежат ваши программы? Будем смотреть что лежит в директории и куда можно перейти.

Посмотреть содержимое текущей директории:

```bash
$ls
```

Можно указать путь к директории или файлу в параметрах. Посмотреть содержимое директории /mnt/c/work/stud/conline. Путь может быть относительным или абсолютным:

```bash
$ls /mnt/c/work/stud/conline
1  1int
```

Параметр -l (от слова long) покажет больше информации о содержимом директории:

```bash
$ls -l conline
total 0
drwxrwxrwx 1 tatyderb tatyderb 512 Sep 14  2020 1
drwxrwxrwx 1 tatyderb tatyderb 512 Jul 19 19:12 1int
```

Задание: Убедитесь, что в вашей текущей директории есть файл hello.c

## Права доступа
drwxrwxrwx описывает права доступа (permissions) к директории или файлу.

+ d или - - директория или файл
+ права доступа пользователя, группы и всех остальных:
    + r или - - может или нет читать (Read)
    + w или - - может или нет писать (Write)
    + x или - - может или нет исполнять (eXecute)

![02](/C_for_beginners_Stepik/Pictures/02_01.webp)

Чтобы в директории можно было создать файл, у вас должны быть права на запись в этой директории.

Права на доступ к объекту можно изменить командой chmod

Разрешить всем изменять файл hello.c:

```
$chmod +w hello.c
```

### cat - показать содержимое файла
Проверьте содержимое файла hello.c

```bash
$cat hello.c
```

Должно напечатать текст программы.

Если текста нет, то скорее всего вы не сохранили файл hello.c в текстовом редакторе. Вернитесь в текстовый редактор и сохраните файл. Потом перейдите в терминал и повторите команду `cat`

`Alt+TAB` - быстро переходить между приложениями. Например, между терминалом и текстовым редактором.

В терминале стрелки вверх и вниз на клавиатуре - перейти на предыдущую или следующую команду в истории команд.

В терминале `Ctrl+R` и набрать часть команды - поиск в истории команд терминала.

Часть файловой системы выглядит так:

```
/Stepik-API
├───examples
│   ├───external-reports
│   │   ├───common
│   │   ├───cache
│   │   ├───latex
│   │   │   ├───default
│   │   │   ├───default-dropout
│   │   │   │   ├───common
│   │   │   │   └───generated
│   │   │   ├───default-item
│   │   │   │   ├───common
│   │   │   │   └───generated
│   │   │   └───default-video
│   │   │       ├───common
│   │   │       └───generated
│   │   ├───library
│   │   └───pdf
│   └───google-scripts
└───tests
```

Какая директория будет текущей после выполнения команд:

```bash
$pwd
/Stepik-API/tests
$cd ..
$cd examples/external-reports/pdf
$ls ..
common cache latex library pdf
$cd ../common
```

```bash
/Stepik-API/examples/external-reports/common
```

# 2.4 gcc

## Собрать программу
+ В текущей директории есть файл hello.c
+ В этом файле текст программы на языке Си
+ Соберем исполняемый модуль - файл hello.exe
+ и выполним программу.

В командной строке напишем:
```bash
$gcc -o hello.exe hello.c
```

+ gcc - это программа (сокращение от GNU C compiler)
+ последний аргумент - путь к файлу с текстом программы,
+ параметр -o файл - в какой файл записать (output) полученную программу, мы придумали, что название файла hello.exe, вы можете придумать любое название файла.
    + В Linux исполняемые файлы принято делать без расширения, просто hello

```bash
$gcc -o hello hello.c
```

Обратите внимание, после gcc пишем пробел, между аргументами пишем пробел.

Если у вас нет ошибок, то в текущей директории появится файл hello

```bash
$ls
hello.c
$gcc -o hello hello.c
$ls
hello  hello.c
```
## Запустить программу
Раньше мы запускали в терминале уже написанные программы pwd, ls, gcc и другие.

Запустим собранную нами программу hello.

```bash
$hello
```

У меня ошибка Command 'hello' not found. Почему? Файл hello в текущей директории:

```bash
$ls
hello   hello.c
```

Когда мы пишем название команды, она ищется только в некоторых директориях. Список этих директорий хранится в переменной окружения `Path`. Для безопасности, обычно в этом списке нет текущей директории.

Значит нужно явно указать, что запускаем программу hello и она лежит в текущей директории. Путь к команде начинается с точки (. - текущая директория):

```bash
$./hello
Hello, world!
```

Заработало!

## Сделаем проще

За урок нужно будет написать около 10 программ. Текст новой программы мы будем писать в новом файле. Новые задачи бывают похожи на старые и мы будем смотреть, как мы решали раньше.

Можно при компиляции не указывать аргумент -o. Тогда будет создан исполняемый файл с именем a.out

Расширение исполняемого файла не обязательно должно быть .exe, оно может быть любое. Нужны только права на исполнение.

Скомпилируем и запустим в файл по умолчанию:

```bash
$gcc hello.c
$./a.out
Hello, world!
```

Не забываем указывать, что a.out лежит в текущей директории. Пишем ./a.out

## Сделаем надежнее

Компилятор может подсказывать, где у вас в программе может быть логическая ошибка и какое место ему кажется подозрительным.

Для этого компилируемся с аргументами -Wall -Wextra. W - от слова warning (предупреждение). Просим показывать все предупреждения и еще больше предупреждений!

```bash
$gcc -Wall -Wextra hello.c
$./a.out
Hello, world!
```

Запишите эту строку компиляции и запуска программы в тетрадь.