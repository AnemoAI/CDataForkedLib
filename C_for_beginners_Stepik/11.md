#  Строки


## Хранение строк

[Video](https://youtu.be/cT5GELfOwsE)

### Что такое строка
__Строка__ - это последовательность символов, оканчивающихся символом `\0`

В языке С нет специального типа для работы со строками. Для этого используются массивы с элементами типа `char` и указатели `char *`.

```c
char a[10] = {'a', 'b', '\0'};
char * a2 = "hello";
```

__Символьная__ (или литеральная) константа в языке С - это один символ, заключенный в __одинарные кавычки__ . Например, 'q' или '0'. Имеет тип int и значение, равное ASCII коду этого символа. Численное значение константы '0' равно 48.

__Строковая константа__ - это ноль или более символов в двойных кавычках. Например, "Hello". Строковая константа имеет тип `const char *`.

### Массивы с элементами типа char
Это одинаковые массивы из 6 элементов.

```c
char b1[6] = {'w', 'o', 'r', 'l', 'd', '\0'};
char b2[] = {'w', 'o', 'r', 'l', 'd', '\0'}; // размер массива вычисляется автоматически
char b3[] = "world"; 
```

В последнем случае стандарт разрешает писать строковую константу, не набор символьных констант для инициализации каждого элемента массива.

Массивы b1, b2, b3 хранятся в памяти одинаково - единым куском памяти.

![11](/C_for_beginners_Stepik/Pictures/11_01.png)

### Массив или указатель?
Эти строки хранятся в памяти по-разному:

```c
char s1[] = "world";    // массив из 6 символов
char * s2 = "world";    // 1 указатель на char, указывает на строковую константу "world"
```

![11](/C_for_beginners_Stepik/Pictures/11_02.png)

+ sizeof(s1) == 6
+ sizeof(s2) == sizeof(void*) и равен размеру любого другого адреса, сколько конкретно - зависит от архитектуры (скорее всего 4 для 32-битного компилятора и 8 для 64-битного).

Строковая константа может храниться в read-only области памяти. То есть ее нельзя изменять.

```c
s1[0] = 'H'; // заменит в массиве первый символ на H
s2[0] = 'W'; // программа упадет, так как нельзя писать в read only область памяти
```

По стандарту языка С модификация строковой константы - это undefined behaviour (неопределенное поведение, программа может вести себя любым образом: работать, падать, выводить на экран "Слава роботам"; стандарт не определяет конкретное поведение).

### Не сравнивайте строки ==
`s1 == s2` - проверяем, что `s1` и `s2` указывают на одну и ту же область памяти. Это сравнение на равенство указателей, а не содержимого, на которые они указывают. Для сравнения строк используют функции `strcmp` и `strncmp`

![11](/C_for_beginners_Stepik/Pictures/11_03.png)

```c
char b1[] = "world";    // пусть массив начинается с адреса 100
char b2[] = "world";    // пусть массив начинается с адреса 200

if (b1 == b2)           // 100 == 200 - сравнение указателей - ложь
    printf("равны\n");
else
    printf("НЕ равны\n");

if (0 == strcmp(b1, b2)) // истина, строки одинаковые
    printf("равны\n");
else
    printf("НЕ равны\n");
```

`b1 == b2` сравнивает адреса начала этих массивов. Если один массив расположен начиная с адреса 100, а другой начиная с адреса 200, то очевидно, что `100 == 200` - ложь.

`0 == strcmp(b1, b2)` у строк `b1` и `b2` нулевая разница (то есть они одинаковые). Истина.

### Равенство адресов и содержимого

```c
char s1[] = "world";    // пусть s1 расположен начиная с адреса 100
char * s2 = "world"     // пусть "world" расположена начиная с адреса 200, в s2 лежит число 200
char * p = s1;          // в p лежит число 100
```

![11](/C_for_beginners_Stepik/Pictures/11_04.png)

+ `s1 == s2` - ложь, сравнение 100 == 200
+ `p == s2` - ложь, сравнение 100 == 200
+ `p == s1` - истина, сравнение 100 == 100
+ `strcmp(s1, s2) == 0` - истина, ибо строки одинаковые
+ `strcmp(s1+3, s2+3) == 0` - истина, ибо строки одинаковые

### elong_set Задаем большие числа
Для хранения больших чисел объявили структуру

```c
#define N 100
typedef struct {
    char a[N];       // number is a[0]*10^0 + a[1]*10^1 + ..+ a[n]*10^n
    unsigned int n;  // наибольшая степень десяти
}Decimal;
```

Реализуйте функцию записи значения большого числа res из строки str.

```c
void elong_set (Decimal * res, const char str[ ]);
```

В проверяющую систему посылать только реализацию требуемой функции elong_set.

Проверять функцию можно так:

```c
int main(){
    Decimal res;
    elong_set(&res, "12345678901234567890");  // res = 12345678901234567890

    elong_print(res);                         // print 12345678901234567890

    return 0;
}
```

Функцию elong_print вы написали раньше.

```c
void elong_set(Decimal* res, const char str[]) {
  int n = 0;
  for (unsigned int i = 0; str[i] != '\0'; i++, n++)
    ;
  res->n = n - 1;
  for (int i = 0; i < n; i++) {
    res->a[i] = str[n - i - 1] - '0';
  }
}
```

```c
void elong_set (Decimal * res, const char str[ ]){
    int i, j;
    res->n = strlen(str) - 1;
    for(i = res->n, j = 0; i >= 0; i--, j++){
            res->a[j] = str[i] - '0';
    }
}
```


## Печать и чтение строк

[Video](https://youtu.be/cT5GELfOwsE)

### Печать строк
Печатать строку можно `printf` по формату `%s` (string). Печатаются все символы от указанного адреса до '\0'. Сам символ '\0' не печатается.

```c
char a[] = "hello";    // массив из 6 символов
char * s = "world";    // 1 указатель на char, указывает на строковую константу "world"


printf("%s\n", a);     // hello
printf("%s\n", s);     // world


printf("%s\n", a+1);   // ello
printf("%s\n", s+1);   // orld
```

Так же можно печатать строку с помощью функции fputs:

```c
fputs ("Hello, world!\n", stdout);
```

### Позаботься о месте заранее
Чтобы прочитать строку, память для нее должна уже быть выделена. Либо объявлен массив подходящей длины, либо выделена динамическая память. В примерах будем объявлять массивы нужной длины.

```c
char a[100];            // массив на 100 символов
char * s = malloc(100); // динамический массив на 100 символов, не забудьте о free
```

### scanf по формату %s

Формат `%s` позволяет функции `scanf` читать набор символов. Выясним на практике, как он работает.

```c
#include <stdio.h>
int main() {
    char a[100];
    scanf("%s", a);       // читаем в массив а (НЕ ДЕЛАЙТЕ ТАК, НУЖЕН КОНТРОЛЬ ПЕРЕПОЛНЕНИЯ МАССИВА)
    printf("<%s>\n", a);  // печатаем прочитанное, спереди и сзади печатаем символ < и > , 
                          // чтобы увидеть где началась и закончилась строка
    return 0;
}
```

Скомпилируем файл в исполняемый модуль a.out и будем его запускать (вторая строка - что вводим, последняя - что печатает программа):

```bash
$./a.out
qaz wsxedc
<qaz>
```

Оказывается, читается не вся строка, а "слово" до пробельного символа (пробела, табуляции, \n и так далее).
```bash
$./a.out
   qaz123. wsxedc
<qaz123.>
```
Пробельные символы спереди пропускаются.

Проблема: пользователь может ввести больше 100 символов и мы выйдем за границы массива char a[100] Что делать?

### Контроль переполнения в `scanf`
Использовать модификацию к форматеру %s, чтобы указать максимальное количество прочитанных символов.

```c
#include <stdio.h>
int main() {
    char a[10] = "hello";
    scanf("%3s", a);      // читаем в массив а НЕ БОЛЕЕ 3 символов
    printf("<%s>\n", a);  // печатаем прочитанное, спереди и сзади печатаем символ < и > , 
                          // чтобы увидеть где началась и закончилась строка
    return 0;
}
```

Запускаем программу:

```bash
$./a.out
qazxcvbnm wsxedc
<qaz>
```

Так как у нас закончилась печать на букве z, после нее был поставлен символ '\0'.

То есть при указанном ограничении в 3 символа записали 4 символа.

Т.е. для массива char a[10] нужно писать scanf("%9s", a);

Если в "слове" вводится меньше символов, чем указано в ограничении, то считывается только это "слово". Заметим, что "слово" - это не слово в терминах русского или английского языка, а последовательность символов до пробельного символа. Пробельный символ определяется стандартной функцией `isspace`. В последовательность символов могут входить буквы разных алфавитов, числа, знаки препинания, математические символы - все, кроме пробельных символов.

[Видео](https://youtu.be/B7BsxW4_gw8)

### fgets - чтение строки

```c
char *fgets(char *s, int size, FILE *stream);
```

Читает из потока `stream` и записывает в буфер `s` строку до `'\n'`, но не более `size` символов.

Буфер - это заранее выделенная нами память, как было описано выше. Массив или динамический массив.

```c
#include <stdio.h>
int main() {
    char a[10];
    fgets(a, 5, stdin);    // читаем и ЗАПИСЫВАЕМ в массив а
                           // НЕ БОЛЕЕ 5 символов с stdin (клавиатуры)
    printf("<%s>\n", a);   // печатаем прочитанное
    return 0;
}
```

Запускаем программу:

```bash
$./a.out
1234567890
<1234>
```

Заметим, что записалось 5 символов ВМЕСТЕ с символом '\0'. Символы '1', '2', '3', '4', '\0' - всего 5 символов.

Т.е. для массива `char a[10]` можно писать `fgets(a, 10, stdin)`. Не нужно, -1, как в scanf.

Введем строку меньшую, чем ожидаемый размер буфера:

```bash
$./a.out
12
<12
>
```

Заметим, что последний символ в записанной строке перед '\0' - это '\n' (новая строка).

### gets - не использовать!
Не используйте при чтении функцией

```c
char *gets(char *s);
```

Стандарт С11 больше не поддерживает эту функцию. Ее объявляют устаревшей и удаляют из библиотек. Почему? Потому что у нее нет возможности контроля переполнения буфера.

### Как завершить ввод
Напишем программу, которая читает по 1 "слову" и печатает 1 слово на строку.

```c
#include <stdio.h>
int main() {
    char s[1001];
    while(1 == scanf("%1000s", s)) {
        printf("%s\n", s);
    }
}
```

Если читаем текст из файла `data.txt` с перенаправлением, то ясно, что поток данных закончится, когда в этом файле закончатся данные:

```bash
$./a.out < data.txt
```

Но как завершить поток данных, если мы вводим данные с клавиатуры? Нажмите `Ctrl+Z` в Windows иди `Ctrl+D` в другой операционной системе.

__Чтобы завершить ввод текста с клавиатуры нажмите Ctrl+D (UNIX, Mac) или Ctrl+Z (Windows)__

### flint Задача про капитана Флинта
Капитан Флинт зарыл клад на Острове сокровищ. Он оставил описание, как найти клад. Описание состоит из строк вида: North 5, где первое слово – одно из "North", "South", "East", "West", а второе число – количество шагов, необходимое пройти в этом направлении.

Напишите программу, которая по описанию пути к кладу определяет точные координаты клада, считая, что начало координат находится в начале пути, ось OX направлена на восток, ось OY – на север.

Программа получает на вход последовательность строк указанного вида, завершающуюся строкой со словом "Treasure!". Программа должна вывести два целых числа: координаты клада.

Пример ввода:

```c
North 5
East 3
South 1
Treasure!
```
Пример вывода:

```
3 4
```

(Примечание: мы будем признательны, если сможем указать автора задачи. Эта задача столько раз кочевала по разным контестам для школьников, что пора писать слова народные "задача классическая").

Вспомним, что мы можем использовать для разбора входных данных:

```c
char s[10]; // подумайте, почему 10 символов должно хватить, если гарантируют именно такие входные данные
int steps;
```

Читаем одно слово:

```c
scanf("%9s", s);
```

Проверяем, что прочитанное слово "Treasure!"

```c
if (0 == strcmp(s, "Treasure!"))
```

Читаем число - количество шагов:

```c
scanf("%d", &steps);
```

```c
#include <stdio.h>
#include <string.h>

int main() {
  int x = 0, y = 0;
  char s[10];

  while (1) {
    scanf("%9s", s);
    if (0 != strcmp(s, "Treasure!")) {
      int step;
      scanf("%d", &step);
      switch (s[0]) {
        case 'N':
          y += step;
          break;
        case 'S':
          y -= step;
          break;
        case 'E':
          x += step;
          break;
        case 'W':
          x -= step;
          break;
        default:
          break;
      }
    } else
      break;
  }
  printf("%d %d", x, y);
}
```

Можно проверять только первые буквы слов  "North", "South", "East", "West", но в случае ошибки во входных данных, например, "No", вы слово "Нет" обработаете как "Север".

В профессиональном программировании стараются ловить ошибки в данных и сообщать о них.

```c
#include <stdio.h>
#include <string.h>            // для strcmp

int main()
{
    char s[10];                // длина "Treasure!" c \0
    int steps, x = 0, y = 0;   // начинаем с точки (0,0)
    while(1){                  // не знаешь как написать цикл? пиши while(1), потом выйдем по break
        scanf("%9s", s);       // & не нужен, так как s - АДРЕС начала памяти, в которую пишем
                               
        if (0 == strcmp(s, "Treasure!")) {    // если нашли клад, печатаем координаты и выходим
            printf("%d %d\n", x, y);
            break;
        }
        scanf("%d", &steps);               // если не клад, то направление и количество шагов
        if (0 == strcmp(s, "North"))
            y += steps;
        else if (0 == strcmp(s, "South"))
            y -= steps;
        else if (0 == strcmp(s, "East"))
            x += steps;
        else if (0 == strcmp(s, "West"))
            x -= steps;
        else {                            // если ошибка во входных данных
            printf("Ошибка во входных данных: направление = <%s>\n", s);
            return 1;
        }  
    }
    
    return 0;
}
```

### Чтение слова с выделением динамической памяти
Если вы еще не знаете, что такое функции _malloc_, _realloc_, _free_, то пропустите последние шаги и вернитесь к ним после изучения работы с динамической памятью.

Иногда сложно предугадать размер вводимых данных. Хочется не писать сложный код, а чтобы функция сама выделяла сколько нужно (динамической) памяти. Это достигается с помощью `%ms`

```c
#include <stdio.h>
#include <stdlib.h>

int main()
{
    char *s = NULL;                 // указатель, в него будет записываться адрес выделяемой памяти

    while(1 == scanf("%ms", &s)) {  // заметим, что &s
        printf("<%s>\n", s);        // используем прочитанное слово

        free(s);                    // освобождаем память после использования, чтобы не было утечек
    }
    return 0;
}
```

Обратите внимание на a1 :

```c
char a1[100];
scanf("%99s", a1);       // a1 типа char *, с контролем переполнения
```

и на &a2:

```c
char * a2 = NULL;
scanf("%ms", &a2);      // a2 типа char **, выделяеся динамическая память
// ...                  используем прочитанное слово
free(a2);               // освобождаем память после использования
```

### Чтение строки с выделением динамической памяти
```c
#include <stdio.h>

ssize_t getline(char **lineptr, size_t *n, FILE *stream);
ssize_t getdelim(char **lineptr, size_t *n, int delim, FILE *stream);
```

Функция getline считывает из потока stream строку, сохраняя ее в памяти по адресу `*lineptr` размером n байтов.

```c
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
        FILE * fp;
        char * line = NULL;
        size_t len = 0;
        ssize_t read;
        fp = fopen("/etc/motd", "r");
        if (fp == NULL)
                exit(EXIT_FAILURE);
        while ((read = getline(&line, &len, fp)) != -1) {
                printf("Retrieved line of length %zu :\n", read);
                printf("%s", line);
        }
        if (line)
                free(line);
        return EXIT_SUCCESS;
}
```

Функция изначально была расширением GNU и была внесена в стандарт POSIX.1-2008.

Как это работает?

+ `getline` считывает строку в `*lineptr`
    + буфер завершается `null`;
    + если во входном потоке был `\n,` то он тоже попадает в буфер; если в последней строке наступил конец файла и не было `\n`, то в буфер `\n` не запишется;
+ при необходимости для `*lineptr` делается `realloc`, новые значения размера буфера записываются в n;
+ `getline` работает как `getdelim` с разделителем `\n`, если нужно указать другой разделитель, используйте аргумент `delim` функции `getdelim`;
+ обе функции возвращают количество считанных символов (с учетом разделителя, если он был), но без учета `null`.
    + При ошибке возвращается -1.

## Стандартные функции языка С

[Видео](https://youtu.be/-t17-0n0kWA)

### Работа с символами
Не забудьте для работы с этими функциями написать

```c
#include <ctype.h>
```

Далее описано что проверяеют функции локали "C" или "POSIX". Для других языков используйте аналогичные функции с указанием локали, например,

```c
int isalnum_l(int c, locale_t locale);
```

Функция | Что проверяет
-|-
int isalpha(int c); | c - латинская буква большая или маленькая
int isdigit(int c); | с - цифра от 0 до 9
int isxdigit(int c); | c - 0..9 a..f A..F
int isalnum(int c); | с - буква или цифра
int isspace(int c); | c - пробельный символ ' ' '\t' '\n' '\r' '\v' '\f'
int isprint(int c); | любой печатный символ (включая пробельные)
int ispunct(int c); | любой печатный символ, не isalnum и не isspace
int islower(int c); | маленькая буква a..z
int isupper(int c); | большая буква A..Z

#### Преобразование символов:

Функция | Что делает
-|-
int toupper(int c); | для буквы возвращает большую букву, иначе не меняет
int tolower(int c); | для буквы возвращает маленькую букву, иначе не меняет

[Видео](https://youtu.be/tL2_B0pRowE)

### strlen - длина строки

```c
size_t strlen(const char *s);
```

Возвращает количество символов в строке БЕЗ подсчета '\0'.

Для печати типа `size_t` используйте `%zu`

```c
printf("%zu\n", strlen("abc"));   // 3
```

Не путайте `strlen` (количество символов от указанного адреса до \0) c `sizeof` (размер объекта).

```c
char a [10] = "abc";
printf("%zd\n", strlen ("abc"));    // 3
printf("%zd\n", sizeof (a) );       // 10
```

### Напишем сами strlen через индексы
Попробуем написать такую же функцию `mystrlen` и проверить ее работу:

```c
#include <stdio.h>
#include <string.h>

size_t mystrlen(const char *s) {
    int i;
    for (i = 0; s[i] != '\0'; i++)
        ;                          // делать в цикле ничего не нужно, пустое тело цикла
    return i;
}
int main() {
    char * s = "abc";
    printf("%zd\n", strlen(s));     // 3, эталонная функция
    printf("%zd\n", mystrlen(s));   // 3, наша функция
    return 0;
}
```

Как понять, возвращать i, i-1 или i+1? Не нужно думать, нужно запустить, проверить и поправить.

Проверьте в уме для строки из одной буквы, например, "z".

Для i=0 условие продолжения цикла `s[0]!='\0'` истина (в этой ячейке массива символ 'z'). Значит, выполняем тело цикла (ничего не делаем), и `i++` (i=1).

Для i=1 условие продолжения цикла s[1]!='\0' ложь (в этой ячейке массива символ конца строки '\0'). Значит, выходим из цикла.

После цикла i=1. Вернуть для "z" функция должна тоже 1. Значит, `return i`.

### Реализация strlen с помощью указателей
Напишем эту функцию через указатели.

При вычитании одного указателя из другого получаем целое число, равное количеству элементов между этими указателями. Значит, запомним начальный указатель и вычислим второй указатель, передвигая его на 1 символ, пока не дойдем до конца строки '\0'.

![11](/C_for_beginners_Stepik/Pictures/11_05.png)

```c
#include <stdio.h>
#include <string.h>

size_t mystrlen(const char *s) {
    const char * p;
    for (p = s; *p != '\0'; p++)   // указатель двигается от начала строки до конца 
        ;                          // делать в цикле ничего не нужно, пустое тело цикла
    return p - s;
}
int main() {
    char * s = "abc";
    printf("%zd\n", strlen(s));     // эталонная функция
    printf("%zd\n", mystrlen(s));   // наша функция
    return 0;
}
```

Пусть указатель `p` сначала указывает на начало строки `s`, потом в цикле сдвигается на 1 символ `p = p+1` или `p++`, пока его содержимое `*p` не станет равно `'\0'` (концу строки).

Как тогда вычислить длину строки? Пусть начало строки "world" лежит по адресу 100 (s = 100). Тогда буква w лежит по адресу 100, o по адресу 101, r по адресу 102, \0 по адресу 105.

Когда мы закончим цикл, p будет содержать адрес 105 (был бы 104, мы бы цикл продолжали, там буква d). Вернуть нужно число 5. В переменной p у нас число 105, в переменной s число 100. Значит возвращаем `p - s`.

### Упростим реализацию
Посмотрим, что можно упростить в реализации функции:

```c
size_t mystrlen(const char *s) {
    const char * p;
    for (p = s; *p != '\0'; p++)   // указатель двигается от начала строки до конца 
        ;                          // делать в цикле ничего не нужно, пустое тело цикла
    return p - s;
}
```

У символа `'\0'` ASCII-код равен нулю. То есть `*p != '\0'` можно заменить на `*p != 0` или на `*p` (потому что 0 ложь, а все другие значения - истина в языке С).

```c
size_t mystrlen(const char *s) {
    const char * p = s;
    for ( ; *p ; p++)   // указатель двигается от начала строки до конца 
        ;               // делать в цикле ничего не нужно, пустое тело цикла
    return p - s;
}
```

Приоритет операции `++` выше, чем у операции `*`. То есть в выражении `*p++` переменная `p` (потом) увеличится на 1, а проверяться на равенство 0 будет ее значение по ее текущему адресу. Так как последняя проверка на '\0' будет после того, как мы попросили потом увеличить адрес, то после выхода из цикла p будет указывать элемент после '\0'. Значит, надо ввести поправку на -1.

```c
size_t mystrlen(const char *s) {
    const char * p = s;
    while (*p++)        // указатель двигается от начала строки до конца 
        ;               // делать в цикле ничего не нужно, пустое тело цикла
    return p - 1 - s;
}
```

[Видео](https://youtu.be/DaQJsmKiksQ)

### strcmp - сравнение строк
Мы уже обсуждали, что с помощью `==` сравниваются указатели (указывают на одно и то же место в памяти), а для сравнения содержимого строк нужно использовать функцию `strcmp` (string compare).

```c
int strcmp(const char *s1, const char *s2);
int strncmp(const char *s1, const char *s2, size_t n);
```

Функции сравнивают строки s1 и s2 и возвращают насколько одна строка отличается от другой. Не более n символов.

Функция возвращает:
+ `0`, если строки равны;
+ `<0`, если первая строка меньше второй;
+ `>0`, если первая строка больше второй.

```c
#include <stdio.h>
#include <string.h>

int main() {
    char * s1, * s2;
    s1 = "abc";
    s2 = "aaaaaaa";
    printf("%d %s %s\n", strcmp(s1, s2), s1, s2);   // 1 abc aaaaaaa
    printf("%d %s %s\n", strcmp(s2, s1), s2, s1);   // -1 aaaaaaa abc
    printf("%d %s %s\n", strcmp(s1, s1), s1, s1);   // 0 abc abc

    s2 = "zaq";
    printf("%d %s %s\n", strcmp(s1, s2), s1, s2);   // -25 abc zaq

    return 0;
}
```

Если нужно выяснить, равна строка s образцу, например "Treasure!", то пишем

```c
if (0 == strcmp(s, "Treasure!")) 
```

Так как строки могут быть длинными, то для удобства чтения кода сначала пишут с чем сравниваем результат `strcmp`.

### Лексикографичесий порядок
Что значит меньше и больше для строк? Представим словарь. В нем слова расположены по порядку. Какое слово расположено раньше, такое и меньше. Это называется сортировка строк в __лексикографическом__ порядке.

Слова расположены по возрастанию:

```
1942
Америка
Москва
Россия
абажур
апельсин
арбуз
банан
вино
виноград
яблоко
```

Обратите внимание, что таблица ASCII-кодов составлена так, чтобы раньше идущий символ имел меньший код. Сначала в таблице идут цифры, потом большие буквы от A до Z, потом маленькие буквы от a до z.

Конец стоки (символ '\0') имеет код 0, поэтому любой другой символ будет больше него. Строка "вино" меньше, чем "виноград".

Отсортируем строки по возрастанию. Обратите внимание, что сравнение чисел и сравнение строк даст разный результат.

```c
1
111
12
2
21
```
### strcmp и strncmp
Функции сравнивают до:
+ первого различного символа;
+ конца строки;
+ n - для strncmp

__Вернет функция strcmp:__

Вернет | Кто больше | Функция
-|-|-
`0` | одинаковые строки | strcmp("abc", "abc")
`<0` | s1 < s2 | strcmp("abc", "xy")
`>0` | s1 > s2 | strcmp("abc", "aBcd")

__Вернет функция strncmp:__

Вернет | Функция
-|-
`0` | strncmp("abcx", "abcA", 3)
`<0` | strncmp("abcx", "abcxABC", 10)
`>0` | strncmp("abcx", "abcABC", 10)

## Стандартные функции языка С (продолжение)

[Видео](https://youtu.be/G0HUky1DRhg)

### strcpy - копирование строк
Копируют строки с помощью функции `strcpy` (string copy).

```c
char *strcpy(char *dest, const char *src);
char *strncpy(char *dest, const char *src, size_t n);
```

+ src — source (откуда)
+ dest — destination (куда) — его вернут
+ n — не более n символов (\0 может не ставить)

Функции `strcpy` и `strncpy` возвращают указатель на результирующую строку `dest`.

Почему первый аргумент `dest`, а второй `src`? По аналогии с выражением x=5. Сначала пишем куда копировать значение, потом - какое это значение.

```c
char a[100];         // нужно место куда копировать, тут мусор
strcpy(a, "qaz");    // откопировали в массив символы 'q', 'a', 'z', '\0'
printf("%s\n", a);   // qaz
```

![11](/C_for_beginners_Stepik/Pictures/11_06.png)

### strncpy
Функция `strcpy()` копирует строку, на которую указывает `src` (включая завершающий символ '\0'), в массив, на который указывает `dest`. Строки не могут перекрываться, и в результирующей строке `dest` должно быть достаточно места для копии.

Функция `strncpy` работает аналогично, кроме того, что копируются только первые `n` байтов строки `src`. Таким образом, если в n байтах строки `src` нет нулевого байта, то строка результата не будет заканчиваться символом '\0'.

Если длина `src` меньше, чем `n`, то остальное место в `dest` будет заполнено нулями.

![11](/C_for_beginners_Stepik/Pictures/11_07.png)

```c
char a [100];           // сами заботимся о месте
strcpy (a, "hello");
printf("%s\n", a);      // hello
strncpy (a, "abc", 2);  // копируем 2 символа, \0 не ставится
printf("%s\n", a);      // abllo        
a[2] = '\0';            // ставим вручную \0 после откопированных символов
printf("%s\n", a);      // ab
strncpy (a, "abc", 10); // abc, остальные 6 элементов массива a заполняются нулями
printf("%s\n", a);      // abс
```

### Нельзя копировать в перекрывающийся участок памяти
Реализуем функцию `char * mystrcpy(char *dest, const char *src)` сами, через индексы массивов. С первого символа до `'\0'` копируем из `src[i]` в `dest[i`]. Не забудем про `'\0'`.

```c
char * mystrcpy1(char *dest, const char *src) {
    int i;
    for (i = 0; src[i] != '\0'; i++)
        dest[i] = src[i];
    dest[i] = '\0';     // так как он в цикле не откопировался, а нужен
    return dest;
}
```

Можно реализовать функцию по-другому: копировать с конца в начало. Сначала вычислим с помощью `strlen`, где `'\0'`, потом будем копировать с `'\0'` до первого символа строки включительно.

```c
char * mystrcpy2(char *dest, const char *src) {
    int i;
    for (i = strlen(src); i >= 0; i--)
        dest[i] = src[i];
    return dest;
}
```

![11](/C_for_beginners_Stepik/Pictures/11_08.png)

Если запустить эти функции на пересекающемся участке из d+2 в d (такая задача возникает часто, например, нужно убрать лидирующие пробелы или нули), то получим из "world" строку "rld" или строку "d", в зависимости от того, какую функцию использовали:

```c
char d[100] = "world";
mystrscp1(d, d+2);
printf("%s\n", d);      // rld

strcpy(d, "world");
mystrscp2(d, d+2);
printf("%s\n", d);      // d
```

В стандарте не говорится о том, как именно нужно реализовывать эту функцию. Поэтому поведение не определено. Для копирования перекрывающихся участков памяти есть функция `memmove`, которая копирует из `src` в `dest` через внутренний буффер `n` байт памяти.

```c
void *memmove(void *dest, const void *src, size_t n);
memmove(d, d+2, strlen(d+2)+1);     // +1 - не забываем копировать \0
```

### strcpy через указатели
Реализуем копирование не через индексы, а через указатели. Указатель s идет по строке src с начала до '\0', сдвигаясь каждый раз на 1 символ. Указатель p идет по строке dest, сдвигаясь каждый раз на 1 символ.

```c
char * mystrcpy2(char *dest, const char *src) {
    char * p;
    const char * s;
    for (s = src, p = dest; *s != '\0'; s++, p++)
        *p = *s;
    *p = '\0';     // так как он в цикле не откопировался, а нужен
    return dest;
}
```

+ вынесем `s = src, p = dest` в объявление переменных `p` и `s`;
+ так как ASCII-код символа '\0' равен 0, то `*s != 0` или тождественно `*s`, так как 0 - ложь, все остальное истина.
+ так как результат оператора `=` это значение в правой части (например, значение выражения `x=5` будет 5, то есть истина), то можно внести присвоение `*p = *s` в условие продолжение цикла `*s != 0`,

```c
char * mystrcpy2(char *dest, const char *src) {
    char * p = dest;
    const char * s = src;
    for (; *p = *s; s++, p++)
        ;
    *p = *s;     // так как s указывает при выходе из цикла на \0
    return dest;
}
```

+ свернем два оператора `*s` и `s++` в один `*s++`. Так как приоритет `++` выше, чем у `*`, то сначала будет срабатывать отложенное увеличение указателя `s++`, а потом прежнее значение указателя будет разыменовано `*s`. Скобки для изменения приоритета не нужны, все работает хорошо.
+ заменим for на while

```c
char * mystrcpy2(char *dest, const char *src) {
    char * p = dest;
    const char * s = src;
    while (*p++ = *s++)
        ;
    return dest;
}
```

Заметим, что дополнительное копирование '\0' не нужно, так как этот символ сначала откопируется, а потом результат присвоения (ноль) будет проверен на истинность (ложь) и цикл прервется.