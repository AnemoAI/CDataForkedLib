# Циклы

[Видео](https://youtu.be/ZknyHkRdbltj70g)

[Презентация](/C_for_beginners_Stepik/Files/c2019_5.pdf)

## Операторы `while` и `do..while`

### Задача про поход
Отряд туристов отправился в поход. В первый день они прошли L км. Каждый следующий день проходили на k км больше Сколько км они прошли за 3 дня?

Пусть дано: L = 4, k = 2. Для конкретной задачи это константы.

Введем переменные:
+ i - закончилось полных дней похода; сначала 0.
+ step - прошли за 1 день похода; сначала L
+ path - прошли за все время; сначала 0.

![07](/C_for_beginners_Stepik/Pictures/07_01.PNG)

### Таблица
Прежде чем писать код, рекомендуем составить таблицу, как изменялись переменные цикла.

![07](/C_for_beginners_Stepik/Pictures/07_02.PNG)

На таблице нарисованы стрелки и операции - как изменялись переменные. Перед тем, как начать писать программу, напишите такую таблицу, нарисуйте стрелками и знаками операции и выпишите формулы. Глядя на стрелки проще понять, зависят изменения одних переменных от других или нет и в каком порядке писать их в коде.

Можно представить, как после дневного перехода, в конце каждого дня отряд останавливался на отдых и заполнялся походный журнал; потом планировалось сколько нужно пройти завтра.

+ i = i + 1; - не зависит от изменения других переменных, можно писать в любом месте относительно других формул;
+ path = path + step; - (новый путь - это старый путь плюс что прошли за последний день) зависит от step, нужно складывать в первый день именно с L;
+ step = step + k; - (завтра пройдем на k больше, чем сегодня) не зависит от других переменных.

То есть изменения step должны пройти позже изменения path.

### Блок-схема последовательная
Напишем эти шаги в виде блок-схемы:

![07](/C_for_beginners_Stepik/Pictures/07_03.PNG)

На схеме видны повторяющиеся блоки. Попробуем оптимизировать блок-схему, чтобы один и тот же код выполнялся несколько раз.

### Блок-схема с повторениями
Будем считать i - сколько дней уже прошли.

Добавим в схему условие: выполняем блок с изменением пути 3 дня. Пока условие истино, продолжаем выполнять блок, а как только станет ложным, выходим из повторения и идем дальше по коду программы - печатаем результат и заканчиваем программу.

Ромб означает условие.

![07](/C_for_beginners_Stepik/Pictures/07_04.PNG)

### Код с последовательным выполнением
На первых порах, если не понятно как писать цикл, стоит написать код без цикла в стиле "copy-paste". Так проще понять, что будет телом цикла.


```c
#include <stdio.h>


int main() {
    int L;      // прошли в первый день
    int k;      // каждый день проходим на k больше


    int i;      // закончилось дней
    int step;   // проходим за 1 день
    int path;   // прошли всего с начала похода


    // читаем входные данные (что дано)
    scanf("%d", &L);
    scanf("%d", &k);


    // готовимся к походу:
    i = 0;      // поход не начался
    step = L;   // планируем в первый день пройти L
    path = 0;   // еще не прошли ничего


    // первый день похода
    path += step;   // прошли еще step км
    i++;            // закончили день
    printf("За %d день прошли %d, всего %d\n", i, step, path);
    step += k;      // готовимся к завтрашнему дню, планируем сколько пройти


    // второй день похода
    path += step;   // прошли еще step км
    i++;            // закончили день
    printf("За %d день прошли %d, всего %d\n", i, step, path);
    step += k;      // готовимся к завтрашнему дню, планируем сколько пройти


    // третий день похода
    path += step;   // прошли еще step км
    i++;            // закончили день
    printf("За %d день прошли %d, всего %d\n", i, step, path);
    step += k;      // готовимся к завтрашнему дню, планируем сколько пройти


    // поход окончен, больше никуда не идем, печатаем ответ
    printf("За %d дня прошли %d км\n", i, path);


    return 0;
}
```

Входные данные:

```
4 2
```

Программа напечатает:

```
За 1 день прошли 4, всего 4
За 2 день прошли 6, всего 10
За 3 день прошли 8, всего 18
За 3 дня прошли 18 км
```

Заметим, что повторяется код

```c
    path += step;   // прошли еще step км
    i++;            // закончили день
    printf("За %d день прошли %d, всего %d\n", i, step, path);
    step += k;      // готовимся к завтрашнему дню, планируем сколько пройти
```

+ Перепишите и запустите программу для 7 дней похода. Проверьте ее.<br>
+ Трудно ли будет изменить программу, чтобы она подсчитала путь для 100 дней?<br>

### Код с циклом while
Используем оператор while

```c
while (условие продолжения цикла)
    тело цикла
```

Если условие продолжения цикла истина, то выполняется тело цикла и управление опять передается на проверку условия.<br>
Если условие ложно, то управление передается на первый оператор за циклом.<br>
Тело цикла - один оператор. Он может быть блочным. То есть можно написать без скобок, если в теле единственный оператор. Рекомендуем первое время всегда писать скобки.

```c
#include <stdio.h>


int main() {
    int L;      // прошли в первый день
    int k;      // каждый день проходим на k больше


    int i;      // закончилось дней
    int step;   // проходим за 1 день
    int path;   // прошли всего с начала похода


    // читаем входные данные (что дано)
    scanf("%d", &L);
    scanf("%d", &k);


    // готовимся к походу:
    i = 0;      // поход не начался
    step = L;   // планируем в первый день пройти L
    path = 0;   // еще не прошли ничего


    while (i < 3) {
        path += step;   // прошли еще step км
        i++;            // закончили день
        printf("За %d день прошли %d, всего %d\n", i, step, path);
        step += k;      // готовимся к завтрашнему дню, планируем сколько пройти
    }


    // поход окончен, больше никуда не идем, печатаем ответ
    printf("За %d дня прошли %d км\n", i, path);


    return 0;
}
```

### Bloop_path2 100 дней
Измените код, чтобы он посчитал путь за 100 дней. Сравните количество изменений в коде с программой без цикла.

Переписать и отладить программу для 100 шагов.

Программа должна печатать ТОЛЬКО ПОСЛЕДНИЙ path. Убрать ненужные printf (закоментируйте их).

```c
#include <stdio.h>

int main() {
	int L; 		// прошли в первый день
	int k; 		// каждый день проходим на k больше

	int i;		// закончилось дней
	int step;	// проходим за 1 день
	int path;	// прошли всего с начала похода

	// читаем входные данные (что дано)
	scanf("%d", &L);
	scanf("%d", &k);

	// готовимся к походу:
	i = 0;		// поход не начался
	step = L;	// планируем в первый день пройти L
	path = 0;	// еще не прошли ничего

	while (i < 100) {
		path += step;	// прошли еще step км
		i++;			// закончили день
		// printf("За %d день прошли %d, всего %d\n", i, step, path);
		step += k;		// готовимся к завтрашнему дню, планируем сколько пройти
	}

	// поход окончен, больше никуда не идем, печатаем ответ
	// printf("За %d дня прошли %d км\n", i, path);
    printf("%d", path);

	return 0;
}
```

### Что где писать?
Правило "один-много-один":
+ __До цикла__ - выполняется 1 раз - инициализация переменных цикла;
+ __Внутри цикла__ - выполняется много раз (много - это 0 или более);
+ __После цикла__ - выполняется 1 раз (возвращаем результат, печатаем ответ и тп).

Правила форматирования кода:
+ Тело цикла надо выделить отступом.
+ Открывающая { может стоять сразу после условия, а может на новой строке сразу под while.
+ Закрывающая } должна быть строго под while.

__Что делает код?__

```c
while(1)
    printf("Hello\n");
```

Так как условие продолжение цикла 1 - истина, и оно не меняется, то цикл будет бесконечным. Т.е. будет бесконечная печать Hello.

__Что делает код?__

```c
while(1);
    printf("Hello\n");
```

Заметим ; после условия. То есть тело цикла - один пустой оператор. А printf лежит вне цикла. Расставим отступы правильно, как на самом деле работает программа:

```c
while(1)
    ;       // подчеркиваем, что тело цикла - пустой оператор
printf("Hello\n");
```

Программа бесконечно в цикле "ничего не делает" (выполняет пустой оператор). До печати управление не доходит.

Типичная ошибка: ( );. Конечно, можно писать циклы с пустым телом (компилятор поймет), но вы должны осознавать, что и зачем вы делаете. В этом случае ; ставится на отдельной строке, с отступом, подчеркивая, что это не ошибка, а осознанное решение.

## `while`: задачи для начинающих

### Bloop_path2 За сколько дней дойдут?
Отряд туристов отправился в поход. В первый день они прошли L км. Каждый следующий день проходили на k км больше

До города Дубна s километров. За сколько дней отряд дойдет до города Дубна?

Входные данные, по 1 числу на каждой строке:
+ L - сколько отряд прошел в первый день
+ k - на сколько больше пройдет завтра,
+ s - сколько нужно всего пройти

Объяснение: за 7 дней прошли 49 км, значит 50 км пройдут за 8 дней.

```c
#include <stdio.h>

int main() {
	int L; 		// прошли в первый день
	int k; 		// каждый день проходим на k больше
    int s;      // нужно всего пройти
    
	int i;		// закончилось дней
	int step;	// проходим за 1 день

	// читаем входные данные (что дано)
	scanf("%d", &L);
	scanf("%d", &k);
    scanf("%d", &s);

	// готовимся к походу:
	i = 0;		// поход не начался
	step = L;	// планируем в первый день пройти L

	while (s > 0) {
		s -= step;	// осталось пройти еще км
		i++;			// закончили день
		step += k;		// готовимся к завтрашнему дню, планируем сколько пройти
        
	}

	// поход окончен, больше никуда не идем, печатаем ответ
    printf("%d", i);

	return 0;
}
```

### Пример: Робот тормозит
+ Робот сделал 7 шагов.
+ Первый шаг робота L сантиметров.
+ Каждый следующий шаг меньше на k сантиметров.
+ Если шаг робота ≤ 0, то робот дальше не идет (робот топает на месте).

Вычислим путь робота за 7 шагов:

```c
#include <stdio.h>


// функция вычисляет следующий шаг после step.
int next_step(int step, int k)
{
    step = step - k;    // следующий шаг на k меньше
    if (step < 0)       // назад не идем!
        step = 0;       // топчемся на месте
    return step;
}
int main()
{
    int L;      // первый шаг робота
    int k;      // следующий шаг на k меньше


    int i;      // закончилось шагов
    int step;   // длина 1 шага
    int path;   // прошли всего с начала


    // читаем входные данные (что дано)
    scanf("%d", &L);
    scanf("%d", &k);


    // робот готовится шагать:
    i = 0;      // робот еще не сделал ни одного шага
    step = L;   // первый шаг будет L
    path = 0;   // робот еще не прошел ничего


    while (i < 7) {
        path += step;   // прошёл еще step см
        i++;            // закончили шаг
        printf("За %d шаг прошли %d, всего %d\n", i, step, path);
        step = next_step(step, k);  // готовимся к следующему шагу, планируем сколько пройти
    }


    // робот закончил шаги, больше никуда не идем, печатаем ответ
    printf("За %d шагов робот прошел %d см\n", i, path);


    return 0;
}
```
### Bloop_path3 Сколько робот прошел за n шагов
+ Переписать и отладить программу для 20 шагов.
+ Программа должна печатать ТОЛЬКО ПОСЛЕДНИЙ path. Убрать (закомментировать) ненужные printf.

```c
#include <stdio.h>

// функция вычисляет следующий шаг после step.
int next_step(int step, int k)
{
    step = step - k;    // следующий шаг на k меньше
    if (step < 0)       // назад не идем!
        step = 0;       // топчемся на месте
    return step;
}
int main()
{
	int L; 		// первый шаг робота
	int k; 		// следующий шаг на k меньше

	int i;		// закончилось шагов
	int step;	// длина 1 шага
	int path;	// прошли всего с начала

	// читаем входные данные (что дано)
	scanf("%d", &L);
	scanf("%d", &k);

	// робот готовится шагать:
	i = 0;		// робот еще не сделал ни одного шага
	step = L;	// первый шаг будет L
	path = 0;	// робот еще не прошел ничего

	while (i < 20) {
		path += step;	// прошёл еще step см
		i++;			// закончили шаг
		// printf("За %d шаг прошли %d, всего %d\n", i, step, path);
		step = next_step(step, k);	// готовимся к следующему шагу, планируем сколько пройти
	}

	// робот закончил шаги, больше никуда не идем, печатаем ответ
	// printf("За %d шагов робот прошел %d см\n", i, path);
    printf("%d", path);

	return 0;
}
```

### Пример: Bloop_path4 путь до остановки
+ Робот сделал несколько шагов.
+ Первый шаг робота L сантиметров.
+ Каждый следующий шаг меньше на k сантиметров.
+ Если шаг робота ≤ 0, то робот останавливается (больше не делает шагов).

Программа вычисляет путь робота и количество шагов. Условие продолжения цикла изменилось на "пока робот идет":

```c
#include <stdio.h>


// функция вычисляет следующий шаг после step.
int next_step(int step, int k)
{
    step = step - k;    // следующий шаг на k меньше
    if (step < 0)       // назад не идем!
        step = 0;       // топчемся на месте
    return step;
}
int main()
{
    int L;      // первый шаг робота
    int k;      // следующий шаг на k меньше


    int i;      // закончилось шагов
    int step;   // длина 1 шага
    int path;   // прошли всего с начала


    // читаем входные данные (что дано)
    scanf("%d", &L);
    scanf("%d", &k);


    // робот готовится шагать:
    i = 0;      // робот еще не сделал ни одного шага
    step = L;   // первый шаг будет L
    path = 0;   // робот еще не прошел ничего


    while (step > 0) {  // ПОКА РОБОТ ИДЕТ
        path += step;   // прошёл еще step см
        i++;            // закончили шаг
        printf("За %d шаг прошли %d, всего %d\n", i, step, path);
        step = next_step(step, k);  // готовимся к следующему шагу, планируем сколько пройти
    }


    // робот закончил шаги, больше никуда не идем, печатаем ответ
    printf("За %d шагов робот прошел %d см\n", i, path);


    return 0;
}
```

### осталось дойти
+ Робот идет к стене. До стены s сантиметров.
+ Первый шаг робота L сантиметров.
+ Каждый следующий шаг больше на k сантиметров.
+ Если робот не может сделать полный шаг, он останавливается.

На каком расстоянии от стены (сантиметров) остановился робот?
+ Можно объявит переменную dist - сколько сантиметров не дошел робот (на очередном шаге).
+ Сначала dist сколько нужно всего пройти s. Каждый шаг она уменьшается на величину шага.
+ Продолжаем идти, пока новый шаг не будет больше dist.

Входные данные: на одной строке через пробел s L k в сантиметрах.

Выходные данные: через пробел сколько сделано шагов и dist - расстояние до стены после последнего шага.

```c
#include <stdio.h>

// функция вычисляет следующий шаг после step.
int next_step(int step, int k)
{
    step = step + k;    // следующий шаг на k меньше
    if (step < 0)       // назад не идем!
        step = 0;       // топчемся на месте
    return step;
}
int main()
{
	int s;      // расстояние 
    int L; 		// первый шаг робота
	int k; 		// следующий шаг на k меньше

	int i;		// закончилось шагов
	int step;	// длина 1 шага

	// читаем входные данные (что дано)
	scanf("%d", &s);
    scanf("%d", &L);
	scanf("%d", &k);

	// робот готовится шагать:
	i = 0;		// робот еще не сделал ни одного шага
	step = L;	// первый шаг будет L
	
	while (step <= s) {
		s -= step;	// прошёл еще step см
		i++;			// закончили шаг
		step = next_step(step, k);	// готовимся к следующему шагу, планируем сколько пройти
	}

	// робот закончил шаги, больше никуда не идем, печатаем ответ
	printf("%d %d", i, s);

	return 0;
}
```

### осталось дойти - 2
+ Робот идет к стене. До стены s сантиметров.
+ Первый шаг робота L сантиметров.
+ Каждый следующий шаг меньше на k сантиметров.
+ Если робот не может сделать полный шаг, он останавливается.
+ Если шаг робота ≤ 0, то робот останавливается (больше не делает шагов).

На каком расстоянии от стены (сантиметров) остановился робот?

Входные данные: на одной строке через пробел s L k в сантиметрах.

Выходные данные: через пробел сколько сделано шагов и dist - расстояние до стены после последнего шага.

```c
#include <stdio.h>

// функция вычисляет следующий шаг после step.
int next_step(int step, int k)
{
    step = step - k;    // следующий шаг на k меньше
    if (step < 0)       // назад не идем!
        step = 0;       // топчемся на месте
    return step;
}
int main()
{
	int s;      // расстояние 
    int L; 		// первый шаг робота
	int k; 		// следующий шаг на k меньше

	int i;		// закончилось шагов
	int step;	// длина 1 шага

	// читаем входные данные (что дано)
	scanf("%d", &s);
    scanf("%d", &L);
	scanf("%d", &k);

	// робот готовится шагать:
	i = 0;		// робот еще не сделал ни одного шага
	step = L;	// первый шаг будет L
	
	while (step !=0 && step <= s) {
		s -= step;	// прошёл еще step см
		i++;			// закончили шаг
		step = next_step(step, k);	// готовимся к следующему шагу, планируем сколько пройти
	}

	// робот закончил шаги, больше никуда не идем, печатаем ответ
	printf("%d %d", i, s);

	return 0;
}
```

### Bloop_money4 На сколько хватит стипендии?
У студента money монет. Студент хочет покупать рис каждый день.

В первую неделю рис стоит price монет. В эти дни цена не меняется.

Каждую следующую неделю (в первый день недели, до начала рабочего дня) цена риса увеличивается на delta монет (price = price + delta). Неделя - 7 дней.

Первый раз студент купил рис в понедельник. Он покупал рис, пока были деньги, money ≥ price монет.

Входные данные: на одной строке через пробел price delta money

Выходные данные: сколько дней студент покупал рис.

Подсказка: используйте в программе переменную wday. В ней храните номер дня недели (понедельник, вторник, среда, четверг, пятница, суббота, воскресенье, дальше меняется цена риса и наступает следующий понедельник).

```c
#include <stdio.h>

int main() {

	int price, delta, money, result = 0;
	scanf("%d%d%d", &price, &delta, &money);
	
	while (money >= 0) {
		money -= price;	// купили рис
		result++;			// посчитали день
        if (result % 7 == 0) {
		    price += delta;
        }
	}
	printf("%d", result > 0 ? result - 1 : 0);
	return 0;
}
```

## `do` .. `while`

### Оператор do .. while
В операторе `while` мы сначала думаем (проверяем условие), а потом делаем (выполняем тело цикла, если верно условие продолжения цикла).

```c
while(условие продолжения цикла) {
    тело цикла;
}
```

В операторе `do .. while` мы сначала делаем (выполняем тело цикла), а потом думаем (проверяем условие продолжения цикла и, если оно верно, идем опять выполнять тело цикла, иначе заканчиваем цикл).

```c
do {
    тело цикла;
} while(условие продолжения цикла);     // вот тут после ( ) ставим ;
```

Этот цикл используем, если тело цикла должно выполниться хотя бы один раз. Если возможна ситуация, что тело цикла не должно выполняться, используйте лучше цикл while.

Рассмотрим пример, когда удобнее писать программу через `do .. while`.

### НОД и НОК. Алгоритм Евклида
Наибольшим общим делителем (НОД, gcd, greatest common divisor) для двух целых чисел a и b называется наибольший из их общих делителей. Будем обозначать его $НОД(a,b)$

Пример: для чисел 54 и 24 наибольший общий делитель равен 6.

Наименьшее общее кратное (НОК, lcm, least common multiple) двух целых чисел a и b — это наименьшее натуральное число, которое делится на a и b (без остатка).

Пример: для чисел 54 и 24 наименьшее общее кратное равно 216.

Числа a и b называются взаимно простыми, если у них нет общих делителей, кроме 1. То есть $НОД(a,b)=1$

Докажите самостоятельно, что $НОД(a,b) \cdot НОК(a,b)=a \cdot b$

Для нахождения НОД можно, конечно, разложить числа на множители и найти общие. Но алгоритм Евклида гораздо эффективнее.

Алгоритм Евклида применим к паре чисел a и b и формирует новую пару, которая состоит из b и остатка от деления a на b. Процесс повторяется, пока остаток от деления не станет 0. Тогда b - искомое число.

Напишем таблицу для вычисления $НОД(123, 21)$

a | b | a % b
-|-|-
123 | 21 | 18
21 | 18 | 3
18 | 3 | 0

$НОД (123, 21) = 3$

Напишем таблицу для вычисления $НОД(21, 125)$

a | b | a % b
-|-|-
21 | 125 | 21
125 | 21 | 20
21 | 20 | 1
20 | 1 | 0

$НОД (21, 125) = 1$

Обратите внимание, что если $a<b$, то первый же шаг алгоритма меняет их местами.

### Готовимся писать код для алгоритма Евклида
Нарисуем на таблице изменения переменных в цикле стрелки и операции, чтобы понять, какие формулы в какой последовательности писать.

Сохраним остаток от деления в переменной `ost`.

![07](/C_for_beginners_Stepik/Pictures/07_05.PNG)

Получаем следующие формулы:
+ ost = a %b;
+ a = b;
+ b = ost;
Заметим, что формулы зависят одна от другой. На таблице видно, что сначала нужно вычислить ost, а потом готовиться к следующему шагу цикла.

И сначала должно выполняться a = b и только потом b = ost. Иначе в конце первой же итерации b = ost положит b = 18. Далее a = b положит a = 18. Т.е все переменные станут равны 18. Это бы рисовалось так:

![07](/C_for_beginners_Stepik/Pictures/07_06.PNG)

### Блок-схема для алгоритма Евклида с while
Построим блок-схему алгоритма, предполагая использование цикла while.

![07](/C_for_beginners_Stepik/Pictures/07_07.PNG)

Видно, что на схеме есть дублирующиеся блоки. Упростим схему, ибо как минимум 1 раз нужно посчитать ost = a % b.

### Блок-схема для алгоритма Евклида с `do .. while`

![07](/C_for_beginners_Stepik/Pictures/07_08.PNG)

### Код программы нахождения НОД с помощью алгоритма Евклида
Подумайте, в какой переменной будет хранится НОД чисел после окончания цикла.

```c
#include <stdio.h>


int main() {
    int a, b, ost;


    // читаем входные данные (что дано)
    scanf("%d%d", &a, &b);

    do {
        ost = a % b;    // считаем остаток
                        // отладочная печать - все переменные цикла
        printf("a=%d b=%d ost=%d\n", a, b, ost);
                        // готовимся к следующей итерации цикла
        a = b;
        b = ost;
    } while (ost != 0);

    // подумайте, какую переменную мы должны печатать вместо ???
    printf("НОД = %d\n", a);


    return 0;
}
```
```c
> nod.exe
123 21
a=123 b=21 ost=18
a=21 b=18 ost=3
a=18 b=3 ost=0
НОД = 3
```

```c
#include <stdio.h>

int main() {
    int a, b, a_, b_;
    scanf("%d %d", &a, &b);
    a_ = a;
    b_ = b;

    // Euclid algoritm

    while (b != 0) {
        int tmp = a % b;
        a = b;
        b = tmp;
    }

    printf("GCD(%d, %d) = %d\n", a_, b_, a);
}
```

### for_10 Число наоборот
Напечатайте число, состоящее из цифр данного числа x в обратном порядке.

Ведущие нули выводить не нужно.

Входные данные: натуральное число.

Выходные данные: это число в обратном порядке без нулей в начале.

```c
#include <stdio.h>

int main() {
    int num, res = 0;
    scanf("%d", &num);
        
    while (num > 0) {
        res = res * 10 + num % 10;
        num /= 10;
    }
    printf("%d", res);
    return 0;
}
```

## Оператор `for`

### В ряду растет 
�
n яблонь. На каждой яблоне $a_i$ яблок. Сколько яблок на всех яблонях?

Формат входных данных:
+ n - количество яблонь
+ на следующей строке через пробел  $a_i$
​ 
Пример входных данных:

```c
3
5 2 10
```

Начнем с простого: пусть всегда будет 3 яблони (число n не читаем). Просуммируем яблони на 3 деревьях.

Решение "в лоб":

```c
#include <stdio.h>
int main() {
    int a, b, c;            // яблок с каждого дерева
    int sum;                // общее количество яблок

    scanf("%d%d%d", &a, &b, &c);
    sum = a + b + c;
    printf("Всего %d яблок\n", sum);

    return 0;
}
```

![07](/C_for_beginners_Stepik/Pictures/07_10.PNG)

На каждой яблоне установлена памятная табличка с названием яблони эта яблоня была посажена студентом Х после получения зачета по информатике a, b, c.

Решение верное, но абсолютно не масштабируется. Если в ряду станет 7 яблонь, то нужно вспоминать алфавит, и писать много неповторяющегося кода. Если яблонь будет 100, букв не хватит.

Попробуем переписать код так, чтобы с ростом яблонь количество переменных не изменялось. А код обработки одной яблони можно было бы копировать.

### Яблони в ряду, пишем таблицу
Введем переменные:
+ i - номер яблони, начинаем с 0 (или "сколько яблонь уже обработали")
+ x - яблок на одной (текущей) яблоне;
+ sum - яблок уже собрали (в корзине, куда собираем яблоки).

![07](/C_for_beginners_Stepik/Pictures/07_10.PNG)

Нарисуем таблицу, в которой стрелками покажем как изменяются переменные:

![07](/C_for_beginners_Stepik/Pictures/07_12.PNG)

Получим формулы:

+ i++
+ scanf("%d", &x)
+ sum += x

В каком порядке писать формулы? Видно, что изменение i не зависит от изменения x или sum, то есть i++ можно писать в любом месте.

sum += x зависит от x, поэтому мы пишем эту формулу после scanf("%d", &x).

### Яблони в ряду, все еще без цикла

```c
#include <stdio.h>

int main()
{
    int x;          // яблок на одной (текущей) яблоне
    int sum = 0;    // уже собрали яблок

    // первая яблоня
    scanf("%d", &x);
    sum += x;
    printf("x is %d and sum is %d\n", x, sum);

    // вторая яблоня
    scanf("%d", &x);
    sum += x;
    printf("x is %d and sum is %d\n", x, sum);

    // последняя яблоня
    scanf("%d", &x);
    sum += x;
    printf("x is %d and sum is %d\n", x, sum);

    printf("%d\n", sum);
    return 0;
}
```

Итого, у нас повторяется код

```c
    scanf("%d", &x);
    sum += x;
    printf("x is %d and sum is %d\n", x, sum);
```

Это одна итерация цикла.

Перепишем решение с использованием цикла.

![07](/C_for_beginners_Stepik/Pictures/07_13.PNG)

Нужно ли в коде задачи писать sum = 0 или будет работать без присвоения 0?

```c
#include <stdio.h>

int main()
{
    int x;          // яблок на одной (текущей) яблоне
    int sum = 0;    // уже собрали яблок

    // первая яблоня
    scanf("%d", &x);
    sum += x;
    printf("x is %d and sum is %d\n", x, sum);

    // вторая яблоня
    scanf("%d", &x);
    sum += x;
    printf("x is %d and sum is %d\n", x, sum);

    // последняя яблоня
    scanf("%d", &x);
    sum += x;
    printf("x is %d and sum is %d\n", x, sum);

    printf("%d\n", sum);
    return 0;
}
```
### Задача про яблоки, теперь с циклом
Добавим переменные n (сколько яблонь в ряду) и i (сколько из них уже без яблок).

Сначала нужно прочитать n и ни одной яблони мы еще не обобрали i = 0. Это нужно сделать 1 раз до цикла.

```c
#include <stdio.h>


int main()
{
    int x;          // яблок на одной (текущей) яблоне
    int sum = 0;    // уже собрали яблок
    int n;          // количество деревьев
    int i;          // сколько деревьев уже обработали


    scanf("%d", &n);
    i = 0;
    while(i < n) {
        scanf("%d", &x);
        sum += x;
        printf("x is %d and sum is %d\n", x, sum);
        i++;
    }


    printf("%d\n", sum);
    return 0;
}
```

### for - ничего не забыто
Чтобы программисты не теряли ни инициализацию управляющей переменной цикла i = 0, ни ее изменение в цикле i++, придумали цикл for.

```c
for(выр1; выр2; выр3)
    тело цикла
```

+ выр1 - инициализация, выполняется один раз в начале цикла.
+ выр2 - условие продолжения цикла.
+ выр3 - выполняется каждый раз после тела цикла, перед проверкой условия продолжения цикла.
```c
for(i = 0; i < n; i++)
```

Пишем выражения через ; (точку с запятой). Мнемоника: "for - два забора" (высокие "запятые").

![07](/C_for_beginners_Stepik/Pictures/07_14.PNG)

### Яблоки в 1 ряду через цикл for

```c
#include <stdio.h>

int main()
{
    int x;          // яблок на одной (текущей) яблоне
    int sum;        // уже собрали яблок
    int n;          // количество деревьев
    int i;          // сколько деревьев уже обработали

    scanf("%d", &n);

    sum = 0;        // не забыть очистить корзину перед сбором яблок!
    for(i= 0; i < n; i++) {
        scanf("%d", &x);
        sum += x;
        printf("apple tree %d: x is %d and sum is %d\n", i, x, sum);
    }

    printf("%d\n", sum);
    return 0;
}
```

### Несколько выражений в первой и последней части for
Напишем вычисление факториала n! через цикл for:

```c
res = 1;
for (i = 1; i <= n; i++) {
    res *= i;
}
printf("%d! = %d\n", n, res);
```

В цикле изменяются две переменные: i и res. Они должны быть обе проинициализированы до цикла.

Можно в первой и последней части цикла for писать несколько выражений через , (запятую):

```c
for (res = 1, i = 1; i <= n; res *= i, i++) {
    ;       // подчеркиваем, что мы осознаем, что в цикле тело пустое
}
printf("%d! = %d\n", n, res);
```

Мнемоника: "for два забора и маленькие грядки"

В условии продолжения цикла никаких запятых! Только логические операторы `&&` `||` `!`

![07](/C_for_beginners_Stepik/Pictures/07_15.PNG)

### C99
Начиная со стандарта С99 можно объявлять переменную i прямо в операторе for. По принципу "где нужно, там и объявили".

```c
for (int i = 0; i < n; i++)
```

Внимание: в проверяющей системе Ejudge на серверах МФТИ эта опция запрещена.

### Бесконечный цикл
В цикле for можно опустить (не писать) любую из частей. Можно даже все:

```c
for( ; ; )              // бесконечный цикл
    printf("Hello\n");
```

## `break`, `continue`, `goto`

### Вернемся к яблоням

![07](/C_for_beginners_Stepik/Pictures/07_16.PNG)

Вспомним код, который подсчитывал количество яблок в 1 ряду яблонь.

```c
#include <stdio.h>

int main()
{
    int x;          // яблок на одной (текущей) яблоне
    int sum;        // уже собрали яблок
    int n;          // количество деревьев
    int i;          // сколько деревьев уже обработали

    scanf("%d", &n);

    sum = 0;        // не забыть очистить корзину перед сбором яблок!
    for(i= 0; i < n; i++) {
        scanf("%d", &x);
        sum += x;
        printf("i=%d x=%d sum=%d\n", i, x, sum);
    }

    printf("%d\n", sum);
    return 0;
}
```

### Добавим ворон
Пусть на некоторых яблонях живут вороны. Они съели все яблоки с яблони. И когда вы подходите к их яблоне, хватают по 1 яблоку из корзины.

Так как они яблоки отнимают, то будем обозначать числом -5, что на яблоне живет 5 ворон.

Напишем код, который учитывает, что на яблоне могут жить вороны. Но перед этим напишем тесты (и таблицу изменения переменных для каждого теста).

__Тест 1__

```c
4
5 -2 10 -6
```

i - номер яблони | x - количество яблок на 1 яблоне | sum - уже собрали яблок
-|-|-
1 | 5 | 5
2 | -2 | 3
3 | 10 | 13
4 | -6 | 7

__Тест 2__

```c
4
2 -5 10 -6
```

i - номер яблони | x - количество яблок на 1 яблоне | sum - уже собрали яблок
-|-|-
1 | 2 | 2
2 | -5 | 0
3 | 10 | 10
4 | -6 | 4

Если в корзине 2 яблока, 5 ворон не могут оставить в корзине -3 яблока. Вороны не берут кредиты. Они крадут настоящие яблоки. Поэтому после 5 ворон корзина будет пустая.

Измените программу так, чтобы учитывались вороны.

### break - очень страшные вороны

![07](/C_for_beginners_Stepik/Pictures/07_17.PNG)

Пусть наш сборщик яблок очень боится ворон и, как только увидит на яблоне ворон, сразу убегает из ряда. Воронам не достается ни одного яблока.

Входные данные:

```c
4
2 5 -3 6
```

i - номер яблони | x - количество яблок на 1 яблоне | sum - уже собрали яблок | Описание
-|-|-|-
1 | 2 | 2 | 
2 | 5 | 7 | 
3 | -3 | 7 | Закончили обрабатывать ряд
4 | ? | ? | Сюда не дошли

Оператор break - управление передается за конец текущего цикла или switch.

```c
#include <stdio.h>

int main()
{
    int x;          // яблок на одной (текущей) яблоне
    int sum;        // уже собрали яблок
    int n;          // количество деревьев
    int i;          // сколько деревьев уже обработали

    scanf("%d", &n);

    sum = 0;        // не забыть очистить корзину перед сбором яблок!
    for(i= 0; i < n; i++) {
        scanf("%d", &x);
        if (x < 0) {                // если ВОРОНЫ
            printf("ВОРОНЫ!\n");
            break;                  // убегаем из ряда
        }
        sum += x;
        printf("i=%d x=%d sum=%d\n", i, x, sum);
    }
    // сюда передаст управление break
    printf("%d\n", sum);
    return 0;
}
```

Входные данные:

```
4
2 5 -3 6
```

Выходные данные:

```
i=0 x=2 sum=2
i=1 x=5 sum=7
ВОРОНЫ!
7
```

### `continue` - продолжаем обрабатывать другие яблони

Если сборщик яблок храбрый, то он может обойти яблоню с воронами (не отдать им ни одного яблока!) и пойти собирать дальше.

Входные данные:

```
4
2 5 -3 6
```

i - номер яблони | x - количество яблок на 1 яблоне | sum - уже собрали яблок | Описание
-|-|-|-
1 | 2 | 2 | 
2 | 5 | 7 | 
3 | -3 | 7 | пропускает эту яблоню
4 | 6 | 13 | собрали яблоки за воронами

Оператор `continue` - управление передается на следующую итерацию цикла. То есть у нас отрабатывается переход к следующей яблоне i++.

```c
#include <stdio.h>

int main()
{
    int x;          // яблок на одной (текущей) яблоне
    int sum;        // уже собрали яблок
    int n;          // количество деревьев
    int i;          // сколько деревьев уже обработали

    scanf("%d", &n);

    sum = 0;        // не забыть очистить корзину перед сбором яблок!
    for(i= 0; i < n; i++) {
        scanf("%d", &x);
        if (x < 0) {                // если ВОРОНЫ
            printf("ВОРОНЫ!\n");
            continue;               // идем к следующей яблоне
        }
                                    // этот код тоже не выполняется при continue
        sum += x;
        printf("i=%d x=%d sum=%d\n", i, x, sum);
    }
    printf("%d\n", sum);
    return 0;
}
```

Входные данные:

```
4
2 5 -3 6
```

Выходные данные:

```
i=0 x=2 sum=2
i=1 x=5 sum=7
ВОРОНЫ!
i=3 x=6 sum=13
13
```

### Яблоневый сад
Усложним задачу.

В саду k рядов яблонь. В каждом ряду n яблонь, на каждой яблоне $a_i$ яблок. Сколько яблок собрали в этом саду?

Сначала задается количество рядов. Потом на 1 строке 1 ряд яблонь по формату: сколько яблонь в ряду и количество яблок на яблонях через пробел

Пример входных данных:

```c
3
2 15 24
3 7 82 15
1 54
```

Ответ:

```
197
```

Надо сложить числа (15 + 24) + (7 + 82 + 15) + (54) = 197

### 1 ряд - отдельной функцией
Вспомним код, который подсчитывал количество яблок в 1 ряду яблонь. Заметим, что это код корректно обрабатывает как такой формат входных данных:

```
3
5 2 10
```

так и количество яблонь на той же строке через пробел:
```
3 5 2 10
```

Вынесем код обработки одного ряда яблок в отдельную функцию pikup_1row()

```c
#include <stdio.h>

/* Суммирует количество яблок в 1 ряду яблонь */
int pikup_1row() 
{
    int x;          // яблок на одной (текущей) яблоне
    int sum;        // уже собрали яблок
    int n;          // количество деревьев
    int i;          // сколько деревьев уже обработали

    scanf("%d", &n);

    sum = 0;        // не забыть очистить корзину перед сбором яблок!
    for(i= 0; i < n; i++) {
        scanf("%d", &x);
        sum += x;
        printf("apple tree %d: x is %d and sum is %d\n", i, x, sum);
    }
    return sum;
}
int main()
{
    printf("%d\n", pikup_1row());
    return 0;
}
```
### Соберем весь сад

```c
#include <stdio.h>

/* Суммирует количество яблок в 1 ряду яблонь */
int pikup_1row() 
{
    int x;          // яблок на одной (текущей) яблоне
    int sum;        // уже собрали яблок
    int n;          // количество деревьев
    int i;          // сколько деревьев уже обработали

    scanf("%d", &n);

    sum = 0;        // не забыть очистить корзину перед сбором яблок!
    for(i= 0; i < n; i++) {
        scanf("%d", &x);
        sum += x;
        printf("i=%d x=%d sum=%d\n", i, x, sum);
    }
    return sum;
}
int main()
{
    int rows;       // сколько рядов яблонь
    int j;          // сколько рядов уже собрали
    int total;      // сколько яблок собрали во всех рядах

    scanf("%d", &rows);

    total = 0;
    for (j = 0; j < rows; j++) {
        total += pikup_1row();
        printf("j=%d total=%d\n", j, total);
    }   
    printf("%d\n", total);
    return 0;
}
```

Входные данные:

```c
3
2 15 24
3 7 82 15
1 54
```

Выходные данные:

```c
i=0 x=15 sum=15
i=1 x=24 sum=39
j=0 total=39
i=0 x=7 sum=7
i=1 x=82 sum=89
i=2 x=15 sum=104
j=1 total=143
i=0 x=54 sum=54
j=2 total=197
197
```

### Вложенный цикл
На месте вызова функции pikup_1row можно написать ее код (то, что она делает). Вынесем в начало функции main декларацию переменных и добавим печать номера ряда j в отладочную печать.

Получим вложенный цикл. Цикл по яблоням в одном ряду вложен в цикл по рядам.

```c
#include <stdio.h>

int main()
{
    // для всего сада:
    int rows;       // сколько рядов яблонь
    int j;          // сколько рядов уже собрали
    int total;      // сколько яблок собрали во всех рядах
    // для 1 ряда:
    int x;          // яблок на одной (текущей) яблоне
    int sum;        // уже собрали яблок
    int n;          // количество деревьев
    int i;          // сколько деревьев уже обработали

    scanf("%d", &rows);

    total = 0;
    for (j = 0; j < rows; j++) {

        scanf("%d", &n);
        sum = 0;        // не забыть очистить корзину перед сбором яблок!

        for(i= 0; i < n; i++) {
            scanf("%d", &x);
            sum += x;
            printf("j=%d i=%d x=%d sum=%d\n", j, i, x, sum);
        }
        total += sum;
        printf("j=%d total=%d\n", j, total);
    }   
    printf("%d\n", total);
    return 0;
}
```

Входные данные:

```c
3
2 15 24
3 7 82 15
1 54
```

Программа напечатает:

```c
j=0 i=0 x=15 sum=15
j=0 i=1 x=24 sum=39
j=0 total=39
j=1 i=0 x=7 sum=7
j=1 i=1 x=82 sum=89
j=1 i=2 x=15 sum=104
j=1 total=143
j=2 i=0 x=54 sum=54
j=2 total=197
197
```

### Оператор goto
Пусть в саду будут вороны.

У нас может быть или очень трусливый сборщик, который, увидев ворону, убегает сразу из всего сада. То есть нам хочется написать оператор `break` по внешнему циклу по j.

Или наш сборщик хочет бросать ряд и сразу убегать в начало следующего. То есть нужно `continue` по внешнему циклу. Подумайте, почему break по внутреннему циклу не равен `continue` по внешнему? (Что происходит с собранными в ряду яблоками? Добавляется ли sum в total?)

Но эти операторы работают только по ближайшему (внутреннему) циклу. Что делать? Использовать оператор `goto`.

Синтаксис оператора:

```c
goto МЕТКА;
```

где МЕТКА - это уже существующая метка, поставленная выше или ниже по коду. Имя метки - это идентификатор, но принято писать имена меток большими буквами.

Чтобы поставить метку, напишите

```c
МЕТКА:
```

Не забудьте поставить двоеточие :

Пример кода с goto

```
A:                          // на этой строке стоит метка А
    printf("Hello!\n");
    goto A;                 // переходим на строку с меткой А
```

+ Все метки в файле должны иметь разные имена.
+ К одной и той же метке могут вести разные goto.
+ goto не может передать управление вне функции, то есть метка и переход на нее должны быть написаны в рамках одной и той же функции.

Что делает этот код?

```c
A:                          // на этой строке стоит метка А
    printf("Hello!\n");
    goto A;                 // переходим на строку с меткой А
```

__Печатает бесконечно Hello!__

### Когда использовать goto
Использование goto понижает читаемость кода. Бесконечный цикл лучше написать как while(1) или for(;;).

goto стоит использовать только в 3 случаях:
+ break по внешнему циклу.
+ continue по внешнему циклу.
+ обработка ошибок (об этом будет подробно рассказано в курсе про IPC).

На какую метку нужно передать управление, чтобы goto работало как break по внешнему циклу (по j )?

То есть чтобы мы убегали из сада?

```c
int main()
{
A:  
    int rows, j, total, n, i, x, sum;
B:  
    scanf("%d", &rows);
    total = 0;
C:  
    for (j = 0; j < rows; j++) {
D:
        scanf("%d", &n);
        sum = 0;        // не забыть очистить корзину перед сбором яблок!
E:
        for(i= 0; i < n; i++) {
F:          
            scanf("%d", &x);
            if (x < 0)
                goto ???;       // куда переходить?
            sum += x;
            printf("j=%d i=%d x=%d sum=%d\n", j, i, x, sum);
G:          
        }
H:      
        total += sum;
        printf("j=%d total=%d\n", j, total);
K:      
    }   
L:  
    printf("%d\n", total);
M:  
    return 0;
}
```

__L__

На какую метку нужно передать управление, чтобы goto работало как continue по внешнему циклу (по j )?

То есть чтобы мы пропускали обработку этого ряда и переходили к началу следующего ряда яблонь?

```c
int main()
{
A:  
    int rows, j, total, n, i, x, sum;
B:  
    scanf("%d", &rows);
    total = 0;
C:  
    for (j = 0; j < rows; j++) {
D:
        scanf("%d", &n);
        sum = 0;        // не забыть очистить корзину перед сбором яблок!
E:
        for(i= 0; i < n; i++) {
F:          
            scanf("%d", &x);
            if (x < 0)
                goto ???;       // куда переходить?
            sum += x;
            printf("j=%d i=%d x=%d sum=%d\n", j, i, x, sum);
G:          
        }
H:      
        total += sum;
        printf("j=%d total=%d\n", j, total);
K:      
    }   
L:  
    printf("%d\n", total);
M:  
    return 0;
}
```

__K__

### break по внешнему циклу

__goto L;__ - break по внешнему циклу, нужно передать управление сразу за окончание цикла.

__goto K;__ - continue по внешнему циклу, нужно чтобы следующим оператором выполнялось увеличение номера ряда j++.

```c
int main()
{
A:  
    int rows, j, total, n, i, x, sum;
B:  
    scanf("%d", &rows);
    total = 0;
C:  
    for (j = 0; j < rows; j++) {
D:
        scanf("%d", &n);
        sum = 0;        // не забыть очистить корзину перед сбором яблок!
E:
        for(i= 0; i < n; i++) {
F:          
            scanf("%d", &x);
            if (x < 0)
                goto ???;       // куда переходить?
            sum += x;
            printf("j=%d i=%d x=%d sum=%d\n", j, i, x, sum);
G:          
        }
H:      
        total += sum;
        printf("j=%d total=%d\n", j, total);
K:      
    }   
L:  
    printf("%d\n", total);
M:  
    return 0;
}
```
## Возведение в натуральную степень

Алгоритм "в лоб"
По определению степени, $a^n$ - это a умноженное на себя n раз.

Записывая рекуррентную формулу $a^n =a \cdot a^{n−1}$
 

Для вычисления $a^{12}$ нам потребуются все остальные степени a:

$a^{12} →a^{11} →a^{10} →a^{9} →a^{8} →a^{7} →a^{6} →a^{5} →a^{4} →a^{3} →a^{2} →a^1$
 

Сложность алгоритма n−1

### n - степень двойки
Можно ли придумать вычисление эффективнее?

Будем на каждом шаге умножать результат сам на себя. Тогда из $a^1$ получим $a^{32}$ всего за 5 шагов:
$a^1→a^2→a^4→a^8→a^{16}→a^{32}$
 
Заметим, что $32 = 2^5$, то есть мы получаем значение за столько шагов, сколько нужно бинарных цифр для записи степени минус 1.

### Остальные степени
Доработаем алгоритм, чтобы он работал с любыми натуральными степенями.

Воспользуемся рекуррентными соотношениями для вычисления четных и нечетных степеней.

![07](/C_for_beginners_Stepik/Pictures/07_17.PNG)

__Задача 1__<br>
Докажите, что количество шагов данного алгоритма не превосходит удвоенного числа знаков в бинарной записи n.

__Задача 2__<br>
Попробуйте найти более точную оценку эффективности алгоритма.

__Задача 3__<br>
Реализуйте алгоритм. Убедитесь, что реализация не ухудшила ожидаемую эффективность.

## Неизвестное количество чисел

### Проблема
В задачах у вас сначала дано n - сколько чисел, потом эти числа.

Такой формат данных удобно применять для передачи данных от одной программы к другой. Например, матрицу MxN задать как
+ число М
+ число N
+ далее М строк по N чисел

Компьютеру удобно сохранять в этом формате и читать его.

Человеку такой формат не удобен. В списке группы студентов не пишут сначала "сколько студентов". Студенты могут добавляться и уходить. Хранить сначала количество студентов в списке значит создать возможность ошибки, когда n будет отличаться от реального количества студентов.

У нас есть список сколько вы потратили на покупки в рублях (целые числа). Хотите найти сумму всех покупок. Числа количества покупок сначала нет.

```
123 46 50
```

или

```
25 52 100 15 240
```

Как быть?

### `scanf`
Функция `scanf` возвращает количество корректно разобранных format placeholder (это разные %d и прочие %что-то, которые мы задаем в форматной строке, первом аргументе `scanf`).

```c
int x, y, res;
res = scanf("%d%d", &x, &y);
```

В строке "%d%d" 2 format placeholder. Посмотрим что возвращает этот вызов функции при разных вводимых данных.

Input | res | x | y | Почему
-|-|-|-|-
12 34 | 2 | 12 | 34 | разобрано 2 числа
hello | 0 | ? | ? | уже первый %d не разобрали, значения x и y не изменятся, указатель на входном потоке стоит на букве h, пробельные символы пропущены
13 abc | 1 | 13 | ? | разобрано первое число
qaz 11 | 0 | ? | ? | указатель входного потока при разборе первого %d остался на букве q, то есть второй %d начинает разбираться с того же места q
закрыт поток / конец файла | -1 | ? | ? | данных нет

__Пример__<br>
Даны точки на плоскости XY, напечатать координаты точек, которые находятся вне круга с радиусом 5 и центром в (0,0). Количество точек заранее не известно.

Пример входных данных:

```c
2 17
-4 4
3 6
1 4
```

Условие продолжение цикла разбора прочитанных данных - это когда успешно прочитано оба числа, то есть scanf вернул 2.

```c
#include <stdio.h>


#define R2 (5*5)


int main()
{
    int x, y;
    while(2 == scanf("%d%d", &x, &y)) {     // ПОКА прочитано два числа
        if (x*x + y*y > R2)
            printf("%d %d\n", x, y);
    }
    return 0;
}
```

Если вы вводите данные с клавиатуры руками, чтобы выйти из цикла вам нужно, чтобы scanf вернул не 2. Для этого или подать некорректные данные, например, букву, а не число. Или закрыть поток ввода (об этом поговорим подробнее в модуле о работе с файлами). Чтобы закрыть поток вводимых данных нажмите:

+ `Ctrl+D` в Linux, на МАС, а так же в WSL (это тоже Linux),
+ `Ctrl+Z` в командной строке Windows.

### Высокие студенты
У студентов измерили рост в сантиметрах (целое число) и записали числа на одной строке через пробел. Напечатайте сколько студентов измерили и сколько человек было выше 170 сантиметров?

```c
#include <stdio.h>

#define HIGHT 170

int main() {
    int x, count = 0, result = 0;
    while(1 == scanf("%d", &x)) {     // ПОКА прочитано число
        count++;
        if (x > HIGHT)
            result++;
    }
    printf("%d %d", count, result);
    return 0;
}
```

## for: задачи для начинающих

### Bfor_sum_even Сумма четных чисел
Дано натуральное число n, потом n целых чисел.

Вычислить и напечатать сумму только четных чисел.

```c
#include <stdio.h>

int main() {
    int n, result = 0;
    scanf("%d", &n);
    
    for (int i = 0; i < n; i++) {
        int x;
        scanf("%d", &x);
        if (x % 2 == 0)
            result += x;
    }
    printf("%d", result);
    return 0;
}
```

### Bfor_count_even Сколько четных чисел
Дано натуральное число n, потом n целых чисел.

Вычислить и напечатать сколько из них четных чисел.

```c
#include <stdio.h>

int main() {
    int n, result = 0;
    scanf("%d", &n);
    
    for (int i = 0; i < n; i++) {
        int x;
        scanf("%d", &x);
        if (x % 2 == 0)
            result++;
    }
    printf("%d", result);
    return 0;
}
```

### Bfor_min Минимальное число
Дано натуральное число n, потом n целых чисел.

Вычислить и напечатать самое маленькое из них.

Напечатать сначала числа через пробел. На следующей строке напечатать минимальное число.

```c
#include <stdio.h>

int main() {
    int n, min;
    scanf("%d", &n);
    scanf("%d", &min);
    printf("%d", min);
    for (int i = 1; i < n; i++) {
        int x;
        scanf("%d", &x);
        printf(" %d", x);
        if (x < min)
            min = x;
    }
    printf("\n%d", min);
    return 0;
}
```

## Циклы: Задачи для продолжающих

### for_4 n!
Дано $0≤n≤12$. Вычислите n!.

```c
#include <stdio.h>

int main() {
  int n, result = 1;
  scanf("%d", &n);

  while (n > 0) {
    result *= n--;
  }
  printf("%d", result);
  return 0;
}
```

### Bfor_min Минимальное число
Дано натуральное число n, потом n целых чисел.

Вычислить и напечатать самое маленькое из них.

```c
#include <stdio.h>

int main() {
  int n, min;
  scanf("%d %d", &n, &min);

	for (int i = 1; i < n; i++) {
		int x;
		scanf("%d", &x);
		if (x < min) {
			min = x;
		}
	}
	printf("%d", min);
  return 0;
}
```

### int_palindr палиндром числа
Дано целое десятичное число $1≤N≤10^9$ , последняя цифра не 0.

Число, записанное десятичными цифрами является палиндромом если его можно одинаково прочитать как справа налево, так и наоборот.

Написать программу, которая выясняет является ли данное число палиндромом (печатать YES) или нет (печатать NO).

Число | Палиндром?
-|-
123321 | YES
12321 | YES
12 | NO

```c
#include <stdio.h>

int main() {
  int num, original, revers = 0;
  scanf("%d", &num);
	original = num;
	while (num > 0) {
		revers = revers * 10 + num % 10;
		num /=10;		
	}
	printf("%s", original == revers ? "YES" : "NO");
  return 0;
}
```

### stepen_ch Степень числа
Дано целое число n, которое может оказаться k-ой ЦЕЛОЙ степенью другого ЦЕЛОГО числа. 
$n=a^k$<br>
$a=(a_1 ⋅ a_2 ⋅..⋅a^t)$

Написать программу, для выяснения для какого другого целого числа данное n является k-ой ЦЕЛОЙ степенью.

Входные данные: два целых числа через пробел $0<n<2^{64} −1$ и $0<k<10$

Выходные данные: отладочная печать - поиск сомножителей.
+ Первая строка - наименьший сомножитель корня $a_1$ , частное от деления на $a_1^k$ первый сомножитель в степени k .
+ Вторая строка -- второй предполагаемый сомножитель корня $a_2$, частное от деления n на $(a_1 ⋅ a_2)^k$ первый и второй сомножителя в степени k.
+ И так далее до тех пор пока могут быть найдены сомножители степени k.
+Последняя строка: если k - степень числа n, печатается корень, если нет -1

Пример 1

Входные данные: 36 2

То есть просят найти разложение числа 36 на квадраты чисел.

36 делится на 2 в квадрате, получаем частное 9. Печатаем 2 9.
9 делится на 3 в квадрате, получаем частное 1. Печатаем 3 1.
Так как частное 1, то процесс поиска делителей закончен, 36 раскладывается на квадрат 2 и квадрат 3, то есть 36 это квадрат 6. Печатаем 6.
Пример 2
Входные данные: 128 5

То есть просят найти разложение числа 128 на пятые степени какого-то числа.

128 делится на 2 в 5 степени, получаем частное 4. Печатаем 2 4.
4 уже не является никаким целым числом в 5 степени. Разложение невозможно. Печатаем -1

```c
#include <stdio.h>
#include <math.h>

int main() {
    int num, k, result = 1;
    scanf("%d %d", &num, &k);
	
    while (num > pow(2, k)) {
	    A:
	    for (int i = 2; i < 10; i++) {
		    int del = (int)pow(i, k);
		    if (num % del == 0) {
			    num /= del;
			    printf("%d %d\n", i, num);
			    result *=i;
			    goto A;				
			}
        }
        break;
    }
    printf("%d", num != 1 ? -1 : result);
    return 0;
}
```

### for_60 Сколько раз встретилась цифра в числе?
Даны через пробел цифра d и целое число в десятичной записи k. $0≤k≤2^32$ 

Напечатайте d, k и сколько раз цифра d входит в десятичную запись числа k?

```c
#include <stdio.h>
#include <math.h>

int main() {
    int d, k, result = 0, num;
    scanf("%d %d", &d, &k);
	num = k;
    while (num > 0) {
	    if (num % 10 == d) {
			result++;
		}
		num /=10;
    }
    printf("%d %d %d", d, k, result);
    return 0;
}
```

### for_6 Сколько раз встретилась цифра в ОЧЕНЬ БОЛЬШОМ числе?
Даны через пробел цифра d и целое число в десятичной записи k. $0≤k≤10^{100}$
 

Напечатайте d, k и сколько раз цифра d входит в десятичную запись числа k?

Подсказка-1: это не копия предыдущей задачи. k не поместится ни в один целочисленный тип. Придется читать и обрабатывать по символу.

Подсказка-2: как проверить, что символ - это цифра от 0 до 9? И при чем тут ctype.h?

Подсказка-2а: где в условии задачи сказано, что во входной последовательности будет обязательно \n? Нигде!

Подсказка-3: Если читаете через scanf, то вспомните, как читать неизвестное заранее количество данных

Подсказка-4: Альтернатива scanf (пока я не написала свою текстовку про символы и вы читаете теорию из курса Овсянниковой)
```c
int c;      // обязательно int
while ((c = getchar()) != EOF) { ... } // читать символы до конца потока (файла)
```

Как это работает и почему int? Если прочитали корректно символ, то getchar возвращает ASCII-код символа, в виде unsigned char, который преобразован к int. То есть в младшем байте ASCII-код, а в старших байтах - нули во всех битах. Если данных нет (ошибка чтения или поток откуда читаем в состоянии EndOfFile, EOF, конец файла), возвращается EOF или другая ошибка, и в старших битах что-то, отличное от "все нули".

Поэтому если у вас с типа char, то вы оставляете только младший байт, а всю часть, которая отвечает за диагностику "ошибка или нет" выбрасываете. Цикл крутится не до конца данных, а бесконечно, пока во входном потоке не появится символ, ASCII-код которого совпадает с (char)EOF.

```c
#include <stdio.h>
#include <string.h>
#define MAX 1001

int main() {
  char d;
  int result = 0;
  scanf("%c", &d);
  printf("%c ", d);
  char number[MAX];
  scanf("%1000s", number);
  printf("%s", number);
  int len = strlen(number);
  for (int i = 0; i < len; i++) {
    if (number[i] == d) {
      result++;
    }
  }
  printf(" %d", result);
  return 0;
}
```

```c
#include <stdio.h>
int main ()
{
    int d,k, c = 0;
    d = getchar();
    putchar(d);
 //   putchar(' ');
    while((k = getchar()) != EOF)
    {
        if(d == k && k>='0' && k<='9') c++;
        putchar(k);
    }
    putchar(' ');
    printf("%d",c);
    return 0;
}
```

### for_14 Скобки
Некоторые скобочные структуры правильные, другие — неправильные. Ваша задача — определить правильная ли скобочная структура.

Вход | Выход
-|-
`()` | YES
`(())()` | YES
`())` | NO
`)(` | NO

Входные данные: Слово в алфавите из двух круглых скобочек ( и ).

Выходные данные: YES, если скобочная последовательность корректная, иначе NO.

```c
#include <stdio.h>
#include <string.h>
#define MAX 200

int main() {
  int result = 0;
  char number[MAX];
  scanf("%199s", number);
  int len = strlen(number);

  for (int i = 0; i < len; i++) {
    if (result < 0) {
      break;
    } else if (number[i] == '(') {
      result++;
    } else if (number[i] == ')') {
      result--;
    }
  }
  printf("%s", result ? "NO" : "YES");
  return 0;
}
```

## Циклы: Задачи на "подумать"

### Aknights Рыцари и лжецы
На острове Буяне жили N человек, каждый из которых был либо рыцарем либо лжецом, встали в круг.

Рыцари говорят только правду, лжецы всегда только лгут. Каждому человеку в кругу задали вопрос: «Кто ты и кто твой сосед слева: рыцарь или лжец?» При этом каждый человек сказал, что он – рыцарь. А ответы всех людей о левом соседе были записаны в следующем формате: 1 – рыцарь 0 – лжец. Все ответы записаны в строку через пробел. Последний спрошенный человек отвечал на вопрос о первом.

Написать программу, которая по ответам жителей определяет, какое количество рыцарей заведомо присутствует в круге.

https://stepik.org/lesson/603570/step/1?unit=598631

### BookOfBooks: страницы книги
Царь Горох решил напечатать книгу книг. Она была отделана золотом и серебром, а цифры,обозначающие страници изготавливались из драгоценных камней. Царь Горох использовал десятичную систему счисления.

Известно количество страниц в этой книге (целое число $0<N<10^{12}$)

Необходимо эффективно подсчитать сколько всего нужно изготовить цифр для номеров страниц.

Требуется написать программу, которая вычисляет количество цифр, используя наименьшее количество итераций цикла в программе.

Входные данные. Одно целое число -- количество страниц.

Выходные данные. Два числа, разделенных пробелами: количество итераций циклов Вашей программы и количество цифр для нумерации страниц.

https://stepik.org/lesson/603570/step/2?unit=598631

### Abmyax Сверим часы
Бяксику и Мяксику подарили часы с 12-ти часовым циферблатом. Когда они встретились, часы Бяксика показывали `hb` часов и `minb` минут, часы Мяксика `hm` часов и `minm` минут.

Все часы ходили исправно.

Чтобы часы показывали одинаковое время, Бяксик сразу решил перевести их вперед на `hbf` часов и `minbf` минут и также переводить каждые `nb` минут, в Мяксик также сразу решил перевести назад на `hmb` часов и `minmb` минут и также переводить каждые `nm` минут. Ни Бякиск, ни Мяксик не переводили часы более чем на 11 часов 59 минут за один раз.

Написать программу, которая выясняет могут ли Бяксик и Мяксик добиться одинаковых показаний часов хотя бы за неделю. Если могут, то программа должна напечатать количество дней, часов и минут, за которые им это удалось, если нет, то программы печатает "NO".

Входные данные

```
hb:minb nb hbf:minbf
hm:minm nm hmb:minmb
```

Первая строка: два целых числа, разделенных ":" (показание часов Бяксика), пробел, целое число не более 60 (через сколько минут он переводит часы), далее два целых числа, разделенных ":" (на сколько часов и минут переводит часы)

Вторая строка: два целых числа, разделенных ":" (показание часов Мяксика), пробел, целое число не более 60 (через сколько минут он переводит часы), далее два целых числа, разделенных ":" (на сколько часов и минут переводит часы)

Выходные данные

Либо три целых числа в формате dd hh:mm, либо слово NO.

