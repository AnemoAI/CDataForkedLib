# Сортировка с помощью qsort

## Указатели на функции

### Объявление типа "указатель на функцию"
Функции, используемые в программах, как и переменные размещаются в памяти. Эта память также имеет адрес (точку входа), по которому и происходит вызов функции.

При объявлении и описании функции используется "имя функции". Адрес функции в языке С получается непосредственно при использовании имени функции (аналогично тому как используется имя массива).

В языке С возможно объявить тип "указатель на функцию" и использовать его, например, как параметры функций, элементы массива и т.д.

#### Пример объявления "указателя на функцию"

```c
#include <stdio.h>
#include <stdlib.h>
// Здесь объявлен тип Oper - указатель на функцию
// ( * Oper) - "указатель на"
// (* Oper) - указатель на функцию, которая возвращает 
// значение типа int и ожидает два аргументра типа int
typedef int (* Oper)(int, int);
// Теперь указатели этого типа могут принимать значения
// адресов функция с соответствующим интерфейсом

// Пример функций с интерфейсом типа Oper
int add(int a, int b) {
    return a + b;
}
int mult( int a, int b) {
    return a * b;
}

int main(){
    int a, b, res;
// Объявление и инициализация через 0
// указателя на функцию myf
  Oper myf = 0;
    scanf("%d%d", &a, &b);
// присваивание myf адреса функции add
    myf = add;
// исполнение кода add через указатель myf
    res = myf(a, b);
    printf("res: %d\n", res);
// присваивание myf адреса функции mult
    myf = mult;
// исполнение кода mult через указатель myf
    res = myf(a, b);
    printf("res: %d\n", res);

    return 0;
}
```

```c
>./fnpt
5 10
res: 15
res: 50
>
```
Заметим следующую особенность.

В описании указателя на функцию использовалась вот такая запись: int (* Oper)(int, int). Эта запись означает указатель на....

Если же написать int * Oper(int, int) - то это будет означать объявление прототипа функции, который возвращает указатель на int. Прототип функции не является указателем на нее. В этом случае необходимо предварительно написать реализацию функции, только тогда она будет размещена в памяти и получит адрес.

### Передача указателя на функцию в качестве параметра другой функции
Указатель на функцию можно передавать в качестве параметра другой функции. Тогда результат работы будет зависеть не только от того как реализована рассматриваемая функция, но и от того как реализована та, на которую передан указатель.

```c
#include <stdio.h>
#include <stdlib.h>
// Описание интерфейса функции и ее реализация
// isEq имеет три параметра: два типа int и 
// указатель на функцию с двумя аргументами int 
// и возвращающую int
int isEq( int a, int b, int (* sub) (int, int))
{
// при реализации isEq программист "ничего не знает" о
// реализации sub. И не должен знать
// При вызове sub получит указатель на реальную функцию,
// чей адрес (имя) будет указан в вызове
        return sub(a, b);
};
// А можно было объявить и так
// int isEq( int a, int b, Oper);

// Функция сравнения через вычитание
int subSimple(int a, int b)
{
    return a - b;
}
// Функция сравнения через абсолютные значения
int subAbs(int a, int b)
{
    return abs(a - b);
}

int main(){
    int a, b, res;
// Тестирование вызовов функции isEq() с 
// различным набором парамеров 
  for(int i = 0; i < 3; i++)
    {
        scanf("%d%d", &a, &b);
// подаем указатель на subSimple
        res = isEq(a, b, subSimple);
        printf("isEq(subSimple): %d\n", res);
// подаем указатель на subAbs
        res = isEq(a, b, subAbs);
        printf("isEq(subAbs): %d\n", res);
    }

    return 0;
}
```

```c
>./fff
2 5
isEq(subSimple): -3
isEq(subAbs): 3
4 4
isEq(subSimple): 0
isEq(subAbs): 0
-4 4
isEq(subSimple): -8
isEq(subAbs): 8
>
```

### Массивы указателей на функции

Раз уж имеется указатель на функцию, то можно использовать и массивы указателей на функцию

```c
#include <stdio.h>
#include <stdlib.h>

typedef int (* Oper)(int, int);
int add(int a, int b) {
    return a + b;
}
int mult( int a, int b) {
    return a * b;
}
int sub(int a, int b) {
    return a - b;
}

int main() {
    int a, b, res;
// Объявление массива указателей на функцию и
// инициализация их 0
  Oper myf[3] = {0, 0, 0};

// а можно было объявитиь и так:
//  int (* myf[3])(int, int) ={0, 0, 0};

// Адреса функций записываются в массив
    myf[0] = add;
    myf[1] = sub;
    myf[2] = mult;
    scanf("%d%d", &a, &b);
// В цикле исполняются все функции из массива 
    for( int i = 0; i < 3; i++) {
        res = myf[i](a, b);
        printf("res[%d]: %d\n", i, res);
    }

    return 0;
}
```

```c
>./ffm
6 7
res[0]: 13
res[1]: -1
res[2]: 42
>
```

## Использование функции qsort - Пример, использования указателей на функцию

### Интрефейс функции qsort().
Задачи сортировки элементов массивов различных типов возникают в программировании довольно часто. В дальнейшем Вам будет предложено реализовать некоторые алгоритмы сортировки самостоятельно. Но в данном разделе рассмотрим функцию языка С `qsort()` в качестве пример использования указателей на функции.

Функция `qsort()` имеет следующий интерфейс:

```c
void qsort(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *));
```

Эта функция сортирует массив `base`, размера `nmemb` элементов, при этом каждый элемент имеет размер `size`.

Для определения соотношения элементов в массиве используется функция `compar()`, которая это отношение и определяет. Если сравниваются два элемента a и b, то `compar()` может принимать следующие значения

Соотношение | возвращаемое значение `compar()`

a=b | 0
-|-
a>b | целое число >0
a<b | целое число <0

Значит для сортировки массива каждого типа нужно иметь реализованную функцию типа int (*compar)(const void *, const void *)

#### Функция типа `compar()`

Рассмотрим интерфейс функции

```c
int (*compar)(const void *, const void *);
```

Эта функция имеет два параметра типа `const void *`. Это означает, что тип указатели элементов, передаваемых в эту функцию, не определен. Кроме того, функция не может изменять элементы в процессе работы. Это совершенно необходимое условие, так как передаются адреса элементов.

Значит, в процессе реализации функций этого типа необходимо преобразовывать переданные элементы к нужному типу. В противном случае они будут интерпретироваться не верно.

### Сортировка массива чисел.
Рассмотрим пример с сортировкой массивов целых

```c
#include <stdio.h>
#include <stdlib.h>

void prInt(int * a, int n) {
    for(int i = 0; i < n; i++) {
        printf("%d ", a[i]);
    }
    printf("\n");
}
// Реализация функции сравнения
int cmpInt(const void* pa, const void * pb) {
// Преобразование неопределенного указателя к указателю типа int*
// и получение значения
    int a = *(int *) pa;
    int b = *(int *) pb;
// возвращвемая разность как раз будет 
// удовлетворять нужному критерию
    return a - b;
}

// Реализация функции сравнения "обратным" порядком
int cmpIntR(const void* pa, const void * pb) {
// Можно сразу получить значения
    return *(int* )pb - *(int *)pa;
}

int main() {
    int ar[10] = {2, 17, 22, -100, 0, -18, 77, -22, 3, 2};
    prInt(ar, 10);
// Вызов функции qsort() для 10 элементов массива ar
    qsort(ar, 10, sizeof(int), cmpInt);
    prInt(ar, 10);
// Соритровка с 3 по 8 элементов  массива ar в "обратном" порядке
     qsort(ar + 2, 5, sizeof(int), cmpIntR);
    prInt(ar, 10);
    return 0;
}
```

```c
>./si0
2 17 22 -100 0 -18 77 -22 3 2 
-100 -22 -18 0 2 2 3 17 22 77 
-100 -22 3 2 2 0 -18 17 22 77 
>
```

### Сортировка дробных чисел
При написании функции типа `compare()` заметим, что она должна возвращать целое число. Значит это нужно учитывать при реализации этой функции для элементов типа `float`

```c
#include <stdio.h>
#include <stdlib.h>

int cmpFloat(const void* pa, const void * pb) {
    float a = *((float*)pa);
    float b = *((float*)pb);
    return (a > b) - (a < b);
}
```

№ | a | b | (a>b)−(a<b)
-|-|-|-
1 | 5 | 5 | 0−0=0
2 | 5 | 4 | 1−0=1
3 | 4 | 5 | 0−1=−1

```c
void prFloat(float *a, float n) {
    for(int i = 0; i < n; i++)
        printf("%0.2f ", a[i]);
    printf("\n");
}

int main() {
    float far[10] = {0.15, 0.12, 0.1, 0.33, 3.15, 3.14, 4., 3., 0., .1 };
    prFloat(far, 10);
    qsort(far, 10, sizeof(float), cmpFloat);
    prFloat(far, 10);
    return 0;
}
```

```c
>./sfl
0.15 0.12 0.10 0.33 3.15 3.14 4.00 3.00 0.00 0.10 
0.00 0.10 0.10 0.12 0.15 0.33 3.00 3.14 3.15 4.00 
>
```
### Сортировка элементов типа struct
Рассмотрим точки на плоскости, заданные целыми координатами (x,y). Необходимо отсортировать эти точки по расстоянию от точки (0,0)

```c
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
// описание точки на плоскости
typedef struct {
    int x, y;
    int dist2; // квадрат расстояния
}Point;

// создание динамического массива и его заполненеипе 
Point * getPoints(int * n) {
    scanf("%d", n);
    Point *tmp = calloc(*n, sizeof(Point));
    for( int i = 0; i < *n; i++) {
        scanf("%d%d", &(tmp[i].x), &(tmp[i].y));
// квадрат расстояния лучше вычислить сразу один раз
        tmp[i].dist2 = tmp[i].x * tmp[i].x + tmp[i].y * tmp[i].y;
    }
    return tmp;
}
// Функция сравнения двух точек

int cmpPoint(const void* pa, const void * pb) {
// Преобразование неопределенного указателя у
// указателю на Point* и обращение к атрибутам структуры
    return ((Point *) pa)->dist2 - ((Point *)pb)->dist2;
}

void prPoint(Point * a, int n) {
    for(int i = 0; i < n; i++) {
        printf("(%d, %d): %0.2f\n", a[i].x, a[i].y, sqrt(a[i].dist2));
    }
    printf("\n");
}
int main(){
    Point * a = 0;
    int n;
    a = getPoints(&n);
    prPoint(a, n);
    qsort(a, n, sizeof(Point), cmpPoint);
    printf("Сортировка по расстоянию от 0\n");
    prPoint(a, n);
    free(a);
    return 0;
}
```

```c
./sortPoints<p.dat 
(0, 4): 4.00
(1, 0): 1.00
(5, 5): 7.07
(1, 1): 1.41
(0, 1): 1.00
(-1, 0): 1.00
(8, 0): 8.00
(4, 0): 4.00
(-5, 5): 7.07
(0, -1): 1.00
```

Сортировка по расстоянию от 0

```c
(1, 0): 1.00
(0, 1): 1.00
(-1, 0): 1.00
(0, -1): 1.00
(1, 1): 1.41
(0, 4): 4.00
(4, 0): 4.00
(5, 5): 7.07
(-5, 5): 7.07
(8, 0): 8.00
>
```

Как видим, неопределенный указатель можно преобразовать к любому другому типу указателя.

### Сортировка по "сложным" критериям

#### "Ямка".
Дан массив целых чисел. Необходимо отсортировать их так, чтобы отрицательные числа были отсортированы по убыванию, а положительные - по возрастанию.

```c
#include <stdio.h>
#include <stdlib.h>

void prInt(int * a, int n) {
    for(int i = 0; i < n; i++)
        printf("%d ", a[i]);
    printf("\n");
}
// Реализация функции сравнения для "ямки"
int cmpEv0(const void* pa, const void * pb) {
    int a = *(int *) pa;
    int b = *(int *) pb;
    if( a < 0 && b < 0   )
        return b - a;

    return a - b;
}
int main() {
    int ar[10] = {2, 17, 22, -100, 0, -18, 77, -22, 3, 2};
    prInt(ar, 10);
    qsort(ar, 10, sizeof(int), cmpInt);
    prInt(ar, 10);

    return 0;
}
```

```c
>./sortInt
./sinc
2 17 22 -100 0 -18 77 -22 3 2 
-18 -22 -100 0 2 2 3 17 22 77 
>
```

### Сортировка точек по расстоянию и координатам

```c
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
typedef struct {
    int x, y;
    int dist2;
}Point;

Point * getPoints(int * n) {
    scanf("%d", n);
    Point *tmp = calloc(*n, sizeof(Point));
    for( int i = 0; i < *n; i++) {
        scanf("%d%d", &(tmp[i].x), &(tmp[i].y));
        tmp[i].dist2 = tmp[i].x * tmp[i].x + tmp[i].y * tmp[i].y;
    }
    return tmp;
}
// Если расстояния равны, то первой располагается точка, 
// которая левее и у которой y меньше
int cmpPointF(const void* pa, const void * pb) {
    Point *a = (Point *) pa;
    Point *b = (Point *) pb;
    if(a->dist2 == b->dist2) {
        if(a->x == b->x)
            return a->y - b->y;
        return a->x - b->x;
    }
    return a->dist2 - b->dist2;
}

void prPoint(Point * a, int n) {
    for(int i = 0; i < n; i++) {
        printf("(%d, %d): %0.2f\n", a[i].x, a[i].y, sqrt(a[i].dist2));
    }
    printf("\n");
}
int main() {
    Point * a = 0;
    int n;
    a = getPoints(&n);
    qsort(a, n, sizeof(Point), cmpPointF);
    prPoint(a, n);
    return 0;
}
```

```c
./sortPointXY<p.dat
(-1, 0): 1.00
(0, -1): 1.00
(0, 1): 1.00
(1, 0): 1.00
(1, 1): 1.41
(0, 4): 4.00
(4, 0): 4.00
(-5, 5): 7.07
(5, 5): 7.07
(8, 0): 8.00
>
```

### Сортировка строк
При сортировке строк нужно учитывать, что начало строки - это тоже указатель на char.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
// Выделение памяти под массив указателей на строки,
// выделение памяти для каждой строки и заполнение значениями 
char ** getStrings(int * n) {
    scanf("%d", n);
    char buf[100];
    char **tmp = calloc(*n, sizeof(char*));
    for( int i = 0; i < *n; i++) {
        scanf("%s", buf);
        int len  = strlen(buf);
        tmp[i] = calloc(len + 1, sizeof(char));
        strcpy(tmp[i], buf);
    }
    return tmp;
}
// Строки будут сравниваться лексикографически
int cmpStr(const void* pa, const void * pb) {
// Преобразуем неопределенный указатель  к (char**) и
// Этот указатель - адрес одной строки из массива
// поэтому ((char **) pa)[0] и *(char **) pb - начало строки
    return strcmp(((char **) pa)[0], *(char **) pb);
}
void prStr(char ** a, int n) {
    for(int i = 0; i < n; i++) {
        printf("%s\n", a[i]);
    }
}

void  destroyStrAr(char ** a, int n) {
    if ( a != 0)
        for(int i = 0; i < n; i++)
            free(a[i]);
    free(a);
}

int main() {
    char ** a = 0;
    int n;
    a = getStrings(&n);
    printf("Изначальный массив\n");
    prStr(a, n);
// В массиве a - УКАЗАТЕЛИ на char (начло строк)
    qsort(a, n, sizeof(char*), cmpStr);
    printf("Сортировка\n");
    prStr(a, n);
    destroyStrAr(a, n);
    return 0;
}
```

```
./sortString<str.dat 
Изначальный массив
abc
ABdre
Vfre
Poilin
123A
Сортировка
123A
ABdre
Poilin
Vfre
abc
>
```

### Как "не испортить" изначальный массив
Часто необходимо работать с элементами массива, отсортированными по определенным (возможно даже разным) критериям, но также важно и изначальное расположение элементов в массиве.

Чтобы иметь возможность манипулировать с расположением элементов "не изменяя" изначальный массив, добавляют еще один массив указателей на элементы изначального массива.

```c
#include <stdio.h>
#include <stdlib.h>

// Печать значений элементов массива, адреса которых
// находятся в элементах массива dir
void prDir(int ** dirAr, int n) {
    for(int i = 0; i < n; i++)
        printf("%d ", dirAr[i][0]);
    printf("\n");
}
// Функция сравнения элементов, адреса которых находятся 
// по адресам переданных указателей
int cmpDir(const void* pa, const void * pb) {
//  (int**)pa - адрес ячейки в массиве dir
//  *( int **)pa или (int **)pa[0] - адрес элемента из массива ar,
// записанный в элемент массива dirAr
// ((int **)pa)[0][0] - значение элемента массива ar
// Вот эти значения и сравниваем, а сортироваться будут значения 
// массива dirAr - указатели на ячейки ar 
    return ((int **)pa)[0][0] - ((int **)pb)[0][0];
}

// Функция сравнения для сортировки по убыванию
int cmpDirR(const void* pa, const void * pb) {

    return ((int **)pb)[0][0] - ((int **)pa)[0][0];
}

void prInt(int * a, int n) {
    for(int i = 0; i < n; i++)
        printf("%d ", a[i]);
    printf("\n");
}

int main() {
    int ar[10] = {2, 17, 22, -100, 0, -18, 77, -22, 3, 2};
// массив указателей на int
// для адресов ячеек ar
    int *dirAr[10]; 
// заполняем dir адресами ячеек ar
    for(int i = 0; i < 10; i++)
        dirAr[i] = ar + i;
// Печать ar
    prInt(ar, 10);
// Печать dir (напечатает то же самое)
    prDir(dirAr, 10);
// Сортировка массива dirAr
    qsort(dirAr, 10, sizeof(int *), cmpDir);
// Печать dirAr
    prDir(dirAr, 10);
// Печать ar (не должен измениться)
    prInt(ar, 10);
// сортировка "реверс"
    qsort(dirAr, 10, sizeof(int *), cmpDirR);
    prDir(dirAr, 10);
    prInt(ar, 10);

    return 0;
}
```

```
>./sortDir
./sdir
2 17 22 -100 0 -18 77 -22 3 2 
2 17 22 -100 0 -18 77 -22 3 2 
-100 -22 -18 0 2 2 3 17 22 77 
2 17 22 -100 0 -18 77 -22 3 2 
77 22 17 3 2 2 0 -18 -22 -100 
2 17 22 -100 0 -18 77 -22 3 2 
>
```

## Примеры сортировки

### return x-y;
Можно ли использовать такую функцию сравнения целых чисел?

```c
int cmp_int(const void * p1, const void * p2) {
    int x = *(const int *)p1;
    int y = *(const int *)p2;
    return x - y;
}
```

Проверим как она работает:

```c
int main() {
    int a = 2, b = 7, d = 7;
    assert(cmp_int(&a, &b) < 0);    // -5 < 0
    assert(cmp_int(&b, &a) > 0);    // 5 > 0
    assert(cmp_int(&b, &d) == 0);   // 0 == 0
    return 0;
}
```

Кажется, что функция сравнения работает правильно.

### cmp_char
Добавим тесты на переполнение `(overflow)`. Покажем переполнение на примере сравнения `char`. Это числа от `-128` до `127`.

```c
int cmp_char(const void * p1, const void * p2) {
    char x = *(const char *)p1;
    char y = *(const char *)p2;
    char res = x - y;
    printf("x=%d y=%d res=%d\n", x, y, res);
    return res;
}
```

Проверим, что функция работает правильно на тех же тестовых данных и добавим новые тесты:

```c
int main() {
    char a = 2, b = 7, d = 7;
    assert(cmp_char(&a, &b) < 0);    // x=2 y=7 res=5    5 < 0
    assert(cmp_char(&b, &a) > 0);    // x=7 y=2 res=-5  -5 > 0
    assert(cmp_char(&b, &d) == 0);   // x=7 y=7 res=0    0 == 0


    a = -128, b = -70, d = 70;
    cmp_char(&a, &b);               // x=-128 y=-70 res=-58
    cmp_char(&a, &d);               // x=-128 y=70 res=58, т.е -128 > 70 ?
    cmp_char(&b, &d);               // x=-70 y=70 res=116, т.е -70 > 70  ?


    char arr[] = {-128, -70, 70};                   // уже отсортирован по возрастанию
    qsort(arr, 3, sizeof(char), cmp_char);
    printf("%d %d %d\n", arr[0], arr[1], arr[2]);   // 70 -128 -70 сломали


    return 0;
}
```

Что делать?
+ Можно переписать сравнение через if else, так как -70 - 70 = -140 не вмещается в диапазон char, поэтому переполнение вx-y приводит к неверному результату сравнения.
+ Можно перейти к большему типу, int, long int или long long int. Но если данные уже в типе long long int или unsigned long long int, то функция сравнения через x-y внесет ошибки в сортировку.

### Операции сравнения
Значение выражения с операцией сравнения в языке Си имеет значение `0`, если сравнение неверно, или `1`, если сравнение верно.

При `x=3` выражение `x<7` имеет значение `1`, а выражение `x>10` имеет значение `0`.

Приоритет сравнения ниже, чем у `+` или `-`. Поэтому в выражении `(x>y)-(x<y)` обязательны скобки. Вычислим его значение при разных `x` и `y`


x ? y | x>y | x<y | (x>y)-(x<y) | результат
-|-|-|-|-
x < y | 0 | 1 | (0)-(1) | -1
x == y | 0 | 0 | (0)-(0) | 0
x > y | 1 | 0 | (1)-(0) | 1

Если данные умещаются в тип `int`, то при сравнении нет переполнения:

```c
int cmp_int(const void * p1, const void * p2) {
    int x = *(const int *)p1;
    int y = *(const int *)p2;
    return (x>y)-(x<y);
}
```

### Сравнение чисел с плавающей точкой
При сравнении через `x-y` чисел с плавающей запятой `(floating point)` возникает другая проблема. Результат этой операции тоже число с плавающей запятой. Возвращать функция должна `int`. То есть результат приводится к целому типу. При этом теряется информация.

x | y | x - y | (int)(x - y) | Ответ
-|-|-|-|-
12.5 | 7.1 | 5.4 | 5 | x > y, 5 > 0 - правильно
12.5 | 12.1 | 0.4 | 0 | x > y, 0 - ошибка

Числа 12.5 и 12.1 можно оставить на своих местах, ибо функция сравнения вернула 0, то есть эти числа равны с точки зрения алгоритма сортировки.

Проверьте, работает ли сравнение таких чисел через $(x>y)-(x<y)$.

### Пример: несколько критериев сортировки
Есть несколько предложений работы. Дана ставка в рублях (гарантированная часть зарплаты) и премия (часть зарплаты, не гарантированная).

Зарплата = ставка + премия.

Отсортируйте предложения по большей сумме ставки и премии, при равной сумме зарплаты сначала идут предложения с большей ставкой.

Дано N < 100. Далее N строк. На каждой строке через пробел ставка и премия. Гарантировано, что и ставка, и премия умещаются в int.

Напечатать N строк отсортированных предложений о работе в формате ставка, премия, зарплата через пробел, по 1 предложению на строку.

Входные данные:

```
4
100 20
155 50
200 5
10 140
```

Выходные данные:

```
200 5 205
155 50 205
10 140 150
100 20 120
```

Объявим структуру Zarplata.

```c
typedef struct {
    int base;   // ставка
    int prem;   // премия
} Zarplata;
```

Прочитаем, отсортируем, напечатаем. Если в массиве хранятся элементы типа Zarplata, то размер одного элемента массива sizeof(Zarplata):

```c
#define N 100
int main() {
    int n, i;
    Zarplata a[N];


    scanf("%d", &n);
    for(i = 0; i < n; i++)
        scanf("%d%d", &a[i].base, &a[i].prem);


    // отладочная печать, проверяем, что прочитали данные верно
    for(i = 0; i < n; i++)
        printf("%d %d\n", a[i].base, a[i].prem);


    qsort(a, n, sizeof(Zarplata), cmp_zarplata);


    for(i = 0; i < n; i++)
        printf("%d %d %d\n", a[i].base, a[i].prem, a[i].base + a[i].prem);


    return 0;
}
```

Функция сравнения `cmp_zarplata`. Преобразуем `p1` и `p2` к указателям на структуры.

```c
int cmp_zarplata(const void * p1, const void * p2) {
    // а и b указатели на зарплату
    const Zarplata * a = (const Zarplata *)p1;
    const Zarplata * b = (const Zarplata *)p2;


    int a_sum = a->base + a->prem;
    int b_sum = b->base + b->prem;


    // если суммы разные, сравниваем только суммы
    if (a_sum != b_sum)
        return (a_sum < b_sum) - (a_sum > b_sum);


    // если дошли сюда, то тут суммы одинаковые, нужно сравнить base
    return (a->base < b->base) - (a->base > b->base);
}
```

Сохраним программу в файл [zarplata.c](https://stepik.org/media/attachments/lesson/630885/zarplata_strip.c), входные данные в файл [data_zarplata.txt](https://stepik.org/media/attachments/lesson/630885/data_zarplata.txt)

Соберем программу:

```bash
gcc -Wall -Wextra -g zarplata.c
```

Запустим тест:

```bash
./a.out < data_zarplata.txt
```

Напечатает отладочную печать и вывод

```
100 20
155 50
200 5
10 140
200 5 205
155 50 205
10 140 150
100 20 120
```

Если кажется, что работает, надо добавить тестов.

### Большая зарплата
Проверим для больших зарплат. Файл `data_big_zarplata.txt` содержит большие зарплаты:

```
4
1000000000 2000000000
1550000000  500000000
2000000000  500000000
100000000 1400000000
```

Запускаем. Программа печатает:

```
1000000000 2000000000
1550000000  500000000
2000000000  500000000
100000000 1400000000
1550000000  500000000 2050000000
100000000 1400000000 1500000000
1000000000 2000000000 -1294967296
2000000000  500000000 -1794967296
```

Ставка и премия верные, а зарплата иногда отрицательная.

Если кажется, что проблема в функции сравнения, закомментируйте сортировку и просто прочитайте и напечатайте данные. Они должны печататься без ошибок.

Получим результат:

```
1000000000 2000000000
1550000000  500000000
2000000000  500000000
100000000 1400000000
1000000000 2000000000 -1294967296
1550000000  500000000 2050000000
2000000000  500000000 -1794967296
100000000 1400000000 1500000000
```

Вывод: проблема в вычислении суммы. Та же проблема в функции сравнения. Научимся складывать правильно.

Сумму будем хранить в long long int переменной.

```c
    long long int sum;
    for(i = 0; i < n; i++) {
        sum = a[i].base + a[i].prem;
        printf("%d %d %lld\n", a[i].base, a[i].prem, sum);
    }
```

Не помогло. Почему?

Вспомним `float x = 7/2`;. `x` равно `3.0`, потому что `7` и `2` оба типа int и сначала происходит целочисленное деление `7/2` и получается `3`, и только потом `3` автоматически преобразуется к типу `float`. Получается `3.0`.

Чтобы получить `3.5` надо сначала преобразовать один или оба операнда к `float`, а потом делить.

```c
float x = (float)7 / 2; // приоритет у (float) больше, чем у /
```

Аналогично нам надо не только хранить результат в `long long int`, но и хотя бы один операнд тоже должен быть этого типа.

```c
        sum = (long long int)a[i].base + a[i].prem;
```

Можно одно или оба поля структуры `Zarplata` сделать типа `long long int`, но это увеличит размер массива.

Аналогично нужно исправить вычисление суммы в функции сравнения.

### Сортировка строк
Строка - это массив ASCII-кодов символов, заканчивающихся символом `\0`. Для сравнения строк используют стандартную функцию языка Си `strcmp`.

Объявим массив строк и отсортируем его по возрастанию (как в словаре).

В массиве a каждый элемент это только указатель на начало строки (адрес), а не вся строка. При сортировке мы будем менять местами адреса. Строки в памяти при этом лежат на тех же местах.

У нас есть стопка зачеток. Каждая зачетка указывает на студента. Мы отсортировали стопку зачеток, например по фамилиям. Студенты при этом сидят на своих местах и мы их не трогаем.

```c
int main() {
    char * a[] = {
        "hello",
        "good bye",
        "abc",
        "hell"
    };
    size_t n, i;
    n = sizeof(a) / sizeof(a[0]);
    // отладочная печать, проверяем, что строки есть
    for(i = 0; i < n; i++)
        printf("%s\n", a[i]);


    qsort(a, n, sizeof(char *), cmp_str);   // каждый элемент массива имеет тип char *


    printf("--------------\n");


    for(i = 0; i < n; i++)
        printf("%s\n", a[i]);


    return 0;
}
```

Чтобы понять как писать функцию сравнения, перепишем программу сортировки массива `int`, использовав `typedef int T`, то есть заменим тип `int` псевдонимом `T`.

```c
#include <stdio.h>
#include <stdlib.h>


typedef int T;


int cmp(const void * p1, const void * p2) {
    const T x = *(const T*)p1;
    const T y = *(const T*)p2;


    return (x>y) - (x<y);
}
int main() {
    T a[4] = {3, -7, 11, 2};
    qsort(a, 4, sizeof(T), cmp);


    for(int i = 0; i < 4; i++)
        printf("%d ", a[i]);
    printf("\n");
    return 0;
}
```

Если я перепишу сортировку через `typedef` какого-то типа в `T`, то какой тип нужно выбрать?

Сравним для `int`:

```c
int a[4] = {3, -7, 11, 2};  // без typedef
T   a[4] = {3, -7, 11, 2};  // с   typedef int T
```

Для массива строк:

```c
char * a[] = {"hello", "good bye", "abc", "hell"};  // без typedef
T      a[] = {"hello", "good bye", "abc", "hell"};  // c   typedef
```

Значит нужна замена указателя на строку `char *` на `T`:

```c
typedef char* T;
```

Вызов функции сортировки для строк (смотрим, почти повторяет для `int`)

```c
qsort(a, n, sizeof(T), cmp_str);   // каждый элемент массива имеет тип T
Теперь сравнение int

int cmp(const void * p1, const void * p2) {
    const T x = *(const T*)p1;  // получаем 2 объекта типа T (целое число)
    const T y = *(const T*)p2;


    return (x>y) - (x<y);       // сравнение целых чисел
}
```

Сравнение целых чисел `(x>y) - (x<y)` тоже можно оформить как отдельную функцию:

```c
int intdiff(int x, int y) {
    return (x>y) - (x<y);       // сравнение целых чисел
}

int cmp(const void * p1, const void * p2) {
    const T x = *(const T*)p1;  // получаем 2 объекта типа T (целое число)
    const T y = *(const T*)p2;


    return intdiff(x, y);       // сравнение целых чисел
}
```

Перепишем на сравнение строк. T пока не убираем:

```c
int cmp_str(const void * p1, const void * p2) {
    const T x = *(const T*)p1;  // получаем 2 объекта типа T (указатель на начало строки)
    const T y = *(const T*)p2;


    return strcmp(x, y);        // сравнение строк x и y
}
```

Заменяем `T` обратно на `char *` и названия строк `x` и `y` меняем на `s1` и `s2`:

```c
int cmp_str(const void * p1, const void * p2) {
    const char * s1 = *(const char **)p1;  // получаем 2 объекта типа T (указатель на начало строки)
    const char * s2 = *(const char **)p2;


    return strcmp(s1, s2);        // сравнение строк s1 и s2
}
```

Заметим, что в элементе массива лежит `char *`. В функцию сравнения мы получаем адрес этого элемента, то есть `char **`.

Полностью программа:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


int cmp_str(const void * p1, const void * p2) {
    // а и b адреса начала строк
    const char * a = *(const char **)p1;
    const char * b = *(const char **)p2;


    return strcmp(a, b);
}


int main() {
    size_t n, i;
    char * a[] = {
        "hello",
        "good bye",
        "abc",
        "hell"
    };
    n = sizeof(a) / sizeof(a[0]);
    // отладочная печать, поверяем, что строки есть
    for(i = 0; i < n; i++)
        printf("%s\n", a[i]);


    qsort(a, n, sizeof(char *), cmp_str);


    printf("--------------\n");


    for(i = 0; i < n; i++)
        printf("%s\n", a[i]);


    return 0;
}
```

### Сортировка двухмерного массива
Пусть есть строки, которые хранятся в двухмерном массиве символов. Их нужно отсортировать.

```c
#define N 20


char text[][N] = {
    "hello",
    "good bye",
    "abc",
    "hell"
};
```

В чем разница с предыдущим случаем? Нам нужно менять местами элементы массива, каждый из которых длинной 20 `char`.

`qsort` укажем длину элемента 20 `char`.

```c
    qsort(text, n, N, cmp_char_array);
```

Функция сравнения будет сразу получать указатели на строки.

```c
int cmp_char_array(const void * p1, const void * p2) {
    // p1 и p2 это УКАЗАТЕЛИ на char[20]
    // но указатель на массив передается как указатель на его первый элемент
    // таким образом в p1 и p2 лежит char * - указатель на строку
    // ее можно сравнить strcmp
    return strcmp(p1, p2);
}
```

[Полный текст программы](https://stepik.org/media/attachments/lesson/630885/sort_text.c)

### Двухмерный массив очень большой
Если такой массив очень большой, то лучше менять указатели на строки и не трогать сами строки.

Создадим массив указателей на начало строк и сведем задачу к сортировке массива указателей.

Если бы у нас были разрешены массивы из C99, размер которых определяется во время выполнения, то можно было бы написать `char * text1[n];`

```c
size_t n = sizeof(text)/sizeof(text[0]);    // количество строк, 80/20 = 4


char ** text1 = malloc(n * sizeof(char*));  // char * text1[n];


for(i = 0; i < n; i++)
    text1[i] = text[i];   // копируем АДРЕС начала строки (а не всю строку)
```

Если в коде использовался `malloc`, не забудьте в конце написать `free(text1);`

[Полный текст программы](https://stepik.org/media/attachments/lesson/630885/sort_str.c)

## Задачи на сортировку

### qsort_1: cmp_int
Реализуйте функцию

```c
int cmp_int(const void * p1, const void * p2)
```

которая сравнивает два числа типа `int`, лежащих по адресам `p1` и `p2` и возвращает:
+ `< 0`, если первое число меньше второго,
+ `0`, если числа равны,
+ `> 0`, если первое число больше второго.

Посылать только реализацию функции. Для её проверки используется функция main:

```c
int main() {
    int x, y, res;
    scanf("%d%d", &x, &y);

    res = cmp_int(&x, &y);

    if (res < 0)
        res = '<';
    else if (res > 0)
        res = '>';
    else
        res = '=';

    printf("%c\n", res);

    return 0;
}
```

```c
int cmp_int(const void * p1, const void * p2) {
    int x = *(const int *)p1;
    int y = *(const int *)p2;
    return (x>y)-(x<y);
}
```

### Тестирование функции сравнения
Рекомендуем отдельно тестировать функцию сравнения. Используйте для этого `assert`:

```c
int a[] = {3, -7, 5, 3};
assert(cmp_int(a, a+1) > 0);
assert(cmp_int(a, a+2) < 0);
assert(cmp_int(a, a+3) == 0);
```

Если в задаче просят прочитать данные и напечатать отсортированные данные, отладьте сначала код, который читает и печатает данные без сортировки.

### qsort_2: по возрастанию
Напечатайте входную последовательность, отсортировав ее по возрастанию с помощью стандартной функции `qsort`.

Дано $N≤1000$, далее N целых чисел, которые помещаются в тип `int`.

Напечатайте числа по возрастанию.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define N 1000

int main() {
    int n, numbers[N];
    scanf("%d", &n);
    for (int i = 0; i < n; i++) scanf("%d", &numbers[i]);
    for (int i = 0; i < n - 1; i++) {
        for (int j = i; j < n; j++) {
            if (numbers[i] > numbers[j]) {
                int tmp = numbers[i];
                numbers[i] = numbers[j];
                numbers[j] = tmp;
            }
        }
    }

    for (int i = 0; i < n; ++i) printf("%d ", numbers[i]);

    return 0;
}
```

```c
#include <stdio.h>
#include <stdlib.h>

#define N 1000

int cmp_int(const void * p1, const void * p2) {
    int x = *(const int*)p1;
    int y = *(const int*)p2;

    return (x > y) - (x < y);
}

void print_arr(int * a, int n) {
    for(int i = 0; i < n; i++)
        printf("%d ", a[i]);
    printf("\n");
}

int main() {
    int a[N];
    int n;
    scanf("%d", &n);
    for (int i = 0; i < n; i++)
        scanf("%d", a + i);
    
    // print_arr(a, n);
    qsort(a, n, sizeof(a[0]), cmp_int);
    print_arr(a, n);
    
    return 0;
}
```

```c
#include <stdio.h>
#include <stdlib.h>
#define N 1000

void prInt(int* a, int n) {
    for (int i = 0; i < n; i++) printf("%d ", a[i]);
    printf("\n");
}
// Реализация функции сравнения
int cmpInt(const void* pa, const void* pb) {
    // Преобразование неопределенного указателя к указателю типа int*
    // и получение значения
    int a = *(int*)pa;
    int b = *(int*)pb;
    // возвращвемая разность как раз будет
    // удовлетворять нужному критерию
    return a - b;
}

// Реализация функции сравнения "обратным" порядком
int cmpIntR(const void* pa, const void* pb) {
    // Можно сразу получить значения
    return *(int*)pb - *(int*)pa;
}
int main() {
    int n, numbers[N];
    scanf("%d", &n);
    for (int i = 0; i < n; i++) scanf("%d", &numbers[i]);

    // prInt(numbers, 10);
    // Вызов функции qsort() для 10 элементов массива numbers
    qsort(numbers, n, sizeof(int), cmpInt);
    prInt(numbers, n);
    // Соритровка с 3 по 8 элементов  массива numbers в "обратном" порядке
    // qsort(numbers + 2, 5, sizeof(int), cmpIntR);
    // prInt(numbers, n);
    return 0;
}
```

### qsort_3: по убыванию
Напечатайте входную последовательность, отсортировав ее по убыванию.

Дано N≤1000, далее N целых чисел, которые помещаются в тип int.

Напечатайте числа по убыванию.

```c
#include <stdio.h>
#include <stdlib.h>
#define N 1000

void prIntArr(int* numbers, int n) {
    for (int i = 0; i < n; i++) printf("%d%s", numbers[i], n == n - 1 ? " \n" : " ");
}

int cmpIntR(const void* pa, const void* pb) { return (*(int*)pb > *(int*)pa) - (*(int*)pb < *(int*)pa); }

int main() {
    int n, numbers[N];
    scanf("%d", &n);
    for (int i = 0; i < n; i++) scanf("%d", &numbers[i]);

    qsort(numbers, n, sizeof(int), cmpIntR);

    prIntArr(numbers, n);
    return 0;
}
```

Поправим ровно одну строку в функции сравнения в коде из предыдущей задачи

```c
    return - (x > y) + (x < y);
```

Изменим что возвращает функция:<br>
+ x < y вернет > 0
+ x = 0 вернет 0
+ x > y вернет < 0

То есть отсортирует так, что `y` будет стоять раньше `x`, то есть по убыванию.

```c
#include <stdio.h>
#include <stdlib.h>

#define N 1000

int cmp_int(const void * p1, const void * p2) {
    int x = *(const int*)p1;
    int y = *(const int*)p2;

    return - (x > y) + (x < y);
}

void print_arr(int * a, int n) {
    for(int i = 0; i < n; i++)
        printf("%d ", a[i]);
    printf("\n");
}

int main() {
    int a[N];
    int n;
    scanf("%d", &n);
    for (int i = 0; i < n; i++)
        scanf("%d", a + i);
    
    // print_arr(a, n);
    qsort(a, n, sizeof(a[0]), cmp_int);
    print_arr(a, n);
    
    return 0;
}
```

```c
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <inttypes.h>

// array definition and related functions

struct array {
    int64_t size;
    int64_t* data;
};

int read_array(struct array *);
void sort_array(struct array *);
void print_array(struct array *);
void free_array(struct array *);

//////////////////////////////////////////////

int main(){
   
    struct array my_array;
    
    if (read_array(&my_array)){

        sort_array(&my_array);
        print_array(&my_array);
   
    }

    free_array(&my_array);
}

//////////////////////////////////////////////

// compare two int values
int cmp_int(const void * p1, const void * p2)
{
    int64_t a = *(const int64_t*)p2, b = *(const int64_t*)p1;
    return a < b ? -1 : a > b ? 1 : 0;
}

int read_array(struct array *a){
    // read array size (n)
    scanf("%" SCNd64, &a->size);
    
    // read array of n int values
    a->data = (int64_t*) malloc(sizeof(int64_t) * a->size);
    
    if (!a->data) return 0; // error
    
    for (size_t i = 0; i < a->size; i++) {
        scanf("%" SCNd64, &a->data[i]);
    }
    
    return 1; // ok
}

void sort_array(struct array *a){
    return qsort(a->data, a->size, sizeof(int64_t), cmp_int);
}

void print_array(struct array *a){
    for (size_t i = 0; i < a->size; i++) {
        printf("%" PRId64 " ", a->data[i]);
    }
}

void free_array(struct array *a){
    if (a->data) free(a->data);
};
```

### qsort_4: float
Напечатайте входную последовательность, отсортировав ее по возрастанию

Дано N≤1000, далее N чисел, которые помещаются в тип float.

Напечатайте числа с точностью до 2 знаков по возрастанию.

```c
#include <stdio.h>
#include <stdlib.h>
#define N 1000

void prIntArr(float* numbers, int n) {
    for (int i = 0; i < n; i++) printf("%.2f%s", numbers[i], n == n - 1 ? " \n" : " ");
}

int cmpFloat(const void* pa, const void* pb) { return (*(float*)pa > *(float*)pb) - (*(float*)pa < *(float*)pb); }

int main() {
    int n;
    float numbers[N];
    scanf("%d", &n);
    for (int i = 0; i < n; i++) scanf("%fd", &numbers[i]);

    qsort(numbers, n, sizeof(float), cmpFloat);

    prIntArr(numbers, n);
    return 0;
}
```

```c
#include <stdio.h>
#include <stdlib.h>

#define N 1000

int cmp_float(const void * p1, const void * p2) {
    float x = *(const float*)p1;
    float y = *(const float*)p2;

    return (x > y) - (x < y);
}

void print_arr(float * a, int n) {
    for(int i = 0; i < n; i++)
        printf("%.2f ", a[i]);
    printf("\n");
}

int main() {
    float a[N];
    int n;
    scanf("%d", &n);
    for (int i = 0; i < n; i++)
        scanf("%f", a + i);
    
    // print_arr(a, n);
    qsort(a, n, sizeof(a[0]), cmp_float);
    print_arr(a, n);
    
    return 0;
}
```

### qsort_5: string
Напечатайте входную строку, отсортировав ее по возрастанию ASCII кода символов, с помощью стандартной функции qsort

Дана строка длиной не более 1000 символов. Первая точка - конец последовательности символов, которую надо отсортировать. Точку сортировать не нужно. Все, что находится после первой точки - игнорировать.

Напечатайте отсортированную строку с точкой в конце.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define N 1001

void printString(char* str, int n) {
    for (int i = 0; i < n; i++) printf("%c", str[i]);
    printf(".");
}

int cmpFloat(const void* pa, const void* pb) { return (*(char*)pa > *(char*)pb) - (*(char*)pa < *(char*)pb); }

int main() {
    char str[N];
    fgets(str, 1000, stdin);
    int len = strlen(str), count = 0;

    for (int i = 0; i < len; i++) {
        if (str[i] == '.') break;
        count++;
    }

    qsort(str, count, sizeof(str[0]), cmpFloat);

    printString(str, count);
    return 0;
}
```


```c
#include <stdio.h>
#include <stdlib.h>

#define N 1000

int cmp_char(const void * p1, const void * p2) {
    int x = *(const char*)p1;
    int y = *(const char*)p2;

    return (x > y) - (x < y);
}

int main() {
    char a[N];
    fgets(a, N, stdin);
    
    // на месте точки закончим строку, чтобы удобно было печатать
    int n = strchr(a, '.') - a;
    a[n] = '\0';
    
    // printf("%s.\n", a);
    qsort(a, n, sizeof(a[0]), cmp_char);
    printf("%s.\n", a);
    
    return 0;
}
```