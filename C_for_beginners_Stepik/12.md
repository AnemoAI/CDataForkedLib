# Сортировка с помощью qsort

## Указатели на функции

### Объявление типа "указатель на функцию"
Функции, используемые в программах, как и переменные размещаются в памяти. Эта память также имеет адрес (точку входа), по которому и происходит вызов функции.

При объявлении и описании функции используется "имя функции". Адрес функции в языке С получается непосредственно при использовании имени функции (аналогично тому как используется имя массива).

В языке С возможно объявить тип "указатель на функцию" и использовать его, например, как параметры функций, элементы массива и т.д.

#### Пример объявления "указателя на функцию"

```c
#include <stdio.h>
#include <stdlib.h>
// Здесь объявлен тип Oper - указатель на функцию
// ( * Oper) - "указатель на"
// (* Oper) - указатель на функцию, которая возвращает 
// значение типа int и ожидает два аргументра типа int
typedef int (* Oper)(int, int);
// Теперь указатели этого типа могут принимать значения
// адресов функция с соответствующим интерфейсом

// Пример функций с интерфейсом типа Oper
int add(int a, int b) {
    return a + b;
}
int mult( int a, int b) {
    return a * b;
}

int main(){
    int a, b, res;
// Объявление и инициализация через 0
// указателя на функцию myf
  Oper myf = 0;
    scanf("%d%d", &a, &b);
// присваивание myf адреса функции add
    myf = add;
// исполнение кода add через указатель myf
    res = myf(a, b);
    printf("res: %d\n", res);
// присваивание myf адреса функции mult
    myf = mult;
// исполнение кода mult через указатель myf
    res = myf(a, b);
    printf("res: %d\n", res);

    return 0;
}
```

```c
>./fnpt
5 10
res: 15
res: 50
>
```
Заметим следующую особенность.

В описании указателя на функцию использовалась вот такая запись: int (* Oper)(int, int). Эта запись означает указатель на....

Если же написать int * Oper(int, int) - то это будет означать объявление прототипа функции, который возвращает указатель на int. Прототип функции не является указателем на нее. В этом случае необходимо предварительно написать реализацию функции, только тогда она будет размещена в памяти и получит адрес.

### Передача указателя на функцию в качестве параметра другой функции
Указатель на функцию можно передавать в качестве параметра другой функции. Тогда результат работы будет зависеть не только от того как реализована рассматриваемая функция, но и от того как реализована та, на которую передан указатель.

```c
#include <stdio.h>
#include <stdlib.h>
// Описание интерфейса функции и ее реализация
// isEq имеет три параметра: два типа int и 
// указатель на функцию с двумя аргументами int 
// и возвращающую int
int isEq( int a, int b, int (* sub) (int, int))
{
// при реализации isEq программист "ничего не знает" о
// реализации sub. И не должен знать
// При вызове sub получит указатель на реальную функцию,
// чей адрес (имя) будет указан в вызове
        return sub(a, b);
};
// А можно было объявить и так
// int isEq( int a, int b, Oper);

// Функция сравнения через вычитание
int subSimple(int a, int b)
{
    return a - b;
}
// Функция сравнения через абсолютные значения
int subAbs(int a, int b)
{
    return abs(a - b);
}

int main(){
    int a, b, res;
// Тестирование вызовов функции isEq() с 
// различным набором парамеров 
  for(int i = 0; i < 3; i++)
    {
        scanf("%d%d", &a, &b);
// подаем указатель на subSimple
        res = isEq(a, b, subSimple);
        printf("isEq(subSimple): %d\n", res);
// подаем указатель на subAbs
        res = isEq(a, b, subAbs);
        printf("isEq(subAbs): %d\n", res);
    }

    return 0;
}
```

```c
>./fff
2 5
isEq(subSimple): -3
isEq(subAbs): 3
4 4
isEq(subSimple): 0
isEq(subAbs): 0
-4 4
isEq(subSimple): -8
isEq(subAbs): 8
>
```

### Массивы указателей на функции

Раз уж имеется указатель на функцию, то можно использовать и массивы указателей на функцию

```c
#include <stdio.h>
#include <stdlib.h>

typedef int (* Oper)(int, int);
int add(int a, int b) {
    return a + b;
}
int mult( int a, int b) {
    return a * b;
}
int sub(int a, int b) {
    return a - b;
}

int main() {
    int a, b, res;
// Объявление массива указателей на функцию и
// инициализация их 0
  Oper myf[3] = {0, 0, 0};

// а можно было объявитиь и так:
//  int (* myf[3])(int, int) ={0, 0, 0};

// Адреса функций записываются в массив
    myf[0] = add;
    myf[1] = sub;
    myf[2] = mult;
    scanf("%d%d", &a, &b);
// В цикле исполняются все функции из массива 
    for( int i = 0; i < 3; i++) {
        res = myf[i](a, b);
        printf("res[%d]: %d\n", i, res);
    }

    return 0;
}
```

```c
>./ffm
6 7
res[0]: 13
res[1]: -1
res[2]: 42
>
```

## Использование функции qsort - Пример, использования указателей на функцию

### Интрефейс функции qsort().
Задачи сортировки элементов массивов различных типов возникают в программировании довольно часто. В дальнейшем Вам будет предложено реализовать некоторые алгоритмы сортировки самостоятельно. Но в данном разделе рассмотрим функцию языка С `qsort()` в качестве пример использования указателей на функции.

Функция `qsort()` имеет следующий интерфейс:

```c
void qsort(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *));
```

Эта функция сортирует массив `base`, размера `nmemb` элементов, при этом каждый элемент имеет размер `size`.

Для определения соотношения элементов в массиве используется функция `compar()`, которая это отношение и определяет. Если сравниваются два элемента a и b, то `compar()` может принимать следующие значения

Соотношение | возвращаемое значение `compar()`

a=b | 0
-|-
a>b | целое число >0
a<b | целое число <0

Значит для сортировки массива каждого типа нужно иметь реализованную функцию типа int (*compar)(const void *, const void *)

#### Функция типа `compar()`

Рассмотрим интерфейс функции

```c
int (*compar)(const void *, const void *);
```

Эта функция имеет два параметра типа `const void *`. Это означает, что тип указатели элементов, передаваемых в эту функцию, не определен. Кроме того, функция не может изменять элементы в процессе работы. Это совершенно необходимое условие, так как передаются адреса элементов.

Значит, в процессе реализации функций этого типа необходимо преобразовывать переданные элементы к нужному типу. В противном случае они будут интерпретироваться не верно.

### Сортировка массива чисел.
Рассмотрим пример с сортировкой массивов целых

```c
#include <stdio.h>
#include <stdlib.h>

void prInt(int * a, int n) {
    for(int i = 0; i < n; i++) {
        printf("%d ", a[i]);
    }
    printf("\n");
}
// Реализация функции сравнения
int cmpInt(const void* pa, const void * pb) {
// Преобразование неопределенного указателя к указателю типа int*
// и получение значения
    int a = *(int *) pa;
    int b = *(int *) pb;
// возвращвемая разность как раз будет 
// удовлетворять нужному критерию
    return a - b;
}

// Реализация функции сравнения "обратным" порядком
int cmpIntR(const void* pa, const void * pb) {
// Можно сразу получить значения
    return *(int* )pb - *(int *)pa;
}

int main() {
    int ar[10] = {2, 17, 22, -100, 0, -18, 77, -22, 3, 2};
    prInt(ar, 10);
// Вызов функции qsort() для 10 элементов массива ar
    qsort(ar, 10, sizeof(int), cmpInt);
    prInt(ar, 10);
// Соритровка с 3 по 8 элементов  массива ar в "обратном" порядке
     qsort(ar + 2, 5, sizeof(int), cmpIntR);
    prInt(ar, 10);
    return 0;
}
```

```c
>./si0
2 17 22 -100 0 -18 77 -22 3 2 
-100 -22 -18 0 2 2 3 17 22 77 
-100 -22 3 2 2 0 -18 17 22 77 
>
```

### Сортировка дробных чисел
При написании функции типа `compare()` заметим, что она должна возвращать целое число. Значит это нужно учитывать при реализации этой функции для элементов типа `float`

```c
#include <stdio.h>
#include <stdlib.h>

int cmpFloat(const void* pa, const void * pb) {
    float a = *((float*)pa);
    float b = *((float*)pb);
    return (a > b) - (a < b);
}
```

№ | a | b | (a>b)−(a<b)
-|-|-|-
1 | 5 | 5 | 0−0=0
2 | 5 | 4 | 1−0=1
3 | 4 | 5 | 0−1=−1

```c
void prFloat(float *a, float n) {
    for(int i = 0; i < n; i++)
        printf("%0.2f ", a[i]);
    printf("\n");
}

int main() {
    float far[10] = {0.15, 0.12, 0.1, 0.33, 3.15, 3.14, 4., 3., 0., .1 };
    prFloat(far, 10);
    qsort(far, 10, sizeof(float), cmpFloat);
    prFloat(far, 10);
    return 0;
}
```

```c
>./sfl
0.15 0.12 0.10 0.33 3.15 3.14 4.00 3.00 0.00 0.10 
0.00 0.10 0.10 0.12 0.15 0.33 3.00 3.14 3.15 4.00 
>
```
### Сортировка элементов типа struct
Рассмотрим точки на плоскости, заданные целыми координатами (x,y). Необходимо отсортировать эти точки по расстоянию от точки (0,0)

```c
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
// описание точки на плоскости
typedef struct {
    int x, y;
    int dist2; // квадрат расстояния
}Point;

// создание динамического массива и его заполненеипе 
Point * getPoints(int * n) {
    scanf("%d", n);
    Point *tmp = calloc(*n, sizeof(Point));
    for( int i = 0; i < *n; i++) {
        scanf("%d%d", &(tmp[i].x), &(tmp[i].y));
// квадрат расстояния лучше вычислить сразу один раз
        tmp[i].dist2 = tmp[i].x * tmp[i].x + tmp[i].y * tmp[i].y;
    }
    return tmp;
}
// Функция сравнения двух точек

int cmpPoint(const void* pa, const void * pb) {
// Преобразование неопределенного указателя у
// указателю на Point* и обращение к атрибутам структуры
    return ((Point *) pa)->dist2 - ((Point *)pb)->dist2;
}

void prPoint(Point * a, int n) {
    for(int i = 0; i < n; i++) {
        printf("(%d, %d): %0.2f\n", a[i].x, a[i].y, sqrt(a[i].dist2));
    }
    printf("\n");
}
int main(){
    Point * a = 0;
    int n;
    a = getPoints(&n);
    prPoint(a, n);
    qsort(a, n, sizeof(Point), cmpPoint);
    printf("Сортировка по расстоянию от 0\n");
    prPoint(a, n);
    free(a);
    return 0;
}
```

```c
./sortPoints<p.dat 
(0, 4): 4.00
(1, 0): 1.00
(5, 5): 7.07
(1, 1): 1.41
(0, 1): 1.00
(-1, 0): 1.00
(8, 0): 8.00
(4, 0): 4.00
(-5, 5): 7.07
(0, -1): 1.00
```

Сортировка по расстоянию от 0

```c
(1, 0): 1.00
(0, 1): 1.00
(-1, 0): 1.00
(0, -1): 1.00
(1, 1): 1.41
(0, 4): 4.00
(4, 0): 4.00
(5, 5): 7.07
(-5, 5): 7.07
(8, 0): 8.00
>
```

Как видим, неопределенный указатель можно преобразовать к любому другому типу указателя.

### Сортировка по "сложным" критериям

#### "Ямка".
Дан массив целых чисел. Необходимо отсортировать их так, чтобы отрицательные числа были отсортированы по убыванию, а положительные - по возрастанию.

```c
#include <stdio.h>
#include <stdlib.h>

void prInt(int * a, int n) {
    for(int i = 0; i < n; i++)
        printf("%d ", a[i]);
    printf("\n");
}
// Реализация функции сравнения для "ямки"
int cmpEv0(const void* pa, const void * pb) {
    int a = *(int *) pa;
    int b = *(int *) pb;
    if( a < 0 && b < 0   )
        return b - a;

    return a - b;
}
int main() {
    int ar[10] = {2, 17, 22, -100, 0, -18, 77, -22, 3, 2};
    prInt(ar, 10);
    qsort(ar, 10, sizeof(int), cmpInt);
    prInt(ar, 10);

    return 0;
}
```

```c
>./sortInt
./sinc
2 17 22 -100 0 -18 77 -22 3 2 
-18 -22 -100 0 2 2 3 17 22 77 
>
```

### Сортировка точек по расстоянию и координатам

```c
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
typedef struct {
    int x, y;
    int dist2;
}Point;

Point * getPoints(int * n) {
    scanf("%d", n);
    Point *tmp = calloc(*n, sizeof(Point));
    for( int i = 0; i < *n; i++) {
        scanf("%d%d", &(tmp[i].x), &(tmp[i].y));
        tmp[i].dist2 = tmp[i].x * tmp[i].x + tmp[i].y * tmp[i].y;
    }
    return tmp;
}
// Если расстояния равны, то первой располагается точка, 
// которая левее и у которой y меньше
int cmpPointF(const void* pa, const void * pb) {
    Point *a = (Point *) pa;
    Point *b = (Point *) pb;
    if(a->dist2 == b->dist2) {
        if(a->x == b->x)
            return a->y - b->y;
        return a->x - b->x;
    }
    return a->dist2 - b->dist2;
}

void prPoint(Point * a, int n) {
    for(int i = 0; i < n; i++) {
        printf("(%d, %d): %0.2f\n", a[i].x, a[i].y, sqrt(a[i].dist2));
    }
    printf("\n");
}
int main() {
    Point * a = 0;
    int n;
    a = getPoints(&n);
    qsort(a, n, sizeof(Point), cmpPointF);
    prPoint(a, n);
    return 0;
}
```

```c
./sortPointXY<p.dat
(-1, 0): 1.00
(0, -1): 1.00
(0, 1): 1.00
(1, 0): 1.00
(1, 1): 1.41
(0, 4): 4.00
(4, 0): 4.00
(-5, 5): 7.07
(5, 5): 7.07
(8, 0): 8.00
>
```

### Сортировка строк
При сортировке строк нужно учитывать, что начало строки - это тоже указатель на char.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
// Выделение памяти под массив указателей на строки,
// выделение памяти для каждой строки и заполнение значениями 
char ** getStrings(int * n) {
    scanf("%d", n);
    char buf[100];
    char **tmp = calloc(*n, sizeof(char*));
    for( int i = 0; i < *n; i++) {
        scanf("%s", buf);
        int len  = strlen(buf);
        tmp[i] = calloc(len + 1, sizeof(char));
        strcpy(tmp[i], buf);
    }
    return tmp;
}
// Строки будут сравниваться лексикографически
int cmpStr(const void* pa, const void * pb) {
// Преобразуем неопределенный указатель  к (char**) и
// Этот указатель - адрес одной строки из массива
// поэтому ((char **) pa)[0] и *(char **) pb - начало строки
    return strcmp(((char **) pa)[0], *(char **) pb);
}
void prStr(char ** a, int n) {
    for(int i = 0; i < n; i++) {
        printf("%s\n", a[i]);
    }
}

void  destroyStrAr(char ** a, int n) {
    if ( a != 0)
        for(int i = 0; i < n; i++)
            free(a[i]);
    free(a);
}

int main() {
    char ** a = 0;
    int n;
    a = getStrings(&n);
    printf("Изначальный массив\n");
    prStr(a, n);
// В массиве a - УКАЗАТЕЛИ на char (начло строк)
    qsort(a, n, sizeof(char*), cmpStr);
    printf("Сортировка\n");
    prStr(a, n);
    destroyStrAr(a, n);
    return 0;
}
```

```
./sortString<str.dat 
Изначальный массив
abc
ABdre
Vfre
Poilin
123A
Сортировка
123A
ABdre
Poilin
Vfre
abc
>
```

### Как "не испортить" изначальный массив
Часто необходимо работать с элементами массива, отсортированными по определенным (возможно даже разным) критериям, но также важно и изначальное расположение элементов в массиве.

Чтобы иметь возможность манипулировать с расположением элементов "не изменяя" изначальный массив, добавляют еще один массив указателей на элементы изначального массива.

```c
#include <stdio.h>
#include <stdlib.h>

// Печать значений элементов массива, адреса которых
// находятся в элементах массива dir
void prDir(int ** dirAr, int n) {
    for(int i = 0; i < n; i++)
        printf("%d ", dirAr[i][0]);
    printf("\n");
}
// Функция сравнения элементов, адреса которых находятся 
// по адресам переданных указателей
int cmpDir(const void* pa, const void * pb) {
//  (int**)pa - адрес ячейки в массиве dir
//  *( int **)pa или (int **)pa[0] - адрес элемента из массива ar,
// записанный в элемент массива dirAr
// ((int **)pa)[0][0] - значение элемента массива ar
// Вот эти значения и сравниваем, а сортироваться будут значения 
// массива dirAr - указатели на ячейки ar 
    return ((int **)pa)[0][0] - ((int **)pb)[0][0];
}

// Функция сравнения для сортировки по убыванию
int cmpDirR(const void* pa, const void * pb) {

    return ((int **)pb)[0][0] - ((int **)pa)[0][0];
}

void prInt(int * a, int n) {
    for(int i = 0; i < n; i++)
        printf("%d ", a[i]);
    printf("\n");
}

int main() {
    int ar[10] = {2, 17, 22, -100, 0, -18, 77, -22, 3, 2};
// массив указателей на int
// для адресов ячеек ar
    int *dirAr[10]; 
// заполняем dir адресами ячеек ar
    for(int i = 0; i < 10; i++)
        dirAr[i] = ar + i;
// Печать ar
    prInt(ar, 10);
// Печать dir (напечатает то же самое)
    prDir(dirAr, 10);
// Сортировка массива dirAr
    qsort(dirAr, 10, sizeof(int *), cmpDir);
// Печать dirAr
    prDir(dirAr, 10);
// Печать ar (не должен измениться)
    prInt(ar, 10);
// сортировка "реверс"
    qsort(dirAr, 10, sizeof(int *), cmpDirR);
    prDir(dirAr, 10);
    prInt(ar, 10);

    return 0;
}
```

```
>./sortDir
./sdir
2 17 22 -100 0 -18 77 -22 3 2 
2 17 22 -100 0 -18 77 -22 3 2 
-100 -22 -18 0 2 2 3 17 22 77 
2 17 22 -100 0 -18 77 -22 3 2 
77 22 17 3 2 2 0 -18 -22 -100 
2 17 22 -100 0 -18 77 -22 3 2 
>
```

## Примеры сортировки

### return x-y;
Можно ли использовать такую функцию сравнения целых чисел?

```c
int cmp_int(const void * p1, const void * p2) {
    int x = *(const int *)p1;
    int y = *(const int *)p2;
    return x - y;
}
```

Проверим как она работает:

```c
int main() {
    int a = 2, b = 7, d = 7;
    assert(cmp_int(&a, &b) < 0);    // -5 < 0
    assert(cmp_int(&b, &a) > 0);    // 5 > 0
    assert(cmp_int(&b, &d) == 0);   // 0 == 0
    return 0;
}
```

Кажется, что функция сравнения работает правильно.

### cmp_char
Добавим тесты на переполнение `(overflow)`. Покажем переполнение на примере сравнения `char`. Это числа от `-128` до `127`.

```c
int cmp_char(const void * p1, const void * p2) {
    char x = *(const char *)p1;
    char y = *(const char *)p2;
    char res = x - y;
    printf("x=%d y=%d res=%d\n", x, y, res);
    return res;
}
```

Проверим, что функция работает правильно на тех же тестовых данных и добавим новые тесты:

```c
int main() {
    char a = 2, b = 7, d = 7;
    assert(cmp_char(&a, &b) < 0);    // x=2 y=7 res=5    5 < 0
    assert(cmp_char(&b, &a) > 0);    // x=7 y=2 res=-5  -5 > 0
    assert(cmp_char(&b, &d) == 0);   // x=7 y=7 res=0    0 == 0


    a = -128, b = -70, d = 70;
    cmp_char(&a, &b);               // x=-128 y=-70 res=-58
    cmp_char(&a, &d);               // x=-128 y=70 res=58, т.е -128 > 70 ?
    cmp_char(&b, &d);               // x=-70 y=70 res=116, т.е -70 > 70  ?


    char arr[] = {-128, -70, 70};                   // уже отсортирован по возрастанию
    qsort(arr, 3, sizeof(char), cmp_char);
    printf("%d %d %d\n", arr[0], arr[1], arr[2]);   // 70 -128 -70 сломали


    return 0;
}
```

Что делать?
+ Можно переписать сравнение через if else, так как -70 - 70 = -140 не вмещается в диапазон char, поэтому переполнение вx-y приводит к неверному результату сравнения.
+ Можно перейти к большему типу, int, long int или long long int. Но если данные уже в типе long long int или unsigned long long int, то функция сравнения через x-y внесет ошибки в сортировку.

### Операции сравнения
Значение выражения с операцией сравнения в языке Си имеет значение `0`, если сравнение неверно, или `1`, если сравнение верно.

При `x=3` выражение `x<7` имеет значение `1`, а выражение `x>10` имеет значение `0`.

Приоритет сравнения ниже, чем у `+` или `-`. Поэтому в выражении `(x>y)-(x<y)` обязательны скобки. Вычислим его значение при разных `x` и `y`


x ? y | x>y | x<y | (x>y)-(x<y) | результат
-|-|-|-|-
x < y | 0 | 1 | (0)-(1) | -1
x == y | 0 | 0 | (0)-(0) | 0
x > y | 1 | 0 | (1)-(0) | 1

Если данные умещаются в тип `int`, то при сравнении нет переполнения:

```c
int cmp_int(const void * p1, const void * p2) {
    int x = *(const int *)p1;
    int y = *(const int *)p2;
    return (x>y)-(x<y);
}
```

### Сравнение чисел с плавающей точкой
При сравнении через `x-y` чисел с плавающей запятой `(floating point)` возникает другая проблема. Результат этой операции тоже число с плавающей запятой. Возвращать функция должна `int`. То есть результат приводится к целому типу. При этом теряется информация.

x | y | x - y | (int)(x - y) | Ответ
-|-|-|-|-
12.5 | 7.1 | 5.4 | 5 | x > y, 5 > 0 - правильно
12.5 | 12.1 | 0.4 | 0 | x > y, 0 - ошибка

Числа 12.5 и 12.1 можно оставить на своих местах, ибо функция сравнения вернула 0, то есть эти числа равны с точки зрения алгоритма сортировки.

Проверьте, работает ли сравнение таких чисел через $(x>y)-(x<y)$.

### 

