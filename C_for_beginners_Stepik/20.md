# Дополнительные главы

## 20.1 Аргументы командной строки. argc и argv

[VIDEO](https://youtu.be/6ib_WjV4Ji0)

### Аргументы командной строки
В этом уроке мы научимся в программе получать аргументы командной строки.

Мы компилируем в командной строке (терминале) программу из файла `hello.c` в исполняемый модуль `hello.exe` так:

```bash
gcc -Wall -Wextra -g -o hello.exe hello.c
```

Программа `gcc` имеет аргументы командной строки `-Wall -Wextra -g -o hello.exe hello.c`.

Пусть у нас есть директория `work`. В командной строке мы запускаем программу `ls` (показать содержимое директории или информацию о файле) так:

```bash
ls
ls work
ls -la work
ls --help
```

Команда `ls`, запускается без аргументов, с единственным аргументом `work`, с двумя аргументами `-la` и `work`, с одним аргументом `--help`.

Как получить аргументы, задаваемые в командной строке, в своей программе?

### argc и argv
Раньше мы писали функцию `main` так:

```c
int main();
```
На самом деле у нее есть аргументы

```c
int main(int argc, char * argv[]);
```

+ `argc` - `argument counter` количество аргументов командной строки, включая саму программу
+ `argv` - `argument vector` - массив аргументов командной строки, это массив указателей на строки.

Пусть наша программа `a.out` запускается так:

```bash
./a.out 12 abc -i
```

Тогда в программе аргументы `argc` и `argv` уже сформированы так (готовы, их можно использовать):

![20](/C_for_beginners_Stepik/Pictures/20_01.png)

### Использование argc и argv
Напечатаем в программе `argc` и все `argv[i]`.

Запустим программу с аргументами:

```bash
./a.out 12 abc -i
```

При таком запуске программы сформируются следующие `argc` и `argv`.

![20](/C_for_beginners_Stepik/Pictures/20_01.png)

```c
#include <stdio.h>


int main(int argc, char * argv[])
{
    printf("argc = %d\n", argc);
    for (int i = 0; i < argc; i++)
        printf("argv[%d] = %s\n", i, argv[i]);


    return 0;
}
```

При запуске

```bash
./a.out 12 abc -i
```
программа напечатает

```bash
argc = 4
argv[0] = ./a.out
argv[1] = 12
argv[2] = abc
argv[3] = -i
```
+ первый элемент массива `argv[0]` - это путь к исполняемому файлу,
+ `argv[1]`, `argv[2]`, `argv[3]` - аргументы программы `12`, `abc`, `-i`, все в виде указателей на строки. 12 - это тоже строка "12", если нужно получить число, используйте стандартную функцию `strtol`.
+ `argc` - сколько всего "слов" в командной строке, включая путь к самой программе. Их 4, `./a.out`, `12`, `abc` и `-i`.

### Чему равно argc?
Программу запустили как `C:\work\info\hello.exe data.txt`, чему равно `argc`?

`2`

### Аргументов нет
Как проверить, что программа запущена без аргументов. Выберите правильный ответ:

+ [ ] if (argc < 0)
+ [ ] if (argc > 1)
+ [ ] if (argc > 0)
+ [x] if (argc == 1)
+ [ ] if (argc < 1)
+ [ ] if (argc == 0)

### Аргументы имя файла и быть может ключ -t
У программы должен быть обязательный аргумент имя входного файла с данными и не обязательный имя файла с результатами работы программы. Какой код проверяет, что обязательный аргумент есть?

Командная строка | Что задано
-|-
./a.out | Ошибка, не хватает аргументов
./a.out data.txt | Ок, есть обязательный аргумент data.txt
./a.out data.txt res.jpg | Ок, есть обязательный аргумент data.txt и необязательный res.jpg
./a.out data.txt 12 a.txt | Ок, есть обязательный аргумент data.txt, то что есть "лишние" аргументы, сейчас не проверяем.

+ [ ] if (argc <= 1)
+ [x] if (argc >= 2)
+ [ ] if (argc <= 2)
+ [ ] if (argc >= 1)
+ [ ] if (argc == 2)
+ [ ] if (argc == 1)

### Пример кода для разбора аргументов
Пусть в программе должен быть один обязательный аргумент (например, путь к файлу с данными) и перед ним может быть, а может и не быть аргумент `-t`. Эти аргументы будут храниться в переменных `filename` и `trace`

Важно! Если в программе аргументы указаны неверно или не указаны (а должны), стоит написать пользователю как правильно запускать программу. Представьте, что вам нужно запустить программу с 10 аргументами, про которые вы ничего не знаете и программа не пишет, какие аргументы нужны, а какие заданы неверно.

Некоторые программы должны работать без аргумента, например, команды `ls` и `cd`. Тогда информацию об аргументах такие программы выводят с ключом `--help`. Запустите в командной строке `ls --help` и посмотрите на результат.

```c
void usage(const char * progname) {
    printf("USAGE: %s [-t] filename\n    filename - input data\n", progname);
}


int main (int argc, char *argv[]) {
    // если аргументов нет, программа работать не может
    if (argc == 1) {
        usage(argv[0]);
        exit(1);
    }
    // имя файла - последний аргумент
    const char * filename = argv[argc-1];


    // ключ -t значит, что trace=1
    char trace = 0;
    if (argc == 3 && 0 == strcmp("-t", argv[1]))
        trace = 1;


    // тут дальнейшая осмысленная часть программы ....


    return 0;
}
```

### getopt (дополнительный материал)
Если аргументы сложные, например, несколько необязательных параметров (опций), они могут идти в произвольном порядке, у них есть краткая и длинная форма (например, `-v` и `--verbose`), у части опций есть аргументы, то не нужно писать километры кода.

Нужно использовать `getopt`.

#### Термины: какие параметры бывают
При компиляции такой строкой

```bash
gcc -g -o hello.exe hello.c main.c
```

+ `gcc` - программа,
+ `-g` - параметр `g` без аргумента,
+ `-o hello.exe` - параметр `о` с аргументом, значение аргумента `hello.exe`,
+ позиционные параметры `hello.c` и `main.c`.

#### Пример использования `getopt`

Пусть в программе есть:

+ необязательные параметры (опции) без значения `-a` и `-b`, запишем их в переменные `aflag` и `bfalg`;
+ необязательный параметр (опция) со значением `-c`, запишем значение в переменную `cvalue`
+ за ними может идти позиционный аргумент (пусть это имя файла и мы запишем его в переменную `filename`).

```c
int getopt (int argc, char * argv[], const char *options);
```

Функции `getopt` передают строку описания опций `options`, в нашем примере это `"abc:"`, после параметра с аргументом пишем `:`, если аргумент может быть, а может и не быть, то ставим `::`.

+ глобальные переменные, которые использует getopt:
    + `int optind` - индекс следующего элемента в `argv`, который будут разбирать.
    + `char * optarg` - указатель на значение аргумента, если разбираем опцию с аргументом, иначе ноль.
    + `int opterr` - надо ли выводить информацию об ошибке в `stderr` (`0` - не выводим, `1` - выводим, по умолчанию `1`).
    + `int optopt` - параметр, который встретился, но его не должно быть (его нет в `options`).
+ В цикле вызываем `getopt`, до тех пор, пока он не вернет `-1`, при этом `optind` станет равен индексу первого элемента, который не является опцией.
+ `getopt` возвращает очередной разобранный параметр или `?`, если разобран аргумент параметра.
+ В `switch` разбираем что вернул `getopt`, тут только присваиваем значения нужным переменным, разбор переменных - отдельно, основная часть работы программы - отдельно, не надо их смешивать.
+ После цикла разбора опций разбираем позиционные аргументы, тут один аргумент, записываем его в переменную `filename`; если аргументов много, организуем цикл

```c
  for (index = optind; index < argc; index++)
    printf ("Non-option argument %s\n", argv[index]);
```

Весь код:

```c
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>     // нужен для работы getopt


int
main (int argc, char **argv) {
  int aflag = 0;        // 1, если задан параметр -a
  int bflag = 0;        // 1, если задан параметр -b
  char *cvalue = NULL;  // указатель на аргумент параметра -c
  int c;                // параметр, его вернет getopt


  opterr = 0;           // информацию об ошибке не выводим в stderr


  while ((c = getopt (argc, argv, "abc:")) != -1)
    switch (c)
      {
      case 'a':         // есть аргумент -a
        aflag = 1;
        break;
      case 'b':         // есть аргумент -b
        bflag = 1;
        break;
      case 'c':         // есть аргумент -с, его значение в переменной optarg
        cvalue = optarg;
        break;
      case '?':         // что-то пошло не так в разборе опций
        if (optopt == 'c')
          // если опция -c без аргументов
          fprintf (stderr, "Option -%c requires an argument.\n", optopt);
        else if (isprint (optopt))
          // если неизвестная опция, символ записан в optopt
          fprintf (stderr, "Unknown option '-%c'.\n", optopt);
        else
          fprintf (stderr,
                   "Unknown option character `\\x%x'.\n",
                   optopt);
        return 1;
      default:
        // что-то в getopt пошло не так, нештатная ошибка
        abort ();
      }


  // печатаем результаты разбора флагов -a, -b и -с
  printf ("aflag = %d, bflag = %d, cvalue = %s\n",
          aflag, bflag, cvalue);


  // ожидаем 1 позиционный аргумент
  filename = argv[optind];
  printf ("Non-option argument %s\n", argv[optind]);


  // лишние позиционные аргументы
  if (optind < argc -1)
      fprintf (stderr, "Unexpected argument %s\n", argv[optind+1]);


  return 0;
}
```

Соберем программу в исполняемый файл `testopt` и запустим его с разными аргументами:

```c
% testopt
aflag = 0, bflag = 0, cvalue = (null)


% testopt -a -b
aflag = 1, bflag = 1, cvalue = (null)


% testopt -ab
aflag = 1, bflag = 1, cvalue = (null)


% testopt -c foo
aflag = 0, bflag = 0, cvalue = foo


% testopt -cfoo
aflag = 0, bflag = 0, cvalue = foo


% testopt arg1
aflag = 0, bflag = 0, cvalue = (null)
Non-option argument arg1


% testopt -a arg1
aflag = 1, bflag = 0, cvalue = (null)
Non-option argument arg1


% testopt -c foo arg1
aflag = 0, bflag = 0, cvalue = foo
Non-option argument arg1


% testopt -a -- -b
aflag = 1, bflag = 0, cvalue = (null)
Non-option argument -b


% testopt -a -
aflag = 1, bflag = 0, cvalue = (null)
Non-option argument -
```

## 20.2 Функции с переменным числом аргументов. va_list

[VIDEO](https://youtu.be/8rwJ1SUUTkg)

## 20.3 Программа-проект

[VIDEO](https://youtu.be/e2p3-B4c1NU)

## 20.4 valgrind - проверка работы с памятью

[VIDEO](https://youtu.be/YX0s4ltwSU8)

## 20.5 make

Простая инструкция по написанию Makefile
Этот текст является вольным переводом статьи https://www.cs.colby.edu/maxwell/courses/tutorials/maketutor

[Репозиторий с переводом](https://github.com/gvino/make_tutorial)

### Что такое make
`Makefile` -- это простой способ для организации процесса компиляции программ.

Данная инструкция не покрывает и сотой доли того, что можно сделать с помощью утилиты `make`, но призвана служить простым пошаговым руководством для новичков, с помощью которого можно создавать собственные `Makefile` для небольших проектов.

__Замечание для студентов МФТИ__. Со временем вам понадобится писать статьи с использованием системы `LaTeX`. `Makefile` можно использовать и для их сборки.

### 1. Простой пример
Начнем с проекта из трех файлов: `hellomake.c`, `hellofunc.c` и `hellomake.h`, которые будут изображать основной файл программы, дополнительные функции в отдельном файле и заголовочный файл соответственно. Исполняемый файл этой программы будет называться `hellomake`.

`hellomake.c`:

```c
#include "hellomake.h"


int main(void) {
  // Вызов функции из другого файла
  myPrintHelloMake();


  return 0;
}
```

`hellofunc.c`:

```c
#include <stdio.h>
#include "hellomake.h"


void myPrintHelloMake(void) {
  printf("Hello makefiles!\n");


  return;
}
```

`hellomake.h`:

```c
/*
 * Пример заголовочного файла
 */


#pragma once


void myPrintHelloMake(void);
```

Обычно, мы бы компилировали этот набор файлов, используя следующую команду:

```bash
gcc -o hellomake hellomake.c hellofunc.c -I.
```

Она комилирует и линкует два `.c` файла и создает исполняемый файл `hellomake`. Опция `-I`. добавлена для того, чтобы `gcc` искал заголовочные файлы в текущей директории (это позволяет писать `#include <hellomake.h>` вместо `#include "hellomake.h"`). Без `Makefile` обычный подход к компиляции, запуску и проверке заключается в нажатии стрелки вверх в терминале до тех пор, пока не отобразится предыдущая команда компиляции, так что нам не надо вводить ее каждый раз до тех пор, пока мы не добавим новые `.c` файлы.

К сожалению, такой подход к компиляции имеет два недостатка. Во-первых, если команда компиляции пропадет или вы будете работать на другом компьютере, команду надо будет набирать заново, что очень неэффективно. Во-вторых, если изменился всего один `.c` файл, пересобирать все остальные не имеет никакого смысла. Теперь посмотрим, как можно решить эти проблемы с помощью `Makefile` и команды `make`.

Простейший `Makefile` будет выглядеть следующим образом:

```bash
# Makefile 1

hellomake: hellomake.c hellofunc.c
    gcc -o hellomake hellomake.c hellofunc.c -I.
```

Если поместить этот текст в файл, названный `Makefile` или `makefile` (второй вариант не рекомендуется), а потом набрать команду `make` в терминале, то запустится команда компиляции, которую мы написали в файле. Обратите внимание, что `make`, вызванный без аргументов, выполняет первое правило в файле. Более того, так как мы указали список файлов, от которых зависит правило в первой строке команды после знака :, команда `make` знает, что правило `hellomake` должно быть выполнено если любой из этих файлов изменился. Сразу же мы решили первую проблему, так как больше не надо искать команду компиляции в истории команд, написать make будет заведомо быстрее. Однако, проблема с компиляцией только изменившихся файлов все-еще актуальна.

Очень важно запомнить, что перед командой `gcc` в `Makefile` стоит табуляция, а не пробелы. Табуляция должна стоять перед каждой командой.

### 2. Компилируем только изменившиеся файлы
Для того, чтобы все работало чуть более эффективно, попробуем следующее:

```bash
# Makefile 2


CC=gcc
CFLAGS=-I.


hellomake: hellomake.o hellofunc.o
    $(CC) -o hellomake hellomake.o hellofunc.o
```

Мы описали специальные константы (макросы) `CC` и `CFLAGS`, для того, чтобы объяснить `make` как мы хотим компилировать файлы `hellomake.c` и `hellofunc.c`. Макрос `CC` это компилятор, который будет использоваться, а `CFLAGS` -- список опций, которые будут передаваться компилятору. Размещая объектные файлы (`hellomake.o` и `hellofunc.o`) в списке зависимостей правила, мы сообщаем `make`, что сначала надо скомпилировать по отдельности `.c` файлы, а затем слинковать их в исполняемый файл `hellomake`.

Такая форма `Makefile` практически достаточна для большинства маленьких проектов. Однако нам не хватает одной детали: зависимости от заголовочных файлов. Если изменить `hellomake.h`, `make` не пересоберет `.c` файлы, даже если это необходимо.

### 3. Добавляем зависимость от заголовочных файлов (A.K.A. немного магии)
Для того, чтобы решить проблему из предыдущего пункта, нам нужно указать `make`, что все `.c` файлы зависят от определенных `.h` файлов (Замечание. Из этого следует, что при изменении заголовочных файлов будут перекомпилированы все `.c` файлы. Это значит, что прорабатывать интерфейсы следует с особой тщательностью.). Для этого мы добавим простое правило и внесем его в `Makefile`.

```bash
# Makefile 3


CC=gcc
CFLAGS=-I.
DEPS=hellomake.h


%.o: %.c $(DEPS)
    $(CC) -c -o $@ $< $(CFLAGS)


hellomake: hellomake.o hellofunc.o
    $(CC) -o hellomake hellomake.o hellofunc.o
```

Здесь сначала создается константа DEPS, в которой перечисляются все `.h` файлы, от которых зависят `.c` файлы. Далее определяется правило, которое применяется ко всем файлам, имеющим расширение `.o`. Оно говорит, что каждый `.o` файл зависит от соответствующего `.c` файла и `.h` файлов, перечисленных в `DEPS`. Далее правило говорит, что для создания `.o` файла нужно скомпилировать `.c` файлы используя компилятор, указанный в `CC`. Флаг `-c` говорит, что нужно создать объектный файл, `-o $@` -- положить результат компиляции в файл имя которого указано слева от `:`, `$<` -- первый элемент из списка зависимости правила, а макрос `CFLAGS` уже был описан ранее.

### 4. Делаем немного аккуратнее (A.K.A. больше магии)
Для того, чтобы избавиться от перечисления файлов в командах, воспользуемся макросами $@ и $^, которые обозначают то, что слева и то, что справа от : соответственно. Это поможет сделать правила более аккуратными и упростить добавление новых файлов в проект. В следующем примере все заголовочные файлы должны быть перечислены в константе DEPS, а все объектные файлы -- OBJ.

```bash
# Makefile 4


CC=gcc
CFLAGS=-I.
DEPS = hellomake.h
OBJ = hellomake.o hellofunc.o


%.o: %.c $(DEPS)
    $(CC) -c -o $@ $< $(CFLAGS)


hellomake: $(OBJ)
    $(CC) -o $@ $^ $(CFLAGS)
```

### 5. Структурируем проект
Что, если мы хотим избежать мешанины файлов и хранить `.h` файлы в папке `include`, `.c` файлы в папке `src`, а также можем ли мы как-то убрать мешающие `.o` файлы, болтающиеся среди файлов с кодом? Конечно, это реально. `Makefile` далее определяет пути к папкам `include` и `src`, а также размещает объектные файлы в папку `obj`. Также, в нем определены костанты для библиотек, которые должны быть подключены, например, `math` (`-lm`). Этот `Makefile` должен быть расположен в корне проекта. Также обратите внимание, что он содержит отдельное правило для удаления временных и объектных файлов, которое вызывается, если набрать `make clean`. Правило `.PHONY` запрещает `make` делать что-либо с файлом, называющимся `clean`.

```bash
# Makefile 5


IDIR=include
CC=gcc
CFLAGS=-I$(IDIR)


SDIR=src
ODIR=obj


LIBS=-lm


_DEPS = hellomake.h
DEPS = $(patsubst %,$(IDIR)/%,$(_DEPS))


_OBJ = hellomake.o hellofunc.o
OBJ = $(patsubst %,$(ODIR)/%,$(_OBJ))


$(ODIR)/%.o: $(SDIR)/%.c $(DEPS)
    $(CC) -c -o $@ $< $(CFLAGS)


hellomake: $(OBJ)
    $(CC) -o $@ $^ $(CFLAGS) $(LIBS)


.PHONY: clean


clean:
    rm -f $(ODIR)/*.o $(SDIR)/*~ $(INCDIR)/*~
```

Структура файлов проекта в этом случае будет следующей:

```
my_project/
|__Makefile
|__src/
|  |__hellomake.c
|  |__hellofunc.c
|__include/
|  |__hellomake.h
|__obj/
   |__hellomake.o
   |__hellofunc.o
```

### 6. Последние штрихи
Несмотря на то, что последний `Makefile` работает, стоит сделать его более соответствующим общепринятым правилам. По соглашению, цель по умолчанию называется `all` и выполняет все действия, которые требуются для того, чтобы получить готовую к работе программу. Эти действия могут включать в себя не только компиляцию исполняемого файла (или файлов, если проект состоит из нескольких программ), но и генерацию файлов конфигурации, документации и так далее. С другой стороны, нам необходимо иметь возможность собрать исполняемый файл без выполнения этих действий. Выход -- создать пустое правило `all`, зависимостью которого указать наш исполняемый файл.

Также, сделаем небольшую корректировку и вынесем имя исполняемого файла в переменную, что позволит нам легко переименовать его при необходимости.

```bash
# Makefile 6


IDIR=include
CC=gcc
CFLAGS=-I$(IDIR)
BIN=hellomake


SDIR=src
ODIR=obj


LIBS=-lm


_DEPS = hellomake.h
DEPS = $(patsubst %,$(IDIR)/%,$(_DEPS))


_OBJ = hellomake.o hellofunc.o
OBJ = $(patsubst %,$(ODIR)/%,$(_OBJ))


all: $(BIN)


$(ODIR)/%.o: $(SDIR)/%.c $(DEPS)
    $(CC) -c -o $@ $< $(CFLAGS)


$(BIN): $(OBJ)
    $(CC) -o $@ $^ $(CFLAGS) $(LIBS)


.PHONY: clean


clean:
    rm -f $(ODIR)/*.o $(SDIR)/*~ $(INCDIR)/*~
```

### Заключение
Теперь у вас есть отличный `Makefile`, который вы можете использовать на небольших проектах, возможно, добавляя новые правила. Можно даже добавлять правила, которые вызывают другие правила (на самом деле, мы это уже делали: наше правило `all` вызывает правило `hellomake`, а сам `hellomake` вызывает правила для создания `.o` файлов).

Если вам нужно больше информации по `Makefile` и команде `make`, обратитесь к официальной документации `GNU Make`, из которой вы узнаете гораздо больше, чем когда-либо хотели. Правда.

## 20.6 enum
