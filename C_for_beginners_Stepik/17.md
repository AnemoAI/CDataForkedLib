# Двусвязный список
## Двусвязный список. Циклический с барьерным элементом

[VIDEO](https://youtu.be/128BR4KvVtk) все фрагменты про двусвязный список

[VIDEO](https://youtu.be/ey6kMI_ByE4)

### Поиск элемента
Есть ли этот элемент в структуре данных? Если данные не упорядочены, то ответ на этот вопрос занимает `O(n)` - проверить все элементы.

Если элементы упорядочены, то для списка это все равно `O(n)`, так как доступ к `i`-тому элементу будет порядка `O(i)`. Для массива доступ к `i`-тому элементу `O(1)`. И по массиву возможен бинарный поиск.

То есть поиск в общем случае `O(log n)` для массива и `O(n)` для списка. Попробуем улучшить эти оценки в следующей структуре данных.

### Вставка элемента
+ Вставка элемента для динамического массива - `О(n)`.
+ Вставка элемента `t` после узла `p` в односвязном списке `O(1)`.
+ Вставка элемента `t` перед узлом `p` в односвязном списке `O(n)`.

Если для каждого узла хранить не только указатель на следующий узел, но и на предыдущий, то вставка элемента перед узлом тоже станет `O(1)`.

Список, в каждом узле которого хранятся указатели на следующий и предыдущий узел называют двусвязным.

### Список с открытыми концами

![17](/C_for_beginners_Stepik/Pictures/17_01.png)

Обычно в литературе описывают двусвязный список с открытыми концами, где поле `prev` первого узла указывает на `NULL` и поле `next` последнего указывает на `NULL`.

Вставка элемента в список простая, если вставляем всегда в середину списка. Но для списка с открытыми концами нужно писать дополнительный код для вставки в начало и конец списка.

Мы не будем показывать сложную реализацию, а упростим список.

### Циклический двусвязный список
Сделаем такой список, что у него не будет особого случая начала и конца, для этого сделаем его циклическим.

![17](/C_for_beginners_Stepik/Pictures/17_02.png)

`prev` первого указывает на последний узел, `next` последнего - на первый узел.

При этом существенно упрощается код вставки в список (всегда в середину). Но остается особый случай - вставка в пустой список.

Функция вставки и удаления должна изменять значение переменной `list` (удаляем элемент, на который указывала эта переменная или вставляем элемент так, чтобы он был "первым" в списке).

### Циклический двусвязный список с барьерным элементом
Упростим список. Пусть узел, на который указывает `list` никогда не меняется. То есть его нельзя удалить. И он сразу добавлен. Пусть у нас один узел будет специальным. Назовем его "барьерным элементом".

![17](/C_for_beginners_Stepik/Pictures/17_03.png)

`prev` первого указывает на последний узел, `next` последнего - на первый узел.

При этом существенно упрощается код вставки в список (всегда в середину). Но остается особый случай - вставка в пустой список.

Функция вставки и удаления должна изменять значение переменной `list` (удаляем элемент, на который указывала эта переменная или вставляем элемент так, чтобы он был "первым" в списке).

### Циклический двусвязный список с барьерным элементом
Упростим список. Пусть узел, на который указывает `list` никогда не меняется. То есть его нельзя удалить. И он сразу добавлен. Пусть у нас один узел будет специальным. Назовем его "барьерным элементом".

![17](/C_for_beginners_Stepik/Pictures/17_03.png)

Узлы с данными - это "бусины", а элемент, на который указывает переменная `list` - это "замочек". Пустой список состоит из одного замочка, бусин нет.

Получим циклический двусвязный список с барьерным элементом.

Как отличать замочек от прочих узлов? В строке конец строки мы помечали специальным значением `\0`. В барьерном элементе мы не можем сделать специальное значение данных. Если взять `0` или `-1`, то такие числа могут быть в списке. Значит, нам все равно, что хранится в барьерном элементе. Там может быть любое значение.

### Тип данных узла

Будем, как и в стеке, определять тип `Data` и реализовывать пример списка, в котором хранятся целые числа.

```c
typedef int Data;


typedef struct Node Node;
struct Node {
    Data data;      // данные в узле
    Node * prev;    // указатель на предыдущий узел
    Node * next;    // указатель на следующий узел
};
```

Этот тип подходит для хранения узла любого двусвязного списка.

### API двусвязного списка
| | |
-|-
`void list_init(Node * list)` | инициализация пустого списка.
`void list_insert(Node * list, Node * t)` | вставляет элемент t после элемента list
`void list_insert_before(Node * list, Node * t)` | вставляет элемент t перед элементом list
`void list_remove(Node * t);` | удаляет элемент t из списка
`Node * list_push_front(Node * list, Data d)` | выделяет память под новый элемент, содержащий данные d, и вставляет его в голову (хвост) списка.
`Node * list_push_back(Node * list, Data d)` | Возвращает указатель на этот новый элемент или NULL, если произошла ошибка.
`Data list_pop_front(Node * list)`<br>`Data list_pop_back(Node * list)`<br>`Data list_delete(Node * t)` | удаляет голову (хвост, указанный элемент t) списка, возвращая данные. Память освободить!
`void list_print (Node * list)` | распечатывает через пробел числа, лежащие в списке. С самого первого до последнего. В конце переводит строку. Полезна для отладки прочих функций.
`int list_is_empty(Node * list)` | проверяет пустой это список или нет
`void list_clear(Node * list)` | опустошает список, освобождая память. После этого можно опять добавлять элементы в список.

Прототипы всех функций для удобства копирования в программу:

```c
void list_init(Node * list);


void list_insert(Node * list, Node * t);
void list_insert_before(Node * list, Node * t);
void list_remove(Node * t);


Node * list_push_front(Node * list, Data d);
Node * list_push_back(Node * list, Data d);


Data list_pop_front(Node * list);
Data list_pop_back(Node * list);
Data list_delete(Node * t);


void list_print (Node * list);
int list_is_empty(Node * list);


void list_clear(Node * list);
```

### Анализ API
Функции разделяются на группы.

Вспомогательные функции

```c
void list_print (Node * list);
int list_is_empty(Node * list);
```

Функции, которые работают с указателями на узлы (никаких выделений или освобождений памяти, нужны, чтобы переместить узел из одного места в другое или из одного списка в другой с наименьшими расходами).

```c
void list_init(Node * list);


void list_insert(Node * list, Node * t);
void list_insert_before(Node * list, Node * t);
void list_remove(Node * t);
```

Функции, которые захватывают и освобождают память:

```c
struct Node * list_push_front(struct Node * list, Data d);
struct Node * list_push_back(struct Node * list, Data d);


Data list_pop_front(struct Node * list);
Data list_pop_back(struct Node * list);
Data list_delete(struct Node * t);


void list_clear(struct Node * list);
```

И особая функция `foreach`, которая позволяет применить конкретную функцию к каждому элементу списка.

## Модель и печать циклического списка с барьерным элементом

[VIDEO](https://youtu.be/CTOhfyZxzaE)

### Модель
Далее будем реализовывать API для самого простого случая - циклический двусвязный список с барьерным элементом.

Начнем с функции печати.

Чтобы понять, как напечатать список, построим сначала его модель из узлов с данными `a`, `b`, `c` и барьерного элемента (замочка) `z`. Переменная `list` будет указывать на z.

В рисунке придумаем адреса для каждого узла и запишем эти адреса в поля. Этот прием помогает, если нарисованных полей и стрелок для вас недостаточно. Адреса придумаем короткие (нам они нужны для понимания, как работает список, а не для реализма).

![17](/C_for_beginners_Stepik/Pictures/17_04.png)

### Реализация в коде

![17](/C_for_beginners_Stepik/Pictures/17_04.png)

Код модели:

```c
int main() {
    // model
    Node z;         // замочек
    Node a, b, c;   // узлы с данными в списке


    Node * list = &z;
    z.data = 0;     z.next = &a;    z.prev = &c;
    a.data = 3;     a.next = &b;    a.prev = &z;
    b.data = 17;    b.next = &c;    b.prev = &a;
    c.data = 21;    c.next = &z;    c.prev = &b;


    return 0;
}
```

### Печать модели
Будем писать функцию печати списка так же последовательно, как и в односвязном списке. Код должен напечатать числа 3, 17, 21.

Можно ли взять код печати для односвязного списка? Можно, но его придется модифицировать, так как `list` указывает не на первый элемент с данными, а на замочек, и список не заканчивается `NULL`.

Если можете написать функцию печати сами, напишите и отладьте их и переходите на последние шаги этой части, чтобы сравнить реализацию.

```c
int main() {
    // model
    Node z;         // замочек
    Node a, b, c;   // узлы с данными в списке


    Node * list = &z;
    z.data = 0;     z.next = &a;    z.prev = &c;
    a.data = 3;     a.next = &b;    a.prev = &z;
    b.data = 17;    b.next = &c;    b.prev = &a;
    c.data = 21;    c.next = &z;    c.prev = &b;


    // напечатаем данные
    printf("%d ", a.data);
    printf("%d ", b.data);
    printf("%d ", c.data);
    printf("\n");


    return 0;
}
```

### От имен узлов к указателю
В функции печати потом у нас не будет узлов с названиями, будет только переменная `list` - указатель на замочек.

Заменим имена узлов `a`, `b`, `c` на указатель `p`, который будет переходить от узла к узлу.

`Node * p;`

Первый узел а - следующий после замочка.

`p = list->next;`

Если это не очевидно, то посмотрим на адреса. Нам нужно, чтобы p было равно адресу 200. Переменная `list` содержит адрес 300 (и указывает на узел `z`). В поле `next` узла `z` лежит число 200. Так что `p = list->next`.

Для перехода на следующий узел, как и в односвязном списке, `p = p->next`.

Перепишем полностью код печати этих узлов через `p`:

```c
    // напечатаем данные
    Node * p = list->next;


    // printf("%d ", a.data);
    printf("%d ", p->data);
    p = p->next;
    // printf("%d ", b.data);
    printf("%d ", p->data);
    p = p->next;
    // printf("%d ", c.data);
    printf("%d ", p->data);
    p = p->next;


    printf("\n");
```

### Печать отдельной функцией
Свернем печать в цикл `for`. Какое условие продолжения цикла?

p сначала указывает на a и переходит на следующий узел при каждой итерации цикла. Продолжаем цикл, пока p указывает на `a`, `b`, `c`. Не печатаем, когда p дошел до замочка (там нет данных). На замочек указывает `list`. Значит печатаем, пока `p` не укажет на замочек.

```c
// печать списка
void list_print(Node * list) {
    for (Node * p = list->next; p != list; p = p->next) {
        printf("%d ", p->data);
    }
    printf("\n");
}
```

### list_print_back
Так как в двусвязном списке нужно поддерживать правильную связь не только полей next, но и `prev`, для тестирования полезно иметь функцию, которая печатает список, используя поля `prev`. То есть в обратном порядке.

```c
// печать списка в обратном порядке
void list_print_back(Node * list) {
    for (Node * p = list->prev; p != list; p = p->prev) {
        printf("%d ", p->data);
    }
    printf("\n");
}
```

Заметьте, условие продолжения цикла не изменилось.

### Отладочная печать
Для отладки будет полезно печатать не только данные, но и поля `prev` и `next` всех узлов. Особенно, когда вы испортите список после вставки или удаления.

Напишем такую функцию:

```c
// отладочная печать с адресами
void list_print_dbg(Node * list) {
    printf("--------\n");       // обозначим начало печати
    Node * p = list;
    // печатаем замочек
    printf("list: prev=%p %p next=%p\n", p->prev, p, p->next);
    // потом остальные элементы
    for (Node * p = list->next; p != list; p = p->next) {
        printf("%d : prev=%p %p next=%p\n", p->data, p->prev, p, p->next);
    }
    printf("========\n");       // обозначим конец печати
}
```

## Добавление узла и инициализация списка. insert, init

[VIDEO](https://youtu.be/vLKAbAY84qA)

### Модель
Вставим узел u с числом 10 после узла а.

![17](/C_for_beginners_Stepik/Pictures/17_05.png)

Для вставки узла нужно вместо ссылок `а` на `b` и `b` на `a` (серые стрелки) поставить стрелки, что
+ перед узлом u будет узел а (стрелка 1)
+ после узла u будет узел b (стрелка 2)
+ после узла a будет узел u (стрелка 3)
+ перед узлом b будет узел u (стрелка 4)

Напишем код вставки узла u для нашей модели:

```c
Node u = {10};


list_print(list);    // 3 17 21


u.prev = &a;    // перед узлом u будет узел а (стрелка 1)
u.next = &b;    // после узла u будет узел b (стрелка 2)
a.next = &u;    // после узла a будет узел u (стрелка 3)
b.prev = &u;    // перед узлом b будет узел u (стрелка 4)


list_print(list);    // 3 10 17 21
```

Рекомендуем, однако, использовать формат инициализации структуры с указанием имени поля. Этот синтаксис может не работать на старых компиляторах.

```c
Node u = {.data = 10};
```

### От имен узлов к указателям
Перейдем в этом коде от имен узлов `a`, `b`, `u` к указателям на них.

Напишем вместо кода модели вызов функции:

```c
list_insert(&a, &u);    // вставить узел u после узла a
```

Перейдем от вызова к прототипу функции (запишем, какие типы у выражений `&a` и `&u`) и ее реализации:

```c
void list_insert(Node * p, Node * t);   // вставить узел t после узла p
```

Вместо узла `b` будем использовать `q` указатель на узел `b`. Этот указатель не передается в функцию, но мы его можем вычислить. `q` - следующий узел после `p`.

Итого, вместо `&a` пишем `p`, вместо `&b` пишем вычисленное `q`, вместо `&u` пишем `t`.

```c
// вставить узел t после узла p
void list_insert(Node * p, Node * t) {
    Node * q = p->next;
    t->prev = p;    // u.prev = &a; (стрелка 1)
    t->next = q;    // u.next = &b; (стрелка 2)
    p->next = t;    // a.next = &u; (стрелка 3)
    q->prev = t;    // b.prev = &u; (стрелка 4)
}
```

Как видите, реализация функции очень простая. Можно обойтись без переменной `q`, попробуйте написать этот вариант функции сами.

### Зачем нужна функция list_init
После реализации `list_insert` можно избавиться от модели в тестах. Возьмем пустой список и будем в него добавлять узлы.

Что такое "пустой список"? Это циклический список, в котором только один замочек и нет элементов с данными.

Будет ли такой список нужным "пустым списком"?

```c
Node * list = NULL;
```

Нет, в нашем списке нигде нет открытых концов `NULL`. Тут нет даже замочка.

Попробуем еще раз:

```c
Node z;
Node * list = &z;
```

Готов ли список к вставке элементов (или хотя бы к печати)?

Нет, если эти переменные локальные, то в полях `prev` и `next` узла `z` будет мусор. Эти поля указывают на какие-то произвольные места в памяти (быть может на `NULL`).

### Инициализация списка

```c
Node z;
Node * list = &z;
list_init(list);    // готовим список к работе
printf("Empty: %s\n", list_is_empty(list) ? "YES" : "NO");  // YES
list_print(list);        // пустой список
```

Такой лист нужно подготовить к работе, сделав его циклическим. Получим хоровод из одного танцора. Нужно чтобы после замочка стоял замочек, и перед замочком тоже замочек.

Напишем еще функцию проверки, что список пустой `list_is_empty`.

![17](/C_for_beginners_Stepik/Pictures/17_06.png)

Проверим, что после замочка стоит замочек. Если мы не ошибались во вставках и удалениях, в таком случае перед замочком тоже стоит замочек.

```c
// список пустой?
int list_is_empty(Node * list) {
    return list->next == list;  // после замочка тоже замочек?
}
// подготовка списка к работе (инициализация)
void list_init(Node * list) {
    list->next = list->prev = list;     // до и после замочка стоит замочек
}
```

### Следующий равен предыдущему
Иногда инициализацию и проверку на пустоту пишут как "равен ли следующий предыдущему?"

```c
// список пустой?
int list_is_empty(Node * list) {
    return list->next == list->prev;  // следующий равен предыдущему
}
// подготовка списка к работе (инициализация)
void list_init(Node * list) {
    list->next = list->prev;        // следующий равен предыдущему
}
```

Представим, что в списке единственный узел `a`. Тогда у замочка следующий узел а и предыдущий тоже `а`. То есть такая `list_is_empty` возвращает истину и когда список пуст, и когда в нем единственный элемент. Это ошибка.

С инициализацией еще хуже. В `list->prev` лежит мусор (поле указывает на какое-то место в памяти). Мы в `list->next` помещаем такой же мусор (это поле будет указывать в то же место, но не в замочек, как требовалось).

Обязательно проверяйте свою реализацию на valgrind.

### Переписываем тесты, избавляясь от модели

Перепишем тесты, конструируя список и добавляя в него узлы `a`, `b`, `c` с помощью `list_insert`.

```c
int main() {
    // model
    Node a, b, c;   // узлы с данными в списке


    Node z;         // замочек
    Node * list = &z;


    a.data = 3;
    b.data = 17;
    c.data = 21;


    list_init(list);    // готовим список к работе
    printf("Empty: %s\n", list_is_empty(list) ? "YES" : "NO");  // YES
    list_print(list);   // пустой список


    list_insert(list, &c);
    list_print(list);            // 21
    printf("Empty: %s\n", list_is_empty(list) ? "YES" : "NO");  // NO


    list_insert(list, &b);
    list_print(list);            // 17 21


    list_insert(list, &a);
    list_print(list);            // 3 17 21


    list_insert(&a, &u);
    print(list);            // 3 10 17 21


    return 0;
}
```

Можно сделать массив узлов и добавлять из него:

```c
int main() {


    Data test_data[] = {3, 17, 21};
    Node test_nodes[sizeof(test_data)/sizeof(test_data[0])]; // 21 17 2
    int n = sizeof(test_data)/sizeof(test_data[0]);
    for (int i = n - 1; i >= 0; i--)
        test_nodes[i].data = test_data[i];


    Node z;             // замочек
    Node * list = &z;
    list_init(list);    // готовим список к работе
    printf("Empty: %s\n", list_is_empty(list) ? "YES" : "NO");  // YES
    list_print(list);   // пустой список


    for (int i = 0; i < n; i++) {
        list_insert(list, &test_nodes[i]);
        list_print(list);
    }


    return 0;
}
```

Оставим пока предыдущий вариант, так как мы еще не реализовали `list_insert _before`.

### Вставка перед узлом

Вставим узел `w` перед узлом `u`.

```c
Node w;
w.data = 8;


list_print(list);    // 3 10 17 21
list_insert_before(&u, &w);
list_print(list);    // 3 8 10 17 21
```

![17](/C_for_beginners_Stepik/Pictures/17_05.png)

Реализуйте эту функцию, проверьте ее, а потом проверьте свое качество кода - сравните с нашим.

### Вставка перед узлом - реализация
Вставим узел u перед узлом b.

![17](/C_for_beginners_Stepik/Pictures/17_05.png)

сли вы написали так, вы написали неправильно:

```c
// вставить узел t перед узлом q
void list_insert_before(Node * q, Node * t) {
    Node * p = q->prev;
    t->prev = p;    // u.prev = &a; (стрелка 1)
    t->next = q;    // u.next = &b; (стрелка 2)
    p->next = t;    // a.next = &u; (стрелка 3)
    q->prev = t;    // b.prev = &u; (стрелка 4)
}
```
Заметим, что вставка перед узлом q это вставка после узла p. Узел p предыдущий для q. Поэтому

```c
void list_insert_before(Node * q, Node * t) {
    list_insert(q->prev, t);
}
```

Чем эта реализация лучше?
+ меньше строк кода - меньше шанс сделать ошибку.
+ если ошибка будет в одной из функций `list_insert` и `list_insert_before`, то ее будет труднее обнаружить, чем если она будет в обоих функциях и одинаковая.

## Удаление узла. remove

[VIDEO](https://youtu.be/a1SHkevSt7Y)

### Удаление
Удалим узел u. Нужно вместо стрелок 1, 2, 3, 4 восстановить серые стрелки.

![17](/C_for_beginners_Stepik/Pictures/17_05.png)

Что передать функции, которая удаляет узел? Хватит ли указателя на сам узел или нужны указатели на следующий или предыдущий узел?

Так как указатели на следующий и предыдущий узел можно вычислить, то хватит указателя на удаляемый узел:
```c
list_remove(&u);
```

Реализация:

```c
void list_remove(Node * t) {
    Node * p = t->prev;
    Node * q = t->next;
    p->next = q;
    q->prev = p;
}
```

### API работающее с узлами без выделения и освобождения памяти

```c
void list_init(Node * list);

void list_insert(Node * list, Node * t);
void list_insert_before(Node * list, Node * t);
void list_remove(Node * t);
```
Эти функции работают с уже готовыми узлами. Нужно добавить набор функций, которые будут создавать узел и разрушать его, освобождая память:

```c
Node * list_push_front(Node * list, Data d);    // добавить в начало списка
Node * list_push_back(Node * list, Data d);     // добавить в конец списка

Data list_pop_front(Node * list);   // удалить из начала списка
Data list_pop_back(Node * list);    // удалить из конца списка
Data list_delete(Node * t);         // удалить узел t

void list_clear(Node * list);       // удалить все, кроме замочка
```

### Функции с выделением памяти. push

[VIDEO](https://youtu.be/obY-A7G1YeU)

### Тестирование
Тесты на добавление и удаление с выделением памяти хорошо бы начать на новом списке. Старые тесты не надо выбрасывать. Лучше оформить их в функцию `void test()` и сейчас дописать тесты в отдельную функцию `void test_alloc()`. Ее мы будем вызывать из `main`. Функцию `test` пока вызывать не будем. Потом, когда у нас будут написаны новые тесты, написаны и отлажены функции, мы включим старые тесты и будем выполнять все тесты, чтобы убедиться, что мы ничего не сломали.

```c
void test_alloc() {
    Node * list = malloc(sizeof(Node));
    list_init(list);
    list_print(list);                    // пустой список


    Node * t;
    t = list_push_front(list, 21);
    printf("push %d: ", t->data);
    list_print(list);                    // 21


    free(list);
}
int main() {
    // test_no_malloc();    // старые тесты оформим отдельной функцией
                            // и пока не будем вызывать
    test_alloc();           // новые тесты, пока запускаем только их
    return 0;
}
```

### list_push_front
По использованию функции `t = list_push_front(list, 21);` можно написать прототип:

`Node * list_push_front(Node * list, Data d);`

Реализуем функцию. Сначала создадим узел, выделив для него динамическую память. Узел типа Node, значит памяти нужно выделять `sizeof(Node)`.

```c
Node * list_push_front(Node * list, Data d) {
    Node * p = malloc(sizeof(Node));    // выделили память под узел
    p->data = d;                        // записали в узел данные
    list_insert(list, p);               // вставили узел в начало списка
    return p;                           // вернули указатель на новый узел
}
```

Заметим, что вставляем новый узел функцией `list_insert`, а не пишем еще раз код вставки, плодя потенциальные ошибки.

Проверяем программу под valgrind. Пока не обращаем внимание на утечки памяти, так как в тестах память выделяется, но не освобождается.

### Тесты на push_front и push_back
Напишем тесты и определим ожидаемый вывод.

```c
void test_alloc() {
    Data test_data1[] = {21, 17, 3};    // для вставки сначала
    Data test_data2[] = {10, 8};        // для вставки с конца


    Node * list = malloc(sizeof(Node));
    list_init(list);
    list_print(list);                    // пустой список


    Node * t;
    for(size_t i = 0; i < sizeof(test_data1)/sizeof(test_data1[0]); i++) {
        t = list_push_front(list, test_data1[i]);
        printf("push_front %d: ", t->data);
        list_print(list);
    }
    // 3 17 21


    for(size_t i = 0; i < sizeof(test_data2)/sizeof(test_data2[0]); i++) {
        t = list_push_back(list, test_data2[i]);
        printf("push_back %d: ", t->data);
        list_print(list);
    }
    // 3 17 21 10 8


    free(list);
}
```

Ожидаемый вывод:

```c
push_front 21: 21
push_front 17: 17 21
push_front 3: 3 17 21
push_back 10: 3 17 21 10
push_back 8: 3 17 21 10 8
```

### Реализуем push_back
Реализуйте сами.

Если у вас код функции занимает больше 1 строки, перечитайте, как мы писали `list_insert_before`.

## Освобождение памяти. delete

[VIDEO](https://youtu.be/QFzIGyG373Y)

### Тестирование list_delete
Как обычно, начнем с использования функции `list_delete`. Удалим узел с числом 17.
+ list указывает на замочек
+ list->next указывает следующий за замочком, с числом 3.
+ list->next->next указывает следующий за узлом с числом 3, на узел 17.

```c
void test_alloc() {
    Node * list = malloc(sizeof(Node));
    list_init(list);
    list_print(list);               // пустой список


//    еще тесты, которые мы описали раньше


    list_print(list);               // 3 17 21 10 8


    Node * t = list->next->next;    // узел с числом 17
    Data res = list_delete(t);
    printf("deleted %d: ", res);    // deleted 17:
    list_print(list);               // 3 21 10 8


    free(list);
}
```

### Реализуем list_delete
По использованию

`Data res = list_delete(t);`

напишем прототип

`Data list_delete(Node * t);`

Функция `list_delete`:
+ удаляет узел t из списка;
+ освобождает память, которая была выделена под этот узел;
+ возвращает данные, которые хранились в этом узле

```c
Data list_delete(Node * t) {
    Data res = t->data;     // сохраним данные в удаляемом узле
    list_remove(t);         // извлечем узел из списка
    free(t);                // освободим память, которую занимал этот узел
    return res;
}
```

### Где ошибка?
Можно ли написать так:

```c
Data list_delete(Node * t) {
    list_remove(t);         // извлечем узел из списка
    free(t);                // освободим память, которую занимал этот узел
    return t->res;
}
```

Нет, после освобождения памяти обращение к ней бесполезно. В худшем случае функция будет иногда работать (и вы будете думать, что она правильно написана).

Мы программисты, а не археологи, мы после `free` к этой памяти не обращаемся.

### Тестируем list_pop_front и list_pop_back

`list_pop_front` - функция, которая удаляет первый элемент списка и освобождает память.

`list_pop_back` - аналогичная, но удаляет последний узел списка.

Допишем для них тесты:

```c
void test_alloc() {
    Node * list = malloc(sizeof(Node));
    list_init(list);
    list_print(list);               // пустой список


    // еще тесты, которые мы описали раньше


    list_print(list);               // 3 17 21 10 8


    Node * t = list->next->next;    // узел с числом 17
    Data res = list_delete(t);
    printf("deleted %d: ", res);    // deleted 17:
    list_print(list);               // 3 21 10 8


    res = list_pop_front(list);
    printf("pop front %d: ", res);  // 3:
    list_print(list);               // 21 10 8


    res = list_pop_back(list);
    printf("pop back %d: ", res);  // 8:
    list_print(list);              // 21 10


    list_clear(list);


    free(list);
}
```

Попробуйте сначала написать их самостоятельно, а потом посмотрите на нашу реализацию.

### Реализация list_pop_front и list_pop_back
У нас уже реализована функция `list_delete`, которая освобождает узел, на который указывает.

`list_pop_front` и `list_pop_back` делают то же самое, что и `list_delete`, но с первым узлом (на который указывает поле `next` замочка) и с последним узлом (на который указывает поле `prev` замочка).

```c
// удаление первого узла
Data list_pop_front(Node * list) {
    return list_delete(list->next);
}


// удаление последнего узла
Data list_pop_back(Node * list) {
    return list_delete(list->prev);
}
```

### Очистка списка list_clear
После использования `list_clear` список должен быть готов к добавлению новых элементов. То есть должен быть пустой список (замочек, который указывает сам на себя).

Добавим тест на `list_clear` в конец тестов. Если он написан правильно, то не будет утечек памяти. Стоит еще раз проверить, как добавляются данные после `list_clear`. Иначе мы можем слишком сильно очистить список. Например, вместе с замочком.

Для реализации воспользуемся уже написанными функциями.

Как нужно решать задачи? Если список нерешенных задач не пуст, реши задачу из него (все равно какую). Повторяй до тех пор, пока список нерешенных задач не будет пуст.

```c
void list_clear(Node * list) {
    while( ! list_is_empty(list))
        list_pop_front(list);
}
```

### list_create, list_destroy
Нехорошо заставлять пользователей нашего списка самим задумываться о том, что надо выделять память для замочка и освобождать ее.

Напишем функции создания списка и его уничтожения.

В тестах теперь будет так:

```c
void test_alloc() {
    Node * list = list_create();    // создает пустой список
    // тестирование других функций
    list_destroy(list);             // удаляет список
    return 0;
}
```
Реализуем их:

```c
// создает пустой список, готовый к работе
Node * list_create() {
    Node * z = malloc(sizeof(Node));    // создали замочек
    list_init(z);                       // проинициализировали его
    return z;                           // список - это указатель на замочек
}


// полностью удаляет список
void list_destroy(Node * list) {
    list_clear(list);                   // удаляем данные
    free(list);                         // удаляем замочек
}
```

Как видите, все функции простые. Мы тратили больше сил на тестирование, чем на реализацию.

Теперь можно перейти к использованию написанного списка.

## Применение функции ко всем элементам. foreach

[VIDEO](https://youtu.be/-kteSgR-x6s)

### Функция foreach
Об этой функции обычно не рассказывают, а она 
+ удобная
+ есть в реализации списков во многих языках программирования
+ полезно рассмотреть ее устройство и как решаются проблемы передачи аргументов и возвращения результата

`foreach` - функция, которая применяет переданную в аргументах функцию к каждому элементу списка.

### Как использовать?
Рассмотрим уже написанную функцию печати списка:

```c
void list_print(Node * list) {
    for (Node * p = list->next; p != list; p = p->next) {
    // перебор элементов списка
        printf("%d ", p->data);     // обработка поля data элемента
    }
    printf("\n");                   // прочее
}
```
Распишем печать всего списка через функцию печати 1 узла, примененную ко всем элементам:

```c
void print_node(Data d) {
    printf("%d ", d);
}
void list_print(Node * list) {
    foreach(list, print_node);      // использование foreach
    printf("\n");                   // прочее
}
```

Что должна делать `foreach`? Перебрать все элементы и применить функцию func к каждому элементу.

```c
void foreach(Node * list, void (*func)(Data)) {
    for (Node * p = list->next; p != list; p = p->next) {
    // перебор элементов списка
        func(p->data);     // обработка поля data элемента
    }
}
```

### Передача аргументов в функцию func
Предположим, что мы хотим указывать в функции печати, куда именно печатать

```c
void list_print(Node * list, FILE * stream) {
    for (Node * p = list->next; p != list; p = p->next) {
    // перебор элементов списка
        fprintf(stream, "%d ", p->data); // обработка поля data элемента
    }
    fprintf(stream, "\n");               // прочее
}
```

Как видно, функция печати 1 элемента должна принимать не только поле `data` этого элемента, но и указатель на поток.

Мы уже видели в функции `qsort`, что когда не знаем какого типа может быть аргумент, мы передаем его как `void *` и в функции приводим к нужному типу.

```c
void print_node(Data d, void * stream) {
    fprintf((FILE*)stream, "%d ", d);
}
void list_print(Node * list) {
    foreach(list, print_node, stderr);  // использование foreach
    fprintf(stderr, "\n");              // прочее
}
```

Для такого использования нужно изменить `foreach`:

```c
void foreach(Node * list, void (*func)(Data, void *), void * arg) {
    for (Node * p = list->next; p != list; p = p->next) {
        // перебор элементов списка
        func(p->data, arg);     // обработка поля data элемента
    }
}
```

### Суммирование всех чисел списка через foreach
Напишем функцию, которая суммирует все элементы списка:

```c
Data sum_all(Node * list) {
    Data res = 0;
    for (Node * p = list->next; p != list; p = p->next) {
        res += p->data;     // это будет функция sum_node
    }
    return res;
}
```
Перепишем ее через использование `foreach`.

В функцию `sum_node` нужно передать поле `data` и указатель на переменную `res`, чтобы можно было добавлять в нее поле `data`:

```c
void sum_node(Data d, void * vres) {
    // напоминает функцию compare, которую мы передавали в qsort
    Data * res = (Data *) vres;
    *res = *res + d;
}
Data sum_all(Node * list) {
    Data res = 0;
    foreach(list, sum_node, &res);      // использование foreach
    return res;
}
```

## Задачи на списки

### list_2 Двусвязный список
Реализуйте структуру данных "двусвязный список". Для этого при объявленных структурах Node (один элемент списка)

```c
typedef int Data;
struct Node {
    struct Node * next;
    struct Node * prev;
    Data data;
};
```

+ data - данные, хранящиеся в одном элементе,
+ next - указатель на следующий элемент списка (для конца списка - сам список)
+ prev - указатель на предыдущий элемент списка (для начала списка - сам список)

Реализуйте функции работы со списком.

+ Без выделения и освобождения памяти:
    + `void list_init (struct Node * list);` - инициализация пустого списка.
    + `void list_insert (struct Node * list, struct Node * t);` - вставляет элемент `t` после элемента `list`
    + `void list_insert_before (struct Node * list, struct Node * t);` - вставляет элемент `t` перед элементом `list`
    + `void list_remove (struct Node * t);` - удаляет элемент `t` из списка
+ С выделением и освобождением памяти:
    + `struct Node * list_push_front (struct Node * list, Data d);` - выделяет память под новый элемент, содержащий данные d, и вставляет его в голову списка. Возвращает указатель на этот новый элемент или NULL, если произошла ошибка.
    + `struct Node * list_push_back (struct Node * list, Data d);` - выделяет память под новый элемент, содержащий данные `d`, и вставляет его в хвост списка. Возвращает указатель на этот новый элемент или `NULL`, если произошла ошибка.
    + `Data list_pop_front (struct Node * list);` - удаляет голову списка, возвращает данные из удаленного узла.
    + `Data list_pop_back (struct Node * list);` - удаляет хвост списка, возвращает данные из удаленного узла.
    + `Data list_delete (struct Node * t);` - удаляет узел `t` из списка, возвращает данные из удаленного узла.
    + `void list_clear (struct Node * list);` опустошает список, освобождая память. После этого можно опять добавлять элементы в список.

+ Прочие функции:
    + `void list_print (struct Node * list);` распечатывает через пробел числа, лежащие в списке. С самого первого до последнего. В конце переводит строку. Полезна для отладки прочих функций.
    + `int list_is_empty (struct Node * list);` проверяет пустой это список или нет

Рекомендуем реализовывать циклический список с барьерным элементом. Но вы можете реализовать любой список с указанным API.

![17](/C_for_beginners_Stepik/Pictures/17_04.png)

```c
void list_init(struct Node * list);

void list_insert(struct Node * list, struct Node * t);
void list_insert_before(struct Node * list, struct Node * t);
void list_remove(struct Node * t);

struct Node * list_push_front(struct Node * list, Data d);
struct Node * list_push_back(struct Node * list, Data d);

Data list_pop_front(struct Node * list);
Data list_pop_back(struct Node * list);
Data list_delete(struct Node * t);

void list_print (struct Node * list);
int list_is_empty(struct Node * list);

void list_clear(struct Node * list);
```

Объявление структуры, прототипы функций и реализацию функции `main` посылать не нужно. Проверку корректности аргументов не делать.

Гарантируется, что набор тестов удовлетворяет следующим требованиям: все команды `remove` и `delete` корректны, то есть при их исполнении в списке содержится хотя бы один элемент.

```c
void test_non_alloc(int n)
{
    struct Node * x = malloc(11*sizeof(struct Node));
    struct Node * a = x+10;

    list_init(a);
    assert(list_is_empty(a));
    if(n == 1)
        goto END;

    for(int i = 0; i < 10; i++) {
        x[i].data = i;
        list_insert(a, &x[i]);
    }
    list_print(a);              // 9 8 7 6 5 4 3 2 1 0
    assert(!list_is_empty(a));
    if(n == 2)
        goto END;

    list_remove(&x[5]);
    list_print(a);              // 9 8 7 6 4 3 2 1 0
    list_remove(&x[0]);
    list_print(a);              // 9 8 7 6 4 3 2 1
    list_remove(&x[9]);
    list_print(a);              // 8 7 6 4 3 2 1
    if(n == 3)
        goto END;

    list_insert_before(a, &x[0]);
    list_print(a);              // 8 7 6 4 3 2 1 0
    list_insert(a, &x[9]);
    list_print(a);              // 9 8 7 6 4 3 2 1 0
    list_insert(&x[6], &x[5]);
    list_print(a);              // 9 8 7 6 5 4 3 2 1 0
    if(n == 4)
        goto END;

    while(!list_is_empty(a))
        list_remove(a->next);
    if(n == 5)
        goto END;

END:
    free(x);
}

void test_alloc(int n)
{
    struct Node a0, b0;
    struct Node * a = &a0;
    struct Node * b = &b0;

    list_init(a);
    list_init(b);

    int i;
    for(i=0; i<10; i++)
        list_push_back(a, i);
    list_print(a);              // 0 1 2 3 4 5 6 7 8 9
    assert(list_is_empty(b));
    if (n == 6)
        goto END;

    for(i=0; i<10; i++)
        list_push_front(b, list_pop_back(a));
    list_print(b);              // 0 1 2 3 4 5 6 7 8 9
    assert(list_is_empty(a));
    if (n == 7)
        goto END;

    for(i=0; i<10; i++) {
        list_push_front(a, i);
        list_pop_front(b);
    }
    list_print(a);              // 9 8 7 6 5 4 3 2 1 0
    assert(list_is_empty(b));
    if (n == 8)
        goto END;

    for(i=0; i<10; i++)
        list_push_back(b, list_pop_front(a));
    list_print(b);              // 9 8 7 6 5 4 3 2 1 0
    assert(list_is_empty(a));
    if (n == 9)
        goto END;

END:
    list_clear(a);
    list_clear(b);
}
```
Если ваш код содержит ошибку, но тесты проходят, пришлите ваш код с указанием ошибки и особая благодарность, если вы придумаете тест, который ошибку ловит.

https://stepik.org/lesson/659477/step/1?unit=656913

### list_3 Пьяница
В игре в пьяницу карточная колода раздается поровну двум игрокам. Далее они вскрывают по одной верхней карте, и тот, чья карта старше, забирает себе обе вскрытые карты, которые кладутся под низ его колоды (сначала кладется карта от первого игрока, потом - от второго). Тот, кто остается без карт – проигрывает.

Для простоты будем считать, что все карты различны по номиналу, а также, что самая младшая карта побеждает самую старшую карту ("шестерка берет туза").

Игрок, который забирает себе карты, сначала кладет под низ своей колоды карту первого игрока, затем карту второго игрока (то есть карта второго игрока оказывается внизу колоды).

Напишите программу, которая моделирует игру в пьяницу и определяет, кто выигрывает. В игре участвует `10` карт, имеющих значения от `0` до `9`, большая карта побеждает меньшую, карта со значением `0` побеждает карту `9`.

Входные данные

Программа получает на вход две строки: первая строка содержит `5` карт первого игрока, вторая – `5` карт второго игрока. Карты перечислены сверху вниз, то есть каждая строка начинается с той карты, которая будет открыта первой.

Выходные данные

Программа должна определить, кто выигрывает при данной раздаче, и вывести слово `first` или `second`, после чего вывести количество ходов, сделанных до выигрыша.

Если на протяжении $10^6$ ходов игра не заканчивается, программа должна вывести слово `botva`.

Реализовать колоды игроков через очереди на основе двухсвязных списков.

Условия задачи взяты из [дистанционной подготовки по информатике для школьников](http://informatics.mccme.ru/moodle/mod/statements/view3.php?id=206&chapterid=50), автор не указан

Отладочная печать на каждой итерации цикла для раздачи карт из примера:

```c
1 3 5 7 9
2 4 6 8 0
---
3 5 7 9
4 6 8 0 1 2
---
5 7 9
6 8 0 1 2 3 4
---
7 9
8 0 1 2 3 4 5 6
---
7 9
8 0 1 2 3 4 5 6
---
9
0 1 2 3 4 5 6 7 8
---

0 1 2 3 4 5 6 7 8
second 5
```

Алгоритм решения (для совсем слабых духом)

Для написания этой программы достаточно реализовать структуру "очередь" и дальше смоделировать все то, о чём написано в условии. А именно:
+ Задаём цикл `for(i: 0 .. N)` на $N = 10^6$ итераций.
+ При каждом заходе в цикл берём по первому элементу из очередей, эмулирующих колоды первого и второго игроков.
    + Сравниваем их согласно описанной в условии методике.
    + Добавляем две взятые карты к конец колоды-очереди игрока выигравшего на данном сравнении.
    + Если при очередной итерации одна из очередей оказывается пуста, то выводим победителя и количество совершённых итераций (i).
+ Если все $10^6$ итераций успешно выполнились - выводим "botva".

Теста на botva нет. Если кто-то найдет входную последовательность, чтобы у нас был тест на ботву, мы будем очень благодарны. А пока лучше сделаем еще одну задачу. Свою.

https://stepik.org/lesson/659477/step/2?unit=656913