# Массивы и адресная арифметика

[Видео](https://youtu.be/6E0ZONXbncU)

[Презентация](/C_for_beginners_Stepik/Files/c2019_6.pdf)

## Понятие массива

### Пример: Сколько шаров каждого цвета
Есть воздушные шары. Цвет будем обозначать числом. 0 - красный, 1 - желтый, 2 - зеленый, 3 - синий.

Даны цвета шаров через пробел. Найти сколько шаров каждого цвета. Напечатаем цвет от 0 до 3 и сколько шаров этого цвета.

Input:
```
2 2 1 0 2 1 3 1 0 1 2 1
```

Output:

```
3 1
2 4
1 5
0 2
```

Программа:

```c
#include <stdio.h>


int main()
{
    int c,      // цвет текущего шара
        c0 = 0, // счетчик для цвета 0 (красный)
        c1 = 0, // счетчик для цвета 1 (желтый)
        c2 = 0, // счетчик для цвета 2 (зеленый)
        c3 = 0; // счетчик для цвета 3 (синий)


    // читаем и считаем шары
    while(1 == scanf("%d", &c)) {
        switch(c) {                 // какой цвет текущего шара?
            case 0: c0++; break;
            case 1: c1++; break;
            case 2: c2++; break;
            case 3: c3++; break;
            default: printf("Error: unknown color %d\n", c);
        }
    }
    // печатаем результат
    printf("0 %d\n", c0);
    printf("1 %d\n", c1);
    printf("2 %d\n", c2);
    printf("3 %d\n", c3);


    return 0;
}
```

Счетчики c0, c1, c2, c3 одинакового типа int.

Расширим задачу. Пусть шары будут 10 разных цветов. Очень неудобно изменять такой код. Что делать?

### Массив
Мы считали каждый цвет в свою переменную.

![08](/C_for_beginners_Stepik/Pictures/08_01.jpg)

Можно объединить отдельные переменные в общий набор (массив)

![08](/C_for_beginners_Stepik/Pictures/08_02.jpg)

Теперь назовем с весь ящик с ячейками (как таблетница). В каждую ячейку (__элемент массива__) можно положить таблетки (__значение__ элемента массива).

![08](/C_for_beginners_Stepik/Pictures/08_03.png)

У ячейки есть номер или индекс. У первой ячейки номер ноль.

![08](/C_for_beginners_Stepik/Pictures/08_04.png)

#### Создание массива
int c[4]; // объявили переменную c типа "массив из 4 int"
Массив можно объявить любого другого типа и другого размера.

#### Обращение к элементу массива
У массива с элементы c[0], c[1], c[2] и c[3]. С ними в программе можно обращаться, как с отдельными переменными.

Как запомнить: квадратные скобки [ ] напоминают коробку.

### Работа с массивами
Большая коробка поделена на 5 одинаковых ячеек. Коробка называется a.

Ячейки имеют номер от 0 до 4. В ячейках лежат шарики.

![08](/C_for_beginners_Stepik/Pictures/08_05.png)

```c
int a[5];   // коробка с ячейками
```

+ В ячейке с номером 0 лежит a[0], то есть 3 шарика.
+ В ячейке с номером 1 лежит a[1], то есть 4 шарика.
+ В ячейке с номером 2 лежит a[2], то есть 2 шарика.
+ В ячейке с номером 3 лежит a[3], то есть 0 шариков.
+ В ячейке с номером 4 лежит a[4], то есть 1 шарик.

Всего 5 ячеек. В них лежит a[0]+a[1]+a[2]+a[3]+a[4] то есть 3+4+2+0+1=10 шариков.

В ячейки можно положить другое количество шариков:

![08](/C_for_beginners_Stepik/Pictures/08_06.png)

+ a[0] = 7; - в ячейку с номером 0 положили 7 шариков.
+ a[2] = 0; - в ячейку с номером 2 положили 0 шариков (в ячейке шариков нет).
+ a[3] = 2; - в ячейку с номером 3 положили 2 шарика.

Элемент массива можно прочитать. В элемент массива можно записать (присвоить).

+ a[4] = a[0]; - присвоить число шариков из ячейки с номером 0 в ячейку с номером 4.
+ a[1] = a[0] - 2; - в ячейку с номером 1 положить на 2 шарика меньше, чем число шариков в ячейке с номером 0.

a[0] произносят как "а нулевое". Это элемент массива a с номером (индексом) 0.

#### Печать и чтение

Используем __элемент массива__ как обычную переменную такого же типа. Одна отдельная коробочка, а не ячейка в большой коробке.

```c
int x;
int a[5];


scanf("%d", &x);        // прочитали число в переменную x
scanf("%d", &a[2]);     // прочитали число в элемент массива a с индексом 2


printf("%d\n", x);       // печать значения переменной х
printf("%d\n", a[2]);    // печать значения элемента массива a с индексом 2
```

### Barr_1 Напечатать элементы

![08](/C_for_beginners_Stepik/Pictures/08_05.png)

Измените программу, чтобы напечатать в конце числа из ячеек (значения элементов) с номерами 0, 3, 4.

```c
#include <stdio.h>

int main()
{
    int a[5];           // коробка с ячейками

    scanf("%d", &a[0]); // получить число шариков в ячейке с номером 0
    scanf("%d", &a[1]); // получить число шариков в ячейке с номером 1
    scanf("%d", &a[2]); // получить число шариков в ячейке с номером 2

    a[3] = 7;           // присвоить 7 ячейке с номером 3

                        // присвоить число шариков из ячейки с номером 0 в
                        // ячейку с номером 4
    a[4] = a[0];

    // печатаем элементы с номерами 0, 3 и 4
    printf("%d ", a[0]); // печать количества шариков в 0 ячейке
    printf("%d ", a[3]); // печать количества шариков в 3 ячейке
    printf("%d", a[4]); // печать количества шариков в 4 ячейке

    return 0;
}
```

### Barr_2 Все элементы

![08](/C_for_beginners_Stepik/Pictures/08_05.png)

В коробке 5 ячеек (cells). В каждую ячейку можно положить шарики.

Дана программа, которая получает 2 числа (сколько шариков) и кладет их в первые ячейки, а затем печатает их.

Надо изменить программу, чтобы она получала, сохраняла в ячейках и затем печатала 5 чисел.

```c
#include <stdio.h>
#define COUNT 5

int main(){
    int a[COUNT];            // коробка с ячейками
    for (int i = 0; i < COUNT; i++) {
        scanf("%d", &a[i]);
    }
    for (int i = 0; i < COUNT; i++) {
        printf("%d%s", a[i], i == COUNT - 1 ? "" : " ");
    }
    return 0;
}
```

```c
#include <stdio.h>

int main(){
    int a[5];            // коробка с ячейками
    int i;               // номер текущей ячейки

    for(i = 0; 1 == scanf("%d", &a[i]); i++)
        printf("%d ", a[i]);
    return 0;
}
```

## Задачи для начинающих

### Barr_3 В 2 раза
Программа делает:
+ объявляет массив для хранения чисел;
+ читает 5 чисел и кладет их в массив;
+ печатает все элементы массива.

Нужно изменить программу. Программа должна:
+ объявить массив для хранения чисел;
+ прочитать 10 чисел и положить их в массив;
+ увеличить значение каждого элемента массива в 2 раза;
+ напечатать все элементы массива.

```c
#include <stdio.h>
#define COUNT 10

int main(){
    int a[COUNT];            // коробка с ячейками
    for(int i = 0; 1 == scanf("%d ", &a[i]); i++) {
        a[i] *= 2;
        printf("%d ", a[i]);
    }
    return 0;
}
```

### Barr_4 Номера от 2 до 8
Программа делает:
+ объявляет массив для хранения чисел;
+ читает 10 чисел и кладет их в массив;
+ печатает все элементы массива.

Измените программу. Она должна печатать только элементы массива с номерами от 2 до 8 включительно.

```c
#include <stdio.h>

int main(){
    int a[10];                  // коробка с ячейками
    int i;                      // номер текущей ячейки

    for(i = 0; i < 10; i++){    // номера ячеек меняются
        scanf("%d", &a[i]);     // получить число шариков в ячейке с номером i
    }

    for(i = 2; i <= 8; i++){    // номера ячеек меняются
        printf("%d ", a[i]);    // печатаем число из ячейки с номером i через пробел
    }
    printf("\n");               // печать новой строки

    return 0;
}
```

### Номера от k до n
Программа читает, записывает в массив и печатает 10 чисел.

Измените ее так, чтобы при заданных k и n печатались значения элементов массива с с номерами от k до n включительно.

Входные данные:
+ 10 целых чисел через пробел в первой строке.
+ Целые числа k и n на следующей строке. Гарантируется, что k и n корректные (не выходят за пределы массива).

Выходные данные:

Требуемые числа через пробел.

```c
#include <stdio.h>

int main(){
    int a[10];                  // коробка с ячейками
    int i, k, n;

    for(i = 0; i < 10; i++){    // номера ячеек меняются
        scanf("%d", &a[i]);     // получить число шариков в ячейке с номером i
    }
    
    scanf("%d %d", &k, &n);
    
    for(i = k; i <= n; i++){    // номера ячеек меняются
        printf("%d ", a[i]);    // печатаем число из ячейки с номером i через пробел
    }
    printf("\n");               // печать новой строки

    return 0;
}
```

### Barr_7 Где число ≥ 0
Есть программа. Она
+ читает 5 чисел, сохраняет в массив.
+ ищет ячейки, у которых значение < 0
+ и печатает их номера и значения.

Измените программу.

Дано 10 чисел.
Ищите ячейки, у которых значение ≥ 0
и печатайте эти значения (числа).

```c
#include <stdio.h>

#define N 10

int main(){
    int a[N];                  // коробка с ячейками
    int i;                      // номер текущей ячейки

    for(i = 0; i < N; i++){    // номера ячеек меняются
        scanf("%d", &a[i]);     // получить число шариков в ячейке с номером i
    }

    // Ищем все ячейки, в которых числа < 0
    for(i = 0; i < N; i++){    // перебираем все ячейки
        if (a[i] >= 0)           // если число в ячейке a[i] подходит
            printf("%d ", a[i]);    // номер i и число из ячейки a[i]
    }

    return 0;
}
```

### Barr_6 Где число ≥ 0
Есть программа. Она
+ читает 5 чисел, сохраняет в массив.
+ ищет ячейки, у которых значение < 0
+ и печатает их номера и значения.

Измените программу.
+ Дано 10 чисел.
+ Ищите ячейки, у которых значение ≥ 0
+ и печатайте их номера.

```c
#include <stdio.h>

#define N 10

int main(){
    int a[N];                  // коробка с ячейками
    int i;                      // номер текущей ячейки

    for(i = 0; i < N; i++){    // номера ячеек меняются
        scanf("%d", &a[i]);     // получить число шариков в ячейке с номером i
    }

    // Ищем все ячейки, в которых числа < 0
    for(i = 0; i < N; i++){    // перебираем все ячейки
        if (a[i] >= 0)           // если число в ячейке a[i] подходит
            printf("%d ", i);    // номер i
    }

    return 0;
}
```

### Barr_9 числа до k или больше n
Написать программу, которая получает 10 чисел, ищет все ячейки с числами a[i] < k или a[i] > n и печатает эти числа.

Входные данные:
+ 10 чисел через пробел
+ k n через пробел

Выходные данные:

Нужные числа через пробел

```c
#include <stdio.h>

#define N 10

int main(){
    int a[N];                  // коробка с ячейками
    int i, n, k;

    for(i = 0; i < N; i++){    // номера ячеек меняются
        scanf("%d", &a[i]);    // получить число шариков в ячейке с номером i
    }
    
    scanf("%d %d", &k, &n); 
    
    // Ищем все ячейки, в которых числа < 0
    for(i = 0; i < N; i++){    // перебираем все ячейки
        if (a[i] < k || a[i] > n)          // если число в ячейке a[i] подходит
            printf("%d ", a[i]);
    }

    return 0;
}
```

### Barr_10 сумма элементов массива
В коробке 5 ячеек. В каждую ячейку можно положить несколько шариков. Нужно вычислить сколько всего шариков во всех ячейках.

Пример программы, которая
+ читает 5 чисел и кладет их в ячейки,
+ вычисляет количество шариков в первых 3 ячейках sum = a[0]+a[1]+a[2]

![08](/C_for_beginners_Stepik/Pictures/08_07.png)

Входные данные: 5 целых чисел через пробел.

Выходные данные: 1 число - сумма всех 5 чисел.

```c
#include <stdio.h>
#define N 5
int main(){
    int a[N];           // коробка с ячейками
    int i, sum = 0;
                        // читаем N чисел в массив a
    for(i=0; i < N; i++) {
        scanf("%d", &a[i]);
        sum += a[i];
    }
    printf("%d\n", sum);    // печатаем сумму

    return 0;
}
```

### Barr_12 сумма части массива
Написать программу c for, которая
+ получает 10 чисел, кладет их в ячейки,
+ вычисляет сумму всех чисел в ячейках с номерами: k≤i<n
+ печатает сумму чисел sum.

Входные данные:

10 целых чисел через пробел
k n через пробел на следующей строке
Выходные данные:

1 число (сумма части массива)
В примере 2+3+4 = 9

```c
#include <stdio.h>
#define N 10

int main() {
    int a[N];           // коробка с ячейками
    int i, sum = 0, k, n;
                        // читаем N чисел в массив a
    for(i = 0; i < N; i++) {
        scanf("%d", &a[i]);
    }
    
    scanf("%d %d", &k, &n);
    
    for(i = k; i < n; i++) {
        sum += a[i];
    }
    printf("%d\n", sum);    // печатаем сумму

    return 0;
}
```

## Массив
Массив (array) - это набор однотипных элементов фиксированной длины.
+ массив состоит из элементов.
+ однотипных: все элементы одного типа, тип задается при объявлении массива.
+ фиксированной длины: размер массива не изменяется после его создания.

![08](/C_for_beginners_Stepik/Pictures/08_08.png)

У элемента есть свой уникальный номер (индекс). В языке Си индексы начинаются с 0.

__Объявление массива__

![08](/C_for_beginners_Stepik/Pictures/08_09.png)

```c
int a[10];          // массив с именем a из 10 элементов, каждый элемент типа int
float b[5];         // массив b из 5 элементов типа float
struct Point tr[3]; // массив tr из 3 элементов типа struct Point
```

__Обращение к элементу массива__

```
a[8] - элемент массива a с номером 8.
```
```
a[0] = a[3] - 17;   // элемент массива можно прочитать, в него можно записать.
```

### Явная инициализация элементов массива
Без инициализации:

```c
int a[7];  // или "мусор" (локальный), или нули (глобальный, static)
```

Можно инициализировать все элементы или часть их (остальные будут равны 0).

```c
int a1[3] = {12, -6, 44};   // a1[0] = 12, a1[1] = -6, a1[2] = 44;
int a2[3] = {12, -6};       // a2[0] = 12, a2[1] = -6, a2[2] = 0; оставшиеся нули
int a3[3] = {12, -6, 44, 8};       // Ошибка, чисел больше, чем размер массива
```

"Оставшиеся - нули":

```c
int a4[8] = {0};    // все элементы нули
int a5[8] = {};     // все элементы нули
```

Размер массива можно не указывать при явной инициализации. Он равен количеству заданных элементов.

```c
int a6[] = {12, -6, 44};    // int a6[3] = {12, -6, 44};
```

Начиная с С99 можно указывать какие именно индексы инициализировать:

```c
int a7[100] = {[77]=6, [8]=11};          // a7[77]=6, a7[8]=11, остальные нули
```

В GNU extension (компилятор gcc) можно инициализировать диапазоны индексов, от и до включительно. Три точки, вокруг них пробелы (чтобы синтаксически не было началом числа с десятичной точкой):

```c
int a8[100] = {[16 ... 18]=6, [33]=11};  // a8[16]=6, a8[17]=6, a8[18]=6, a8[33]=11, остальные нули
```

При инициализации [33]=11 означает, что только одному элементу a8[33] присвоить 11, формат [16 ... 18]=6 означает, что все элементы с индексами от 16 до 18 включительно будут равны 6.

### Пример: читаем, сохраняем и печатаем
Дано натуральное число n < 100, далее n целых чисел.
+ прочитать числа и сохранить в массив,
+ распечатать числа из массива

```c
#include <stdio.h>


int main()
{
    int n;      // сколько чисел
    int a[100]; // числа
    int i;


    scanf("%d", &n);
    // читаем числа и сохраняем в массив
    for(i = 0; i < n; i++)
        scanf("%d", &a[i]);


    // печатаем сохраненные числа через пробел
    for(i = 0; i < n; i++)
        printf("%d ", a[i]);
    printf("\n");


    return 0;
}
```

### Когда нужны массивы
Чтобы прочитать и напечатать числа массив не нужен.

Массив нужен, когда информацию нужно хранить.
+ прочитать числа и напечатать их два раза,
+ прочитать числа и напечатать их в обратном порядке.

Дано:

```c
5
7 -3 19 42 -6
```

напечатать:

```c
7 -3 19 42 -6
7 -3 19 42 -6
```

Тут нужно сохранить числа и два раза напечатать их.

```c
#include <stdio.h>


int main()
{
    int n;      // сколько чисел
    int a[100]; // числа
    int i;


    scanf("%d", &n);
    // читаем числа и сохраняем в массив
    for(i = 0; i < n; i++)
        scanf("%d", &a[i]);


    // печатаем сохраненные числа через пробел
    for(i = 0; i < n; i++)
        printf("%d ", a[i]);
    printf("\n");


    // печатаем сохраненные числа через пробел
    for(i = 0; i < n; i++)
        printf("%d ", a[i]);
    printf("\n");


    return 0;
}
```

### Размер массива
До стандарта С99 размер массива всегда определялся на этапе компиляции.

```c
#define N 100   // препроцессор выполняет команды до компилятора
int a[N];       // компилятор знает размер массива и может выделить память под него
```

В задачах обычно указывается, например, "дано не более 100 чисел". Из условия задачи можно определить наибольший размер массива, который понадобится.

Если дано n сколько чисел, далее числа, то начиная с С99 можно написать:

```c
int n;
scanf("%d", &n);    // узнали размер на этапе выполнения программы
float a[n];         // массив из n элементов типа float
```

В проверяющей системе ejudge, где будут проходить контрольные, этот способ объявить массив запрещен и приводит к ошибке.

Если вы из условия задачи не поняли ограничение на размер массива, то можно создать массив с использованием динамической памяти. Подробно о динамической памяти и работы с ней расскажем позже. А сейчас шпаргалка.

Тот же самый код с использованием динамической памяти можно написать так:

```c
#include <stdlib.h>     // нужно для malloc и free


int main()
{
    int n;
    scanf("%d", &n);
    float * a = malloc(n * sizeof(float));  // выделяем динамическую память для размещения массива
    // обращаемся как с обычным массивом, доступ к элементу a[i]
    // ...
    free(a);                                // когда массив не нужен, освобождаем выделенную память
    return 0;
}
```

Как видите, ничего сложного.

## Задачи легкие

### L_arr_01 Четные и нечетные
Дано натуральное число $n<1000$, далее n целых чисел.

Напечатать сначала четные числа. На следующей строке напечатать нечетные числа.

```c
#include <stdio.h>
#define N 1000
int main(){
    int a[N];           // массив для N чисел
    int i;              // номер текущей ячейки
    int n;              // сколько чисел дано

    scanf("%d", &n);
    // читаем n чисел в массив a
    for(i=0; i<n; i++)
        scanf("%d", &a[i]);

    // печатаем числа
    for(i=0; i<n; i++) {
        if (a[i] % 2 == 0) {
            printf("%d ", a[i]);
        }
    }
    printf("\n");
    // печатаем числа еще раз
    for(i=0; i<n; i++) {
        if (a[i] % 2) {
            printf("%d ", a[i]);
        }
    }
    printf("\n");
    return 0;
}
```

### L_arr_1 revers
Дано натуральное число $n<1000$, далее n целых чисел.

Напечатать числа в обратном порядке.

```c
#include <stdio.h>
#define N 1000
int main(){
    int a[N];           // массив для N чисел
    int i;              // номер текущей ячейки
    int n;              // сколько чисел дано

    scanf("%d", &n);
    // читаем n чисел в массив a
    for(i=0; i<n; i++)
        scanf("%d", &a[i]);

    // печатаем числа
    for(i = 1; i <= n; i++) {
        printf("%d ", a[n - i]);
    }
    printf("\n");
    return 0;
}
```

### L_arr_02 первый индекс
Написать программу, которая в заданной последовательности чисел ищет встречается ли заданное число k.

Входные данные:

натуральное число $n<1000$ - количество чисел, n чисел на одной строке через пробел,k - заданное число (гарантируется, что оно встречается в предыдущей последовательности 1 или более раз).

Выходные данные:

первый индекс числа k в последовательности чисел.

```c
#include <stdio.h>
#define N 1000
int main(){
    int a[N];           // массив для N чисел
    int i;              // номер текущей ячейки
    int n;              // сколько чисел дано
    int k;
    scanf("%d", &n);
    // читаем n чисел в массив a
    for(i=0; i<n; i++)
        scanf("%d", &a[i]);
    scanf("%d", &k);
    
    for(i = 0; i < n; i++) {
        if (a[i] == k) {
            printf("%d", i);
            break;
        }
    }
    return 0;
}
```

### L_arr_02 первый индекс или -1
Написать программу, которая в заданной последовательности чисел ищет встречается ли заданное число k.

Входные данные:
+ натуральное число $n<1000$ - количество чисел,
+ n чисел на одной строке через пробел,
+ k - заданное число.

Выходные данные:

+ первый индекс числа k в последовательности чисел. Если такого числа нет, то напечатайте -1.

```c
#include <stdio.h>
#define N 1000
int main(){
    int a[N];           // массив для N чисел
    int i;              // номер текущей ячейки
    int n;              // сколько чисел дано
    int k, result = -1;
    scanf("%d", &n);
    // читаем n чисел в массив a
    for(i=0; i<n; i++)
        scanf("%d", &a[i]);
    scanf("%d", &k);
    
    for(i = 0; i < n; i++) {
        if (a[i] == k) {
            result = i;
            break;
        }
    }
    printf("%d", result);
    return 0;
}
```

### L_arr_10 сложение векторов
Найдите сумму двух векторов.

Для векторов $(a_1, a_2,..,a_n)$ и $(b_1, b_2, ..,b_n)$  суммой будет вектор $(a_1 + b_1, a_2 + b_2, ..,a_n + b_n)$

Входные данные:
+ Натуральное число n<1000 - размерность векторов.
+ n целых чисел через пробел на одной строке (первый вектор)
+ n целых чисел через пробел на следующей строке (второй вектор)

Выходные данные:
+ n целых чисел через пробел на одной строке (сумма векторов)

```c
#include <stdio.h>
#define N 1000
int main(){
    int a[N], b[N];
    int n;
    scanf("%d", &n);
    for(int i = 0; i < n; i++) {
        scanf("%d", &a[i]);
    }
    for(int i = 0; i < n; i++) {
        scanf("%d", &b[i]);
    }
    for(int i = 0; i < n; i++) {
        printf("%d ", a[i] + b[i]);
    }
    return 0;
}
```

### L_arr_11 Скалярное произведение векторов
Найдите скалярное произведение двух векторов.

Для векторов 
Для векторов $(a_1, a_2,..,a_n)$ и $(b_1, b_2, ..,b_n)$ скалярным произведением является число $(a_1 \cdot b_1 + a_2 \cdot b_2 + .. + a_n \cdot b_n)$
​
Входные данные:
+ Натуральное число n<1000 - размерность векторов.
+ n целых чисел через пробел на одной строке (первый вектор)
+ n целых чисел через пробел на следующей строке (второй вектор)

Выходные данные:
+ Скалярное произведение этих векторов.

```c
#include <stdio.h>
#define N 1000
int main(){
    int a[N], b[N];
    int n, result = 0;
    scanf("%d", &n);
    for(int i = 0; i < n; i++) {
        scanf("%d", &a[i]);
    }
    for(int i = 0; i < n; i++) {
        scanf("%d", &b[i]);
        result += (a[i] * b[i]);
    }
    printf("%d", result);
    return 0;
}
```

### L_arr_counter Массив как набор счетчиков
Для украшения делают гирлянду из шаров. Каждый цвет имеет свой номер от 0 до 9. Есть схема гирлянды, где указан цвет каждого шара. Сколько нужно шаров каждого цвета для гирлянды?

Входные данные:
+ Натуральное число n
+ Цвета шаров в гирлянде через пробел на следующей строке.

Выходные данные:
+ Номер цвета и количество шаров этого цвета через пробел. По одному цвету на строку, цвета от 0 до 9.

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
  int b[10] = {0}, *a = NULL;
  int n;
  scanf("%d", &n);
  a = malloc(n * sizeof(int));
  for (int i = 0; i < n; i++) {
    scanf("%d", &a[i]);
    b[a[i]]++;
  }
  for (int i = 0; i < 10; i++) {
    printf("%d %d\n", i, b[i]);
  }
  free(a);
  return 0;
}
```

## `sizeof`
+ Оператор `sizeof` дает размер переменной или типа в байтах.
+ Результат имеет тип `size_t`.
+ Напечатать результат можно по формату `%zd`
+ `sizeof(char)` всегда 1.
    + В современных архитектурах `char` обычно размером 1 байт. Поэтому мы будем говорить, что "sizeof вычисляет размер в байтах".

Чему равен sizeof(int)? В стандарте языка об этом не говорится. Размер зависит от архитектуры компьютера, от операционный системы и компилятора.

Как правило в gcc int занимает 32 бита, long long int 64 бита. В других комиляторах int и/или long может быть 64 бита в зависимости от платформы, но gcc на linux использует x86-64 abi, в котором int и long имеет размер 4 байта.

```c
int x;
printf("%zd\n", sizeof x);      // 4 в моей системе и на repl.it
printf("%zd\n", sizeof(1 + 2)); // 4 в моей системе и на repl.it
printf("%zd\n", sizeof 3.5);    // 8 в моей системе и на repl.it
printf("%zd\n", sizeof(char));  // 1 всегда
```

Можно писать операнд в скобках sizeof(x) или без них sizeof x. Тип можно указать только в скобках. Поэтому не думайте, пишите все в скобках.

Результат вычисляется во время компиляции, а не выполнения программы. Выражения не вычисляются, а подставляется их тип. То есть вместо sizeof(2+3) вычисляется sizeof(int).

### sizeof и массивы
```c
int     a[5];
size_t  n = sizeof(a);  // 20 = 4*5, если sizeof(int) равен 4
```

Перебрать все элементы массива можно так:

```c
int a = {7, -12, 34, 2};
for (int i = 0; i < sizeof(a)/sizeof(a[0]); i++)
    что-то делаем с a[i]
```

+ sizeof(a) - размер всего массива в байтах.
+ sizeof(a[0]) - размер нулевого элемента в байтах.
+ sizeof(a)/sizeof(a[0]) - сколько элементов в массиве.

### sizeof и структуры

```c
struct A {
    int x;
    char c;
    double d;
} z;
```

+ Тип struct A, значит размер sizeof(struct A)
+ Не занимайтесь арифметикой. sizeof(int)+sizeof(char)+sizeof(double) ≤ sizeof(struct A) из-за выравнивания данных

Подробнее об этом вы узнаете в курсе про архитектуру компьютера. Числа при хранении выравниваются по машинным словам. При этом образуются "дырки", которые не заняты данными.

## Адресная арифметика

### Чем массив отличается от указателя
Пусть у нас int 4 байта, а любой адрес 8 байт.

![08](/C_for_beginners_Stepik/Pictures/08_10.png)

```c
int a[5];  // массив из 5 int
int * pa;   // указатель на int (пока никуда не указывает)


pa = &a[0]; // pa указывает на начало массива
pa = a;     // pa указывает на начало массива
```

Когда говорят об указателе на массив, говорят об указателе на первый элемент массива &a[0].

Имя массива содержит адрес его начала. Поэтому можно писать pa = a.

Чем отличается pa (указатель на начало массива) от a (массива)?

+ pa (указатель) это:
    + адрес, на который указывает переменная,
    + определенный тип данных, который находится по этому адресу, int
    + sizeof(pa) равен 8 (размер адреса).
+ a (массив) это:
    + адрес его начала,
    + тип каждого элемента массива int,
    + размер массива sizeof(a) равно 5*4=20.

Массив это не только адрес и тип элемента, но и их количество.

```
pa может указывать не только на начало массива, но и на любой его элемент.
```

### Адреса элементов массива

![08](/C_for_beginners_Stepik/Pictures/08_11.png)

Пусть массив начинается с адреса 100, тогда адреса его элементов 100, 104, 108, 112 и 116.

```c
int a[5];   // массив из 5 int
int * p0;   // еще один указатель (никуда не указывает)
int * p3;   // еще один указатель (никуда не указывает)


p0 = &a[0]; // p0 указывает на a[0]
p3 = &a[3]; // p3 указывает на a[3]


printf("p0=%p p3=%p \n", p0, p3);   // проверим адреса
```

Адрес печатаем по формату %p.

Как из p0 получить p3? Нужно из адреса 100 получить адрес 112, это 100+3*4, то есть p0 + 3*sizeof(int). Выглядит ужасно. Плохо читается. Для многомерных массивов будет ещё хуже.

При разработке стандарта языка Си придумали адресную арифметику. Решили не писать везде sizeof(int), прибавлять не 3 байта, а 3 элемента массива.

Если одно слагаемое указатель, а другое целого типа, то результат указатель.

Можно писать:

```c
p0 = a;         // имя массива указывает на его начало, a[0]
p3 = p0 + 3;    // p3 указывает на 3 элемент массива, a[3]


printf("p0=%p p3=%p \n", p0, p3);   // проверим адреса, должны остаться прежними
```

Так как p0 типа указатель на int, то сдвигаемся на 3 int.

```c
double z[10];
double * pz = z;    // pz указывает на начало массива z
```

pz+2 - сдвинуться на 2 double.

### [] и операции с указателями

```c
int a[5] = {2, -4, -5, 11, 27};
int * p = a;
```

Как записать число 7 в первый элемент массива?

```c
a[0] = 7;       // через массив
*p = 7;         // через указатель на первый элемент
```

Заменить число 11 на 88 в массив можно так:

```c
a[3] = 88;      // через массив
*(p + 3) = 88;  // указатель на начало сдвинули на 3 элемента и разыменовали
```

На самом деле компилятор преобразовывает оператор [] в * и + и потом разбирает полученное выражение.

Эти выражения делают одно и то же:

```c
a[0] = 7;
*(a+0) = 7;
*a = 7;
*p = 7;
*(p+0) = 7;
p[0] = 7;
```

Эти выражения делают одно и то же:

```c
a[3] = 88;
*(a+3) = 88;
*(p+3) = 88;
p[3] = 88;
```

__Оператор [] придуман для удобства записи. a[b] идентично *(a+b)__

`scanf` тоже можно записать с помощью адресной арифметики

```c
scanf("%d", &a[3]);     // через []
scanf("%d", a+3);       // &*(a+3) можно сократить до a+3
```

__Курьёзы адресной арифметики__

Все выражения синтаксически корректны:

```c
*(3+a) = 88;
3[a] = 88;
char c = "abcdefgh"[2];     // строка - это массив символов с символом '\0' в конце
```

Что будет напечатано? В случае ошибки напишите Error.

```c
int b[] = {10, 11, 12, 13, 14, 15, 16, 17, 18, 19};
int * p = b+4;
printf("%d", p[2]);
```

__16__

Что будет напечатано? В случае ошибки напишите Error.

```c
int b[] = {10, 11, 12, 13, 14, 15, 16, 17, 18, 19};
int * p = b+4;
printf("%d", *(p-3));
```

__11__

Что будет напечатано? В случае ошибки напишите Error.

```c
int b[] = {10, 11, 12, 13, 14, 15, 16, 17, 18, 19};
int * p = b+4;
printf("%d", p[-1]);
```

__13__

### Когда работают правила адресной арифметики
+ указатель + целое = указатель
+ указатель - указатель = целое
    + указатели должны быть одинакового типа,
    + целое - сколько элементов укладывается между этими адресами
+ Указатель + указатель = ошибка (бессмысленно складывать указатели)

__Сравниваем указатели__
+ указатель1 == указатель2
+ указатель1 != указатель2
+ Эти сравнения машинно-зависимы (лучше так не писать):
    + указатель1 < указатель2
    + указатель1 > указатель2
+ Надо сравнивать так (машинно-независимый код):
    + указатель1 - указатель2 < 0
    + указатель1 - указатель2 > 0

### `void *` - просто адрес
Иногда нужен "просто адрес" без уточнения, данные какого типа расположены по этому адресу.

Например, в стандартные функции копирования участков памяти или сортировки передается адрес начала данных в памяти. Нам нужно уметь сортировать и копировать массивы разных типов, поэтому в этих функциях не привязывались к типу элементов массива, в функциях нужен только адрес.

Если функция `foo` ничего не возвращает, то тип возвращаемого значения `void`.

Аналогично "просто адрес" имеет тип `void *` указатель на `void`.

```c
void * pv;
```

+ C `void*` не работает адресная арифметика. `pv+3`, "сдвинуть на 3 элемента типа `void`", но в Си нельзя объявить переменную типа `void`, неизвестно какого она размера.
+ Нельзя разыменовать
    + *pv не работает, нет данных типа void
    + pv-> не работает, потому что это (*pv).
    + pv[i] не работает, потому что это *(pv+i)

Неявные преобразования указателей к/из void *

```c
int x;
char c;
double z;


int * px = &x;
char * pc = &c;
double * pz = &z;


void * pv;  // указатель типа void*


pv = px;    // неявное преобразование int* в void*
px = pv;    // неявное преобразование из void* в int *


pv = pc;    // из char* в void*
pc = pv;    // из void* в char*


pv = pz;    // из double* в void*
pz = pv;    // из void* в double*
```

В языке Си разрешено неявное преобразование любого указательного типа в тип `void*`, и наоборот, `void*` можно неявно преобразовать к любому другому указательному типу.

В языке С++ преобразование из `void*` к другому типу нужно записывать явно. Если вы используете компилятор С++ для компиляции программы на Си (не надо так делать!), то нужно явно преобразовывать тип. Функция `malloc` возвращает `void*`:

```c
int * p1 = malloc(3*sizeof(int));       // язык Си - работает, язык С++ - ошибка
int * p1 = (int*)malloc(3*sizeof(int)); // язык Си и С++ - работает
int * p1 = new int[3];                  // язык Си - ошибка, язык С++ - работает (именно так создают в C++ массивы)
```

### NULL - адрес, которого не существует
По определению, стандартная константа NULL - это адрес, которого не существует.

Обычно NULL это (void*)0.

Нельзя писать по этому адресу. Нельзя читать по этому адресу.

Это работает:

```c
int y, x = 7;
int * p = &x;   // p указывает на x
y = *p;         // y = 7;
*p = 22;        // x = 22;
```

Это не работает:

```c
p = NULL;       // p указывает на несуществующий адрес
y = *p;         // Ошибка, нельзя читать по адресу NULL
*p = 22;        // Ошибка, нельзя писать по адресу NULL
```

### Функция печати массива
Напишем функцию печати элементов массива. Будем передавать в функцию адрес a и количество элементов n. Надо печатать массив int.

```c
// от адреса a печатаем n чисел
int print_arr(int * a, int n)
{
    for(int i = 0; i < n; i++)
        printf("%d ", a[i]);
    printf("\n");
}
int main()
{
    int b[10] = {1, -2, 3, -4, 5, -6, 7, -8, 9, 10};
    print_arr(b, 10);       // печатаем весь массив
    print_arr(b, 7);        // печатаем первые 7 чисел
    print_arr(b+3, 7);      // печатаем последние 7 чисел
    print_arr(b+3, 4);      // печатаем от -4 до 7


    return 0;
}
```

Не важно какие фактические границы массива b. С помощью указателя и адресной арифметики можно работать с любой частью этого массива.

## Копирование массивов

### a = b
Представим, что мы придумываем язык программирования и описываем как в нем надо будет работать с массивами.

```c
int a[10];
a[3] = 7;   // присвоили значение одному ЭЛЕМЕНТУ массива
```

Давайте придумаем, что для двух массивов = будет копировать массив. Удобно же!

```c
int b[10];
b = a;      // пусть это копирует массив a в массив b
```

Хорошо, если размеры массивов совпадают, а если массив a меньше? Что делать?

```c
int big[100];
big = a;    // что делать?
```

Можно придумать, что "оставшиеся" элементы не изменяются или туда записываются нули.

Что делать, если данных больше, чем места в новом массиве? Будем копировать только те данные, для которых есть места?

Получилась очень сложная система правил копирования массивов.

Я пишу компилятор и мне трудно реализовать эти правила. Код компилятора увеличивается и становится сложнее.

Я учу язык Си и путаюсь когда какие данные будут записаны в массив.

Я программист и ищу ошибку, которая возникла из-за такого сложного алгоритма копирования массивов.

В Си решили сделать простые правила: массиву присвоить нельзя. Просто и понятно.

```c
int a[10];
int b[10];
int * p;


p = a;      // p указывает на начало массива a
a = p;      // Ошибка, нельзя массиву что-то присвоить
b = a;      // Ошибка, нельзя массиву что-то присвоить
```

### Копирование массива
Как все же копировать массив? Хочу написать dest (destination, куда), src (source, откуда) и n (сколько элементов копировать). Использовать так:

```c
int main()
{
    int a[10] = {1, -2, 3, -4, 5, -6, 7, -8, 9, 10};
    int b[10];
    arr_copy(b, a, 10);


    return 0;
}
```
Можно написать такую функцю:

```c
void arr_copy1(int * dst, int * src, int n)
{
    for(int i = 0; i < n; i++)
        dst[i] = src[i];
}
```

или такую:

```c
void arr_copy2(int * dst, int * src, int n)
{
    for(int i = n-1; i >= 0; i--)
        dst[i] = src[i];
}
```

Если функция очень нужна, значит есть такая стандартная функция.

#### `memcpy`

```c
#include <string.h>
void *memcpy(void *dest, const void *src, size_t n);
```

+ dest (destination) - куда копировать
+ src (source) - откуда копировать
+ n - сколько байт копировать

Использование:

```c
int a[10] = {1, -2, 3, -4, 5, -6, 7, -8, 9, 10};
int b[10];
memcpy(b, a, sizeof(a));
```

### Копирование перекрывающихся участков памяти

```c
int a[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
```

Откопируем первые 5 элементов с a на a+2 место. Исходный и результирующий участки памяти пересекаются.

Копируем от начала к концу участка, значения элементов изменяются так:

```c
a[2] = a[0];    // 1, 2, 1, 4, 5, 6, 7, 8, 9, 10
a[3] = a[1];    // 1, 2, 1, 2, 5, 6, 7, 8, 9, 10
a[4] = a[2];    // 1, 2, 1, 2, 1, 6, 7, 8, 9, 10
a[5] = a[3];    // 1, 2, 1, 2, 1, 2, 7, 8, 9, 10
a[6] = a[4];    // 1, 2, 1, 2, 1, 2, 1, 8, 9, 10
```

Копируем от конца к началу участка, значения элементов изменяются так:

```c
a[6] = a[4];    // 1, 2, 3, 4, 5, 6, 5, 8, 9, 10
a[5] = a[3];    // 1, 2, 3, 4, 5, 4, 5, 8, 9, 10
a[4] = a[2];    // 1, 2, 3, 4, 3, 4, 5, 8, 9, 10
a[3] = a[1];    // 1, 2, 3, 2, 3, 4, 5, 8, 9, 10
a[2] = a[0];    // 1, 2, 1, 2, 3, 4, 5, 8, 9, 10
```

Получаем разный результат копирования в зависимости от того, какой алгоритм применяли.

В стандарте не сказано, как именно нужно реализовать функцию memcpy. Поэтому ее результат для работы на пересекающихся участках памяти может отличаться от компилятора к компилятору.

__memcpy нельзя использовать на перекрывающихся участках памяти.__

У меня на компьютере работает, посылаю задачу на проверку - не работает. Чтобы не было такой ситуации используйте функцию

```c
void *memmove(void *dest, const void *src, size_t n);
```

Делает то же самое, что memcpy, но работает для перекрывающихся участков памяти. Она копирует из src нужную часть в свой массив (его называют "буфер"), а потом из буфера копируется в dst. Не имеет значения, откуда начинать копировать, с начала или с конца.

### `memset`
Иногда нужно заполнить часть памяти одним и тем же значением, например, проиницилизировать массив нулями.

Размер массива известен на этапе компиляции:

```c
int a[] = {3, 7, -12, 4};   // явная инициализация работает
int b[10] = {1};            // и тут работает
```

Если размер массива заранее не известен, то компилятор не знает - вышли вы при инициализации за границы или нет, поэтому предполагает худшее. В С99 можно определить размер массива на этапе выполнения, но нельзя при этом его явно инициализировать.

```c
size_t n;
scanf("%zu", &n);
int a[n];           // ok
int b[n] = {};      // error: variable-sized object may not be initialized
```

Что делать? Или определяйте размер массива на этапе компиляции, или используйте функцию `memset` из

```c
#include <string.h>


void *memset(void *s, int c, size_t n);
```

Записывает младший байт числа `с` в каждый байт на участке памяти размером `n`байт, начиная с адреса `s`.

Заполнение массива b нулями:

```c
memset(b, 0, sizeof(b));    // это работает
bzero(b, sizeof(b));        // это тоже работает
```

Посмотрим, что будет, если заполнить массив int единицами:

```c
int a[5] = {1, 1, 1, 1, 1};
int b[5];
memset(b, 1, sizeof(b));
```

Распечатаем содержимое массивов а и b:

```c
a: 1 1 1 1 1
b: 16843009 16843009 16843009 16843009 16843009
```

Что произошло? Каждый элемент типа int состоит из нескольких байт. В каждый из них записали 1. Если sizeof(int) равен 4, то в каждом элементе массива хранится число $1⋅256^3 + 1⋅256^2 + 1⋅256^1 + 1⋅256^0 = 16843009$

## Передаем массив в функцию

