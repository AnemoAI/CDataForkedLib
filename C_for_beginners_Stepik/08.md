# Массивы и адресная арифметика

[Видео](https://youtu.be/6E0ZONXbncU)

[Презентация](/C_for_beginners_Stepik/Files/c2019_6.pdf)

## Понятие массива

### Пример: Сколько шаров каждого цвета
Есть воздушные шары. Цвет будем обозначать числом. 0 - красный, 1 - желтый, 2 - зеленый, 3 - синий.

Даны цвета шаров через пробел. Найти сколько шаров каждого цвета. Напечатаем цвет от 0 до 3 и сколько шаров этого цвета.

Input:
```
2 2 1 0 2 1 3 1 0 1 2 1
```

Output:

```
3 1
2 4
1 5
0 2
```

Программа:

```c
#include <stdio.h>


int main()
{
    int c,      // цвет текущего шара
        c0 = 0, // счетчик для цвета 0 (красный)
        c1 = 0, // счетчик для цвета 1 (желтый)
        c2 = 0, // счетчик для цвета 2 (зеленый)
        c3 = 0; // счетчик для цвета 3 (синий)


    // читаем и считаем шары
    while(1 == scanf("%d", &c)) {
        switch(c) {                 // какой цвет текущего шара?
            case 0: c0++; break;
            case 1: c1++; break;
            case 2: c2++; break;
            case 3: c3++; break;
            default: printf("Error: unknown color %d\n", c);
        }
    }
    // печатаем результат
    printf("0 %d\n", c0);
    printf("1 %d\n", c1);
    printf("2 %d\n", c2);
    printf("3 %d\n", c3);


    return 0;
}
```

Счетчики c0, c1, c2, c3 одинакового типа int.

Расширим задачу. Пусть шары будут 10 разных цветов. Очень неудобно изменять такой код. Что делать?

### Массив
Мы считали каждый цвет в свою переменную.

![08](/C_for_beginners_Stepik/Pictures/08_01.jpg)

Можно объединить отдельные переменные в общий набор (массив)

![08](/C_for_beginners_Stepik/Pictures/08_02.jpg)

Теперь назовем с весь ящик с ячейками (как таблетница). В каждую ячейку (__элемент массива__) можно положить таблетки (__значение__ элемента массива).

![08](/C_for_beginners_Stepik/Pictures/08_03.png)

У ячейки есть номер или индекс. У первой ячейки номер ноль.

![08](/C_for_beginners_Stepik/Pictures/08_04.png)

#### Создание массива
int c[4]; // объявили переменную c типа "массив из 4 int"
Массив можно объявить любого другого типа и другого размера.

#### Обращение к элементу массива
У массива с элементы c[0], c[1], c[2] и c[3]. С ними в программе можно обращаться, как с отдельными переменными.

Как запомнить: квадратные скобки [ ] напоминают коробку.

### Работа с массивами
Большая коробка поделена на 5 одинаковых ячеек. Коробка называется a.

Ячейки имеют номер от 0 до 4. В ячейках лежат шарики.

![08](/C_for_beginners_Stepik/Pictures/08_05.png)

```c
int a[5];   // коробка с ячейками
```

+ В ячейке с номером 0 лежит a[0], то есть 3 шарика.
+ В ячейке с номером 1 лежит a[1], то есть 4 шарика.
+ В ячейке с номером 2 лежит a[2], то есть 2 шарика.
+ В ячейке с номером 3 лежит a[3], то есть 0 шариков.
+ В ячейке с номером 4 лежит a[4], то есть 1 шарик.

Всего 5 ячеек. В них лежит a[0]+a[1]+a[2]+a[3]+a[4] то есть 3+4+2+0+1=10 шариков.

В ячейки можно положить другое количество шариков:

![08](/C_for_beginners_Stepik/Pictures/08_06.png)

+ a[0] = 7; - в ячейку с номером 0 положили 7 шариков.
+ a[2] = 0; - в ячейку с номером 2 положили 0 шариков (в ячейке шариков нет).
+ a[3] = 2; - в ячейку с номером 3 положили 2 шарика.

Элемент массива можно прочитать. В элемент массива можно записать (присвоить).

+ a[4] = a[0]; - присвоить число шариков из ячейки с номером 0 в ячейку с номером 4.
+ a[1] = a[0] - 2; - в ячейку с номером 1 положить на 2 шарика меньше, чем число шариков в ячейке с номером 0.

a[0] произносят как "а нулевое". Это элемент массива a с номером (индексом) 0.

#### Печать и чтение

Используем __элемент массива__ как обычную переменную такого же типа. Одна отдельная коробочка, а не ячейка в большой коробке.

```c
int x;
int a[5];


scanf("%d", &x);        // прочитали число в переменную x
scanf("%d", &a[2]);     // прочитали число в элемент массива a с индексом 2


printf("%d\n", x);       // печать значения переменной х
printf("%d\n", a[2]);    // печать значения элемента массива a с индексом 2
```

### Barr_1 Напечатать элементы

![08](/C_for_beginners_Stepik/Pictures/08_05.png)

Измените программу, чтобы напечатать в конце числа из ячеек (значения элементов) с номерами 0, 3, 4.

```c
#include <stdio.h>

int main()
{
    int a[5];           // коробка с ячейками

    scanf("%d", &a[0]); // получить число шариков в ячейке с номером 0
    scanf("%d", &a[1]); // получить число шариков в ячейке с номером 1
    scanf("%d", &a[2]); // получить число шариков в ячейке с номером 2

    a[3] = 7;           // присвоить 7 ячейке с номером 3

                        // присвоить число шариков из ячейки с номером 0 в
                        // ячейку с номером 4
    a[4] = a[0];

    // печатаем элементы с номерами 0, 3 и 4
    printf("%d ", a[0]); // печать количества шариков в 0 ячейке
    printf("%d ", a[3]); // печать количества шариков в 3 ячейке
    printf("%d", a[4]); // печать количества шариков в 4 ячейке

    return 0;
}
```

### Barr_2 Все элементы

![08](/C_for_beginners_Stepik/Pictures/08_05.png)

В коробке 5 ячеек (cells). В каждую ячейку можно положить шарики.

Дана программа, которая получает 2 числа (сколько шариков) и кладет их в первые ячейки, а затем печатает их.

Надо изменить программу, чтобы она получала, сохраняла в ячейках и затем печатала 5 чисел.

```c
#include <stdio.h>
#define COUNT 5

int main(){
    int a[COUNT];            // коробка с ячейками
    for (int i = 0; i < COUNT; i++) {
        scanf("%d", &a[i]);
    }
    for (int i = 0; i < COUNT; i++) {
        printf("%d%s", a[i], i == COUNT - 1 ? "" : " ");
    }
    return 0;
}
```

```c
#include <stdio.h>

int main(){
    int a[5];            // коробка с ячейками
    int i;               // номер текущей ячейки

    for(i = 0; 1 == scanf("%d", &a[i]); i++)
        printf("%d ", a[i]);
    return 0;
}
```

## Задачи для начинающих

### Barr_3 В 2 раза
Программа делает:
+ объявляет массив для хранения чисел;
+ читает 5 чисел и кладет их в массив;
+ печатает все элементы массива.

Нужно изменить программу. Программа должна:
+ объявить массив для хранения чисел;
+ прочитать 10 чисел и положить их в массив;
+ увеличить значение каждого элемента массива в 2 раза;
+ напечатать все элементы массива.

```c
#include <stdio.h>
#define COUNT 10

int main(){
    int a[COUNT];            // коробка с ячейками
    for(int i = 0; 1 == scanf("%d ", &a[i]); i++) {
        a[i] *= 2;
        printf("%d ", a[i]);
    }
    return 0;
}
```

### Barr_4 Номера от 2 до 8
Программа делает:
+ объявляет массив для хранения чисел;
+ читает 10 чисел и кладет их в массив;
+ печатает все элементы массива.

Измените программу. Она должна печатать только элементы массива с номерами от 2 до 8 включительно.

```c
#include <stdio.h>

int main(){
    int a[10];                  // коробка с ячейками
    int i;                      // номер текущей ячейки

    for(i = 0; i < 10; i++){    // номера ячеек меняются
        scanf("%d", &a[i]);     // получить число шариков в ячейке с номером i
    }

    for(i = 2; i <= 8; i++){    // номера ячеек меняются
        printf("%d ", a[i]);    // печатаем число из ячейки с номером i через пробел
    }
    printf("\n");               // печать новой строки

    return 0;
}
```

### Номера от k до n
Программа читает, записывает в массив и печатает 10 чисел.

Измените ее так, чтобы при заданных k и n печатались значения элементов массива с с номерами от k до n включительно.

Входные данные:
+ 10 целых чисел через пробел в первой строке.
+ Целые числа k и n на следующей строке. Гарантируется, что k и n корректные (не выходят за пределы массива).

Выходные данные:

Требуемые числа через пробел.

```c
#include <stdio.h>

int main(){
    int a[10];                  // коробка с ячейками
    int i, k, n;

    for(i = 0; i < 10; i++){    // номера ячеек меняются
        scanf("%d", &a[i]);     // получить число шариков в ячейке с номером i
    }
    
    scanf("%d %d", &k, &n);
    
    for(i = k; i <= n; i++){    // номера ячеек меняются
        printf("%d ", a[i]);    // печатаем число из ячейки с номером i через пробел
    }
    printf("\n");               // печать новой строки

    return 0;
}
```

### Barr_7 Где число ≥ 0
Есть программа. Она
+ читает 5 чисел, сохраняет в массив.
+ ищет ячейки, у которых значение < 0
+ и печатает их номера и значения.

Измените программу.

Дано 10 чисел.
Ищите ячейки, у которых значение ≥ 0
и печатайте эти значения (числа).

```c
#include <stdio.h>

#define N 10

int main(){
    int a[N];                  // коробка с ячейками
    int i;                      // номер текущей ячейки

    for(i = 0; i < N; i++){    // номера ячеек меняются
        scanf("%d", &a[i]);     // получить число шариков в ячейке с номером i
    }

    // Ищем все ячейки, в которых числа < 0
    for(i = 0; i < N; i++){    // перебираем все ячейки
        if (a[i] >= 0)           // если число в ячейке a[i] подходит
            printf("%d ", a[i]);    // номер i и число из ячейки a[i]
    }

    return 0;
}
```

### Barr_6 Где число ≥ 0
Есть программа. Она
+ читает 5 чисел, сохраняет в массив.
+ ищет ячейки, у которых значение < 0
+ и печатает их номера и значения.

Измените программу.
+ Дано 10 чисел.
+ Ищите ячейки, у которых значение ≥ 0
+ и печатайте их номера.

```c
#include <stdio.h>

#define N 10

int main(){
    int a[N];                  // коробка с ячейками
    int i;                      // номер текущей ячейки

    for(i = 0; i < N; i++){    // номера ячеек меняются
        scanf("%d", &a[i]);     // получить число шариков в ячейке с номером i
    }

    // Ищем все ячейки, в которых числа < 0
    for(i = 0; i < N; i++){    // перебираем все ячейки
        if (a[i] >= 0)           // если число в ячейке a[i] подходит
            printf("%d ", i);    // номер i
    }

    return 0;
}
```

### Barr_9 числа до k или больше n
Написать программу, которая получает 10 чисел, ищет все ячейки с числами a[i] < k или a[i] > n и печатает эти числа.

Входные данные:
+ 10 чисел через пробел
+ k n через пробел

Выходные данные:

Нужные числа через пробел

```c
#include <stdio.h>

#define N 10

int main(){
    int a[N];                  // коробка с ячейками
    int i, n, k;

    for(i = 0; i < N; i++){    // номера ячеек меняются
        scanf("%d", &a[i]);    // получить число шариков в ячейке с номером i
    }
    
    scanf("%d %d", &k, &n); 
    
    // Ищем все ячейки, в которых числа < 0
    for(i = 0; i < N; i++){    // перебираем все ячейки
        if (a[i] < k || a[i] > n)          // если число в ячейке a[i] подходит
            printf("%d ", a[i]);
    }

    return 0;
}
```

### Barr_10 сумма элементов массива
В коробке 5 ячеек. В каждую ячейку можно положить несколько шариков. Нужно вычислить сколько всего шариков во всех ячейках.

Пример программы, которая
+ читает 5 чисел и кладет их в ячейки,
+ вычисляет количество шариков в первых 3 ячейках sum = a[0]+a[1]+a[2]

![08](/C_for_beginners_Stepik/Pictures/08_07.png)

Входные данные: 5 целых чисел через пробел.

Выходные данные: 1 число - сумма всех 5 чисел.

```c
#include <stdio.h>
#define N 5
int main(){
    int a[N];           // коробка с ячейками
    int i, sum = 0;
                        // читаем N чисел в массив a
    for(i=0; i < N; i++) {
        scanf("%d", &a[i]);
        sum += a[i];
    }
    printf("%d\n", sum);    // печатаем сумму

    return 0;
}
```

### Barr_12 сумма части массива
Написать программу c for, которая
+ получает 10 чисел, кладет их в ячейки,
+ вычисляет сумму всех чисел в ячейках с номерами: k≤i<n
+ печатает сумму чисел sum.

Входные данные:

10 целых чисел через пробел
k n через пробел на следующей строке
Выходные данные:

1 число (сумма части массива)
В примере 2+3+4 = 9

```c
#include <stdio.h>
#define N 10

int main() {
    int a[N];           // коробка с ячейками
    int i, sum = 0, k, n;
                        // читаем N чисел в массив a
    for(i = 0; i < N; i++) {
        scanf("%d", &a[i]);
    }
    
    scanf("%d %d", &k, &n);
    
    for(i = k; i < n; i++) {
        sum += a[i];
    }
    printf("%d\n", sum);    // печатаем сумму

    return 0;
}
```

## Массив
Массив (array) - это набор однотипных элементов фиксированной длины.
+ массив состоит из элементов.
+ однотипных: все элементы одного типа, тип задается при объявлении массива.
+ фиксированной длины: размер массива не изменяется после его создания.

![08](/C_for_beginners_Stepik/Pictures/08_08.png)

У элемента есть свой уникальный номер (индекс). В языке Си индексы начинаются с 0.

__Объявление массива__

![08](/C_for_beginners_Stepik/Pictures/08_09.png)

```c
int a[10];          // массив с именем a из 10 элементов, каждый элемент типа int
float b[5];         // массив b из 5 элементов типа float
struct Point tr[3]; // массив tr из 3 элементов типа struct Point
```

__Обращение к элементу массива__

```
a[8] - элемент массива a с номером 8.
```
```
a[0] = a[3] - 17;   // элемент массива можно прочитать, в него можно записать.
```

### Явная инициализация элементов массива
Без инициализации:

```c
int a[7];  // или "мусор" (локальный), или нули (глобальный, static)
```

Можно инициализировать все элементы или часть их (остальные будут равны 0).

```c
int a1[3] = {12, -6, 44};   // a1[0] = 12, a1[1] = -6, a1[2] = 44;
int a2[3] = {12, -6};       // a2[0] = 12, a2[1] = -6, a2[2] = 0; оставшиеся нули
int a3[3] = {12, -6, 44, 8};       // Ошибка, чисел больше, чем размер массива
```

"Оставшиеся - нули":

```c
int a4[8] = {0};    // все элементы нули
int a5[8] = {};     // все элементы нули
```

Размер массива можно не указывать при явной инициализации. Он равен количеству заданных элементов.

```c
int a6[] = {12, -6, 44};    // int a6[3] = {12, -6, 44};
```

Начиная с С99 можно указывать какие именно индексы инициализировать:

```c
int a7[100] = {[77]=6, [8]=11};          // a7[77]=6, a7[8]=11, остальные нули
```

В GNU extension (компилятор gcc) можно инициализировать диапазоны индексов, от и до включительно. Три точки, вокруг них пробелы (чтобы синтаксически не было началом числа с десятичной точкой):

```c
int a8[100] = {[16 ... 18]=6, [33]=11};  // a8[16]=6, a8[17]=6, a8[18]=6, a8[33]=11, остальные нули
```

При инициализации [33]=11 означает, что только одному элементу a8[33] присвоить 11, формат [16 ... 18]=6 означает, что все элементы с индексами от 16 до 18 включительно будут равны 6.

### Пример: читаем, сохраняем и печатаем
Дано натуральное число n < 100, далее n целых чисел.
+ прочитать числа и сохранить в массив,
+ распечатать числа из массива

```c
#include <stdio.h>


int main()
{
    int n;      // сколько чисел
    int a[100]; // числа
    int i;


    scanf("%d", &n);
    // читаем числа и сохраняем в массив
    for(i = 0; i < n; i++)
        scanf("%d", &a[i]);


    // печатаем сохраненные числа через пробел
    for(i = 0; i < n; i++)
        printf("%d ", a[i]);
    printf("\n");


    return 0;
}
```

### Когда нужны массивы
Чтобы прочитать и напечатать числа массив не нужен.

Массив нужен, когда информацию нужно хранить.
+ прочитать числа и напечатать их два раза,
+ прочитать числа и напечатать их в обратном порядке.

Дано:

```c
5
7 -3 19 42 -6
```

напечатать:

```c
7 -3 19 42 -6
7 -3 19 42 -6
```

Тут нужно сохранить числа и два раза напечатать их.

```c
#include <stdio.h>


int main()
{
    int n;      // сколько чисел
    int a[100]; // числа
    int i;


    scanf("%d", &n);
    // читаем числа и сохраняем в массив
    for(i = 0; i < n; i++)
        scanf("%d", &a[i]);


    // печатаем сохраненные числа через пробел
    for(i = 0; i < n; i++)
        printf("%d ", a[i]);
    printf("\n");


    // печатаем сохраненные числа через пробел
    for(i = 0; i < n; i++)
        printf("%d ", a[i]);
    printf("\n");


    return 0;
}
```

### Размер массива
До стандарта С99 размер массива всегда определялся на этапе компиляции.

```c
#define N 100   // препроцессор выполняет команды до компилятора
int a[N];       // компилятор знает размер массива и может выделить память под него
```

В задачах обычно указывается, например, "дано не более 100 чисел". Из условия задачи можно определить наибольший размер массива, который понадобится.

Если дано n сколько чисел, далее числа, то начиная с С99 можно написать:

```c
int n;
scanf("%d", &n);    // узнали размер на этапе выполнения программы
float a[n];         // массив из n элементов типа float
```

В проверяющей системе ejudge, где будут проходить контрольные, этот способ объявить массив запрещен и приводит к ошибке.

Если вы из условия задачи не поняли ограничение на размер массива, то можно создать массив с использованием динамической памяти. Подробно о динамической памяти и работы с ней расскажем позже. А сейчас шпаргалка.

Тот же самый код с использованием динамической памяти можно написать так:

```c
#include <stdlib.h>     // нужно для malloc и free


int main()
{
    int n;
    scanf("%d", &n);
    float * a = malloc(n * sizeof(float));  // выделяем динамическую память для размещения массива
    // обращаемся как с обычным массивом, доступ к элементу a[i]
    // ...
    free(a);                                // когда массив не нужен, освобождаем выделенную память
    return 0;
}
```

Как видите, ничего сложного.

## Задачи легкие

### L_arr_01 Четные и нечетные
Дано натуральное число $n<1000$, далее n целых чисел.

Напечатать сначала четные числа. На следующей строке напечатать нечетные числа.

```c
#include <stdio.h>
#define N 1000
int main(){
    int a[N];           // массив для N чисел
    int i;              // номер текущей ячейки
    int n;              // сколько чисел дано

    scanf("%d", &n);
    // читаем n чисел в массив a
    for(i=0; i<n; i++)
        scanf("%d", &a[i]);

    // печатаем числа
    for(i=0; i<n; i++) {
        if (a[i] % 2 == 0) {
            printf("%d ", a[i]);
        }
    }
    printf("\n");
    // печатаем числа еще раз
    for(i=0; i<n; i++) {
        if (a[i] % 2) {
            printf("%d ", a[i]);
        }
    }
    printf("\n");
    return 0;
}
```

### L_arr_1 revers
Дано натуральное число $n<1000$, далее n целых чисел.

Напечатать числа в обратном порядке.

```c
#include <stdio.h>
#define N 1000
int main(){
    int a[N];           // массив для N чисел
    int i;              // номер текущей ячейки
    int n;              // сколько чисел дано

    scanf("%d", &n);
    // читаем n чисел в массив a
    for(i=0; i<n; i++)
        scanf("%d", &a[i]);

    // печатаем числа
    for(i = 1; i <= n; i++) {
        printf("%d ", a[n - i]);
    }
    printf("\n");
    return 0;
}
```

### L_arr_02 первый индекс
Написать программу, которая в заданной последовательности чисел ищет встречается ли заданное число k.

Входные данные:

натуральное число $n<1000$ - количество чисел, n чисел на одной строке через пробел,k - заданное число (гарантируется, что оно встречается в предыдущей последовательности 1 или более раз).

Выходные данные:

первый индекс числа k в последовательности чисел.

```c
#include <stdio.h>
#define N 1000
int main(){
    int a[N];           // массив для N чисел
    int i;              // номер текущей ячейки
    int n;              // сколько чисел дано
    int k;
    scanf("%d", &n);
    // читаем n чисел в массив a
    for(i=0; i<n; i++)
        scanf("%d", &a[i]);
    scanf("%d", &k);
    
    for(i = 0; i < n; i++) {
        if (a[i] == k) {
            printf("%d", i);
            break;
        }
    }
    return 0;
}
```

### L_arr_02 первый индекс или -1
Написать программу, которая в заданной последовательности чисел ищет встречается ли заданное число k.

Входные данные:
+ натуральное число $n<1000$ - количество чисел,
+ n чисел на одной строке через пробел,
+ k - заданное число.

Выходные данные:

+ первый индекс числа k в последовательности чисел. Если такого числа нет, то напечатайте -1.

```c
#include <stdio.h>
#define N 1000
int main(){
    int a[N];           // массив для N чисел
    int i;              // номер текущей ячейки
    int n;              // сколько чисел дано
    int k, result = -1;
    scanf("%d", &n);
    // читаем n чисел в массив a
    for(i=0; i<n; i++)
        scanf("%d", &a[i]);
    scanf("%d", &k);
    
    for(i = 0; i < n; i++) {
        if (a[i] == k) {
            result = i;
            break;
        }
    }
    printf("%d", result);
    return 0;
}
```

### L_arr_10 сложение векторов
Найдите сумму двух векторов.

Для векторов $(a_1, a_2,..,a_n)$ и $(b_1, b_2, ..,b_n)$  суммой будет вектор $(a_1 + b_1, a_2 + b_2, ..,a_n + b_n)$

Входные данные:
+ Натуральное число n<1000 - размерность векторов.
+ n целых чисел через пробел на одной строке (первый вектор)
+ n целых чисел через пробел на следующей строке (второй вектор)

Выходные данные:
+ n целых чисел через пробел на одной строке (сумма векторов)

```c
#include <stdio.h>
#define N 1000
int main(){
    int a[N], b[N];
    int n;
    scanf("%d", &n);
    for(int i = 0; i < n; i++) {
        scanf("%d", &a[i]);
    }
    for(int i = 0; i < n; i++) {
        scanf("%d", &b[i]);
    }
    for(int i = 0; i < n; i++) {
        printf("%d ", a[i] + b[i]);
    }
    return 0;
}
```

### L_arr_11 Скалярное произведение векторов
Найдите скалярное произведение двух векторов.

Для векторов 
Для векторов $(a_1, a_2,..,a_n)$ и $(b_1, b_2, ..,b_n)$ скалярным произведением является число $(a_1 \cdot b_1 + a_2 \cdot b_2 + .. + a_n \cdot b_n)$
​
Входные данные:
+ Натуральное число n<1000 - размерность векторов.
+ n целых чисел через пробел на одной строке (первый вектор)
+ n целых чисел через пробел на следующей строке (второй вектор)

Выходные данные:
+ Скалярное произведение этих векторов.

```c
#include <stdio.h>
#define N 1000
int main(){
    int a[N], b[N];
    int n, result = 0;
    scanf("%d", &n);
    for(int i = 0; i < n; i++) {
        scanf("%d", &a[i]);
    }
    for(int i = 0; i < n; i++) {
        scanf("%d", &b[i]);
        result += (a[i] * b[i]);
    }
    printf("%d", result);
    return 0;
}
```

### L_arr_counter Массив как набор счетчиков
Для украшения делают гирлянду из шаров. Каждый цвет имеет свой номер от 0 до 9. Есть схема гирлянды, где указан цвет каждого шара. Сколько нужно шаров каждого цвета для гирлянды?

Входные данные:
+ Натуральное число n
+ Цвета шаров в гирлянде через пробел на следующей строке.

Выходные данные:
+ Номер цвета и количество шаров этого цвета через пробел. По одному цвету на строку, цвета от 0 до 9.

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
  int b[10] = {0}, *a = NULL;
  int n;
  scanf("%d", &n);
  a = malloc(n * sizeof(int));
  for (int i = 0; i < n; i++) {
    scanf("%d", &a[i]);
    b[a[i]]++;
  }
  for (int i = 0; i < 10; i++) {
    printf("%d %d\n", i, b[i]);
  }
  free(a);
  return 0;
}
```

## `sizeof`
+ Оператор `sizeof` дает размер переменной или типа в байтах.
+ Результат имеет тип `size_t`.
+ Напечатать результат можно по формату `%zd`
+ `sizeof(char)` всегда 1.
    + В современных архитектурах `char` обычно размером 1 байт. Поэтому мы будем говорить, что "sizeof вычисляет размер в байтах".

Чему равен sizeof(int)? В стандарте языка об этом не говорится. Размер зависит от архитектуры компьютера, от операционный системы и компилятора.

Как правило в gcc int занимает 32 бита, long long int 64 бита. В других комиляторах int и/или long может быть 64 бита в зависимости от платформы, но gcc на linux использует x86-64 abi, в котором int и long имеет размер 4 байта.

```c
int x;
printf("%zd\n", sizeof x);      // 4 в моей системе и на repl.it
printf("%zd\n", sizeof(1 + 2)); // 4 в моей системе и на repl.it
printf("%zd\n", sizeof 3.5);    // 8 в моей системе и на repl.it
printf("%zd\n", sizeof(char));  // 1 всегда
```

Можно писать операнд в скобках sizeof(x) или без них sizeof x. Тип можно указать только в скобках. Поэтому не думайте, пишите все в скобках.

Результат вычисляется во время компиляции, а не выполнения программы. Выражения не вычисляются, а подставляется их тип. То есть вместо sizeof(2+3) вычисляется sizeof(int).

### sizeof и массивы
```c
int     a[5];
size_t  n = sizeof(a);  // 20 = 4*5, если sizeof(int) равен 4
```

Перебрать все элементы массива можно так:

```c
int a = {7, -12, 34, 2};
for (int i = 0; i < sizeof(a)/sizeof(a[0]); i++)
    что-то делаем с a[i]
```

+ sizeof(a) - размер всего массива в байтах.
+ sizeof(a[0]) - размер нулевого элемента в байтах.
+ sizeof(a)/sizeof(a[0]) - сколько элементов в массиве.

### sizeof и структуры

```c
struct A {
    int x;
    char c;
    double d;
} z;
```

+ Тип struct A, значит размер sizeof(struct A)
+ Не занимайтесь арифметикой. sizeof(int)+sizeof(char)+sizeof(double) ≤ sizeof(struct A) из-за выравнивания данных

Подробнее об этом вы узнаете в курсе про архитектуру компьютера. Числа при хранении выравниваются по машинным словам. При этом образуются "дырки", которые не заняты данными.

## Адресная арифметика

### Чем массив отличается от указателя
Пусть у нас int 4 байта, а любой адрес 8 байт.

![08](/C_for_beginners_Stepik/Pictures/08_10.png)

```c
int a[5];  // массив из 5 int
int * pa;   // указатель на int (пока никуда не указывает)


pa = &a[0]; // pa указывает на начало массива
pa = a;     // pa указывает на начало массива
```

Когда говорят об указателе на массив, говорят об указателе на первый элемент массива &a[0].

Имя массива содержит адрес его начала. Поэтому можно писать pa = a.

Чем отличается pa (указатель на начало массива) от a (массива)?

+ pa (указатель) это:
    + адрес, на который указывает переменная,
    + определенный тип данных, который находится по этому адресу, int
    + sizeof(pa) равен 8 (размер адреса).
+ a (массив) это:
    + адрес его начала,
    + тип каждого элемента массива int,
    + размер массива sizeof(a) равно 5*4=20.

Массив это не только адрес и тип элемента, но и их количество.

```
pa может указывать не только на начало массива, но и на любой его элемент.
```

### Адреса элементов массива

![08](/C_for_beginners_Stepik/Pictures/08_11.png)

Пусть массив начинается с адреса 100, тогда адреса его элементов 100, 104, 108, 112 и 116.

```c
int a[5];   // массив из 5 int
int * p0;   // еще один указатель (никуда не указывает)
int * p3;   // еще один указатель (никуда не указывает)


p0 = &a[0]; // p0 указывает на a[0]
p3 = &a[3]; // p3 указывает на a[3]


printf("p0=%p p3=%p \n", p0, p3);   // проверим адреса
```

Адрес печатаем по формату %p.

Как из p0 получить p3? Нужно из адреса 100 получить адрес 112, это 100+3*4, то есть p0 + 3*sizeof(int). Выглядит ужасно. Плохо читается. Для многомерных массивов будет ещё хуже.

При разработке стандарта языка Си придумали адресную арифметику. Решили не писать везде sizeof(int), прибавлять не 3 байта, а 3 элемента массива.

Если одно слагаемое указатель, а другое целого типа, то результат указатель.

Можно писать:

```c
p0 = a;         // имя массива указывает на его начало, a[0]
p3 = p0 + 3;    // p3 указывает на 3 элемент массива, a[3]


printf("p0=%p p3=%p \n", p0, p3);   // проверим адреса, должны остаться прежними
```

Так как p0 типа указатель на int, то сдвигаемся на 3 int.

```c
double z[10];
double * pz = z;    // pz указывает на начало массива z
```

pz+2 - сдвинуться на 2 double.

### [] и операции с указателями

```c
int a[5] = {2, -4, -5, 11, 27};
int * p = a;
```

Как записать число 7 в первый элемент массива?

```c
a[0] = 7;       // через массив
*p = 7;         // через указатель на первый элемент
```

Заменить число 11 на 88 в массив можно так:

```c
a[3] = 88;      // через массив
*(p + 3) = 88;  // указатель на начало сдвинули на 3 элемента и разыменовали
```

На самом деле компилятор преобразовывает оператор [] в * и + и потом разбирает полученное выражение.

Эти выражения делают одно и то же:

```c
a[0] = 7;
*(a+0) = 7;
*a = 7;
*p = 7;
*(p+0) = 7;
p[0] = 7;
```

Эти выражения делают одно и то же:

```c
a[3] = 88;
*(a+3) = 88;
*(p+3) = 88;
p[3] = 88;
```

__Оператор [] придуман для удобства записи. a[b] идентично *(a+b)__

`scanf` тоже можно записать с помощью адресной арифметики

```c
scanf("%d", &a[3]);     // через []
scanf("%d", a+3);       // &*(a+3) можно сократить до a+3
```

__Курьёзы адресной арифметики__

Все выражения синтаксически корректны:

```c
*(3+a) = 88;
3[a] = 88;
char c = "abcdefgh"[2];     // строка - это массив символов с символом '\0' в конце
```

Что будет напечатано? В случае ошибки напишите Error.

```c
int b[] = {10, 11, 12, 13, 14, 15, 16, 17, 18, 19};
int * p = b+4;
printf("%d", p[2]);
```

__16__

Что будет напечатано? В случае ошибки напишите Error.

```c
int b[] = {10, 11, 12, 13, 14, 15, 16, 17, 18, 19};
int * p = b+4;
printf("%d", *(p-3));
```

__11__

Что будет напечатано? В случае ошибки напишите Error.

```c
int b[] = {10, 11, 12, 13, 14, 15, 16, 17, 18, 19};
int * p = b+4;
printf("%d", p[-1]);
```

__13__

### Когда работают правила адресной арифметики
+ указатель + целое = указатель
+ указатель - указатель = целое
    + указатели должны быть одинакового типа,
    + целое - сколько элементов укладывается между этими адресами
+ Указатель + указатель = ошибка (бессмысленно складывать указатели)

__Сравниваем указатели__
+ указатель1 == указатель2
+ указатель1 != указатель2
+ Эти сравнения машинно-зависимы (лучше так не писать):
    + указатель1 < указатель2
    + указатель1 > указатель2
+ Надо сравнивать так (машинно-независимый код):
    + указатель1 - указатель2 < 0
    + указатель1 - указатель2 > 0

### `void *` - просто адрес
Иногда нужен "просто адрес" без уточнения, данные какого типа расположены по этому адресу.

Например, в стандартные функции копирования участков памяти или сортировки передается адрес начала данных в памяти. Нам нужно уметь сортировать и копировать массивы разных типов, поэтому в этих функциях не привязывались к типу элементов массива, в функциях нужен только адрес.

Если функция `foo` ничего не возвращает, то тип возвращаемого значения `void`.

Аналогично "просто адрес" имеет тип `void *` указатель на `void`.

```c
void * pv;
```

+ C `void*` не работает адресная арифметика. `pv+3`, "сдвинуть на 3 элемента типа `void`", но в Си нельзя объявить переменную типа `void`, неизвестно какого она размера.
+ Нельзя разыменовать
    + *pv не работает, нет данных типа void
    + pv-> не работает, потому что это (*pv).
    + pv[i] не работает, потому что это *(pv+i)

Неявные преобразования указателей к/из void *

```c
int x;
char c;
double z;


int * px = &x;
char * pc = &c;
double * pz = &z;


void * pv;  // указатель типа void*


pv = px;    // неявное преобразование int* в void*
px = pv;    // неявное преобразование из void* в int *


pv = pc;    // из char* в void*
pc = pv;    // из void* в char*


pv = pz;    // из double* в void*
pz = pv;    // из void* в double*
```

В языке Си разрешено неявное преобразование любого указательного типа в тип `void*`, и наоборот, `void*` можно неявно преобразовать к любому другому указательному типу.

В языке С++ преобразование из `void*` к другому типу нужно записывать явно. Если вы используете компилятор С++ для компиляции программы на Си (не надо так делать!), то нужно явно преобразовывать тип. Функция `malloc` возвращает `void*`:

```c
int * p1 = malloc(3*sizeof(int));       // язык Си - работает, язык С++ - ошибка
int * p1 = (int*)malloc(3*sizeof(int)); // язык Си и С++ - работает
int * p1 = new int[3];                  // язык Си - ошибка, язык С++ - работает (именно так создают в C++ массивы)
```

### NULL - адрес, которого не существует
По определению, стандартная константа NULL - это адрес, которого не существует.

Обычно NULL это (void*)0.

Нельзя писать по этому адресу. Нельзя читать по этому адресу.

Это работает:

```c
int y, x = 7;
int * p = &x;   // p указывает на x
y = *p;         // y = 7;
*p = 22;        // x = 22;
```

Это не работает:

```c
p = NULL;       // p указывает на несуществующий адрес
y = *p;         // Ошибка, нельзя читать по адресу NULL
*p = 22;        // Ошибка, нельзя писать по адресу NULL
```

### Функция печати массива
Напишем функцию печати элементов массива. Будем передавать в функцию адрес a и количество элементов n. Надо печатать массив int.

```c
// от адреса a печатаем n чисел
int print_arr(int * a, int n)
{
    for(int i = 0; i < n; i++)
        printf("%d ", a[i]);
    printf("\n");
}
int main()
{
    int b[10] = {1, -2, 3, -4, 5, -6, 7, -8, 9, 10};
    print_arr(b, 10);       // печатаем весь массив
    print_arr(b, 7);        // печатаем первые 7 чисел
    print_arr(b+3, 7);      // печатаем последние 7 чисел
    print_arr(b+3, 4);      // печатаем от -4 до 7


    return 0;
}
```

Не важно какие фактические границы массива b. С помощью указателя и адресной арифметики можно работать с любой частью этого массива.

## Копирование массивов

### a = b
Представим, что мы придумываем язык программирования и описываем как в нем надо будет работать с массивами.

```c
int a[10];
a[3] = 7;   // присвоили значение одному ЭЛЕМЕНТУ массива
```

Давайте придумаем, что для двух массивов = будет копировать массив. Удобно же!

```c
int b[10];
b = a;      // пусть это копирует массив a в массив b
```

Хорошо, если размеры массивов совпадают, а если массив a меньше? Что делать?

```c
int big[100];
big = a;    // что делать?
```

Можно придумать, что "оставшиеся" элементы не изменяются или туда записываются нули.

Что делать, если данных больше, чем места в новом массиве? Будем копировать только те данные, для которых есть места?

Получилась очень сложная система правил копирования массивов.

Я пишу компилятор и мне трудно реализовать эти правила. Код компилятора увеличивается и становится сложнее.

Я учу язык Си и путаюсь когда какие данные будут записаны в массив.

Я программист и ищу ошибку, которая возникла из-за такого сложного алгоритма копирования массивов.

В Си решили сделать простые правила: массиву присвоить нельзя. Просто и понятно.

```c
int a[10];
int b[10];
int * p;


p = a;      // p указывает на начало массива a
a = p;      // Ошибка, нельзя массиву что-то присвоить
b = a;      // Ошибка, нельзя массиву что-то присвоить
```

### Копирование массива
Как все же копировать массив? Хочу написать dest (destination, куда), src (source, откуда) и n (сколько элементов копировать). Использовать так:

```c
int main()
{
    int a[10] = {1, -2, 3, -4, 5, -6, 7, -8, 9, 10};
    int b[10];
    arr_copy(b, a, 10);


    return 0;
}
```
Можно написать такую функцю:

```c
void arr_copy1(int * dst, int * src, int n)
{
    for(int i = 0; i < n; i++)
        dst[i] = src[i];
}
```

или такую:

```c
void arr_copy2(int * dst, int * src, int n)
{
    for(int i = n-1; i >= 0; i--)
        dst[i] = src[i];
}
```

Если функция очень нужна, значит есть такая стандартная функция.

#### `memcpy`

```c
#include <string.h>
void *memcpy(void *dest, const void *src, size_t n);
```

+ dest (destination) - куда копировать
+ src (source) - откуда копировать
+ n - сколько байт копировать

Использование:

```c
int a[10] = {1, -2, 3, -4, 5, -6, 7, -8, 9, 10};
int b[10];
memcpy(b, a, sizeof(a));
```

### Копирование перекрывающихся участков памяти

```c
int a[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
```

Откопируем первые 5 элементов с a на a+2 место. Исходный и результирующий участки памяти пересекаются.

Копируем от начала к концу участка, значения элементов изменяются так:

```c
a[2] = a[0];    // 1, 2, 1, 4, 5, 6, 7, 8, 9, 10
a[3] = a[1];    // 1, 2, 1, 2, 5, 6, 7, 8, 9, 10
a[4] = a[2];    // 1, 2, 1, 2, 1, 6, 7, 8, 9, 10
a[5] = a[3];    // 1, 2, 1, 2, 1, 2, 7, 8, 9, 10
a[6] = a[4];    // 1, 2, 1, 2, 1, 2, 1, 8, 9, 10
```

Копируем от конца к началу участка, значения элементов изменяются так:

```c
a[6] = a[4];    // 1, 2, 3, 4, 5, 6, 5, 8, 9, 10
a[5] = a[3];    // 1, 2, 3, 4, 5, 4, 5, 8, 9, 10
a[4] = a[2];    // 1, 2, 3, 4, 3, 4, 5, 8, 9, 10
a[3] = a[1];    // 1, 2, 3, 2, 3, 4, 5, 8, 9, 10
a[2] = a[0];    // 1, 2, 1, 2, 3, 4, 5, 8, 9, 10
```

Получаем разный результат копирования в зависимости от того, какой алгоритм применяли.

В стандарте не сказано, как именно нужно реализовать функцию memcpy. Поэтому ее результат для работы на пересекающихся участках памяти может отличаться от компилятора к компилятору.

__memcpy нельзя использовать на перекрывающихся участках памяти.__

У меня на компьютере работает, посылаю задачу на проверку - не работает. Чтобы не было такой ситуации используйте функцию

```c
void *memmove(void *dest, const void *src, size_t n);
```

Делает то же самое, что memcpy, но работает для перекрывающихся участков памяти. Она копирует из src нужную часть в свой массив (его называют "буфер"), а потом из буфера копируется в dst. Не имеет значения, откуда начинать копировать, с начала или с конца.

### `memset`
Иногда нужно заполнить часть памяти одним и тем же значением, например, проиницилизировать массив нулями.

Размер массива известен на этапе компиляции:

```c
int a[] = {3, 7, -12, 4};   // явная инициализация работает
int b[10] = {1};            // и тут работает
```

Если размер массива заранее не известен, то компилятор не знает - вышли вы при инициализации за границы или нет, поэтому предполагает худшее. В С99 можно определить размер массива на этапе выполнения, но нельзя при этом его явно инициализировать.

```c
size_t n;
scanf("%zu", &n);
int a[n];           // ok
int b[n] = {};      // error: variable-sized object may not be initialized
```

Что делать? Или определяйте размер массива на этапе компиляции, или используйте функцию `memset` из

```c
#include <string.h>


void *memset(void *s, int c, size_t n);
```

Записывает младший байт числа `с` в каждый байт на участке памяти размером `n`байт, начиная с адреса `s`.

Заполнение массива b нулями:

```c
memset(b, 0, sizeof(b));    // это работает
bzero(b, sizeof(b));        // это тоже работает
```

Посмотрим, что будет, если заполнить массив int единицами:

```c
int a[5] = {1, 1, 1, 1, 1};
int b[5];
memset(b, 1, sizeof(b));
```

Распечатаем содержимое массивов а и b:

```c
a: 1 1 1 1 1
b: 16843009 16843009 16843009 16843009 16843009
```

Что произошло? Каждый элемент типа int состоит из нескольких байт. В каждый из них записали 1. Если sizeof(int) равен 4, то в каждом элементе массива хранится число $1⋅256^3 + 1⋅256^2 + 1⋅256^1 + 1⋅256^0 = 16843009$

## Передаем массив в функцию

### Как массив передается в функцию
Физика наука экспериментальная, программирование - тем более

Передадим массив в функцию разным способом и измерим sizeof переданного в функцию аргумента. Код отформатирован так, чтобы вы видели разницу в функциях:

```c
void foo10 (int a[10]) { printf("foo10 : %zu\n", sizeof(a)); }
void foo   (int a[])   { printf("foo   : %zu\n", sizeof(a)); }
void foop  (int * a)   { printf("foop  : %zu\n", sizeof(a)); }


int main(){
    int a[10];
    printf("main : %zu\n", sizeof(a));      // main : 40
    printf("int* : %zu\n", sizeof(int*));   // int* : 8


    foo10(a);                               // foo10 : 8
    foo(a);                                 // foo   : 8
    foop(a);                                // foop  : 8


    return 0;
}
```

Гипотеза: массив передается в функцию как указатель.

Попробуйте изменить размер массива b на 20 и указать void foo10 (int a[20]). Увидим, что размер массива в main увеличился в 2 раза, а в функциях размер все тот же, 8. Гипотеза подтвердилась.

__Массив в функцию передается как указатель__

Массив - это много данных. Копировать их при передаче в функцию, как копировали структуру, требует много памяти и занимает время. Проще передавать указатель на массив. Поэтому массивы не копируются в функцию, а передается указатель, то есть адрес и тип одного элемента.

### Сколько элементов в переданном массиве
Мы использовали `sizeof` для вычисления количества элементов массива:

```c
int a[10];
for(int i = 0; i < sizeof(a)/sizeof(a[0]); i++)         // i < 40/4
    scanf("%d", a+i);
При передаче массива в функцию теряется информация о размере массива. Если sizeof(int *) 8, а sizeof(int) 4, то в этом коде прочитают и запишут в массив только 2 числа:

void read_arr(int a[10]) {
    for(int i = 0; i < sizeof(a)/sizeof(a[0]); i++)     // i < 8/4
        scanf("%d", a+i);
}
```

Поэтому в функции или передают параметр сколько элементов, или в массиве после данных пишут специальное значение, которое показывает, что данные закончились. В строках \0 обозначает конец строки.

### Пример: подсчет длины строки
Строка - это массив символов, оканчивающихся символом '\0'

Напишем функцию подсчета длины строки (количество элементов до \0)

```c
int my_strlen1(char str[])
{
    int n;
    for(n = 0; str[n] != '\0'; n++)
        ;
    return n;
}
```

Использование функции:

```c
int main()
{
    char s[10] = {'a', 'b', 'c', '\0'};     // то же самое char s[10] = "abc";
    printf("length = %d\n", my_strlen1(s)); // length = 3
    return 0;
}
```

Перепишем функцию с использованием указателей вместо индексов:

```c
int my_strlen2(char str[])
{
    char * p;
    for(p = str; *p != '\0'; p++)
        ;
    return p - str;
}
```

Когда p дойдет до \0, условие продолжения цикла станет ложным и мы выйдем из цикла. Чтобы найти сколько элементов массива между указателями p и str нужно вычесть из большего адреса меньший p - str.

![08](/C_for_beginners_Stepik/Pictures/08_12.png)

## Задачи обязательные

### R_arr_12 Размен
В банкомате монеты имеют цену 1, 2, 5, 10, 50, 100, 500, 1000, 5000 рублей.

Надо выдать банкоматом X рублей так, чтобы количество монет было наименьшим.

Дано натуральное число Х.

Напечатать сколько каких монет надо выдавать. Печатать цену монеты и количество таких монет через пробел, по паре чисел на строку, от самой большой монеты к меньшей.

```c
#include <stdio.h>

int main() {
  int const mon[] = {5000, 1000, 500, 100, 50, 10, 5, 2, 1};
  int x;
  scanf("%d", &x);
  for (int i = 0; i < 9; i++) {
    printf("%d %d\n", mon[i], x / mon[i]);
    x %= mon[i];
  }
  return 0;
}
```

### R_kupetc "Справедливый" купец
Если вы не поймете условие задачи, переходите на следующий шаг, задача дальше подробно описана и разбита на этапы.

Купец нанял N работников (не менее 1 и не более 100). Все работники делали одинаковую работу. По окончании работ купец расплатился с работниками монетами. Но он дал каждому монет не поровну, а как-нибудь: кому-то много, а кому-то мог вообще не заплатить.

Работники возмутились и стали требовать справедливости.

Купец обещал уладить дело.

Он поставил всех работников в круг. Затем у каждой пары работников он брал деньги и складывал. Если число монет двух работников нечетное, то одну монету купец забирал себе, а остальное поровну делил между этими двумя работниками. Купец начинал круг с пары 1-2, затем 2-3, ... и заканчивал круг парой N-1

После каждого такого "уравнивания" все проверяли поровну ли у них монет. Если у всех было поровну, процесс заканчивался.

Рабочие, получив РАВНОЕ количество монет уходили домой, а купец получал еще немножечко денег.

Написать программу, которая вычисляет сколько монет получил купец и сколько каждый работник.

Входные данные
+ Первая строка - количество работников.
+ Вторая строка - число монет, которое вначале получил каждый работник.

Выходные данные
+ Два целых числа: количество монет, полученных купцом и количество монет, которое осталось у каждого работника.

```c

```

### Задача R_kupec
Я устала рассказывать нашим студентам, которые только начали изучать русский язык, кто такой купец, что у него делали работники и "монета - это сколько денег?". Перепишем условие задачи про детей и конфеты.

Есть n детей. Им дали конфеты $a^0 ,a^1 ,..a^{n−1}$ штук. Дети хотят, чтобы у каждого было одинаковое количество конфет. Дети маленькие. Они не умеют складывать и делить на n.

Дети умеют делить поровну на двоих. Если есть лишняя конфета, ее откладывают.

Хитрый школьник решил помочь детям.
+ Школьник поставил детей в круг и делил так:
    + Поделил для ребенка 0 и ребенка 1, если есть лишняя конфета взял себе.
    + Поделил для ребенка 1 и ребенка 2, если есть лишняя конфета взял себе.
    + ...
    + Поделил для ребенка n−2 и ребенка n−1, если есть лишняя конфета взял себе.
    + Поделил для ребенка 0 и ребенка n−1, если есть лишняя конфета взял себе.
+ потом дети проверили - у всех одинаковое количество конфет или нет. Если не одинаковое, они повторяют уравнивание еще раз для всех детей.

Дано: 1≤n≤100, на следующей строке n чисел через пробел (конфет у каждого ребенка)

Найти: Сколько конфет у каждого ребенка в конце и сколько конфет у хитрого школьника.

Разберем, как проходит обмен. Будем выводить номера двух детей и сколько конфет у каждого ребенка. Пусть детям дали 1 5 3 4 2 конфет.

+ `+` означает, что школьник получил +1 конфету.
+ check - проверка, поровну у всех или нет.

```c
      1 5 3 4 2   # дали детям
0 1 : 3 3 3 4 2   # поделили у ребенка 0 и 1, сложили 1+5=6, по 3 конфеты, лишних нет
1 2 : 3 3 3 4 2   # поделили у ребенка 1 и 2, сложили 3+3=6, по 3 конфеты, лишних нет
2 3 : 3 3 3 3 2 + # поделили у ребенка 2 и 3, сложили 3+4=7, по 3 конфеты, +1 лишняя
3 4 : 3 3 3 2 2 + # поделили у ребенка 3 и 4, сложили 3+2=5, по 2 конфеты, +1 лишняя
0 4 : 2 3 3 2 2 + # поделили у ребенка 0 и 4, сложили 3+2=5, по 2 конфеты, +1 лишняя
check NO          # проверили, что у всех детей одинаково - НЕТ
0 1 : 2 2 3 2 2 + # поделили у ребенка 0 и 1, сложили 3+2=5, по 2 конфеты, +1 лишняя
1 2 : 2 2 2 2 2 + # поделили у ребенка 1 и 2, сложили 3+2=5, по 2 конфеты, +1 лишняя
2 3 : 2 2 2 2 2   # поделили у ребенка 2 и 3, сложили 2+2=2, по 2 конфеты, лишних нет
3 4 : 2 2 2 2 2   # поделили у ребенка 3 и 4, сложили 2+2=2, по 2 конфеты, лишних нет
0 4 : 2 2 2 2 2   # поделили у ребенка 0 и 4, сложили 2+2=2, по 2 конфеты, лишних нет
check YES         # проверили, что у всех детей одинаково - ДА
2 5               # ответ: у детей по 2 конфеты, у школьника 5 конфет
```

Что делать:
+ написать функцию, которая делит конфеты у двух детей и дает конфету (1 или 0) школьнику
+ написать функцию проверки, что у все одинаково (делали раньше)
+ написать функцию, которая делит конфеты у всех детей и дает конфеты школьнику

Дальше мы будем разбирать, как писать эту программу. Можете сразу перейти к ее решению.

### 2 ребенка делят конфеты пополам
Напишите и отладьте функцию `int delim(int a[], int i, int j)`.

Дети a[i] и a[j] делят конфеты поровну, лишние 0 или 1 конфету возвращают из функции.

```c
#include <stdio.h>
#include <assert.h>


int delim(int a[], int i, int j);


// тестируем функцию delim
void test_delim()
{
    int a[] = {7, 3, 4, 9};
    int rest = 0;
    rest += delim(a, 0, 1);
    assert(a[0] == a[1]);
    assert(a[0] == 5);
    assert(rest == 0);
    // правильно еще проверить, что остальные элементы массива не изменились
    // но мы надеемся на вас.


    rest += delim(a, 2, 3);
    assert(a[2] == a[3]);
    assert(a[2] == 6);
    assert(rest == 1);
}


int main()
{
    test_delim();
    return 0;
}
```

### У всех поровну?
Напишите и отладьте функцию `int all_equal(int a[], int n)`. Она возвращает 1, если у всех n детей поровну конфет. Иначе возвращает 0.

```c
#include <stdio.h>
#include <assert.h>


int all_equal(int a[], int n);


void test_all_equal()
{
    int a[] = {2, 2, 2, 3};
    int b[] = {-1, -3, -3};


    assert(all_equal(a, 3));
    assert(!all_equal(a, 4));
    assert(all_equal(b, 1));
    assert(!all_equal(b, 3));
}


int main()
{
    test_all_equal();
    return 0;
}
```

### Вся задача про конфеты
Это дубль задачи про купца. Можете послать решения в оба шага.

Дано:
+ 0 < n ≤ 100
+ $a^0 ,a^1 ,..a^n$  - конфет у каждого ребенка

Печатать ответ нужно только 2 числа: сколько конфет у школьника и сколько конфет у каждого ребенка.

```c
int delim(int a[], int i, int j);
    // Функция делит конфеты детей a[i] и a[j].
    // Отдает школьнику (return) лишние конфеты.

int all_equal(int a[], int n);
    // Проверяет, все ли числа в массиве a одинаковые.
    // Возвращает 1 (все одинаковые) или 0 (не все)
    // вы писали раньше такую задачу

int make_all_happy(int a[], int n);
    // Дети делят конфеты, "лишние" конфеты возвращают

int main()
{
    int a[100];     // ребенок i имеет a[i] конфет
    int n;          // всего детей

    scanf("%d", &n);                        // читаем входные данные
    for(i = 0; i < n; i++)
        scanf("%d", a+i);

    int schoolboy = make_all_happy(a, n);   // делим
    printf("%d %d\n", schoolboy, a[0]);     // печатаем ответ

    return 0;
}
```

### R_decimal_fract десятичная дробь
Известно, что любое рациональное число можно представить в виде периодической десятичной дроби.

Написать программу, которая представляет заданную правильную простую дробь в виде десятичной дроби с выделением периодической части.

Входные данные:

Два натуральных числа, записанных через пробел - числитель и знаменатель дроби

Выходные данные:

Десятичное представление этой дроби в виде: 0, далее (без разделителей) непериодическая часть и, в скобках, периодическая часть.

### R_arr_pascal Треугольник Паскаля
Коэффициенты $C(n,k)$ в биноме Ньютона 

$(a+x)^n = C(n,0)a^{n} + C(n,1)a^{n−1} \cdot x +..+C(n,k)a^{n−k} \cdot x^k  +..+C(n,n)x^n$

$C_n^k  = \dfrac{n!}{(n−k)!k!}$
 

Вы видели, что при вычислении факториала очень быстро происходит переполнение.

Коэффициенты можно вычислить с помощью треугольника Паскаля, В этом треугольнике на вершине и по бокам стоят единицы. Каждое число равно сумме двух расположенных над ним чисел.

```
         1
       1   1
      1  2  1
     1  3  3  1
   1  4  6  4  1
  1 5  10 10  5 1
 1 6  15 20 15 6 1
1 7 21 35 35 21 7 1
```

Разберемся, как можно вычислить коэффициенты для заданного n.

Двумерный массив
Если вы изучали другие языки, где есть массивы, то можете использовать двумерный массив.

```c
int a[3][4];    // объявляем массив 3x4, доступ к элементу a[i][j]
```

![08](/C_for_beginners_Stepik/Pictures/08_13.png)

Часть элементов массива не используется.

__2 массива__

Обратите внимание, при вычислении нового ряда нам нужны числа только из предыдущего ряда. Давайте будем хранить только 2 ряда. В массиве a уже заполненный ряд и по нему будем вычислять ряд в массиве b.

После того, как ряд в массиве b заполнен, его нужно откопировать в массив a.

![08](/C_for_beginners_Stepik/Pictures/08_14.png)

Копирование массива - долгая процедура. Улучшим алгоритм. Объявим два указателя. pa пусть указывает на уже заполненный массив, а pb на заполняемый сейчас:

![08](/C_for_beginners_Stepik/Pictures/08_15.png)

Тогда после заполнения массива, нужно будет только поменять указатели и по только что заполненному массиву заполнять другой массив (затирая его данные).

![08](/C_for_beginners_Stepik/Pictures/08_16.png)

__1 массив__

Попробуем обойтись единственным массивом. Будем заполнять его с конца.
+ Следующий ряд должен быть шире предыдущего на 1 ячейку. В эту ячейку запишем число 1.
+ Остальные ячейки (кроме первой) - это сумма ее и предыдущей ячейки.
+ В первой ячейке всегда остается 1.

До вычисления ячейки

![08](/C_for_beginners_Stepik/Pictures/08_17.png)

После вычисления этой ячейки: 

![08](/C_for_beginners_Stepik/Pictures/08_18.png)

Какой алгоритм лучше?

Зависит от полной задачи. Если нам регулярно нужны $C_n^k$  , то лучше один раз вычислить и сохранить в двухмерном массиве и потом использовать.

Если нужна только одна строка или один коэффициент, то можно воспользоваться алгоритмами для одномерных массивов.

Дано натуральное n ≤ 66.

Напечатайте через пробел коэффициенты $C_n^k$ для данного n.

```c
#include <stdio.h>
#define MAX 70
int main() {
  int n;
  scanf("%d", &n);
  unsigned long long int arr[MAX] = {0};
  arr[0] = 1;
  for (int i = 1; i <= n; i++) {
    arr[i] = 1;
    for (int k = i - 1; k > 0; k--) {
      arr[k] += arr[k - 1];
    }
  }
  for (int i = 0; i <= n; i++) {
    printf("%llu ", arr[i]);
  }
  return 0;
}
```

### R_arr_4 Решето Эратосфена
Из последовательности напечатайте только простые числа. 1 - НЕ простое число.

Дано n, на следующей строке n натуральных чисел через пробел. Каждое число меньше 1300000.

Напечатайте только простые числа в том порядке, в каком они следуют в последовательности.

Если решать задачу "в лоб", перебирая все возможные делители для каждого числа, получится очень долго. Проще найти все простые числа до 1300000, сохранить в массиве признак простое число или нет и далее быстро делать запросы к массиву.

Создадим массив, в котором для i будем хранить prime[i] - простое число i или нет.

#### Решето Эратосфена
Как найти простые числа от 2 до N?
+ Запишем эти числа
+ начиная с 2 будем вычеркивать каждое второе число (4, 6, 8 и так далее)
+ перейдем к следующему числу,
    + если оно не вычеркнуто, то повторим вычеркивание для этого числа.
    + если вычеркнуто, то перейдем к следующему числу.

Когда дойдем до конца, невычеркнутыми останутся только простые числа.

Распишем процесс вычеркивания и укажем k. Будем писать число (если оно не вычеркнуто) или -, если его вычеркнули.

```c
k | числа
  | 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 числа сначала
2 | 2 3 - 5 - 7 - 9 -  11 -  13 -  15 -  17 -  19 -  вычеркнули кратные 2
3 | 2 3 - 5 - 7 - - -  11 -  13 -  -  -  17 -  19 -  вычеркнули кратные 3
4 | 2 3 - 5 - 7 - - -  11 -  13 -  -  -  17 -  19 -  4 вычеркнуто, переходим к 5
5 | 2 3 - 5 - 7 - - -  11 -  13 -  -  -  17 -  19 -  вычеркнули кратные 5 и так далее
```

Заметим, что для 5 и далее вычеркивать уже нечего. Когда можно остановить алгоритм? Пусть у нас 100 чисел. Для 7 еще есть что вычеркивать, а для 11 числа уже вычеркнуты (22, 33, 44, 55, 66, 77, 88, 99), то есть для 11 уже вычеркивать не нужно. Подумайте, начиная с каких k алгоритм не вычеркивает новых чисел.

В prime[i] хранится простое число i или нет. То есть 0 или 1. Для этого хватит 1 бита, но мы еще не умеем работать с битами, значит объявим массив наименьшего целого типа:

```
char prime[i];
```

Тут должен быть рассказ о том, где выделять память и почему решение с локальным массивом может не работать.

```c
#include <stdio.h>
#include <stdlib.h>

int max(int *a, int n) {
  int maximum = a[0];
  for (int i = 1; i < n; i++) {
    if (maximum < a[i]) {
      maximum = a[i];
    }
  }
  return maximum;
}

int main() {
  int n, *a = NULL;
  scanf("%d", &n);
  a = malloc(n * sizeof(int));
  for (int i = 0; i < n; i++) {
    scanf("%d", &a[i]);
  }
  int max_num = max(a, n) + 1;
  char *prime = NULL;
  prime = malloc((max_num + 1) * sizeof(char));

  for (int i = 0; i < max_num; i++) {
    prime[i] = 1;
  }

  for (int i = 2; i * i <= max_num; i++) {
    if (prime[i]) {
      for (int k = i * i; k <= max_num; k += i) {
        prime[k] = 0;
      }
    }
  }

  for (int i = 0; i < n; i++) {
    if (prime[a[i]]) {
      printf("%d ", a[i]);
    }
  }
  free(a);
  free(prime);
  return 0;
}
```

### arr_log_uniq Сколько разных покупателей
В интернет-магазине могут покупать только зарегистрированные покупатели. Каждый покупатель имеет свой уникальный номер (id).

Информацию о каждой покупке в тот же момент записывают в формате:
+ timestamp - количество секунд с 00:00 1 января 1970 года;
+ id - номер клиента, который совершил покупку;
+ recept_id - номер чека этой покупки.

Сколько разных покупателей сделали покупки в магазине?

Входные данные

Натуральное число n < 10000 - количество покупок.

Через пробел timestamp id recept_id на одной строке - информация об одной покупке.

$0 < timestamp ≤ 2 \cdot 10^9, 0 < id ≤ 1000, 0 < recept_id ≤ 10^8$.

Выходные данные

Количество разных покупателей.

```c
#include <stdio.h>
#include <stdlib.h>
#define MAX 10000

int main() {
  int n;
  int a[MAX][3];

  scanf("%d", &n);

  // записали входные данные
  for (int i = 0; i < n; i++) {
    for (int k = 0; k < 3; k++) {
      scanf("%d", &a[i][k]);
    }
  }
  // отсортировали
  for (int i = 0; i < n; i++) {
    for (int k = i + 1; k < n; k++) {
      if (a[i][1] > a[k][1]) {
        int temp = a[k][1];
        a[k][1] = a[i][1];
        a[i][1] = temp;
      }
    }
  }
  // посчитали
  int result = 1;
  for (int i = 1; i < n; i++) {
    if (a[i][1] != a[i - 1][1]) {
      result++;
    }
  }
  printf("%d", result);
  return 0;
}
```

```c
#include <stdio.h>

#define CLIENTBIG 1000

int main() {
  int n, i, client_id, tmp;
  int a[CLIENTBIG + 1] = {};  // a[i] - сколько покупок сделал клиент i

  // читаем все записи
  scanf("%d", &n);
  for (i = 0; i < n; i++) {
    scanf("%d %d %d", &tmp, &client_id, &tmp);
    a[client_id]++;  // клиент client_id сделал еще 1 покупку
  }

  int x = 0;  // сколько уникальных клиентов
  for (i = 0, x = 0; i <= CLIENTBIG; i++)  // для всех клиентов
    if (a[i])  // если этот клиент покупал
      x++;  // мы его учитываем, как уникального клиента
  printf("%d\n", x);

  return 0;
}
```

## Задачи со структурами

### Пример: хранение карт
Напишем часть кода для игры с игральными картами, например, для покера.

Для хранения 1 карты объявим структуру с полями suit (масть) и rank (достоинство).

```c
struct Card {
    char rank;    // достоинство
    char suit;    // масть
};
```

Для кодирования карт используют обозначения:

+ Масть (suit):
    + c - clubs, трефы, ♣
    + s - spades, пики, ♠️
    + h - hearts, червы, ♥️
    + d - diamond, бубны, ♦️
+ Достоинство (rank):
    + '2', '3', '4', '5', '6', '7', '8', '9' - от 2 до 9
    + 'T' (ten - десять),
    + 'J' (валет),
    + 'Q' (дама),
    + 'K' (король),
    + 'A' (туз).

В этой нотации дама пик и король бубен записываются как QsKd.

![08](/C_for_beginners_Stepik/Pictures/08_19.png)

Напишем функции, которые печатают набор карт в указанном формате и из строки в этом формате создают массив карт.

Дальше мы будем писать функции, которые проверяют набор карт в руке, поэтому массив карт будем называть hand (рука). В массиве последняя карта "фальшивая" с мастью 0 и достоинством 0.

```c
void print_cards(struct Card * hand);
void read_cards(struct Card * hand);
```

#### Функция печати карт
В функции main создадим массив карт (с "фальшивой" последней картой в конце). Перебираем карты в цикле до "фальшивой" карты, которая обозначает конец карт в руке:

```c
#include <stdio.h>


struct Card {
    char rank;    // достоинство
    char suit;    // масть
};


int main()
{
    struct Card hand [] = {{'Q', 's'}, {'A','h'}, {'9', 'd'}, {0, 0}};


    // напечатаем карты до фальшивой, фальшивую не печатаем:
    for(int i = 0; hand[i].rank != 0; i++)
        printf("%c%c", hand[i].rank, hand[i].suit);
    printf("\n");
    return 0;
}
```

Перепишем цикл через указатель, p - указатель на одну карту. Сначала он указывает на первую карту руки &hand[0] или &*(hand+0), оно же просто hand.

`p++` перемещает указатель на следующую карту.

```c
    struct Card * p;    // указатель на одну карту
    for(p = hand; p->rank != 0; p++)
        printf("%c%c", p->rank, p->suit);
    printf("\n");
```

Оформим этот код в виде отдельной функции печати массива карт до фальшивой карты.

```c
void print_cards(struct Card * hand)
{
    struct Card * p;    // указатель на одну карту
    for(p = hand; p->rank != 0; p++)
        printf("%c%c", p->rank, p->suit);
    printf("\n");
}
```

Функция main:

```c
int main()
{
    struct Card hand [] = {{'Q', 's'}, {'A','h'}, {'9', 'd'}, {0, 0}};
    print_cards(hand);
    return 0;
}
```

#### Функция чтения карт

Колода 52 карты, +1 "фальшивая" обозначает конец карт. Значит в массиве не может быть больше 53 карт.

Прочитаем и сразу для проверки напечатаем карты. Входная и выходная строка должна совпасть.

```c
#define DECKSIZE 52
int main()
{
    struct Card hand[DECKSIZE+1];
    read_cards(hand);
    print_cards(hand);


    return 0;
}
```

Символы будем читать парами, ожидая в паре достоинство и масть. Мы умеем читать неизвестное количество чисел с помощью функции scanf. Аналогично прочитаем неизвестное количество пар символов.

```c
void read_cards(struct Card * hand)
{
    struct Card * p;    // указатель на одну карту
    for(p = hand; 2 == scanf("%c%c", &p->rank, &p->suit); p++)
        ;
    // в конец положим фальшивую карту
    p->rank = p->suit = 0;
}
```

Такой подход работает, если у нас после карт не будет, например, двух пробельных символов. Тогда будет ошибка. Хорошо бы проверять, что читаем именно карты, а если прочли не карту, завершать чтение:

```c
void read_cards(struct Card * hand)
{
    struct Card * p;    // указатель на одну карту
    for(p = hand; 2 == scanf("%c%c", &p->rank, &p->suit); p++) {
        if (!valid_card(p))
            break;
    }
    // в конец положим фальшивую карту
    p->rank = p->suit = 0;
}
int valid_card(struct Card * card)
{
    char * const suit = "cshd";        // в строках в конце тоже есть "фальшивый" символ '\0'
    char * const rank = "23456789TJQKA";
    int i;
    for (i = 0; suit[i] != '\0'; i++)
        if (suit[i] == card->suit)      // масть такая существует
            break;
    if (suit[i] == '\0')                // в card->suit была неправильная масть
        return 0;


    for (i = 0; rank[i] != '\0'; i++)
        if (rank[i] == card->rank)      // достоинство такое существует
            return 1;                   // масть и достоинство существуют, карта правильная


    return 0;                           // в card->rank было неправильное достоинство
}
```

Не забывайте писать прототипы функций (или реализацию) раньше первого вызова функции.

Заметьте, что функция чтения имеет уязвимость. Она не проверяет сколько карт уже считано и можно ввести больше карт, чем выделено памяти под массив. Подумайте, как можно изменить функцию, чтобы она гарантированно не писала вне переданного массива.

### struct_card Пиковая дама
Реализуйте функцию, которая ищет пиковую даму в переданной руке.

```c
int check(struct Card * hand);
```

`hand` - указатель на массив карт, последняя карта в котором имеет достоинство 0 (именно 0, а не '0', это фальшивая карта, используется только для обозначения конца массива).

`struct Card` определена, как описывалось раньше (на предыдущем шаге).

Функция возвращает 1, если в руке есть пиковая дама, иначе возвращает 0.

Посылать только реализацию функции.

Не забудьте проверить свой код. Например, так:

```c
int main()
{
    struct Card hand1 [] = {{'Q', 's'}, {'A','h'}, {'9', 'd'}, {0, 0}};
    struct Card hand2 [] = {{'2', 's'}, {'A','h'}, {0, 0}};
    assert(1 == check(hand1));
    assert(0 == check(hand2));

    return 0;
}
```

```c
int check(struct Card * hand) {
    int result = 0;
    struct Card * p;    // указатель на одну карту
    for(p = hand; p->rank != 0; p++) {
        if (p->rank == 'Q' && p->suit == 's') {
            result++;
            break;
        }
    }
    return result;
}
```

### elong_print Печать длинного числа
В Си целые числа ограничены типами unsigned long long int. Чтобы работать с большими числами нужно придумать как их хранить и написать функции для работы с ними.

Число 147 это $7 \ cdot10^0 + 4 \ cdot10^1 +1 \ cdot10^2$.

можно представить любое число a как $a_0 \cdot 10^0 + a_1 \cdot 10^1 + a_2 \cdot 10^2$.
 
Будем хранить коэффициенты $a_0, a_1, a_2$ в массиве a как a[0], a[1], a[2]. И будем в n хранить максимальную степень 10 в разложении числа по степеням 10.

Объединим массив a и поле n в структуру Decimal, так как они описывают одно и то же число. Чисел в программе может быть много, поэтому лучше их объединить в структуру. Например, мы захотим посчитать 50 число Фибоначчи.

```c
#define N 100
typedef struct {
    char a[N];       // number is a[0]*10^0 + a[1]*10^1 + ..+ a[n]*10^n
    unsigned int n;  // наибольшая степень десяти
}Decimal;
```

Напишите функцию `void elong_print(Decimal x)`, которая печатает длинное число и \n в конце.

```c
int main()
{
    Decimal x = {{7, 4, 1}, 2}; // число 147
    Decimal zero ={{0}, 0};     // число 0 представим как 0 умножить на 10 в степени 0

    elong_print(x);     // 147
    elong_print(zero);  // 0

    return 0;
}
```

Посылать только реализацию функции `elong_print`.

```c
void elong_print(Decimal x) {
    for (int i = 0; i <= x.n; i++) {
        printf("%d", x.a[x.n - i]);
    }
}
```

### elong_add Сложение больших чисел
В этой задаче мы слегка изменили функцию печати. Она сначала печатает n:, потом длинное число. Так как много ошибок совершают студенты, выставляя некорректное n.

Для хранения больших чисел объявили структуру

```c
#define N 100
typedef struct {
    char a[N];       // number is a[0]*10^0 + a[1]*10^1 + ..+ a[n]*10^n
    unsigned int n;  // наибольшая степень десяти
}Decimal;
```

Реализуйте функцию сложения чисел x и y, которая возвращает сумму чисел. Проверьте функцию.

```c
Decimal add (Decimal x, Decimal y);
```

В проверяющую систему посылать только реализацию требуемой функции add.

Проверять функцию можно так:

```c
int main(){
    Decimal x = {{7, 4, 1}, 2};  // set number 147
    Decimal y = {{3, 1}, 1};     // set number 13
    Decimal res;

    res = add(x, y);             // res = x+y = 147+13 = 160
    elong_print(res);            // print 160

    return 0;
}
```

```c
Decimal add (Decimal x, Decimal y) {
    Decimal result;
    int over = 0, n;
    n = (x.n >= y.n ? x.n : y.n);
    for (int i = 0; i <= n + 1; i++) {
        int res = (i <= x.n ? x.a[i] : 0) + (i <= y.n ? y.a[i] : 0) + over;
        result.a[i] = res % 10;
        over = res / 10;
    }
    result.n = n + result.a[n + 1];
    return result;
}
```

### Как отлаживать сложные задачи
1. Забудьте о встроенном редакторе степика. Установите, наконец, WSL.
2. Научитесь компилировать в командной строке (терминале WSL) и запускать программу с valgrind.
3. Напишите свою функцию main, если надо посылать только часть программы. Заведите в ней тестовые данные самым простым образом. Например, явно пропишите, не надо читать их с клавиатуры.
4. Добавьте отладочной печати. Используйте fprintf(stderr, "форматная стока" и дальше как обычно) (потом разберемся почему это может сработать).
5. Запускайте и смотрите. Читайте диагностику valgrind и смотрите на какие строки она указывает. Проблема в invalid read в printf? Значит вы пытаетесь читать данные, которые не инициализированы. Смотрите на функции, которые должны были вызываться раньше, почему данные не записаны в это место надлежащим образом.

Пример реализации первого теста 147+13=160 для предыдущей задачи:

```c
void check(Decimal * p)
{
    unsigned int i;
    for (i=0; i <= p->n; i++)
        if (p->a[i] > 9 || p->a[i] < 0) {
            printf("ERROR: a[%d]=%d\n", i, p->a[i]);
        }
}
int main()
{


    Decimal a = {{7, 4, 1}, 2};     // 147
    Decimal b = {{3, 1}, 1};        // 13


    print(a);
    print(b);


    Decimal res = add(a, b);
    print(res);
    check(&res);


    return 0;
}
```

