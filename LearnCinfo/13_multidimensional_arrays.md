![13](/LearnCinfo/Pictures/13_01.PNG)

# Многомерные статические массивы в си

|[Массивы](/LearnCinfo/12_arrays.md) | [Оглавление](/LearnCinfo/README.md) | [Строки](/LearnCinfo/14_strings.md)|
|:-|:-:|-:|

## Содержание

+ [Многомерные статические массивы](#многомерные-статические-массивы)
+ [Примеры](#примеры)
    + [Отсортируем двумерный массив методом пузырька](#отсортируем-двумерный-массив-методом-пузырька)
    + [Даны координаты x и y точки, полученные в ходе фотосъёмки. Известно, сколько кадров в секунду делала камера. Вычислить скорость в каждый момент времени и среднюю скорость за всё время](#даны-координаты-x-и-y-точки-полученные-в-ходе-фотосъёмки-известно-сколько-кадров-в-секунду-делала-камера-вычислить-скорость-в-каждый-момент-времени-и-среднюю-скорость-за-всё-время)
    + [Массив используется как карта, где число 2 означает начало, а 3 - конец пути. Программа сначала находит координаты этих точек, после этого вычисляет расстояние Манхеттена (сколько нужно пройти по x и y от начала до конца) и расстояние по Евклиду (как гипотенузу прямоугольного треугольника)](#массив-используется-как-карта-где-число-2-означает-начало-а-3---конец-пути-программа-сначала-находит-координаты-этих-точек-после-этого-вычисляет-расстояние-манхеттена-сколько-нужно-пройти-по-x-и-y-от-начала-до-конца-и-расстояние-по-евклиду-как-гипотенузу-прямоугольного-треугольника)
    + [Пользователь вводит 10 слов. Вывести слово с максимальной длиной. Программа внешне совершенно простая, единственная проблема - считывание и вывод слова. Так как слова хранятся в двумерном массиве, то указатель на words[i][0] - это начало нового слова. Также не забываем об ограничении на длину при вводе](#пользователь-вводит-10-слов-вывести-слово-с-максимальной-длиной-программа-внешне-совершенно-простая-единственная-проблема---считывание-и-вывод-слова-так-как-слова-хранятся-в-двумерном-массиве-то-указатель-на-wordsi0---это-начало-нового-слова-также-не-забываем-об-ограничении-на-длину-при-вводе)

 

# Многомерные статические массивы
В си, наряду с одномерными, существуют и многомерные массивы.

Например, двумерный массив: его можно представлять как массив массивов, или как матрицу. 

Размерность массива может быть и больше: трёхмерные, четырёхмерные и т.д.

Синтаксис остаётся прежним, добавляется только новая размерность

```c
<тип> <имя>[размерность1][размерность2]...;
```

Например, двумерный массив

```c
int a[2][3];
```

Трёхмерный массив

```c
int a[3][4][5];
```

Доступ до элементов массива осуществляется также, как и в одномерном массиве

```c
#include <conio.h>
#include <stdio.h>
 
#define SIZE 5
 
void main() {
    int M[3][3];
    unsigned i, j;
 
    for (i = 0; i < 3; i++) {
        for (j = 0; j < 3; j++) {
            M[i][j] = i * j;
        }
    }
 
    do {
        printf("enter indexes:\n");
        scanf("%d", &i);
        scanf("%d", &j);
        if (i < 3 && j < 3) {
            printf("M[%d][%d] == %d\n", i, j, M[i][j]);
        } else {
            break;
        }
    } while (1);
 
    for (i = 0; i < 3; i++) {
        for (j = 0; j < 3; j++) {
            printf("\t%d", M[i][j]);
        }
        printf("\n");
    }
    getch();
}
```

Особенностью является то, что по своему строению многомерный массив является обыкновенным, "одномерным", массивом. 

Все элементы расположены друг за другом. Доступ до элемента a[i][j] – по существу сдвиг на i*число столбцов + j. В двумерном массиве, таким образом, элементы расположены "по рядам", в трёхмерном - "по слоям", внутри которых элементы расположены "по рядам" и т.д.

В связи с этим, при начальной инициализации опускать размерность можно только в первых квадратных скобках:

```c
int a[][3] = {0};
int b[][5][25] = {0};
```

Компилятор будет знать в таком случае сдвиг, необходимый для доступа к элементу.

С этим связаны и особенности начальной инициализации. Так как многомерный массив по сути одномерный, то его начальную инициализацию можно провести так

```c
int a[2][3] = {1, 2, 3, 4, 5, 6};
```

Можно опустить первую размерность

```c
int a[][2][3] = {1, 2, 3, 34, 5, 6, 7, 8, 9, 10, 11, 12};
```

Можно с помощью фигурных скобок сделать данные более удобными для чтения

```c
int a[2][3] = {{1, 2, 3}, {4, 5, 6}}
```

или

```c
int a[][3][4] = 
{{{1, 2, 3, 4}, {2, 4, 6, 8}, {3, 6, 9, 12}},
 {{1, 2, 3, 4}, {2, 4, 6, 8}, {3, 6, 9, 12}},
 {{1, 2, 3, 4}, {2, 4, 6, 8}, {3, 6, 9, 12}}};
```

Также, как и в одномерных массивах, если заявлено данных больше, чем указано при инициализации, то оставшиеся заполняются нулями. 

Например, единичная матрица 3 на 3

```c
int zero3[3][3] = {{1}, {0, 1}, {0, 0, 1}};
```
Из того, что многомерный массив является одномерным по структуре, вытекают некоторые интересные свойства. 

Например, доступ до элемента может быть осуществлён через его порядковый номер
a[i][j] === a[0][i*число столбцов + j] и т.д.

[Содержание](#содержание)

<hr>

# Примеры

## Отсортируем двумерный массив методом пузырька. 

Для сортировки обычно используется два подхода - превращение двумерного массива в одномерный, сортировка, обратно превращение одномерного в двумерный, либо запутанное обращение к элементам через индекс. Можно сделать всё проще: работать с многомерным массивом как с одномерным

```c
#include <conio.h>
#include <stdio.h>
 
#define ROWS 4
#define COLS 3
 
void main() {
    int a[ROWS][COLS] = 
        {{1, 4, 5}, 
         {2, 6, 8}, 
         {1, 0, 9}, 
         {4, 2, 8}};
    int i, j, tmp, flag;
 
    do {
        flag = 0;
        for (i = 1; i < ROWS*COLS; i++) {
            if (a[0][i] < a[0][i-1]) {
                tmp = a[0][i];
                a[0][i] = a[0][i-1];
                a[0][i-1] = tmp;
                flag = 1;
            }
        }
    } while(flag);
 
    for (i = 0; i < ROWS; i++) {
        for (j = 0; j < COLS; j++) {
            printf("%3d", a[i][j]);
        }
        printf("\n");
    }
 
    _getch();
}
```

Замечание: по стандарту явно такое поведение не определено, но косвенно должно поддерживаться.

[Содержание](#содержание)

<hr>

## Даны координаты x и y точки, полученные в ходе фотосъёмки. Известно, сколько кадров в секунду делала камера. Вычислить скорость в каждый момент времени и среднюю скорость за всё время.

```c
#include <conio.h>
#include <stdio.h>
#include <math.h>
 
#define SIZE 10
 
void main() {
    float a[2][SIZE] = 
        {{1.03, 1.52, 2.11, 2.53, 3.08, 3.48,  3.98,  4.51,  5.02,  5.17}, 
         {1.03, 2.45, 4.13, 5.64, 7.22, 8.73, 10.32, 11.75, 13.28, 14.87}};
    float velocity[SIZE-1];
    float speed = 0.0;
    float vx, vy;
    float dt = 0.1;
    int i;
 
    for (i = 0; i < SIZE-1; i++) {
        vx = ( a[0][i+1] - a[0][i] ) / dt;
        vy = ( a[1][i+1] - a[1][i] ) / dt;
        velocity[i] = sqrt(vx*vx + vy*vy);
        speed += velocity[i];
    }
 
    speed /= (float)(SIZE - 1);
    for (i = 1; i < SIZE; i++) {
        printf("v[%d] = %.3f m/s\n", i, velocity[i-1]);
    }
    printf("mean velocity = %.3f", speed);
    _getch();
}
```

[Содержание](#содержание)

<hr>

## Массив используется как карта, где число 2 означает начало, а 3 - конец пути. Программа сначала находит координаты этих точек, после этого вычисляет расстояние Манхеттена (сколько нужно пройти по x и y от начала до конца) и расстояние по Евклиду (как гипотенузу прямоугольного треугольника).

```c
#include <conio.h>
#include <stdio.h>
#include <math.h>
 
#define SIZE 5
#define START  2
#define FINISH 3
 
void main() {
    char field[SIZE][SIZE] = {
        {0, 0, 0, 0, 0},
        {2, 0, 0, 0, 0},
        {0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0},
        {0, 0, 0, 0, 3}
    };
    unsigned i, j;
    unsigned x, y;
    char xFound = 0;
    int X, Y;
    char XFound = 0;
    unsigned manhattanDist;
    float euclidDist;
 
    for (i = 0; i < SIZE; i++) {
        for (j = 0; j < SIZE; j++) {
            if (field[i][j] == START) {
                x = i;
                y = j;
                xFound = 1;
                if (XFound) {
                    break;
                }
            }
            if (field[i][j] == FINISH) {
                X = i;
                Y = j;
                XFound = 1;
                if (xFound) {
                    break;
                }
            }
        }
        if (xFound && XFound) {
            break;
        }
    }
    if (!(xFound && XFound)) {
        printf("Error: corrupted data\n");
        getch();
        exit(1);
    }
 
    printf("(x,y) = %d, %d\n(X,Y)= %d, %d\n", x, y, X, Y);
 
    manhattanDist = abs((int)(x-X)) + abs((int)(y-Y));
    //тоже самое, что и sqrt((x-X)*(x-X)+(y-Y)*(y-Y))
    x -= X;
    y -= Y;
    euclidDist = sqrt((float)(x*x + y*y));
    printf("Manhattan dist. = %d\nEuclid dist. = %.3f", manhattanDist, euclidDist);
    getch();
}
```

[Содержание](#содержание)

<hr>

## Пользователь вводит 10 слов. Вывести слово с максимальной длиной. Программа внешне совершенно простая, единственная проблема - считывание и вывод слова. Так как слова хранятся в двумерном массиве, то указатель на words[i][0] - это начало нового слова. Также не забываем об ограничении на длину при вводе.

```c
#include <conio.h>
#include <stdio.h>
 
#define SIZE 10
#define MAX_LENGTH 128
 
void main() {
    //Массив хранит 10 слов максимум по 128 символов
    char words[SIZE][MAX_LENGTH];
    unsigned i, j, maxLength;
    //Так как длина слова ограничена 127 символами, то типа char хватит
    unsigned char counter[SIZE];
 
    for (i = 0; i < SIZE; i++) {
        //Считываем слова. words[i][0] - это символ, нам нужен
        //адрес, начиная с которого можно писать в массив
        fgets(&words[i][0], MAX_LENGTH - 1, stdin);
        j = 0;
        //Считаем длину слова
        while (words[i][j]) {
            j++;
        }
        counter[i] = j;
    }
 
    //Ищем слово с максимальной длиной
    maxLength = counter[0];
    j = 0;
    for (i = 1; i < SIZE; i++) {
        if (counter[i] > maxLength) {
            maxLength = counter[i];
            j = i;
        }
    }
 
    //Выводим слово на печать. При выводе строки
    //необходимо передавать указатель
    printf("%s", &words[j][0]);
    _getch();
}
```

[Содержание](#содержание)

<hr>

|[Массивы](/LearnCinfo/12_arrays.md) | [Оглавление](/LearnCinfo/README.md) | [Строки](/LearnCinfo/14_strings.md)|
|:-|:-:|-:|