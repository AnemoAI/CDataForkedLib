# 3. Стандартные (базовые) типы данных, операции и выражения

## Содержание
+ [3.1 Типы данных, переменные и константы](#31-типы-данных-переменные-и-константы)
    + [Как работает память?](#как-работает-память)
    + [Понятие типов данных](#понятие-типов-данных)
    + [Классификация простых предопределенных  типов данных](#классификация-простых-предопределенных--типов-данных)
    + [Что определяет тип данных?](#что-определяет-тип-данных)
    + [Основные (предопределенные) типы данных.](#основные-предопределенные-типы-данных)
    + [Недопустимое сочетание.](#недопустимое-сочетание)
    + [Переменные, константы](#переменные-константы)
+ [3.2 Время жизни и область видимости](#32-время-жизни-и-область-видимости)
    + [Область видимости и продолжительность жизни](#область-видимости-и-продолжительность-жизни)
+ [3.3 Ввод и вывод простых типов данных](#33-ввод-и-вывод-простых-типов-данных)
    + [Ввод и вывод простых типов данных](#ввод-и-вывод-простых-типов-данных)
    + [Ввод/вывод арифметических типов данных](#вводвывод-арифметических-типов-данных)
    + [Форматирование ввода / вывода](#форматирование-ввода--вывода)
    + [Использование `iomanip`](#использование-iomanip)
+ [3.4 Целочисленные типы данных](#34-целочисленные-типы-данных)
    + [Калькулятор](#калькулятор)
    + [Число десятков](#число-десятков)
    + [Последняя цифра](#последняя-цифра)
    + [Сумма цифр двухзначного числа](#сумма-цифр-двухзначного-числа)
    + [Симметричное число](#симметричное-число)
+ [3.5 Вещественные типы данных](#35-вещественные-типы-данных)
    + [Сколько битов в двоичном представлении `double` отводится под знак (знаковый бит)](#сколько-битов-в-двоичном-представлении-double-отводится-под-знак-знаковый-бит)
    + [Вводится два вещественных числа (тип данных float). Необходимо вывести их сумму, разность, произведение и частное.](#вводится-два-вещественных-числа-тип-данных-float-необходимо-вывести-их-сумму-разность-произведение-и-частное)
+ [3.6 Логический тип данных](#36-логический-тип-данных)
    + [Сколько памяти (байт) будет занимать переменная gender](#сколько-памяти-байт-будет-занимать-переменная-gender-если)
+ [3.7 Символьный тип данных](#37-символьный-тип-данных)
    + [Напишите сообщение "Привет, я студент ЛЭТИ!" в 4 строчки таким образом:](#напишите-сообщение-привет-я-студент-лэти-в-4-строчки-таким-образом)
+ [3.8 Операции и выражения](#38-операции-и-выражения)
    + [Унарные операции](#унарные-операции)
    + [Бинарные операции](#бинарные-операции)
    + [Тернарная операция](#тернарная-операция)
    + [Преобразования типов данных](#преобразования-типов-данных)
    + [Операция присваивания](#операция-присваивания)
    + []()

[Оглавление](/CPP_from_LETI/LETI_01/README.md)

# 3.1 Типы данных, переменные и константы

## Как работает память?

Представьте, что вы пришли в театр и хотите оставить свои личные вещи в гардеробе. Для хранения вещей есть специальные ящики.

![03](/CPP_from_LETI/LETI_01/img/03_01.png)

В каждом ящике помещается один предмет. Вы хотите сдать на хранение две вещи, поэтому требуете выделить вам два ящика.

![03](/CPP_from_LETI/LETI_01/img/03_02.png)

И вы оставляете свои две вещи.

![03](/CPP_from_LETI/LETI_01/img/03_03.png)

Готово, можно идти на спектакль!

В сущности, именно так работает память вашего компьютера. Она представляет собой нечто вроде огромного шкафа с множеством ящиков, и у каждого ящика есть адрес.

![03](/CPP_from_LETI/LETI_01/img/03_04.png)

`feOffeeb` - адрес ячейки памяти.

Каждый раз, когда вы хотите сохранить в памяти отдельное значение, вы запрашиваете у компьютера место в памяти, а он выдает адрес для сохранения значения. Если же вам понадобится сохранить несколько элементов, это можно сделать двумя основными способами: воспользоваться массивом или списком. 

<hr>

[Содержание](#содержание)

## Понятие типов данных

Любая программа предназначена для обработки некоторых данных. Данные представляют некоторую информацию. Информация многообразна – это  числовая информация, текстовая информация, аудио и видеоинформация и т.д. Однако, несмотря на многообразие видов информации, внутреннее машинное представление ее едино. Любые данные хранятся в памяти компьютера в виде двоичных кодов.

Память компьютера можно представить в виде непрерывной последовательности двоичных ячеек, каждая из которых может находиться в двух состояниях условно обозначаемых `0` и `1`. Каждая такая двоичная ячейка называется __битом__. Вся эта последовательность ячеек условно разбита на порции из `8` бит, называемые __байтами__. Таким образом, `1` байт = `8` битам. Байт является основной единицей измерения объема памяти.

![03](/CPP_from_LETI/LETI_01/img/03_05.jpg)

С каждым байтом памяти связано понятие адреса, который, по сути, является номером байта в непрерывной последовательности байтов памяти компьютера. То есть каждый байт памяти имеет свой адрес. По этому адресу и осуществляется доступ к данным, хранящимся в памяти.

Пусть, например, программе необходимо вывести на экран данные, хранящиеся в байте с адресом 1. Но как это сделать? Ведь двоичный код, содержащийся в этом байте, можно трактовать по-разному: это может быть число, а может быть это некоторая буква. Таким образом, программе для правильной обработки этого байта необходимо «знать» что это – число или буква. Другими словами, программе необходимо точно представлять какие данные хранятся  в этом байте памяти.

Для разрешения подобных коллизий в языках программирования введено __понятие типов данных__.

Тип данных для каждого программного объекта, представляющего данные, определяет:
+ характер данных (число, со знаком или без знака, целое или с дробной частью, одиночный символ или текст, представляющий последовательность символов и т.д.);
+ объем памяти, который занимают в памяти эти данные;
+ диапазон или множество возможных значений;
+ правила обработки этих данных (например, допустимые операции).

В разных языках программирования определены разные наборы типов данных, но, в целом, типы данных можно разделить на две группы: __простые__ и __структурированные__ типы. Простые типы данных представляют неразделимые данные, не имеющие внутренней структуры (это, например, числа, символы и т.д.). Структурированные типы данных, как это вытекает из их названия, имеют внутреннюю структуру (иногда достаточно сложную). Структурированные типы строятся на основе простых типов данных.

Другой уровень классификации разделяет все типы данных на __предопределенные__ (изначально встроенные в язык программирования) и __пользовательские__ (типы данных, определяемые программистом) типы данных.

<hr>

[Содержание](#содержание)

## Классификация простых предопределенных  типов данных

Основные (предопределенные) типы данных часто называют арифметическими, поскольку их можно использовать в арифметических операциях. Для описания основных типов определены следующие ключевые слова:
+ `int` (целый);
+ `float` (вещественный);
+ `double` (вещественный тип с двойной точностью);
+ `bool` (логический);
+ `char` (символьный).

Типы `int`, `bool` и `char`  относят к группе целочисленных (целых) типов, а `float` и `double` - к группе вещественных типов - типов с плавающей точкой. Код, который формирует компилятор для обработки целых величин, отличается от кода для величин с плавающей точкой.

Существует четыре спецификатора типа, уточняющих внутреннее представление и диапазон значений стандартных типов:
+ `short` (короткий);
+ `long` (длинный);
+ `signed` (знаковый);
+ `unsigned` (без знаковый).

Спецификаторы добавляются слева к названию типа, например, так:
+ `short int` – короткое целое;
+ `unsigned short int` - короткое целое без знака.

Спецификаторы могут в произвольном порядке. Например: `unsigned short int` эквивалентно `short unsigned int`.

Допустимы не все сочетания спецификаторов и типов данных. Например:  `unsigned double` является недопустимым сочетанием. Есть и другие варианты. Допустимые сочетания спецификаторов и типов данных будут приведены при рассмотрении конкретных типов данных.

<hr>

[Содержание](#содержание)

## Что определяет тип данных?

+ [x] диапазон или множество возможных значений;
+ [ ] область видимости данных
+ [ ] время жизни данных
+ [ ] Время выполнение программы
+ [x] характер данных

<hr>

[Содержание](#содержание)

## Основные (предопределенные) типы данных.

+ [ ] `auto`
+ [x] `bool`
+ [x] `int`
+ [x] `float`
+ [x] `char`

<hr>

[Содержание](#содержание)

## Недопустимое сочетание.

+ [ ] `short unsigned int`
+ [x] `unsigned double`
+ [ ] `signed int`
+ [ ] `short int`

<hr>

[Содержание](#содержание)

## Переменные, константы

В программах данные представлены константами и переменными.

__Переменная__ — это именованная область памяти, в которой хранятся данные определенного типа. Каждая переменная имеет имя и значение. Именем переменной является идентификатор, придуманный программистом, и служит для обращения к области памяти, в которой хранится значение этой переменной. Идентификатор переменной преобразуется в адрес памяти, где хранится переменная, в процессе компиляции программы. Перед использованием любая переменная должна быть описана.

Общее правил определения переменной можно сформулировать так:

```c++
[класс памяти]  <тип данных>  <идентификатор - имя> [инициализатор];
```

Понятие  класс памяти определяет такие важные характеристики как время жизни и область видимости переменных. Эти понятия будут рассмотрены позднее, и в следующих примерах они пока не используется.

Примеры описания переменных:

```c++
int а;  // переменная a типа int (целого типа)
double х; // переменная х типа double (вещественного типа с двойной точностью)
unsigned short int d; // переменная d – короткое целое без знака
```

Однотипные переменные можно определять в одной строке:

```c++
int i, j, k;
```

Описание переменной можно совместить с ее инициализацией:

```c++
int а = 1213;  // переменная a инициализирована значением 1213
double х = 0.003; // переменная х инициализирована значением 0.003
unsigned short int d = 13; // переменная d инициализирована значением 13
```

Существует альтернативный способ инициализации переменных. Следующие примеры эквивалентны предыдущим:

```c++
int а (1213);  // переменная a инициализирована значением 1213
double х (0.003); // переменная х инициализирована значением 0.003
unsigned short int d (13); // переменная d инициализирована значением 13
```

Определения неинициализированных и инициализированных однотипных переменных можно совмещать в одной строке:

```c++
int i = 0, j, k (10);
```

Инициализировать переменные можно не только конкретными значениями, как в предыдущих примерах. В качестве инициализирующего значения можно использовать любые допустимые выражения. Например:

```c++
double y = a * x; /* переменная y инициализирована значением равным произведению значений переменных a и x */
```

При инициализации переменной присваивается конкретное значение. Однако, если переменная не инициализирована, это не означает, что она не имеет значения. На самом деле она хранит некоторое значение, которое находилось в этой области памяти до определения переменной. Это значение невозможно предсказать. Такие случайные данные обычно называют “мусором”.

Во время выполнения программы значение переменной можно изменять.

__Константа__ – это величина, значение которой в процессе работы программы не изменяется.

Константы бывают двух видов: константы – литералы и именованные константы.

`Константы – литералы` представляют собой сами значения. Например:

```c++
123    -245    0.003   -12.45   ’R’     ”Это текст”
```

Тип данных, которому принадлежит констант – литерал, определяется компилятором автоматически по виду самого значения. Способы записи констант – литералов разных типов будет рассмотрены позже при изучении соответствующих типов данных.

Именованные константы задаются с помощью ключевого слова `const`:

```c++
const double Pi = 3.14;
const int c1 = 1000, c2 = 2000;
const char point = ’.’;
```

Далее в программе можно использовать имена этих констант, а не сами значения. Удобство использования именованных констант обусловлено возможностью изменения значения константы (например, при модификации программы) только в одном месте программы – в определении константы. При этом во всех местах программы, где используется имя этой константы, будет применено ее новое значение.

<hr>

[Содержание](#содержание)

# 3.2 Время жизни и область видимости

## Область видимости и продолжительность жизни

Область видимости определяет, где можно использовать переменную. Продолжительность жизни (или «время жизни») определяет, где переменная создается и где уничтожается. Эти две концепции связаны между собой.

Переменные, определенные внутри блока, называются локальными переменными. Локальные переменные имеют автоматическую продолжительность жизни: они создаются (и инициализируются, если необходимо) в точке определения и уничтожаются при выходе из блока. Локальные переменные имеют локальную область видимости (или «блочную»), то есть они входят в область видимости с точки объявления и выходят в самом конце блока, в котором определены.

```c++
#include <iostream>
 
int main() {
    int numb(15); // переменная numb создается и инициализируется здесь 
    double pi(3.14); // переменная pi создается и инициализируется здесь
 
    return 0;
 
} // numb и pi выходят из области видимости и уничтожаются здесь
```

Поскольку переменные `numb` и `pi` определены внутри блока, который является главной функцией, то они обе уничтожаются, когда `main()` завершает своё выполнение.

Переменные, определенные внутри вложенных блоков, уничтожаются, как только заканчивается вложенный блок:

```c++
#include <iostream>
 
int main() // внешний блок
{
    int numb(4); // переменная numb создается и инициализируется здесь 
 
    { // начало вложенного блока 
        double pi(3.14); // переменная pi создается и инициализируется здесь
    } // pi выходит из области видимости и уничтожается здесь 
 
    // Переменная pi не может быть использована здесь, так как она уже уничтожена!
 
    return 0;
} // переменная numb выходит из области видимости и уничтожается здесь
```

Что будет выведено на консоль?

```c++
#include <iostream>
 
int main() // внешний блок
{
int a = 4, b = 6;
if(a > b) // условная конструкция ~ если а больше b
  {
  int c;
  c = a + b;
  }
else 
  int c = 0;
std::cout << c;
    return 0;
} 
```

+ [x] Ошибка определения идентификатора
+ [ ] 46
+ [ ] 6
+ [ ] 4

Что будет выведено на консоль?

```c++
#include <iostream>
 
int main() // внешний блок
{
int a = 4, b = 6;
  {
  a = a + b;
  int c = 3;
  b = b - c;
  }
b = a - b;
std::cout << a << " " << b;
    return 0;
}
```

+ [ ] 4 2
+ [x] 10 7
+ [ ] 10 4
+ [ ] 3 3

<hr>

[Содержание](#содержание)

# 3.3 Ввод и вывод простых типов данных

## Ввод и вывод простых типов данных

Ввод/вывод данных является  неотъемлемой составляющей любой программы - без ввода исходных данных для обработки и без вывода результатов не обходится ни одна программа.

В этом разделе будут рассмотрены только некоторые аспекты организации ввода/вывода в языке C++, относящиеся к консольному вводу/выводу простых типов данных.

В языке C++ нет встроенных средств ввода/вывода — он осуществляется с помощью функций и объектов, содержащихся в стандартных библиотеках.

В C++ можно использовать два различных способа реализации ввода-вывода.

Первый способ (унаследованный от языка C) основан на использовании ряда библиотечных функций, наиболее употребимыми из которых являются функции printf  и scanf. Они выполняют форматированный ввод и вывод произвольного количества величин в соответствии со строкой формата. Строка формата содержит символы, которые при выводе копируются в поток (на экран) или запрашиваются из потока (с клавиатуры) при вводе, и спецификации преобразования, начинающиеся со знака %, которые при вводе и выводе заменяются конкретными величинами. Например:

```c++
#include <stdio.h>
using namespace std;

int main () {
     setlocale (0, "");
     int a;
     printf ("Введите целое число:\t");
     scanf ("%d", &a);
     printf ("Вы ввели значение:\t%d\n\n", a);
     system ("Pause");
     return 0;
}
```

Второй способ, характерный для C++, основан на использовании стандартных потоков ввода (`cin`) и вывода (`cout`). Та же самая программа в стиле C++ будет выглядеть так:

```c++
#include <iostream>
using namespace std;
int main () {
     setlocale (0, "");
     int a;
     cout << "Введите целое число:\t";
     cin >> a;
     cout << "Вы ввели значение:\t" << a << "\n\n";
//   cout << "Вы ввели значение:\t" << a << endl << endl;
     system ("Pause");
     return 0;
}
```

В одной и той же программе совмещать эти два способа не рекомендуется.

В дальнейшем будем использовать именно второй способ организации ввода/вывода.

При использовании потоков для вывода данных на экран используется операция `<<`, которая так и называется: __операция вывода__ или операция __вставки__ (данные "вставляются" в поток вывода).

Ввод данных с клавиатуры осуществляется с помощью __операции ввода__ `>>` (операция __извлечения__ данных из потока ввода).

Обе эти операции "знают" как осуществлять ввод и вывод стандартных простых типов данных. Более того эти операции можно "научить", как осуществлять ввод/вывод нестандартных пользовательских типов данных (перегрузка операций, которая будет рассмотрена позднее).

А сейчас перейдем к изучению приемов ввода/вывода простых стандартных типов данных.

Текстовые (строковые) литералы в C++ представляются как последовательность символов, заключенная в двойные кавычки. Например:

"Это пример текстовой строки".

Вывод текстовых строк на экран осуществляется через стандартный поток вывода с помощью операции вывода `<<`:

```c++
std::cout << "Это пример текстовой строки";
```

Внутрь текстовых строк можно вставлять управляющие `escape`-последовательности.  `Escape`-последовательности служат для управления выводом, и представляют собой специальные последовательности из двух или более символов, начинающиеся символом обратной наклонной черты - `\`. При этом каждая такая последовательность воспринимается компилятором как 1 символ. Примерами таких управляющих последовательностей в предыдущих программах являются `\t` - символ табуляции и `\n` - символ перевода строки (все эти последовательности приведены в разделе 3.5). С помощью `Escape`-последовательностей в текстовую строку можно включить любой символ с помощью его восьмеричного или шестнадцатеричного кода (в том числе и символы, которых нет на клавиатуре). Например:

```c++
std::cout << "Это символ с восьмеричным кодом 254:\t\254\n";
std::cout << "А это символ с шестнадцатеричным кодом xAA:\t\xAA\n";
```

На экран будут выведены две строки:

```
Это символ с восьмеричным кодом 254:         ┐

А это символ с шестнадцатеричным кодом xAA:          Є
```

Если на экран необходимо вывести пустую строку, достаточно вставить в поток дважды подряд управляющую последовательность `\n`:

```c++
std::​​​​​​​cout << "Это первая строка\n";
std::cout << "\n";                                        // Вторая строка пустая
std::cout << "Это третья строка\n";
```

При выводе длинных текстовых строк их можно в тексте программы разбивать на части следующим образом:

```c++
cout << "Это " \
              "условный "  \
              "пример " \
              "длинного " \
              "текста\n";
```

или так

```c++
cout << "Это "  "условный "  "пример " "длинного "  "текста\n";
```

На экран будет выведена одна строка, после чего экранный курсор перейдет на новую строку (управляющая последовательность `\n`):

Это условный пример длинного текста​​​​​​​

Символ `\` и символ пробела можно использовать для "сцепления" отдельных строк. Если в программе встречаются два или более строковых литерала, разделенные только пробелами, то они будут рассматриваться как одна символьная строка.

Ввод текстовых строк с клавиатуры будет рассмотрен позже.

<hr>

[Содержание](#содержание)

## Ввод/вывод арифметических типов данных

Пример простого ввода/вывода арифметических типов данных:

```c++
#include <iostream>
using namespace std;

int main () {
  setlocale (0, "");
  int i;
  double d;
  char c;
  bool b;
  cin >> i;   
  cout << i;
  cin >> d;
  cout << d;
  cin >> c;
  cout << c;
  cin >> b;
  cout << b;
  system ("Pause");
  return 0;
}
```

Особенности:

1. Ввод/вывод целочисленных значений осуществляется обычным образом в десятичной системе счисления.
2. Ввод вещественных типов данных можно осуществлять либо в формате с фиксированной точкой, либо в экспоненциальном формате.
3. Формат вывода вещественных значений выбирается автоматически в зависимости от выводимого значения.
4. Ввод символьных значений можно осуществлять только в виде одиночного символа. При вводе нескольких символов переменной c будет присвоен только первый символ. Могут возникнуть сложности с вводом русских букв.
5. Ввод/вывод логических значений осуществляется в числовом формате (0 - false, 1 - true).

Замечание:

При вводе числовых данных с клавиатуры могут возникать непредвиденные ошибки, вызванные вводом символов, недопустимых для числовых форматов. Например:

```c++
int i;
cin >> i;
```

При попытке ввода с клавиатуры числа `1234` допущена ошибка - набрано `12y34` и нажата клавиша `ENTER` (ошибочно была нажата клавиша `y`). Переменная `i` в этом случае будет содержать значение `12`,  и эта ошибка может привести к непредсказуемому дальнейшему поведению программы. В любом случае символы из потока ввода извлекаются оператором `>>` до тех пор, пока они соответствуют числовому формату. Как только в потоке ввода встречается символ, не соответствующий числовому формату, уже извлеченные символы преобразуются в числовое значение и присваиваются переменной

<hr>

[Содержание](#содержание)

## Форматирование ввода / вывода

В приведенных ранее примерах были использованы простейшие способы управления вводом/выводом с помощью специальных управляющих символов (`ESCAPE` последовательностей) - `\n` и `\t`. Однако, очень часто этого бывает недостаточно, например, для аккуратного структурированного оформления данных на экране.

Более гибкое управление вводом/выводом (форматирование ввода/вывода) в C++ осуществляется либо с помощью установки флагов форматирования, либо с помощью специальных манипуляторов ввода/вывода.

![03](/CPP_from_LETI/LETI_01/img/03_06.png)

Замечания:

1. Приставка `ios::` указывает на то, что определение флага принадлежит классу `ios`, опускать ее не следует, иначе компилятор выдаст ошибку.
2. Некоторые компиляторы (старые) могут не воспринимать представления этих флагов в виде идентификаторов. В этом случае необходимо использовать их числовые эквиваленты.
3. По сути, каждый флаг можно рассматривать как целочисленную именованную константу. Все эти константы определены в классе `ios`.

Флаги работают как переключатели (включен - выключен, установлен - сброшен). Все флаги упакованы в одном целом значении типа `long int`. Это целое значение определяет общее состояние всех флагов потока. Каждый флаг в этом целом значении представлен `1` битом (`1` двоичным разрядом). Установленному флагу соответствует значение `1` некоторого двоичного разряда. Если флаг сброшен (отключен), соответствующий двоичный разряд равен `0`.

Для управления флагами используются три функции: `flags`, `setf` и `unsetf`. Эти функции являются членами потоковых классов `cout` и `cin`, поэтому обращаться к ним следует через идентификаторы соответствующих потоковых классов: `cout.flags`, `cout.setf`, `cout.unsetf` или `cin.flags`, `cin.setf`, `cin.unsetf`. Если необходимо управлять флагами потока вывода, используется класс `cout`, если флагами потока ввода - класс `cin`. Все эти функции возвращают предыдущее состояние флагов.

Функция `flags` может использоваться двумя способами. Если вызвать ее без параметров,  то она не изменяет состояние флагов, а только возвращает значение состояния всех флагов потока. Например, строка

```c++
cout << cin.flags () << endl;
```

выведет на экран целое значение соответствующее состоянию флагов потока ввода. А строка

```c++
cout << cout.flags () << endl;
```

выведет на экран целое значение соответствующее состоянию флагов потока вывода.

Эту функцию можно использовать и для изменения состояния флагов. Для этого при ее вызове в качестве параметра ей необходимо передать необходимое значение флага (флагов). Например, оператор `cout.flags(ios::hex)`; установит флаг `hex`, все остальные флаги будут сброшены.

Особенностью этой функции является то, что она сначала сбрасывает все флаги, а уже потом устанавливает флаг (флаги), заданный параметром.

Замечание. Если вызвать функцию следующим образом: `flags(0)`, то будут сброшены все флаги соответствующего потока.

Функция `setf` также служит для установки флагов. Она добавляет новый флаг (флаги) без изменения всех остальных.

```c++
/* 1 */       cout.flags(0);                     // Отключены все флаги
/* 2 */       cout.setf(ios :: showpos); // Установлен единственный флаг showpos
/* 3 */       cout.setf(ios :: hex);          // Установлены два флага - showpos и hex
```

Если требуется сбросить флаг (флаги), используют функцию `unsetf`. В качестве параметра используется значение флага (флагов), который необходимо отключить. При этом остальные флаги изменены не будут. Например, если добавить к предыдущим строкам программы строку:

```c++
/* 4 */       cout.unsetf(ios :: showpos);
```

флаг `showpos` будет отключен, и останется установленным только флаг `hex`.

При использовании этих процедур можно оперировать не одиночными флагами, а объединением нескольких флагов. Например, строки 2 и 3 можно заменить одной строкой:

```c++
cout.setf ( ios :: showpos | ios :: hex);
```

Объединение флагов осуществляется с помощью операции `|` - арифметическое ИЛИ.

Среди всех флагов можно выделить три группы, в каждой из которых флаги управляют одной и той же характеристикой ввода / вывода, но являются взаимоисключающими. Флагам каждой из этих групп в классе `ios` присвоены обобщающие имена:

Группа | Флаги | Обобщающее имя
-|-|-
Флаги основания систем счисления | `dec`, `oct`, `hex` | `basefield`
Флаги выравнивания | `left`, `right`, `internal` | `adjustfield`
Флаги формата вещественных значений | `scientific`, `fixed` | `floatfield`

Обобщающие имена групп удобно использовать для выполнения операции со всеми флагами группы, например, для сброса всех флагов группы:

```c++
cout.unsetf (ios :: basefield);     // Отключаем флаги dec, oct, hex
```

Более того, функцию `setf` можно использовать с двумя параметрами:

```c++
setf (новые флаги, маска)
```

В этом случае функция `setf` устанавливает только те флаги, которые одновременно присутствуют и в первом и во втором параметре, а те флаги, которые присутствуют во втором параметре, но отсутствуют в первом, будут сброшены. Это дает возможность отключать и включать флаги за один вызов функции `setf`. Например,  для установки любого флага из группы  `basefield` достаточно использовать всего один оператор:

```c++
cout.setf (ios :: hex, ios :: basefield);
```

Здесь второй параметр содержит три флага: `dec`, `oct`, `hex`. Первый параметр содержит флаг `hex`. Этот флаг будет установлен, а флаги `dec` и `oct` будут сброшены.

В классе co`ut имеются еще несколько функций управляющих форматом вывода данных. К ним относятся:

+ `precision` - определяет точность представления вещественных значений;
+ `width` - устанавливает ширину поля вывода;
+ `fill` - определяет символ заполнения при выводе данных.

<hr>

[Содержание](#содержание)

## Использование `iomanip`

`Iomanip` – это библиотека в С++, которая предоставляет различные манипуляторы для управления форматированием вывода данных. Она позволяет задавать различные параметры вывода, такие как ширина поля, точность вывода чисел, заполнитель поля и многое другое.

Один из наиболее часто используемых манипуляторов из `iomanip` - это `setw()`, который позволяет задавать ширину поля вывода. Например, для вывода числа `42` с шириной поля `5` можно использовать следующий код:

```c++
#include <iostream>
#include <iomanip>

int main() {
    int number = 42;
    std::cout << "Number: " << std::setw(5) << number << std::endl;
    return 0;
}
```

Результатом выполнения данного кода будет строка "Number:    42", где число 42 отобразится в поле шириной в 5 символов, заполненное пробелами.

Следующим полезным манипулятором является `setprecision()`, который позволяет задавать точность вывода чисел. Например, для вывода числа `3.14159265359` с точностью 2 можно использовать следующий код:

```c++
#include <iostream>
#include <iomanip>

int main() {
    double pi = 3.14159265359;
    std::cout << "Pi: " << std::setprecision(2) << pi << std::endl;
    return 0;
}
```

Результатом выполнения данного кода будет строка `"Pi: 3.14"`. Здесь число `pi` будет выведено с точностью до двух знаков после запятой.

Еще одним полезным манипулятором библиотеки `iomanip` является `setfill()`, который позволяет задавать заполнитель поля вывода. Например, для вывода числа `42` в поле шириной `5` символов, заполненное символом `#`, можно использовать следующий код:

```c++
#include <iostream>
#include <iomanip>

int main() {
    int number = 42;
    std::cout << "Number: " << std::setfill('#') << std::setw(5) << number << std::endl;
    return 0;
}
```

Результатом выполнения данного кода будет строка `"Number: ###42"`, где число `42` отобразится в поле шириной в `5` символов, заполненное символами `'#'`.

Одним из полезных приемов при использовании iomanip является комбинирование различных манипуляторов. Например, для вывода числа 3.14 с точностью 2 и шириной поля 10 символов, заполненное символом '0', можно использовать следующий код:

```c++
#include <iostream>
#include <iomanip>

int main() {
    double pi = 3.14159265359;
    std::cout << "Pi: " << std::setfill('0') << std::setw(10) << std::setprecision(2) << pi << std::endl;
    return 0;
}
```

Результатом выполнения данного кода будет строка `"Pi: 00000003.14"`, где число `pi` будет выведено с точностью до двух знаков после запятой, поле будет иметь ширину `10` символов и будет заполнено символами '`0`'.

Описанные принципы и приемы работы с `iomanip` позволяют более гибко управлять выводом данных и делать его более красивым и читаемым. Это особенно полезно при работе с большим объемом данных или при необходимости вывести числа с определенной точностью или выравниванием. Успешное использование `iomanip` поможет вам создать программу, которая выглядит профессионально и ясно комментирует ваш код.

Для чего нужна приставка `ios::`?

+ [ ] Приставка `ios::` позволяет расходовать меньше памяти
+ [ ] Приставка `ios::` указывает на то, что определение флага принадлежит пространству имён ios
+ [ ] Приставка `ios::` указывает на то, что определение флага принадлежит классу операционной системе iOS
+ [x] Приставка `ios::` указывает на то, что определение флага принадлежит классу ios.

![03](/CPP_from_LETI/LETI_01/img/03_07.PNG)

Соотнесите флаги с группами, к которым они относятся. 

![03](/CPP_from_LETI/LETI_01/img/03_08.PNG)

Напишите программу, которая выведет в консоль названия всех времен года в порядке: зима, весна, лето, осень

```c++
#include <iostream>

using namespace std;

int main() {
    setlocale (0, "");
    puts("зима, весна, лето, осень\n");
return 0;
}
```

Используя функции, управляющие форматом вывода данных, напишите программу, которая будет выводить строку "..........123" (10 точек и '123').

```c++
#include <iomanip>
#include <iostream>

int main() {
  int a = 123;
  std::cout << ".........." << a << std::endl;
  return 0;
}
```

<hr>

[Содержание](#содержание)

# 3.4 Целочисленные типы данных

Размер типа `int` не определяется стандартом, а зависит от компьютера и компилятора. Для 16-разрядного процессора под величины этого типа отводится 2 байта – в этом случае диапазон возможных значений составляет -32 768 ... 32 767 (2 в степени 16 различных значений). Для 32-разрядного - 4 байта – диапазон значений -2 147 483 648 ... 2 147 483 647 (2 в степени 32 различных значений).

Спецификатор `short` перед именем типа указывает компилятору, что под число требуется отвести 2 байта независимо от разрядности процессора.

Спецификатор `long` означает, что целая величина будет занимать 4 байта. Таким образом, на 16-разрядном компьютере эквиваленты `int` и `short int`, а на 32-разрядном — `int` и `long int`.

При определении переменных вместо `short int` или `long int` можно использовать более короткие обозначения: `short` или `long` соответственно:

```c++
short a;
long b;
```

Использование типов `int`, `short int (short)`, `long int (long)` подразумевает представление целых чисел со знаком, поэтому спецификатор `signed` можно не указывать.

Внутреннее представление величины целого типа — целое число в двоичном коде. Например, число  `+22` типа `short int (short)` представляются в памяти так:

```
Номера разрядов:  15  14  13  12  11  10  9    8    7    6    5    4    3    2    1    0
Значения разрядов:  0    0    0    0    0    0    0    0    0    0    0    1    0    1    1    0     
```

а отрицательное число `-22` выглядит следующим образом:

```
Номера разрядов:  15  14  13  12  11  10  9    8    7    6    5    4    3    2    1    0
Значения разрядов:  1    1    1    1    1    1    1    1    1    1    1    0   1    0    1    0     
```

При использовании спецификатора `signed` (или при его отсутствии) старший бит числа (в данном случае – разряд с номером `15`) интерпретируется как знаковый (`О` — положительное число, `1` — отрицательное).

Спецификатор `unsigned` позволяет представлять только положительные числа, при этом старший разряд рассматривается как часть кода числа. Таким образом, диапазон значений типа `int` зависит от спецификаторов. Диапазоны значений величин целого типа со спецификатором `unsigned` выглядят так:
```c
unsigned int // (16-разрядного процессор): от 0 до 65 535;
unsigned int // (32-разрядного процессор): от 0 до 4 294 967 295;
unsigned short int /*или*/ unsigned short // (не зависимо от процессора): от 0 до 65 535. 
```

По умолчанию все целочисленные типы считаются знаковыми, то есть спецификатор `signed` можно опускать.

Целые константы литералы можно задавать в трех форматах: в десятичном, восьмеричном и в шестнадцатеричном.

В десятичном формате целые значения записываются в обычном виде:

```
1345   +34   -245
```

В восьмеричном формате сначала записывается 0 (нуль), а за ним восьмеричные разряды самого числа:

```
011     07345    -0456
```

В шестнадцатеричном формате значащим разрядам числа должны предшествовать символы 0x или 0X:

```
0x12B5   -0xAF2B    0X1FF02
```

Как уже говорилось ранее, константам, встречающимся в программе, приписывается тот или иной тип в соответствии с их видом. Если этот тип по каким-либо причинам не устраивает программиста, он может явно указать требуемый тип с помощью суффиксов L, l (long) и u, U (unsigned). Например, константа 32L будет иметь тип long и занимать 4 байта. Можно использовать суффиксы L и U одновременно, например, Ox22UL или 05LU.

Результат выполнения программы:

```c++
#include "pch.h"
#include <iostream>

int main() {
	int a = 3;
	int b = 4;
	unsigned c;
	c = a - b;
	std::cout << c;
}
```

+ [ ] 1
+ [ ] 7
+ [x] 4294967295
+ [ ] Программа не запустится

<hr>

[Содержание](#содержание)

## Калькулятор

Вводится два целых числа. Необходимо вывести их сумму, разность, произведение и частное.
```
а + б
а - б
а * б
а / б
```
Формат входных данных<br>
На вход дается два натуральных число a и b.<br>
Формат выходных данных<br>
Выведите четыре целых числа - результаты арифметических операций<br>
Sample Input:<br>
1 2<br>
Sample Output:<br>
3 -1 2 0<br>

```c++
#include <iostream>

int main() {
    int a, b;
    std::cin >> a >> b;

    printf("%d %d %d %d", a + b, a - b, a * b, a / b);
    return 0;
}
```

<hr>

[Содержание](#содержание)

## Число десятков

Дано целое неотрицательное число N, определите число десятков в нем (предпоследнюю цифру числа).<br>
Формат входных данных<br>
На вход дается целое положительное число N (0 ≤ N ≤ 1000000).<br>
Формат выходных данных<br>
Целое число, ответ на поставленную задачу<br>
```c++
int a = 10 / 3; // Результат - деление - 3
int a = 10 % 3; // Результат - остаток от деления - 1
```
Sample Input:<br>
841<br>
Sample Output:<br>
4<br>

```c++
#include <iostream>

int main() {
    int a;
    std::cin >> a;

    int result = (a / 10) % 10;

    std::cout << result << std::endl;

    return 0;
}
```

<hr>

[Содержание](#содержание)

## Последняя цифра

Дано натуральное число, выведите его последнюю цифру.<br>
Формат входных данных<br>
На вход дается натуральное число N.<br>
Формат выходных данных<br>
Выведите одно целое число - ответ на задачу.<br>

```c++
int a = 10 / 3; // Результат - деление - 3
int a = 10 % 3; // Результат - остаток от деления - 1
```
Sample Input:<br>
67<br>
Sample Output:<br>
7<br>

```c++
#include <iostream>

int main() {
    int a;
    std::cin >> a;

    int result = a % 10;

    std::cout << result << std::endl;

    return 0;
}
```

<hr>

[Содержание](#содержание)

## Сумма цифр двухзначного числа

Дано целое число. Найдите сумму его цифр.<br>
Формат входных данных<br>
На вход дается число от 10 до 99.<br>
Формат выходных данных<br>
Выведите одно целое число - ответ на задачу.<br>
Sample Input:<br>
99<br>
Sample Output:<br>
18<br>

```c++
#include <iostream>

int main() {
    int a;
    std::cin >> a;

    int result = a % 10 + a / 10;

    std::cout << result << std::endl;

    return 0;
}
```

<hr>

[Содержание](#содержание)

## Симметричное число

Дано четырехзначное число. Выведите его в обратном порядке.<br>
Формат входных данных<br>
Вводится одно четырехзначное число.<br>
Формат выходных данных<br>
Выводится число в обратной записи.<br>
Sample Input:<br>
1234<br>
Sample Output:<br>
4321<br>

```c++
#include <iostream>

int main() {
    int a;
    std::cin >> a;
    int result = 0;
    while (a > 0) {
        result = result * 10 + a % 10;
        a /= 10;
    }
    printf("%04d", result);
    return 0;
}
```

<hr>

[Содержание](#содержание)

# 3.5 Вещественные типы данных

Стандарт C++ определяет три типа данных для хранения вещественных значений: `float`, `double` и `long double`. Все эти типы предназначены для представления отрицательных и положительных значений (спецификатор `unsigned` к ним не применим) в разных диапазонах:
+ тип `float` занимает в памяти 4 байта с диапазоном абсолютных значений от 3.4е-38 до 3.4е+38;
+ тип `double` занимает в памяти 8 байт с диапазоном абсолютных значений от 1.7е-308 до 1.7е+308;
+ тип `long double` занимает в памяти 10 байт с диапазоном абсолютных значений от 3.4e-4932 до 3.4e+4932.

Замечание. В консольных приложениях `Windows` тип данных `long double` занимает в памяти 8 байт, то есть ничем не отличается от типа `double`.

Константы вещественных типов задаются двумя способами:
+ нормальный формат: `123.456` или `-3.14`;
+ экспоненциальный формат: `1.23456e2` (`1.23456е+2`). 

Дробная часть отделяется от целой части точкой, а не запятой.

По умолчанию вещественные константы трактуются как константы типа double. Для явного указания другого типа вещественной константы можно использовать суффиксы `F (f)` - тип `float` или `L (l)` - тип `long double`:
+ `3.14F` - константа типа `float`,
+ `3.14L`- константа типа `long double`.

Вещественные типы данных (типы данных с плавающей точкой) хранятся в памяти компьютера иначе, чем целочисленные. Внутреннее представление вещественного числа состоит из двух частей — мантиссы и порядка:

![03](/CPP_from_LETI/LETI_01/img/03_09.png)

Тип `float` занимает 4 байта, из которых один двоичный разряд отводится под знак мантиссы, 8 разрядов под порядок и 23 под мантиссу.

Для величин типа `double`, занимающих 8 байт, под порядок и мантиссу отводится 11 и 52 разряда соответственно. Длина мантиссы определяет точность числа, а длина порядка — его диапазон.

Все вычисления с вещественными значениями осуществляются приближенно, при этом, ошибки вычислений могут достигать весьма существенных значений. 

Это объясняется дискретностью внутреннего (машинного) представления непрерывного диапазона вещественных значений. Точность представления значений вещественных типов зависит от размера мантиссы. 

Относительная точность представления вещественных значений остается постоянной при различных значениях порядка. Однако, абсолютная точность существенно зависит от значения порядка (с уменьшением порядка абсолютная точность возрастает).

Пример неточности вычислений:

```c++
float a = 1e30f, b;
b = a + 1e10f;
cout << b - a << endl;   // На экран выведено 0
```

<hr>

[Содержание](#содержание)

## Сколько битов в двоичном представлении `double` отводится под знак (знаковый бит)

+ [ ] 128
+ [ ] 8
+ [ ] 5
+ [x] 1

<hr>

[Содержание](#содержание)

## Вводится два вещественных числа (тип данных float). Необходимо вывести их сумму, разность, произведение и частное.
а + б<br>
а - б<br>
а * б<br>
а / б<br>
Sample Input:<br>
1.5 <br>
4.7<br>
Sample Output:<br>
6.2<br>
-3.2<br>
7.05<br>
0.319149<br>

```c++
#include <iostream>

int main() {
    float a, b;
    std::cin >> a >> b;

    std::cout << a + b << std::endl;
    std::cout << a - b << std::endl;
    std::cout << a * b << std::endl;
    std::cout << a / b << std::endl;

    return 0;
}
```

<hr>

[Содержание](#содержание)

# 3.6 Логический тип данных

Величины логического типа могут принимать только значения `true` и `false`, являющиеся зарезервированными словами. Внутренняя форма представления значения false - `О` (нуль). Любое другое значение интерпретируется как `true`. При преобразовании к целому типу `true` имеет значение `1` (единица).

В памяти переменные этого типа занимают `1` байт.

Определения переменных этого типа выглядят, например, так:

```c++
bool  b1, b2 = true, b3 (false), b4 = 1, b5 = 0;
```

Константы – литералы задаются ключевыми словами `true` и `false`.

Именованные константы этого типа особого смысла не имеют, но имеют право на существование.

## Сколько памяти (байт) будет занимать переменная gender, если

```c++
bool gender = 300;
```

+ [ ] 8
+ [x] 1
+ [ ] 4
+ [ ] 2

<hr>

[Содержание](#содержание)

# 3.7 Символьный тип данных

Для обозначения этого типа используется ключевое слово `char`.

Под величину символьного типа отводится количество байт, достаточное для размещения любого символа из набора символов для данного компьютера, что и обусловило название типа. Как правило, это `1`байт. Тип `char`, как и другие целые типы, может быть со знаком или без знака. В величинах со знаком можно хранить значения в диапазоне от `-128` до `127`. По умолчанию тип `char` является знаковым, то есть спецификатор `signed` использовать не обязательно. При использовании спецификатора `unsigned` значения могут находиться в пределах от `0` до `255`. Этого достаточно для хранения любого символа из `256`-символьного набора `ASCII`. Величины типа `char` могут применяться и для хранения целых чисел, не выходящих за границы указанных диапазонов.

Спецификаторы `short` и `long` к этому типу данных не применяются.

Константы - литералы символьного типа представляют собой символы, заключенные в апострофы. Например:

```
'A'  '!'   '#'   'f'   'ш'   'я'
```

В языке C++ существует понятие управляющих или `ESCAPE` – последовательностей.

Управляющие последовательности начинаются символом обратной косой черты и служат:

+ Для представления символов, не имеющих графического изображения. Например: `\n` – перевод экранного курсора в начало следующей строки; `\t` символ табуляции и т.д.
+ Для представления некоторых специальных символов, а именно: знака косой черты, апострофа, знака вопроса и кавычки – `\\`, `\'`, `\?`, `\"`.
+ Для представления любого из `256` символов таблицы ASCII с помощью его восьмеричного или шестнадцатеричного номера. Например: `\054`, `\x4A`.

Управляющая последовательность воспринимается компилятором как одиночный символ. Если непосредственно за обратной косой чертой следует не предусмотренный символ, результат интерпретации не определен. Если в последовательности цифр встречается недопустимая, она считается концом цифрового кода.

Допустимые варианты управляющих последовательностей приведены в следующей таблице:

Изображение | Шестнадцатеричный код | Назначение
-|-|-
`\а` | 7 | Звуковой сигнал
`\b` | 8 | Возврат на шаг
`\f` | С | Перевод страницы (формата)
`\n` | A | Перевод строки
`\г` | D | Возврат каретки
`\t` | 9 | Горизонтальная табуляция
`\v` | 8 | Вертикальная табуляция
`\\` | 5C | Обратная косая черта
`\’` | 27 | Апостроф
`\"` | 22 | Кавычка
`\?` | 3F | Вопросительный знак
`\0oo` | — | 0oo - восьмеричный код символа
`\xdd` | dd | xdd - шестнадцатеричный код символа

![03](/CPP_from_LETI/LETI_01/img/03_10.PNG)

## Напишите сообщение "Привет, я студент ЛЭТИ!" в 4 строчки таким образом:
Привет,<br>
я<br>
студент<br>
​​​​​​​ЛЭТИ!<br>
Sample Input:<br>
Sample Output:<br>
Привет,<br>
я<br>
студент<br>
ЛЭТИ!<br>

```c++
#include <iostream>

int main() {

    std::cout << "Привет," << std::endl;
    std::cout << "я" << std::endl;
    std::cout << "студент" << std::endl;
    std::cout << "ЛЭТИ!" << std::endl;

    return 0;
}
```

<hr>

[Содержание](#содержание)

# 3.8 Операции и выражения

Обработка данных выполняется с помощью операций.

Операция – это действие, осуществляемое над операндами. Например:
```
2 + 3
```
Здесь операция сложения (`+`) выполняется над двумя операндами (2 и 3).

В зависимости от количества операндов в языке C++ имеются унарные (с одним операндом), бинарные (с двумя операндами) и одна тернарная (с тремя операндами) операция.

Из знаков операций, операндов и круглых скобок строятся выражения. В качестве операндов могут использоваться константы, переменные, функции и другие выражения (константы и переменные считаются частными случаями выражений). В результате вычисления выражения получается некоторое значение определенного типа. Тип данных значения выражения зависит от выполняемой операции (операций) и типов данных операндов.

Особенностью языка  C++ является то, что некоторые операции в зависимости от контекста могут иметь разное назначение.

Ниже приведены операции характерные для рассмотренных выше арифметических типов данных. Другие операции будут рассмотрены по мере изучения соответствующих типов данных.

<hr>

[Содержание](#содержание)

## Унарные операции

Операция | Описание
-|-
`++` | увеличение на 1 (инкремент)
`--` | уменьшение на 1 (декремент)
`sizeof` | размер объекта или типа данных в байтах
`~` | поразрядное отрицание
`!` | логическое отрицание
`-` | арифметическое отрицание (унарный минус)
`+` | унарный плюс
`(тип)` | явное преобразование типов

<hr>

[Содержание](#содержание)

## Бинарные операции

Операция | Описание
-|-
`*` | умножение
`/` | деление
`%` | остаток от деления
`+` | сложение
`-` | вычитание
`<<` | сдвиг влево
`>>` | сдвиг вправо
`<`  | меньше
`<=` | меньше или равно
`>`  | больше
`>=` | больше или равно
`==` | равно
`!=` | не равно
`&`  | поразрядная конъюнкция (И)
`^`  | поразрядное исключающее ИЛИ
`|`  | поразрядная дизъюнкция (ИЛИ)
`&&` | логическое И
`||` | логическое ИЛИ

Особое значение имеет операция присвоения и ее модификации:

Операция | Краткое описание
-|-
`=` | присваивание
`*=` | умножение с присваиванием
`/=` | деление с присваиванием
`%=` | остаток отделения с присваиванием
`+=` | сложение с присваиванием
`-=` | вычитание с присваиванием
`<<=` | сдвиг влево с присваиванием
`>>=`  | сдвиг вправо с присваиванием
`&=` | поразрядное И с присваиванием
`\|=` | поразрядное ИЛИ с присваиванием
`^=` | поразрядное исключающее ИЛИ с присваиванием

<hr>

[Содержание](#содержание)

## Тернарная операция

Операция | Описание
-|-
`?:` | условная операция

<hr>

[Содержание](#содержание)

## Преобразования типов данных

Рассмотрим пример:

Определены переменные

```c++
int a = 5;
double b = 7.6;
```

В программе необходимо подсчитать их сумму `a + b`.

Внутреннее (машинное) представление типа `int` и типа `double` существенно различаются. Существенно различаются и процедуры сложения целых значений и  процедуры сложения вещественных значений. Как же тогда сложить целое и вещественное? Выход – преобразовать оба значения к одному и тому же типу данных, а затем выполнить соответствующую операцию. Но если преобразовать значение переменной `b` к целому типу данных (отбросить дробную часть или округлить до ближайшего целого) результат будет равен либо `12`, либо `13`, то есть произошла потеря точности. А вот если сначала преобразовать значение a к типу `double` и сложить их как вещественные значения, тогда точность потеряна не будет (результат будет равен `12.6` и будет вещественного типа). На самом деле так и происходит.

Следовательно, при выполнении различных операций над разнотипными данными необходимы преобразования одних типов данных к другим.

В языке C++ различают неявное (автоматическое) и явное преобразование типов данных.

Неявное преобразование типов данных при выполнении операций, подобной рассмотренной выше (и в ряде других случаев), выполняется компилятором по определенным правилам автоматически. В чем же состоят эти правила?

Схема преобразования, используемая при выполнении арифметических операций, называется обычными арифметическими преобразованиями. Эта схема может быть описана следующими правилами:

1. Все данные типов `char` и `short int` преобразуются  к типу `int`.
2. Если хотя бы один из операндов имеет тип `double`, то и другой операнд преобразуется к типу `double` (если он другого типа); результат вычисления имеет тип `double`.
3. Если хотя бы один из операндов имеет тип `float`, то и другой операнд преобразуется к типу `float` (если он другого типа); результат вычисления имеет тип `float`.
4. Если хотя бы один операнд имеет тип `long`, то и другой операнд преобразуется к типу `long` (если он другого типа); результат имеет тип `long`.
5. Если хотя бы один из операндов имеет тип `unsigned`, то и другой операнд преобразуется к типу `unsigned` (если его тип не `unsigned`); результат имеет тип `unsigned`.

Если ни один из случаев 1-5 не имеет места, то оба операнда должны иметь тип `int`; такой же тип будет и у результата.

Следует отметить, что компиляторы языка C++ достаточно свободно выполняют подобные преобразования, что может в ряде случаев привести к неожиданным результатам.

```c++
#include <iostream> 
using namespace std; 

int main() {
	unsigned a = 5; 
	int b = 10;
    	cout << a << " - " << b << " = " << a - b  << endl; 

	system("Pause"); 
	return 0; 
}
```

Результат работы программы:
```
5 – 10 = 4294967291
```

Таким образом, несмотря на то, что язык C++ достаточно «снисходителен» к действиям программиста, это требует от программиста еще большей дисциплины в его действиях и четких знаний нюансов языка программирования.

Для исправления ошибки в работе предыдущей программы можно, например, изменить вычисление выражения `a – b` следующим образом: `(int) a – b` или `int(a) – b`. В этом случае мы получим правильный результат:
```
5 – 10 = -5.
```

Здесь было использовано явное преобразование типов данных.

Явное преобразование типов данных осуществляется с помощью соответствующей операции преобразования типов данных, которая имеет один из двух следующих форматов:

```c++
(<тип данных>) <выражение>   или   <тип данных> (<выражение>)
```

Например:

```c++
(int) 3.14
int (3.14)
(double) a
double (a)
(long) (a + 1e5f)
long (a + 1e5f)
```

Подобные преобразования имеют своим исходом три ситуации:
+ преобразование без потерь;
+ с потерей точности;
+ с потерей данных.

Преобразование происходит без потерь, если преобразуемое значение принадлежит множеству значений типа, к которому осуществляется преобразование. Например:

```c++
short a = 100;
cout << (int) a << endl;   // На экран выведено 100
cout << (char) a << endl;   // Выведена буква d (ее десятичный эквивалент - 100)
cout << (float) a << endl;   // На экран выведено 100
cout << (double) a << endl;   // На экран выведено 100
float b = 3.14f;
cout << (double) b << endl;   // На экран выведено 3.14
double d = 3.14;
cout << (float) d << endl;   // На экран выведено 3.14
```

Преобразование любого вещественного типа к целому осуществляется путем отбрасывания дробной части вещественного значения, поэтому практически всегда такие преобразования приводят к потере точности (осуществляются приближенно). Например:

```c++
double d = 3.74;
cout << (int) d << endl;   // На экран выведено 3
```

А вот попытки преобразования значений выходящих за пределы диапазона типа данных, к которому осуществляется преобразование, приводят к полному искажению данных. Например:

```c++
int a = -100;
cout << (unsigned) a << endl;   // На экран выведено 4294967196
int a = 50000;
cout << (short) a << endl;   // На экран выведено -15536
float b = 3e+9f;
cout << (int) b << endl;   // На экран выведено -2147483648
double d = 3e+9;
cout << (int) d << endl;   // На экран выведено -2147483648
double d = 3e+40;
cout << (float) d << endl;   // На экран выведено 1.#INF - переполнение
double d = -3e+40;
cout << (float) d << endl;   // На экран выведено -1.#INF - переполнение
```

Рассмотренная операция преобразования типов перешла в C++ из C. 

В C++ имеются свои операции преобразования типов данных. Например, рассмотренные выше преобразования в C++  можно было бы выполнить с помощью операции `static_cast`, имеющей следующий формат:

```c++
static_cast <тип данных> (выражение)
```

Например:

```c++
static_cast <double> (a + 2e+40f)
```

Пользоваться явными преобразованиями типов следует очень аккуратно и только там, где это действительно необходимо.

При явном преобразовании типов значения преобразуемых величин на самом деле не изменяются – изменяется только представление этих значений при выполнении действий над ними.

<hr>

[Содержание](#содержание)

## Операция присваивания

Одна из наиболее часто используемых операций. Формат операции:

![03](/CPP_from_LETI/LETI_01/img/03_11.png)

Например: a = b; b = 3 * a; c = 1.234;

Сначала вычисляется значение выражения с правой стороны, а затем полученное значение присваивается переменной в левой части операции (значение выражения записывается в область памяти переменной). Старое значение переменной при этом безвозвратно теряется.

__При выполнении операции присваивания тип значения выражения автоматически преобразуется к типу левого операнда (к типу данных переменной в левой части). При этом возможны потери данных или точности (см. явное преобразование типов).__

```c++
#include <iostream>
using namespace std;

int main() {
    int i = 100000, k;
    short j = 10000, m;
    k = j;  // Короткое целое преобразуется к целому без потерь
    m = i;  // Преобразование целого к короткому целому приводит к искажению данных
    cout << k << "      " << m << endl;  // На экран будет выведено:   10000    -31072

    k = 12500;
    m = k;                               // Потери данных нет
    cout << k << "      " << m << endl;  // На экран будет выведено:   12500   12500

    double d = 1.8234, n1, n2;
    n1 = i;  // Без ошибок
    n2 = j;  // Без ошибок
    k = d;   // С потерей точности
    j = d;   // С потерей точности
    /* На экран будет выведено:    100000    10000   1     1   */
    cout << n1 << "      " << n2 << "      " << k << "      " << j << endl;

    d = 1e+100;
    k = d;  // С потерей данных
    m = d;  // С потерей данных
    /* На экран будет выведено:    1е+100     -2147483648     0   */
    cout << d << "      " << k << "      " << m << endl;

    system("Pause");
    return 0;
}
```
Операция присваивания в свою очередь является выражением, значением которого является значение переменной в левой части после присваивания (эту переменную часто называют `L`-значением (от слова left – левая сторона)).

```c++

#include <iostream>
using namespace std;

int main() {
    int i = 7, j = 30, k;
    cout << i * j << endl;        // 210
    cout << (k = i * j) << endl;  // 210
    cout << k << endl;            // 210

    system("Pause");
    return 0;
}
```

Благодаря тому, что операция присваивания является выражением, в языке C++ возможно множественное присваивание:

```c++
<Переменная1> = <Переменная2> = … = <ПеременнаяN> = <Выражение>
```

```c++
#include <iostream>
using namespace std;

int main() {
    int i = 7, j = 30, k, l, m, n;
    k = l = m = n = i + j;
    cout << k << "      " << l << "      " << m << "      " << n << "      " << endl;  // 37 37 37 37

    system("Pause");
    return 0;
}
```

Операция присваивания имеет самый низкий приоритет.

## Арифметические операции