# 3. Стандартные (базовые) типы данных, операции и выражения

# 3.1 Типы данных, переменные и константы

## Как работает память?

Представьте, что вы пришли в театр и хотите оставить свои личные вещи в гардеробе. Для хранения вещей есть специальные ящики.

![03](/CPP_from_LETI/LETI_01/img/03_01.png)

В каждом ящике помещается один предмет. Вы хотите сдать на хранение две вещи, поэтому требуете выделить вам два ящика.

![03](/CPP_from_LETI/LETI_01/img/03_02.png)

И вы оставляете свои две вещи.

![03](/CPP_from_LETI/LETI_01/img/03_03.png)

Готово, можно идти на спектакль!

В сущности, именно так работает память вашего компьютера. Она представляет собой нечто вроде огромного шкафа с множеством ящиков, и у каждого ящика есть адрес.

![03](/CPP_from_LETI/LETI_01/img/03_04.png)

`feOffeeb` - адрес ячейки памяти.

Каждый раз, когда вы хотите сохранить в памяти отдельное значение, вы запрашиваете у компьютера место в памяти, а он выдает адрес для сохранения значения. Если же вам понадобится сохранить несколько элементов, это можно сделать двумя основными способами: воспользоваться массивом или списком. 

## Понятие типов данных

Любая программа предназначена для обработки некоторых данных. Данные представляют некоторую информацию. Информация многообразна – это  числовая информация, текстовая информация, аудио и видеоинформация и т.д. Однако, несмотря на многообразие видов информации, внутреннее машинное представление ее едино. Любые данные хранятся в памяти компьютера в виде двоичных кодов.

Память компьютера можно представить в виде непрерывной последовательности двоичных ячеек, каждая из которых может находиться в двух состояниях условно обозначаемых `0` и `1`. Каждая такая двоичная ячейка называется __битом__. Вся эта последовательность ячеек условно разбита на порции из `8` бит, называемые __байтами__. Таким образом, `1` байт = `8` битам. Байт является основной единицей измерения объема памяти.

![03](/CPP_from_LETI/LETI_01/img/03_05.jpg)

С каждым байтом памяти связано понятие адреса, который, по сути, является номером байта в непрерывной последовательности байтов памяти компьютера. То есть каждый байт памяти имеет свой адрес. По этому адресу и осуществляется доступ к данным, хранящимся в памяти.

Пусть, например, программе необходимо вывести на экран данные, хранящиеся в байте с адресом 1. Но как это сделать? Ведь двоичный код, содержащийся в этом байте, можно трактовать по-разному: это может быть число, а может быть это некоторая буква. Таким образом, программе для правильной обработки этого байта необходимо «знать» что это – число или буква. Другими словами, программе необходимо точно представлять какие данные хранятся  в этом байте памяти.

Для разрешения подобных коллизий в языках программирования введено __понятие типов данных__.

Тип данных для каждого программного объекта, представляющего данные, определяет:
+ характер данных (число, со знаком или без знака, целое или с дробной частью, одиночный символ или текст, представляющий последовательность символов и т.д.);
+ объем памяти, который занимают в памяти эти данные;
+ диапазон или множество возможных значений;
+ правила обработки этих данных (например, допустимые операции).

В разных языках программирования определены разные наборы типов данных, но, в целом, типы данных можно разделить на две группы: __простые__ и __структурированные__ типы. Простые типы данных представляют неразделимые данные, не имеющие внутренней структуры (это, например, числа, символы и т.д.). Структурированные типы данных, как это вытекает из их названия, имеют внутреннюю структуру (иногда достаточно сложную). Структурированные типы строятся на основе простых типов данных.

Другой уровень классификации разделяет все типы данных на __предопределенные__ (изначально встроенные в язык программирования) и __пользовательские__ (типы данных, определяемые программистом) типы данных.

## Классификация простых предопределенных  типов данных

Основные (предопределенные) типы данных часто называют арифметическими, поскольку их можно использовать в арифметических операциях. Для описания основных типов определены следующие ключевые слова:
+ `int` (целый);
+ `float` (вещественный);
+ `double` (вещественный тип с двойной точностью);
+ `bool` (логический);
+ `char` (символьный).

Типы `int`, `bool` и `char`  относят к группе целочисленных (целых) типов, а `float` и `double` - к группе вещественных типов - типов с плавающей точкой. Код, который формирует компилятор для обработки целых величин, отличается от кода для величин с плавающей точкой.

Существует четыре спецификатора типа, уточняющих внутреннее представление и диапазон значений стандартных типов:
+ `short` (короткий);
+ `long` (длинный);
+ `signed` (знаковый);
+ `unsigned` (без знаковый).

Спецификаторы добавляются слева к названию типа, например, так:
+ `short int` – короткое целое;
+ `unsigned short int` - короткое целое без знака.

Спецификаторы могут в произвольном порядке. Например: `unsigned short int` эквивалентно `short unsigned int`.

Допустимы не все сочетания спецификаторов и типов данных. Например:  `unsigned double` является недопустимым сочетанием. Есть и другие варианты. Допустимые сочетания спецификаторов и типов данных будут приведены при рассмотрении конкретных типов данных.

Что определяет тип данных?

+ [x] диапазон или множество возможных значений;
+ [ ] область видимости данных
+ [ ] время жизни данных
+ [ ] Время выполнение программы
+ [x] характер данных

Основные (предопределенные) типы данных.

+ [ ] `auto`
+ [x] `bool`
+ [x] `int`
+ [x] `float`
+ [x] `char`

Недопустимое сочетание.

+ [ ] `short unsigned int`
+ [x] `unsigned double`
+ [ ] `signed int`
+ [ ] `short int`

## Переменные,  константы

В программах данные представлены константами и переменными.

__Переменная__ — это именованная область памяти, в которой хранятся данные определенного типа. Каждая переменная имеет имя и значение. Именем переменной является идентификатор, придуманный программистом, и служит для обращения к области памяти, в которой хранится значение этой переменной. Идентификатор переменной преобразуется в адрес памяти, где хранится переменная, в процессе компиляции программы. Перед использованием любая переменная должна быть описана.

Общее правил определения переменной можно сформулировать так:

```c++
[класс памяти]  <тип данных>  <идентификатор - имя> [инициализатор];
```

Понятие  класс памяти определяет такие важные характеристики как время жизни и область видимости переменных. Эти понятия будут рассмотрены позднее, и в следующих примерах они пока не используется.

Примеры описания переменных:

```c++
int а;  // переменная a типа int (целого типа)
double х; // переменная х типа double (вещественного типа с двойной точностью)
unsigned short int d; // переменная d – короткое целое без знака
```

Однотипные переменные можно определять в одной строке:

```c++
int i, j, k;
```

Описание переменной можно совместить с ее инициализацией:

```c++
int а = 1213;  // переменная a инициализирована значением 1213
double х = 0.003; // переменная х инициализирована значением 0.003
unsigned short int d = 13; // переменная d инициализирована значением 13
```

Существует альтернативный способ инициализации переменных. Следующие примеры эквивалентны предыдущим:

```c++
int а (1213);  // переменная a инициализирована значением 1213
double х (0.003); // переменная х инициализирована значением 0.003
unsigned short int d (13); // переменная d инициализирована значением 13
```

Определения неинициализированных и инициализированных однотипных переменных можно совмещать в одной строке:

```c++
int i = 0, j, k (10);
```

Инициализировать переменные можно не только конкретными значениями, как в предыдущих примерах. В качестве инициализирующего значения можно использовать любые допустимые выражения. Например:

```c++
double y = a * x; /* переменная y инициализирована значением равным произведению значений переменных a и x */
```

При инициализации переменной присваивается конкретное значение. Однако, если переменная не инициализирована, это не означает, что она не имеет значения. На самом деле она хранит некоторое значение, которое находилось в этой области памяти до определения переменной. Это значение невозможно предсказать. Такие случайные данные обычно называют “мусором”.

Во время выполнения программы значение переменной можно изменять.

__Константа__ – это величина, значение которой в процессе работы программы не изменяется.

Константы бывают двух видов: константы – литералы и именованные константы.

`Константы – литералы` представляют собой сами значения. Например:

```c++
123    -245    0.003   -12.45   ’R’     ”Это текст”
```

Тип данных, которому принадлежит констант – литерал, определяется компилятором автоматически по виду самого значения. Способы записи констант – литералов разных типов будет рассмотрены позже при изучении соответствующих типов данных.

Именованные константы задаются с помощью ключевого слова `const`:

```c++
const double Pi = 3.14;
const int c1 = 1000, c2 = 2000;
const char point = ’.’;
```

Далее в программе можно использовать имена этих констант, а не сами значения. Удобство использования именованных констант обусловлено возможностью изменения значения константы (например, при модификации программы) только в одном месте программы – в определении константы. При этом во всех местах программы, где используется имя этой константы, будет применено ее новое значение.

# 3.2 Время жизни и область видимости

## Область видимости и продолжительность жизни

Область видимости определяет, где можно использовать переменную. Продолжительность жизни (или «время жизни») определяет, где переменная создается и где уничтожается. Эти две концепции связаны между собой.

Переменные, определенные внутри блока, называются локальными переменными. Локальные переменные имеют автоматическую продолжительность жизни: они создаются (и инициализируются, если необходимо) в точке определения и уничтожаются при выходе из блока. Локальные переменные имеют локальную область видимости (или «блочную»), то есть они входят в область видимости с точки объявления и выходят в самом конце блока, в котором определены.

```c++
#include <iostream>
 
int main() {
    int numb(15); // переменная numb создается и инициализируется здесь 
    double pi(3.14); // переменная pi создается и инициализируется здесь
 
    return 0;
 
} // numb и pi выходят из области видимости и уничтожаются здесь
```

Поскольку переменные `numb` и `pi` определены внутри блока, который является главной функцией, то они обе уничтожаются, когда `main()` завершает своё выполнение.

Переменные, определенные внутри вложенных блоков, уничтожаются, как только заканчивается вложенный блок:

```c++
#include <iostream>
 
int main() // внешний блок
{
    int numb(4); // переменная numb создается и инициализируется здесь 
 
    { // начало вложенного блока 
        double pi(3.14); // переменная pi создается и инициализируется здесь
    } // pi выходит из области видимости и уничтожается здесь 
 
    // Переменная pi не может быть использована здесь, так как она уже уничтожена!
 
    return 0;
} // переменная numb выходит из области видимости и уничтожается здесь
```

Что будет выведено на консоль?

```c++
#include <iostream>
 
int main() // внешний блок
{
int a = 4, b = 6;
if(a > b) // условная конструкция ~ если а больше b
  {
  int c;
  c = a + b;
  }
else 
  int c = 0;
std::cout << c;
    return 0;
} 
```

+ [x] Ошибка определения идентификатора
+ [ ] 46
+ [ ] 6
+ [ ] 4

Что будет выведено на консоль?

```c++
#include <iostream>
 
int main() // внешний блок
{
int a = 4, b = 6;
  {
  a = a + b;
  int c = 3;
  b = b - c;
  }
b = a - b;
std::cout << a << " " << b;
    return 0;
}
```

+ [ ] 4 2
+ [x] 10 7
+ [ ] 10 4
+ [ ] 3 3

# 3.3 Ввод и вывод простых типов данных

## Ввод и вывод простых типов данных

Ввод/вывод данных является  неотъемлемой составляющей любой программы - без ввода исходных данных для обработки и без вывода результатов не обходится ни одна программа.

В этом разделе будут рассмотрены только некоторые аспекты организации ввода/вывода в языке C++, относящиеся к консольному вводу/выводу простых типов данных.

В языке C++ нет встроенных средств ввода/вывода — он осуществляется с помощью функций и объектов, содержащихся в стандартных библиотеках.

В C++ можно использовать два различных способа реализации ввода-вывода.

Первый способ (унаследованный от языка C) основан на использовании ряда библиотечных функций, наиболее употребимыми из которых являются функции printf  и scanf. Они выполняют форматированный ввод и вывод произвольного количества величин в соответствии со строкой формата. Строка формата содержит символы, которые при выводе копируются в поток (на экран) или запрашиваются из потока (с клавиатуры) при вводе, и спецификации преобразования, начинающиеся со знака %, которые при вводе и выводе заменяются конкретными величинами. Например:

```c++
#include <stdio.h>
using namespace std;

int main () {
     setlocale (0, "");
     int a;
     printf ("Введите целое число:\t");
     scanf ("%d", &a);
     printf ("Вы ввели значение:\t%d\n\n", a);
     system ("Pause");
     return 0;
}
```

Второй способ, характерный для C++, основан на использовании стандартных потоков ввода (`cin`) и вывода (`cout`). Та же самая программа в стиле C++ будет выглядеть так:

```c++
#include <iostream>
using namespace std;
int main () {
     setlocale (0, "");
     int a;
     cout << "Введите целое число:\t";
     cin >> a;
     cout << "Вы ввели значение:\t" << a << "\n\n";
//   cout << "Вы ввели значение:\t" << a << endl << endl;
     system ("Pause");
     return 0;
}
```

В одной и той же программе совмещать эти два способа не рекомендуется.

В дальнейшем будем использовать именно второй способ организации ввода/вывода.

При использовании потоков для вывода данных на экран используется операция `<<`, которая так и называется: __операция вывода__ или операция __вставки__ (данные "вставляются" в поток вывода).

Ввод данных с клавиатуры осуществляется с помощью __операции ввода__ `>>` (операция __извлечения__ данных из потока ввода).

Обе эти операции "знают" как осуществлять ввод и вывод стандартных простых типов данных. Более того эти операции можно "научить", как осуществлять ввод/вывод нестандартных пользовательских типов данных (перегрузка операций, которая будет рассмотрена позднее).

А сейчас перейдем к изучению приемов ввода/вывода простых стандартных типов данных.

Текстовые (строковые) литералы в C++ представляются как последовательность символов, заключенная в двойные кавычки. Например:

"Это пример текстовой строки".

Вывод текстовых строк на экран осуществляется через стандартный поток вывода с помощью операции вывода `<<`:

```c++
std::cout << "Это пример текстовой строки";
```

Внутрь текстовых строк можно вставлять управляющие `escape`-последовательности.  `Escape`-последовательности служат для управления выводом, и представляют собой специальные последовательности из двух или более символов, начинающиеся символом обратной наклонной черты - `\`. При этом каждая такая последовательность воспринимается компилятором как 1 символ. Примерами таких управляющих последовательностей в предыдущих программах являются `\t` - символ табуляции и `\n` - символ перевода строки (все эти последовательности приведены в разделе 3.5). С помощью `Escape`-последовательностей в текстовую строку можно включить любой символ с помощью его восьмеричного или шестнадцатеричного кода (в том числе и символы, которых нет на клавиатуре). Например:

```c++
std::cout << "Это символ с восьмеричным кодом 254:\t\254\n";
std::cout << "А это символ с шестнадцатеричным кодом xAA:\t\xAA\n";
```

На экран будут выведены две строки:

```
Это символ с восьмеричным кодом 254:         ┐

А это символ с шестнадцатеричным кодом xAA:          Є
```

Если на экран необходимо вывести пустую строку, достаточно вставить в поток дважды подряд управляющую последовательность `\n`:

```c++
std::​​​​​​​cout << "Это первая строка\n";
std::cout << "\n";                                        // Вторая строка пустая
std::cout << "Это третья строка\n";
```

При выводе длинных текстовых строк их можно в тексте программы разбивать на части следующим образом:

```c++
cout << "Это " \
              "условный "  \
              "пример " \
              "длинного " \
              "текста\n";
```

или так

```c++
cout << "Это "  "условный "  "пример " "длинного "  "текста\n";
```

На экран будет выведена одна строка, после чего экранный курсор перейдет на новую строку (управляющая последовательность `\n`):

Это условный пример длинного текста​​​​​​​

Символ `\` и символ пробела можно использовать для "сцепления" отдельных строк. Если в программе встречаются два или более строковых литерала, разделенные только пробелами, то они будут рассматриваться как одна символьная строка.

Ввод текстовых строк с клавиатуры будет рассмотрен позже.

## Ввод/вывод арифметических типов данных
Пример простого ввода/вывода арифметических типов данных:

```c++
#include <iostream>
using namespace std;

int main () {
  setlocale (0, "");
  int i;
  double d;
  char c;
  bool b;
  cin >> i;   
  cout << i;
  cin >> d;
  cout << d;
  cin >> c;
  cout << c;
  cin >> b;
  cout << b;
  system ("Pause");
  return 0;
}
```

Особенности:

1. Ввод/вывод целочисленных значений осуществляется обычным образом в десятичной системе счисления.
2. Ввод вещественных типов данных можно осуществлять либо в формате с фиксированной точкой, либо в экспоненциальном формате.
3. Формат вывода вещественных значений выбирается автоматически в зависимости от выводимого значения.
4. Ввод символьных значений можно осуществлять только в виде одиночного символа. При вводе нескольких символов переменной c будет присвоен только первый символ. Могут возникнуть сложности с вводом русских букв.
5. Ввод/вывод логических значений осуществляется в числовом формате (0 - false, 1 - true).

Замечание:

При вводе числовых данных с клавиатуры могут возникать непредвиденные ошибки, вызванные вводом символов, недопустимых для числовых форматов. Например:

```c++
int i;
cin >> i;
```

При попытке ввода с клавиатуры числа `1234` допущена ошибка - набрано `12y34` и нажата клавиша `ENTER` (ошибочно была нажата клавиша `y`). Переменная `i` в этом случае будет содержать значение `12`,  и эта ошибка может привести к непредсказуемому дальнейшему поведению программы. В любом случае символы из потока ввода извлекаются оператором `>>` до тех пор, пока они соответствуют числовому формату. Как только в потоке ввода встречается символ, не соответствующий числовому формату, уже извлеченные символы преобразуются в числовое значение и присваиваются переменной

## Форматирование ввода / вывода

В приведенных ранее примерах были использованы простейшие способы управления вводом/выводом с помощью специальных управляющих символов (`ESCAPE` последовательностей) - `\n` и `\t`. Однако, очень часто этого бывает недостаточно, например, для аккуратного структурированного оформления данных на экране.

Более гибкое управление вводом/выводом (форматирование ввода/вывода) в C++ осуществляется либо с помощью установки флагов форматирования, либо с помощью специальных манипуляторов ввода/вывода.

![03](/CPP_from_LETI/LETI_01/img/03_06.png)

Замечания:

1. Приставка `ios::` указывает на то, что определение флага принадлежит классу `ios`, опускать ее не следует, иначе компилятор выдаст ошибку.
2. Некоторые компиляторы (старые) могут не воспринимать представления этих флагов в виде идентификаторов. В этом случае необходимо использовать их числовые эквиваленты.
3. По сути, каждый флаг можно рассматривать как целочисленную именованную константу. Все эти константы определены в классе `ios`.

Флаги работают как переключатели (включен - выключен, установлен - сброшен). Все флаги упакованы в одном целом значении типа `long int`. Это целое значение определяет общее состояние всех флагов потока. Каждый флаг в этом целом значении представлен `1` битом (`1` двоичным разрядом). Установленному флагу соответствует значение `1` некоторого двоичного разряда. Если флаг сброшен (отключен), соответствующий двоичный разряд равен `0`.

Для управления флагами используются три функции: `flags`, `setf` и `unsetf`. Эти функции являются членами потоковых классов `cout` и `cin`, поэтому обращаться к ним следует через идентификаторы соответствующих потоковых классов: `cout.flags`, `cout.setf`, `cout.unsetf` или `cin.flags`, `cin.setf`, `cin.unsetf`. Если необходимо управлять флагами потока вывода, используется класс `cout`, если флагами потока ввода - класс `cin`. Все эти функции возвращают предыдущее состояние флагов.

Функция `flags` может использоваться двумя способами. Если вызвать ее без параметров,  то она не изменяет состояние флагов, а только возвращает значение состояния всех флагов потока. Например, строка

```c++
cout << cin.flags () << endl;
```

выведет на экран целое значение соответствующее состоянию флагов потока ввода. А строка

```c++
cout << cout.flags () << endl;
```

выведет на экран целое значение соответствующее состоянию флагов потока вывода.

Эту функцию можно использовать и для изменения состояния флагов. Для этого при ее вызове в качестве параметра ей необходимо передать необходимое значение флага (флагов). Например, оператор `cout.flags(ios::hex)`; установит флаг `hex`, все остальные флаги будут сброшены.

Особенностью этой функции является то, что она сначала сбрасывает все флаги, а уже потом устанавливает флаг (флаги), заданный параметром.

Замечание. Если вызвать функцию следующим образом: `flags(0)`, то будут сброшены все флаги соответствующего потока.

Функция `setf` также служит для установки флагов. Она добавляет новый флаг (флаги) без изменения всех остальных.

```c++
/* 1 */       cout.flags(0);                     // Отключены все флаги
/* 2 */       cout.setf(ios :: showpos); // Установлен единственный флаг showpos
/* 3 */       cout.setf(ios :: hex);          // Установлены два флага - showpos и hex
```

Если требуется сбросить флаг (флаги), используют функцию `unsetf`. В качестве параметра используется значение флага (флагов), который необходимо отключить. При этом остальные флаги изменены не будут. Например, если добавить к предыдущим строкам программы строку:

```c++
/* 4 */       cout.unsetf(ios :: showpos);
```

флаг `showpos` будет отключен, и останется установленным только флаг `hex`.

При использовании этих процедур можно оперировать не одиночными флагами, а объединением нескольких флагов. Например, строки 2 и 3 можно заменить одной строкой:

```c++
cout.setf ( ios :: showpos | ios :: hex);
```

Объединение флагов осуществляется с помощью операции `|` - арифметическое ИЛИ.

Среди всех флагов можно выделить три группы, в каждой из которых флаги управляют одной и той же характеристикой ввода / вывода, но являются взаимоисключающими. Флагам каждой из этих групп в классе `ios` присвоены обобщающие имена:

Группа | Флаги | Обобщающее имя
-|-|-
Флаги основания систем счисления | `dec`, `oct`, `hex` | `basefield`
Флаги выравнивания | `left`, `right`, `internal` | `adjustfield`
Флаги формата вещественных значений | `scientific`, `fixed` | `floatfield`

Обобщающие имена групп удобно использовать для выполнения операции со всеми флагами группы, например, для сброса всех флагов группы:

```c++
cout.unsetf (ios :: basefield);     // Отключаем флаги dec, oct, hex
```

Более того, функцию `setf` можно использовать с двумя параметрами:

```c++
setf (новые флаги, маска)
```

В этом случае функция `setf` устанавливает только те флаги, которые одновременно присутствуют и в первом и во втором параметре, а те флаги, которые присутствуют во втором параметре, но отсутствуют в первом, будут сброшены. Это дает возможность отключать и включать флаги за один вызов функции `setf`. Например,  для установки любого флага из группы  `basefield` достаточно использовать всего один оператор:

```c++
cout.setf (ios :: hex, ios :: basefield);
```

Здесь второй параметр содержит три флага: `dec`, `oct`, `hex`. Первый параметр содержит флаг `hex`. Этот флаг будет установлен, а флаги `dec` и `oct` будут сброшены.

В классе co`ut имеются еще несколько функций управляющих форматом вывода данных. К ним относятся:

+ `precision` - определяет точность представления вещественных значений;
+ `width` - устанавливает ширину поля вывода;
+ `fill` - определяет символ заполнения при выводе данных.

## Использование `iomanip`

`Iomanip` – это библиотека в С++, которая предоставляет различные манипуляторы для управления форматированием вывода данных. Она позволяет задавать различные параметры вывода, такие как ширина поля, точность вывода чисел, заполнитель поля и многое другое.

Один из наиболее часто используемых манипуляторов из `iomanip` - это `setw()`, который позволяет задавать ширину поля вывода. Например, для вывода числа `42` с шириной поля `5` можно использовать следующий код:

```c++
#include <iostream>
#include <iomanip>

int main() {
    int number = 42;
    std::cout << "Number: " << std::setw(5) << number << std::endl;
    return 0;
}
```

Результатом выполнения данного кода будет строка "Number:    42", где число 42 отобразится в поле шириной в 5 символов, заполненное пробелами.

Следующим полезным манипулятором является `setprecision()`, который позволяет задавать точность вывода чисел. Например, для вывода числа `3.14159265359` с точностью 2 можно использовать следующий код:

```c++
#include <iostream>
#include <iomanip>

int main() {
    double pi = 3.14159265359;
    std::cout << "Pi: " << std::setprecision(2) << pi << std::endl;
    return 0;
}
```

Результатом выполнения данного кода будет строка `"Pi: 3.14"`. Здесь число `pi` будет выведено с точностью до двух знаков после запятой.

Еще одним полезным манипулятором библиотеки `iomanip` является `setfill()`, который позволяет задавать заполнитель поля вывода. Например, для вывода числа `42` в поле шириной `5` символов, заполненное символом `#`, можно использовать следующий код:

```c++
#include <iostream>
#include <iomanip>

int main() {
    int number = 42;
    std::cout << "Number: " << std::setfill('#') << std::setw(5) << number << std::endl;
    return 0;
}
```

Результатом выполнения данного кода будет строка `"Number: ###42"`, где число `42` отобразится в поле шириной в `5` символов, заполненное символами `'#'`.

Одним из полезных приемов при использовании iomanip является комбинирование различных манипуляторов. Например, для вывода числа 3.14 с точностью 2 и шириной поля 10 символов, заполненное символом '0', можно использовать следующий код:

```c++
#include <iostream>
#include <iomanip>

int main() {
    double pi = 3.14159265359;
    std::cout << "Pi: " << std::setfill('0') << std::setw(10) << std::setprecision(2) << pi << std::endl;
    return 0;
}
```

Результатом выполнения данного кода будет строка `"Pi: 00000003.14"`, где число `pi` будет выведено с точностью до двух знаков после запятой, поле будет иметь ширину `10` символов и будет заполнено символами '`0`'.

Описанные принципы и приемы работы с `iomanip` позволяют более гибко управлять выводом данных и делать его более красивым и читаемым. Это особенно полезно при работе с большим объемом данных или при необходимости вывести числа с определенной точностью или выравниванием. Успешное использование `iomanip` поможет вам создать программу, которая выглядит профессионально и ясно комментирует ваш код.

Для чего нужна приставка `ios::`?

+ [ ] Приставка `ios::` позволяет расходовать меньше памяти
+ [ ] Приставка `ios::` указывает на то, что определение флага принадлежит пространству имён ios
+ [ ] Приставка `ios::` указывает на то, что определение флага принадлежит классу операционной системе iOS
+ [x] Приставка `ios::` указывает на то, что определение флага принадлежит классу ios.

![03](/CPP_from_LETI/LETI_01/img/03_07.PNG)

Соотнесите флаги с группами, к которым они относятся. 

![03](/CPP_from_LETI/LETI_01/img/03_08.PNG)

Напишите программу, которая выведет в консоль названия всех времен года в порядке: зима, весна, лето, осень

```c++
#include <iostream>

using namespace std;

int main() {
    setlocale (0, "");
    puts("зима, весна, лето, осень\n");
return 0;
}
```

Используя функции, управляющие форматом вывода данных, напишите программу, которая будет выводить строку "..........123" (10 точек и '123').

```c++
#include <iomanip>
#include <iostream>

int main() {
  int a = 123;
  std::cout << ".........." << a << std::endl;
  return 0;
}
```

# 3.4 Целочисленные типы данных

Размер типа `int` не определяется стандартом, а зависит от компьютера и компилятора. Для 16-разрядного процессора под величины этого типа отводится 2 байта – в этом случае диапазон возможных значений составляет -32 768 ... 32 767 (2 в степени 16 различных значений). Для 32-разрядного - 4 байта – диапазон значений -2 147 483 648 ... 2 147 483 647 (2 в степени 32 различных значений).

Спецификатор `short` перед именем типа указывает компилятору, что под число требуется отвести 2 байта независимо от разрядности процессора.

Спецификатор `long` означает, что целая величина будет занимать 4 байта. Таким образом, на 16-разрядном компьютере эквиваленты `int` и `short int`, а на 32-разрядном — `int` и `long int`.

При определении переменных вместо `short int` или `long int` можно использовать более короткие обозначения: `short` или `long` соответственно:

```c++
short a;
long b;
```

Использование типов `int`, `short int (short)`, `long int (long)` подразумевает представление целых чисел со знаком, поэтому спецификатор `signed` можно не указывать.

Внутреннее представление величины целого типа — целое число в двоичном коде. Например, число  `+22` типа `short int (short)` представляются в памяти так:

```
Номера разрядов:  15  14  13  12  11  10  9    8    7    6    5    4    3    2    1    0
Значения разрядов:  0    0    0    0    0    0    0    0    0    0    0    1    0    1    1    0     
```

а отрицательное число `-22` выглядит следующим образом:

```
Номера разрядов:  15  14  13  12  11  10  9    8    7    6    5    4    3    2    1    0
Значения разрядов:  1    1    1    1    1    1    1    1    1    1    1    0   1    0    1    0     
```

При использовании спецификатора `signed` (или при его отсутствии) старший бит числа (в данном случае – разряд с номером `15`) интерпретируется как знаковый (`О` — положительное число, `1` — отрицательное).

Спецификатор `unsigned` позволяет представлять только положительные числа, при этом старший разряд рассматривается как часть кода числа. Таким образом, диапазон значений типа `int` зависит от спецификаторов. Диапазоны значений величин целого типа со спецификатором `unsigned` выглядят так:
```c
unsigned int // (16-разрядного процессор): от 0 до 65 535;
unsigned int // (32-разрядного процессор): от 0 до 4 294 967 295;
unsigned short int /*или*/ unsigned short // (не зависимо от процессора): от 0 до 65 535. 
```

По умолчанию все целочисленные типы считаются знаковыми, то есть спецификатор `signed` можно опускать.

Целые константы литералы можно задавать в трех форматах: в десятичном, восьмеричном и в шестнадцатеричном.

В десятичном формате целые значения записываются в обычном виде:

```
1345   +34   -245
```

В восьмеричном формате сначала записывается 0 (нуль), а за ним восьмеричные разряды самого числа:

```
011     07345    -0456
```

В шестнадцатеричном формате значащим разрядам числа должны предшествовать символы 0x или 0X:

```
0x12B5   -0xAF2B    0X1FF02
```

Как уже говорилось ранее, константам, встречающимся в программе, приписывается тот или иной тип в соответствии с их видом. Если этот тип по каким-либо причинам не устраивает программиста, он может явно указать требуемый тип с помощью суффиксов L, l (long) и u, U (unsigned). Например, константа 32L будет иметь тип long и занимать 4 байта. Можно использовать суффиксы L и U одновременно, например, Ox22UL или 05LU.

Результат выполнения программы:

```c++
#include "pch.h"
#include <iostream>

int main() {
	int a = 3;
	int b = 4;
	unsigned c;
	c = a - b;
	std::cout << c;
}
```

+ [ ] 1
+ [ ] 7
+ [x] 4294967295
+ [ ] Программа не запустится

## Калькулятор 

Вводится два целых числа. Необходимо вывести их сумму, разность, произведение и частное.
```
а + б
а - б
а * б
а / б
```
Формат входных данных<br>
На вход дается два натуральных число a и b.<br>
Формат выходных данных<br>
Выведите четыре целых числа - результаты арифметических операций<br>
Sample Input:<br>
1 2<br>
Sample Output:<br>
3 -1 2 0<br>

```c++
#include <iostream>

int main() {
    int a, b;
    std::cin >> a >> b;

    printf("%d %d %d %d", a + b, a - b, a * b, a / b);
    return 0;
}
```

## Число десятков

Дано целое неотрицательное число N, определите число десятков в нем (предпоследнюю цифру числа).<br>
Формат входных данных<br>
На вход дается целое положительное число N (0 ≤ N ≤ 1000000).<br>
Формат выходных данных<br>
Целое число, ответ на поставленную задачу<br>
```c++
int a = 10 / 3; // Результат - деление - 3
int a = 10 % 3; // Результат - остаток от деления - 1
```
Sample Input:<br>
841<br>
Sample Output:<br>
4<br>

```c++
#include <iostream>

int main() {
    int a;
    std::cin >> a;

    int result = (a / 10) % 10;

    std::cout << result << std::endl;

    return 0;
}
```

## Последняя цифра

Дано натуральное число, выведите его последнюю цифру.<br>
Формат входных данных<br>
На вход дается натуральное число N.<br>
Формат выходных данных<br>
Выведите одно целое число - ответ на задачу.<br>

```c++
int a = 10 / 3; // Результат - деление - 3
int a = 10 % 3; // Результат - остаток от деления - 1
```
Sample Input:<br>
67<br>
Sample Output:<br>
7<br>

```c++
#include <iostream>

int main() {
    int a;
    std::cin >> a;

    int result = a % 10;

    std::cout << result << std::endl;

    return 0;
}
```

## Сумма цифр двухзначного числа

Дано целое число. Найдите сумму его цифр.<br>
Формат входных данных<br>
На вход дается число от 10 до 99.<br>
Формат выходных данных<br>
Выведите одно целое число - ответ на задачу.<br>
Sample Input:<br>
99<br>
Sample Output:<br>
18<br>

```c++
#include <iostream>

int main() {
    int a;
    std::cin >> a;

    int result = a % 10 + a / 10;

    std::cout << result << std::endl;

    return 0;
}
```

## Симметричное число

Дано четырехзначное число. Выведите его в обратном порядке.<br>
Формат входных данных<br>
Вводится одно четырехзначное число.<br>
Формат выходных данных<br>
Выводится число в обратной записи.<br>
Sample Input:<br>
1234<br>
Sample Output:<br>
4321<br>

```c++
#include <iostream>

int main() {
    int a;
    std::cin >> a;
    int result = 0;
    while (a > 0) {
        result = result * 10 + a % 10;
        a /= 10;
    }
    printf("%04d", result);
    return 0;
}
```

# 3.5 Вещественные типы данных

