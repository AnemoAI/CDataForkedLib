# 3. Объектно-ориентированная парадигма

## Содержание

+ [3.1 Фундаменты ООП](#31-фундаменты-ооп)
    + [Абстракция](#абстракция)
    + [Инкапсуляция](#инкапсуляция)
    + [Наследование](#наследование)
    + [Ключи доступа](#ключи-доступа)
    + [Простое наследование](#простое-наследование)
    + [Правила наследования различных методов](#правила-наследования-различных-методов)
    + [Виртуальные методы](#виртуальные-методы)
    + [Механизм позднего связывания](#механизм-позднего-связывания)
    + [Абстрактные классы](#абстрактные-классы)
    + [Множественное наследование](#множественное-наследование)
    + [Задачи](#задачи-1)
+ [3.2 Принципы SOLID ООП](#32-принципы-solid-ооп)
    + [Принцип единственной ответственности (SRP)](#принцип-единственной-ответственности-srp)
        + [Признак 1: непреднамеренное дублирование](#признак-1-непреднамеренное-дублирование)
        + [Признак 2: слияния](#признак-2-слияния)
        + [Решение](#решение)
    + [Принцип открытости/закрытости (OCP)](#принцип-открытостизакрытости-ocp)
    + [Принцип подстановки Барбары Лисков (LSP)](#принцип-подстановки-барбары-лисков-lsp)
        + [Проблема квадрат/прямоугольник](#проблема-квадратпрямоугольник)
    + [Принцип разделения интерфейса (ISP)](#принцип-разделения-интерфейса-isp)
    + [Принцип инверсии зависимостей (DIP)](#принцип-инверсии-зависимостей-dip)
    + []()
[Оглавление](/CPP_from_LETI/LETI_03/README.md)

# 3.1 Фундаменты ООП

## Абстракция

История телефонов превышает 100 лет и современный гаджеты, в отличие от своего предшественника из 19 века, представляет собой куда более сложное устройство.

Когда мы пользуемся телефоном, то не задумываемся о его устройстве и процессах, происходящих внутри него. Мы просто используем функции, предоставленные разработчиками телефона — кнопки или сенсорный экран для выбора номера и совершения вызовов.

Одним из первых интерфейсов телефона была рукоятка, которую нужно было вращать, чтобы сделать вызов. Разумеется, это было не очень удобно. Тем не менее, свою функцию рукоять исправно выполняла.

Если посмотреть на самый современный и на самый первый телефон, можно сразу выделить самые важные детали, которые важны и для устройства конца 19-го века, и для суперсовременного смартфона. Это совершение вызова (набор номера) и приём вызова. По сути это то, что делает телефон телефоном, а не чем-то другим. Сейчас мы применили принцип в ООП — выделение наиболее важных характеристик и информации об объекте. Этот принцип ООП называется абстракцией.

Абстракцию в ООП можно также определить, как способ представления элементов задачи из реального мира в виде объектов в программе. Абстракция всегда связана с обобщением некоторой информации о свойствах предметов или объектов, поэтому главное — это отделить значимую информацию от незначимой в контексте решаемой задачи. При этом уровней абстракции может быть несколько.

<hr>

[Содержание](#содержание)

## Инкапсуляция

Инкапсуляция упоминается как часть определения ООП потому, что языки ООП поддерживают простой и эффективный способ инкапсуляции данных и функций. Как результат, есть возможность очертить круг связанных данных и функций. За пределами круга эти данные невидимы и доступны только некоторые функции. Воплощение этого понятия можно наблюдать в виде приватных членов данных и общедоступных членов-функций класса.

С помощью абстракции мы выделяем общее для всех объектов. Однако каждая модель телефона — индивидуальна и чем-то отличается от других. Как же нам в программе провести границы и обозначить эту индивидуальность?

Как сделать так, чтоб никто из пользователей случайно или преднамеренно не смог сломать наш телефон, или попытаться переделать одну модель в другую? 

Для мира реальных объектов ответ очевиден: нужно поместить все детали в корпус телефона. Ведь если этого не сделать и оставить все внутренности телефона и провода, соединяющие их снаружи, обязательно найдется любознательный экспериментатор, который захочет “улучшить” работу нашего телефона. 

Для исключения подобного вмешательства в конструкцию и работу объекта в ООП используют принцип инкапсуляции – еще один базовый принцип ООП, при котором атрибуты и поведение объекта объединяются в одном классе, внутренняя реализация объекта скрывается от пользователя, а для работы с объектом предоставляется открытый интерфейс.

Задача программиста — определить, какие атрибуты и методы будут доступны для открытого доступа, а какие являются внутренней реализацией объекта и должны быть недоступны для изменений.

В мире C++ состояние будущих объектов описывается в классе с помощью полей, а их поведение – с помощью методов. Возможность же изменения состояния и поведения осуществляется с помощью модификаторов доступа к полям и методам – `private`, `protected`, `public`, а также `default` (доступ по умолчанию).

Модификатор `private` делает доступными поля и методы класса только внутри данного класса. Это означает, что получить доступ к `private` полям из вне невозможно, как и нет возможности вызвать `private` методы.

<hr>

[Содержание](#содержание)

## Наследование

Механизм наследования классов позволяет строить иерархии, в которых производные классы получают элементы родительских, или базовых, классов и могут дополнять их или изменять их свойства. При большом количестве никак не связанных классов управлять ими становится невозможным. Наследование позволяет справиться с этой проблемой путем упорядочивания и ранжирования классов, то есть объединения общих для нескольких классов свойств в одном классе и использования его в качестве базового.

Классы, находящиеся ближе к началу иерархии, объединяют в себе наиболее общие черты для всех нижележащих классов. По мере продвижения вниз по иерархии классы приобретают все больше конкретных черт. Множественное наследование позволяет одному классу обладать свойствами двух и более родительских классов.

<hr>

[Содержание](#содержание)

## Полиморфизм

Полиморфизм – это способность программы идентично использовать объекты с одинаковым интерфейсом без информации о конкретном типе этого объекта. Если вы ответите на вопрос, что такое полиморфизм, таким образом, вас, скорее всего, попросят объяснить, что вы имели ввиду. Лишний раз, не напрашиваясь на кучу дополнительных вопросов, разложите интервьюеру все по полочкам. Тесно связано с наследованием.

![03](/CPP_from_LETI/LETI_03/img/03_01.jpg)

Поскольку С++ относится к строго типизированным языкам, в программном коде всегда нужно указать тип объекта при объявлении переменных. К этому добавьте, что строгая типизация повышает безопасность кода, и надежность программы и позволяет еще на стадии компиляции предотвратить ошибки несовместимости типов (например, попытку разделить строку на число).

В C++ каждая виртуальная функция в классе представлена указателем в таблице виртуальных методов `vtable` и все вызовы виртуальных функций выполняются через эту таблицу. Конструкторы производных классов просто инициализируют таблицу `vtable` объекта указателями на свои версии функций.

Суть полиморфизма заключается в применении указателей на функции. Программисты использовали указатели на функции для достижения полиморфного поведения еще со времен появления архитектуры фон Неймана в конце 1940-х годов. Иными словами, парадигма ООП не принесла ничего нового.

Впрочем, это не совсем верно. Пусть полиморфизм появился раньше языков ООП, но они сделали его намного надежнее и удобнее.

Проблема явного использования указателей на функции для создания полиморфного поведения в том, что указатели на функции по своей природе опасны. Такое их применение оговаривается множеством соглашений. Вы должны помнить об этих соглашениях и инициализировать указатели. Вы должны помнить об этих соглашениях и вызывать функции посредством указателей. Если какой-то программист забудет о соглашениях, возникшую в результате ошибку будет чертовски трудно отыскать и устранить.

Языки ООП избавляют от необходимости помнить об этих соглашениях и, соответственно, устраняют опасности, связанные с этим. Поддержка полиморфизма на уровне языка делает его использование тривиально простым. Это обстоятельство открывает новые возможности, о которых программисты на С могли только мечтать. Отсюда можно заключить, что ООП накладывает ограничение на косвенную передачу управления.

<hr>

[Содержание](#содержание)

## Ключи доступа

При описании класса в его заголовке перечисляются все классы, являющиеся для него базовыми. Возможность обращения к элементам этих классов регулируется с помощью ключей доступа `private`, `protected` и `public`:

```c++
class имя : [private | protected | public] базовыйКласс
{ тело класса };
```

Если базовых классов несколько, они перечисляются через запятую. Ключ доступа может стоять перед каждым классом, например:

```c++
class А { ... };
class В { ... };
class С { ... };
class D: А, protected В, public С { ... }: 
```

По умолчанию для классов используется ключ доступа `private`, а для структур — `public`.

До сих пор мы рассматривали только применяемые к элементам класса спецификаторы доступа `private` и `public`. Для любого элемента класса может также использоваться спецификатор `protected`, который для одиночных классов, не входящих в иерархию, равносилен `private`. Разница между ними проявляется при наследовании, что можно видеть из приведенной таблицы:

![03](/CPP_from_LETI/LETI_03/img/03_02.jpg)

Как видно из таблицы, `private` элементы базового класса в производном классе недоступны вне зависимости от ключа. Обращение к ним может осуществляться только через методы базового класса.

Элементы `protected` при наследовании с ключом `private` становятся в производном классе `private`, в остальных случаях права доступа к ним не изменяются.

Доступ к элементам `public` при наследовании становится соответствующим ключу доступа.

Если базовый класс наследуется с ключом `private`, можно выборочно сделать некоторые его элементы доступными в производном классе, объявив их в секции `public` производного класса с помощью операции доступа к области видимости:

```c++
class Base {
  ...
  public: void f();
};

class Derived : private Base {
  ...
  public: Base::void f();
};
```

<hr>

[Содержание](#содержание)

## Простое наследование

Простым называется наследование, при котором производный класс имеет одного родителя. Для различных методов класса существуют разные правила наследования — например, конструкторы и операция присваивания в производном классе не наследуются, а деструкторы наследуются. Рассмотрим наследование классов и проблемы, возникающие при этом, на примере.

Создадим производный от класса `Monster` класс `Daemon`, добавив полезную в некоторых случаях способность думать. Базовый класс приведен с некоторыми методами, добавленными в предыдущих разделах:

```c++
#include <iostream>
#include <string.h>

enum Color { red, green, blue };

// Класс Monster
class Monster {
    // -- Скрытые поля класса:
    int health, ammo;
    Color skin;
    char *name;

   public:
    // Конструкторы:
    Monster(int he = 100, int am = 10);
    Monster(Color sk);
    Monster(char *nam);
    Monster(Monster &M);

    // Деструктор:
    ~Monster() { delete[] name; };

    // Операции:
    Monster &operator++() {
        ++health;
        return *this;
    };
    Monster operator++(int) {
        Monster M(*this);
        health++;
        return M;
    };
    operator int() { return health; }
    bool operator>(Monster &M) { return health > M.health ? true : false; }
    const Monster &operator=(Monster &M) {
        if (&M == this) return *this;
        if (name) delete[] name;
        if (M.name) {
            name = new char[strlen(M.name) + 1];
            strcpy(name, M.name);
        } else
            name = 0;
        health = M.health;
        ammo = M.ammo;
        skin = M.skin;
        return *this;
    }

    // Методы доступа к полям:
    int getHealth() const { return health; }
    int getAmmo() const { return ammo; }
    // Методы, изменяющие значения полей:

    void changeHealth(int he) { health << he; }
    // Прочие методы:

    void draw(int x, int y, int scale, int position);
};

// Реализация класса monster
Monster::Monster(int he, int am) : health(he), ammo(am), skin(red), name(0) {}

Monster::Monster(Monster &M) {
    if (M.name) {
        name = new char[strlen(M.name) + 1];
        strcpy(name, M.name);
    } else
        name = 0;
    health - M.health;
    ammo - M.ammo;
    skin = M.skin;
}

Monster::Monster(Color sk) {
    switch (sk) {
        case red:
            health = 100;
            ammo = 10;
            skin = red;
            name = 0;
            break;
        case green:
            health = 100;
            ammo = 20;
            skin = green;
            name = 0;
            break;
        case blue:
            health = 100;
            ammo = 40;
            skin = blue;
            name = 0;
            break;
    }
}

Monster::Monster(char *nam) {
    name = new char[strlen(nam) + 1];
    strcpy(name, nam);
    health = 100;
    ammo = 10;
    skin << red;
}

void Monster::draw(int x, int y, int scale, int position) { /* ... Отрисовка monster */
}

// Класс Daemon
class Daemon : public Monster {
    int brain;

   public:
    // Конструкторы:
    Daemon(int br = 10) { brain = br; };
    Daemon(Color sk) : Monster(sk) { brain = 10; };
    Daemon(char *nam) : Monster(nam) { brain = 10; };
    Daemon(Daemon &M) : Monster(M) { brain = M.brain; };

    // Операции:
    const Daemon &operator=(Daemon &M) {
        if (M == *this) return *this;
        brain = M.brain;
        Monster::operator=(M);
        return *this;
    }

    // Методы, изменяющие значения полей:
    void think();
    // Прочие методы:
    void draw(int х, int у, int scale, int position);
};

// Реализация класса Daemon
void Daemon::think() { /* ... */
}
void Daemon::draw(int x, int y, int scale, int position) { /* ... Отрисовка Daemon */
}
```

В классе `Daemon` введено поле `brain` и метод `think`, определены собственные конструкторы и операция присваивания, а также переопределен метод отрисовки `draw`. Все поля класса `Monster`, операции (кроме присваивания) и методы `getHealth`, `getAmmo` и `changeHealth` наследуются в классе `Daemon`, а деструктор формируется по умолчанию.

<hr>

[Содержание](#содержание)

## Правила наследования различных методов

Конструкторы не наследуются, поэтому производный класс должен иметь собственные конструкторы. Порядок вызова конструкторов определяется приведенными ниже правилами.
+ Если в конструкторе производного класса явный вызов конструктора базового класса отсутствует, автоматически вызывается конструктор базового класса по умолчанию (то есть тот, который можно вызвать без параметров). Это использовано в первом из конструкторов класса `Daemon`.
+ Для иерархии, состоящей из нескольких уровней, конструкторы базовых классов вызываются начиная с самого верхнего уровня. После этого выполняются конструкторы тех элементов класса, которые являются объектами, в порядке их объявления в классе, а затем исполняется конструктор класса.
+ В случае нескольких базовых классов их конструкторы вызываются в порядке объявления.

__Если конструктор базового класса требует указания параметров, он должен быть явным образом вызван в конструкторе производного класса в списке инициализации.__

Не наследуется и операция присваивания, поэтому ее также требуется явно определить в классе `Daemon`. Обратите внимание на запись функции-операции: в ее теле применен явный вызов функции-операции присваивания из базового класса. Чтобы лучше представить себе синтаксис вызова, ключевое слово `operator` вместе со знаком операции можно интерпретировать как имя функции-операции.

Вызов функций базового класса предпочтительнее копирования фрагментов кода из функций базового класса в функции производного. Кроме сокращения объема кода, этим достигается упрощение модификации программы: изменения требуется вносить только в одну точку программы, что сокращает количество возможных ошибок.

Ниже перечислены правила наследования деструкторов.
+ Деструкторы не наследуются, и если программист не описал в производном классе деструктор, он формируется по умолчанию и вызывает деструкторы всех базовых классов.
+ В отличие от конструкторов, при написании деструктора производного класса в нем не требуется явно вызывать деструкторы базовых классов, поскольку это будет сделано автоматически.
+ Для иерархии классов, состоящей из нескольких уровней, деструкторы вызываются в порядке, строго обратном вызову конструкторов:
    + сначала вызывается деструктор класса,
    + затем — деструкторы элементов класса,
    + а потом деструктор базового класса.

Поля, унаследованные из класса `Monster`, недоступны функциям производного класса, поскольку они определены в базовом классе как `private`. Если функциям, определенным в `Daemon`, требуется работать с этими полями, можно либо описать их в базовом классе как `protected`, либо обращаться к ним с помощью функций из `Monster`, либо явно переопределить их в `Daemon`.

Рассматривая наследование методов, обратите внимание на то, что в классе `Daemon` описан метод `draw`, переопределяющий метод с тем же именем в классе `Monster`(поскольку отрисовка различных персонажей, естественно, выполняется по-разному). Таким образом, производный класс может не только дополнять, но и корректировать поведение базового класса. Доступ к переопределенному методу базового класса для производного класса выполняется через имя, уточненное с помощью операции доступа к области видимости (`::`).

<hr>

[Содержание](#содержание)

## Виртуальные методы

Работа с объектами чаще всего производится через указатели. Указателю на базовый класс можно присвоить значение адреса объекта любого производного класса, например:

```c++
// Описывается указатель на базовый класс:
Monster *р;
// Указатель ссылается на объект производного класса:
р = new Daemon;
```

Вызов методов объекта происходит в соответствии с типом указателя, а не фактическим типом объекта, на который он ссылается, поэтому при выполнении оператора, например,

```
p->draw(1, 1, 1, 1);
```

будет вызван метод класса `Monster`, а не класса `Daemon`, поскольку ссылки на методы разрешаются во время компоновки программы. Этот процесс, называется ранним связыванием. Чтобы вызвать метод класса `Daemon`, можно использовать явное преобразование типа указателя:

```c++
(Daemon* p) -> draw(1, 1, 1, 1);
```

Это не всегда возможно, поскольку в разное время указатель может ссылаться на объекты разных классов иерархии, и во время компиляции программы конкретный класс может быть неизвестен. В качестве примера можно привести функцию, параметром которой является указатель на объект базового класса. На его место во время выполнения программы может быть передан указатель на любой производный класс. Другой пример — связный список указателей па различные объекты иерархии, с которым требуется работать единообразно.

В C++ реализован механизм позднего связывания, когда разрешение ссылок на метод происходит на этапе выполнения программы в зависимости от конкретного типа объекта, вызвавшего метод. Этот механизм реализован с помощью виртуальных методов.

Для определения виртуального метода используется спецификатор `virtual`, например:

```c++
virtual void draw(int х, int у, int scale, int position); 
```

Рассмотрим правила описания и использования виртуальных методов.
+ Если в базовом классе метод определен как виртуальный, метод, определенный в производном классе с тем же именем и набором параметров, автоматически становится виртуальным, а с отличающимся набором параметров — обычным.
+ Виртуальные методы наследуются, то есть переопределять их в производном классе требуется только при необходимости задать отличающиеся действия. Права доступа при переопределении изменить нельзя.
+ Если виртуальный метод переопределен в производном классе, объекты этого класса могут получить доступ к методу базового класса с помощью операции доступа к области видимости.
+ Виртуальный метод не может объявляться с модификатором `static`, но может быть объявлен как дружественный.
+ Если в классе вводится описание виртуального метода, он должен быть определен хотя бы как чисто виртуальный.

Чисто виртуальный метод содержит признак `= 0` вместо тела, например: 

```c++
virtual void f(int) = 0;
```

Чисто виртуальный метод должен переопределяться в производном классе (возможно, опять как чисто виртуальный).

Если определить метод `draw` в классе `Monster` как виртуальный, решение о том, метод какого класса вызвать, будет приниматься в зависимости от типа объекта, на который ссылается указатель:

```c++
Monster *r, *р;
r = new Monster; // Создается объект класса Monster
р = new daemon; // Создается объект класса Daemon
r -> draw(1, 1, 1, 1); // Вызывается метод Monster::draw
p -> draw(1, 1, 1, 1); // Вызывается метод Daemon::draw 
р -> Monster::draw(1, 1, 1, 1); // Обход механизма виртуальных методов
```

Если объект класса `Daemon` будет вызывать метод `draw` не непосредственно, а косвенно (то есть из другого метода, определенного в классе `Monster`), будет вызван метод `draw` класса `Daemon`.

Итак, виртуальным называется методу ссылка на который разрешается на этапе выполнения программы (перевод красивого английского слова `virtual` — в данном значении всего-навсего «фактический», то есть ссылка разрешается по факту вызова).

<hr>

[Содержание](#содержание)

## Механизм позднего связывания

Для каждого класса (не объекта!), содержащего хотя бы один виртуальный метод, компилятор создает таблицу виртуальных методов (`vtbl`), в которой для каждого виртуального метода записан его адрес в памяти. Адреса методов содержатся в таблице в порядке их описания в классах. Адрес любого виртуального метода имеет в `vtbl` одно и то же смещение для каждого класса в пределах иерархии.

Каждый объект содержит скрытое дополнительное поле ссылки на `vtbl`, называемое `vptr`. Оно заполняется конструктором при создании объекта (для этого компилятор добавляет в начало тела конструктора соответствующие инструкции).

На этапе компиляции ссылки на виртуальные методы заменяются на обращения к `vtbl` через `vptr` объекта, а на этапе выполнения в момент обращения к методу его адрес выбирается из таблицы. Таким образом, вызов виртуального метода, в отличие от обычных методов и функций, выполняется через дополнительный этап получения адреса метода из таблицы. Это несколько замедляет выполнение программы.

Рекомендуется делать виртуальными деструкторы для того, чтобы гарантировать правильное освобождение памяти из-под динамического объекта, поскольку в этом случае в любой момент времени будет выбран деструктор, соответствующий фактическому типу объекта. Деструктор передает операции `delete` размер объекта, имеющий тип `size_t`. Если удаляемый объект является производным и в нем не определен виртуальный деструктор, передаваемый размер объекта может оказаться неправильным.

Четкого правила, по которому метод следует делать виртуальным, не существует. Можно только дать рекомендацию объявлять виртуальными методы, для которых есть вероятность, что они будут переопределены в производных классах. Методы, которые во всей иерархии останутся неизменными или те, которыми производные классы пользоваться не будут, делать виртуальными нет смысла. С другой стороны, при проектировании иерархии не всегда можно предсказать, каким образом будут расширяться базовые классы (особенно при проектировании библиотек классов), а объявление метода виртуальным обеспечивает гибкость и возможность расширения.

Для пояснения последнего тезиса представим себе, что вызов метода `draw` осуществляется из метода перемещения объекта. Если текст метода перемещения не зависит от типа перемещаемого объекта (поскольку принцип перемещения всех объектов одинаков, а для отрисовки вызывается конкретный метод), переопределять этот метод в производных классах нет необходимости, и он может быть описан как невиртуальный. Если метод `draw` виртуальный, метод перемещения сможет без перекомпиляции работать с объектами любых производных классов — даже тех, о которых при его написании ничего известно не было.

Виртуальный механизм работает только при использовании указателей или ссылок на объекты. Объект, определенный через указатель или ссылку и содержащий виртуальные методы, называется полиморфным. В данном случае полиморфизм состоит в том, что с помощью одного и того же обращения к методу выполняются различные действия в зависимости от типа, на который ссылается указатель в каждый момент времени.

<hr>

[Содержание](#содержание)

## Абстрактные классы

Класс, содержащий хотя бы один чисто виртуальный метод, называется абстрактным. Абстрактные классы предназначены для представления общих понятий, которые предполагается конкретизировать в производных классах. Абстрактный класс может использоваться только в качестве базового для других классов — объекты абстрактного класса создавать нельзя, поскольку прямой или косвенный вызов чисто виртуального метода приводит к ошибке при выполнении.

При определении абстрактного класса необходимо иметь в виду следующее:
+ абстрактный класс нельзя использовать при явном приведении типов, для описания типа параметра и типа возвращаемого функцией значения;
+ допускается объявлять указатели и ссылки на абстрактный класс, если при инициализации не требуется создавать временный объект;
+ если класс, производный от абстрактного, не определяет все чисто виртуальные функции, он также является абстрактным.

Таким образом, можно создать функцию, параметром которой является указатель на абстрактный класс. На место этого параметра при выполнении программы может передаваться указатель на объект любого производного класса. Это позволяет создавать полиморфные функции^ работающие с объектом любого типа в пределах одной иерархии.

<hr>

[Содержание](#содержание)

## Множественное наследование

Множественное наследование (в Java запрещено) означает, что класс имеет несколько базовых классов. Если в базовых классах есть одноименные элементы, при этом может произойти конфликт идентификаторов, который устраняется с помощью операции доступа к области видимости:

```c++
class Monster {
  public: 
    int getHealth();
  ...
};

class Hero {
  public: 
    int getHealth();
  ...
};

class Ostrich: public Monster, public Hero {
  ...
};

int main() {
    ostrich A;
    std::cout << A.Monster::getHealth();
    std::cout << A.Hero::getHealth();
}
```

Как видно из примера, для вызова метода `getHealth` требуется явно указывать класс, в котором он описан. Использование обычной для вызова метода класса конструкции `A.getHealth()` приведет к ошибке, поскольку компилятор не в состоянии разобраться, к методу какого из базовых классов требуется обратиться.

Если у базовых классов есть общий предок, это приведет к тому, что производный от этих базовых класс унаследует два экземпляра полей предка, что чаще всего является нежелательным. Чтобы избежать такой ситуации, требуется при наследовании общего предка определить его как виртуальный класс:

```c++
class Monster{
  ...
};

class Daemon: virtual public Monster{
  ...
};

class Lady: virtual public Monster{
  ...
};

class Baby: public Daemon, public Lady{
  ...
};
```

Класс `Baby` содержит только один экземпляр полей класса `Monster`. Если базовый класс наследуется и как виртуальный, и обычным образом, в производном классе будут присутствовать отдельные экземпляры для каждого невиртуального вхождения и еще один экземпляр для виртуального.

Множественное наследование применяется для того, чтобы обеспечить производный класс свойствами двух или более базовых. Чаще всего один из этих классов является основным, а другие обеспечивают некоторые дополнительные свойства, поэтому они называются классами подмешивания. По возможности классы подмешивания должны быть виртуальными и создаваться с помощью конструкторов без параметров, что позволяет избежать многих проблем, возникающих при ромбовидном наследовании (когда у базовых классов есть общий предок).

<hr>

[Содержание](#содержание)

## Задачи 1

Что называется наследованием?

+ [ ] это механизм, посредством которого производный класс получает все поля базового класса
+ [ ] это механизм переопределения методов базового класса
+ [ ] это механизм, посредством которого производный класс получает элементы родительского, может их дополнить, но не может переопределить
+ [x] это механизм, посредством которого производный класс получает элементы родительского и может дополнять либо изменять их свойства и методы

Выберите все подходящие ответы из списка

+ [x] Для иерархии, состоящей из нескольких уровней, конструкторы базовых классов вызываются начиная с самого верхнего уровня
+ [x] Если в конструкторе производного класса явный вызов конструктора базового класса отсутствует, автоматически вызывается конструктор базового класса по умолчанию
+ [x] Если конструктор базового класса требует указания параметров, он должен быть явным образом вызван в конструкторе производного класса в списке инициализации
+ [x] В случае нескольких базовых классов их конструкторы вызываются в порядке объявления

Выберите все подходящие ответы из списка


+ [x] Для иерархии классов, состоящей из нескольких уровней, деструкторы вызываются в порядке, строго обратном вызову конструкторов
+ [ ] Производный класс не может корректировать поведение базового класса
+ [x] Деструкторы не наследуются, и если программист не описал в производном классе деструктор, он формируется по умолчанию и вызывает деструкторы всех базовых классов
+ [x] Производный класс может не только дополнять, но и корректировать поведение базового класса
+ [x] В отличие от конструкторов, при написании деструктора производного класса в нем не требуется явно вызывать деструкторы базовых классов, поскольку это будет сделано автоматически
+ [ ] Сначала вызывается деструктор базового класса, затем деструкторы элементов класса

Класс, содержащий хотя бы один чисто виртуальный метод, называется [абстрактным]

Выберите все подходящие ответы из списка

+ [x] Абстрактный класс может использоваться только в качестве базового для других классов
+ [x] Если класс, производный от абстрактного, не определяет все чисто виртуальные функции, он также является абстрактным
+ [x] Допускается объявлять указатели и ссылки на абстрактный класс, если при инициализации не требуется создавать временный объект

<hr>

[Содержание](#содержание)


# 3.2 Принципы SOLID ООП

## Принцип единственной ответственности (SRP)

Соответствует букве `S` акронима `SOLID`. Согласно этому принципу, не должно быть более одной причины для изменения класса, или класс должен всегда обрабатывать одну функциональность.

Из всех принципов `SOLID` наиболее трудно понимаемым является принцип единственной ответственности (`Single Responsibility Principle, SRP`). Это, вероятно, обусловлено выбором названия, недостаточно точно соответствующего сути. Услышав это название, многие программисты решают: оно означает, что каждый модуль должен отвечать за что-то одно.

Самое интересное, что такой принцип действительно существует. Он гласит: функция должна делать что-то одно и только одно. Этот принцип мы используем, когда делим большие функции на меньшие, то есть на более низком уровне. Но он не является одним из принципов `SOLID` — это не принцип единственной ответственности.

Традиционно принцип единственной ответственности описывался так:

**_Модуль должен иметь одну и только одну причину для изменения._**

Программное обеспечение изменяется для удовлетворения нужд пользователей и заинтересованных лиц. Пользователи и заинтересованные лица как раз и есть та самая «причина для изменения», о которой говорит принцип. Фактически принцип можно перефразировать так:

**_Модуль должен отвечать за одного и только за одного пользователя или заинтересованное лицо._**

К сожалению, слова «пользователь» и «заинтересованное лицо» не совсем правильно использовать здесь, потому что одного и того же изменения системы могут желать несколько пользователей или заинтересованных лиц. Более правильным выглядит понятие группы, состоящей из одного или нескольких лиц, желающих данного изменения. Мы будем называть такие группы актёрами (`actor`).

Соответственно, окончательная версия принципа единственной ответственности выглядит так:

**_Модуль должен отвечать за одного и только за одного актёра._**

Теперь определим, что означает слово «модуль». 

Самое простое определение — файл с исходным кодом. 

В большинстве случаев это определение можно принять. Однако некоторые языки среды разработки не используют исходные файлы для хранения кода. В таких случаях модуль — это просто связный набор функций и структур данных.

Слово «связный» подразумевает принцип единственной ответственности. Связность — это сила, которая связывает код, ответственный за единственного актёра. Пожалуй, лучший способ понять суть этого принципа — исследовать признаки его нарушения.

<hr>

[Содержание](#содержание)

## Признак 1: непреднамеренное дублирование

Класс `Employee` из приложения платежной ведомости. Он имеет три метода: `calculatePay()`, `reportHours()` и `save()`.

![03](/CPP_from_LETI/LETI_03/img/03_03.jpg)

Этот класс нарушает принцип единственной ответственности, потому что три его метода отвечают за три разных актора.
+ Реализация метода `calculatePay()` определяется бухгалтерией.
+ Реализация метода `reportHours()` определяется и используется отделом по работе с персоналом.
+ Реализация метода `save()` определяется администраторами баз данных.

Поместив исходный код этих трех методов в общий класс `Employee`, разработчики объединили перечисленных акторов. В результате такого объединения действия сотрудников бухгалтерии могут затронуть что-то, что требуется сотрудникам отдела по работе с персоналом.

Например, представьте, что функции `calculatePay()` и `reportHours()` используют общий алгоритм расчета не сверхурочных часов. Представьте также, что разработчики, старающиеся не дублировать код, поместили реализацию этого алгоритма в функцию с именем `regularHours()`.

![03](/CPP_from_LETI/LETI_03/img/03_04.jpg)

Теперь вообразите, что сотрудники бухгалтерии решили немного изменить алгоритм расчета не сверхурочных часов. Сотрудники отдела по работе с персоналом были бы против такого изменения, потому что вычисленное время они используют для других целей.

Разработчик, которому было поручено внести изменение, заметил, что функция `regularHours()` вызывается методом `calculatePay()`, но, к сожалению, не заметил, что она также вызывается методом `reportHours()`.

Разработчик внес требуемые изменения и тщательно протестировал результат. Сотрудники бухгалтерии проверили и подтвердили, что обновленная функция действует в соответствии с их пожеланиями, после чего измененная версия системы была развернута.

Разумеется, сотрудники отдела по работе с персоналом не знали о произошедшем и продолжали использовать отчеты, генерируемые функцией `reportHours()`, но теперь содержащие неправильные цифры. В какой-то момент проблема вскрылась, и сотрудники отдела по работе с персоналом разом побледнели от ужаса, потому что ошибочные данные обошлись их бюджету в несколько миллионов долларов.

Принцип единственной ответственности требует разделять код, от которого зависят разные актёры.

<hr>

[Содержание](#содержание)

## Признак 2: слияния

Слияния — обычное дело для исходных файлов с большим количеством разных методов. Эта ситуация особенно вероятна, если эти методы отвечают за разных актёров.

Например, представим, что коллектив администраторов баз данных решил внести простое исправление в схему таблицы `Employee`. Представим также, что сотрудники отдела по работе с персоналом пожелали немного изменить формат отчета, возвращаемого функцией `reportHours()`.

Два разных разработчика, возможно, из двух разных команд, извлекли класс `Employee` из репозитория и внесли изменения. К сожалению, их изменения оказались несовместимыми. В результате потребовалось выполнить слияние.

Современные инструменты довольно совершенны, но никакой инструмент не сможет правильно обработать все возможные варианты слияния. В итоге риск есть всегда. В нашем примере процедура слияния поставила под удар администраторов баз данных и отдел по работе с персоналом. Вполне возможно, что риску подверглась также бухгалтерия.

Существует много других признаков, которые мы могли бы рассмотреть, но все они сводятся к изменению одного и того же исходного кода разными людьми по разным причинам.

И снова, исправить эту проблему можно, разделив код, предназначенный для обслуживания разных актёров.

<hr>

[Содержание](#содержание)

## Решение

Существует много решений этой проблемы. Но каждое связано с перемещением функций в разные классы.

Наиболее очевидным, пожалуй, является решение, связанное с отделением данных от функций. Три класса используют общие данные `EmployeeData `— простую структуру без методов. Каждый класс включает только исходный код для конкретной функции. Эти три класса никак не зависят друг от друга. То есть любое непреднамеренное дублирование исключено.

![03](/CPP_from_LETI/LETI_03/img/03_05.jpg)

Недостаток такого решения — разработчик теперь должен создавать экземпляры трех классов и следить за ними. Эта проблема часто решается применением шаблона проектирования «Фасад» (`Facade`), его мы рассмотрим в разделе о паттернах проектирования.

![03](/CPP_from_LETI/LETI_03/img/03_06.jpg)

Некоторые разработчики предпочитают держать наиболее важные бизнес-правила как можно ближе к данным. Это можно сделать, сохранив важные методы в оригинальном классе `Employee`, и затем использовать этот класс как фасад для низкоуровневых функций.

![03](/CPP_from_LETI/LETI_03/img/03_07.jpg)

Вы можете возразить против такого решения на том основании, что каждый класс содержит только одну функцию. Однако в реальности такое едва ли возможно. Количество функций, необходимых для расчета зарплаты, создания отчета или сохранения данных, наверняка будет больше в любом случае. Каждый из таких классов может иметь также много приватных методов.

Каждый такой класс, содержащий подобное семейство методов, образует свою область видимости. Вне этой области никто не знает о существовании приватных членов семейства.

<hr>

[Содержание](#содержание)

## Принцип открытости/закрытости (OCP)

Соответствует букве O акронима SOLID.

Принцип можно выразить так: «Классы, методы или функции должны быть открыты для расширения (добавления новой функциональности) и закрыты для модификации». Такой подход запрещает кому-либо изменять уже опробованный и протестированный код, а значит, он не ломается. В этом и состоит основное преимущество такого подхода.

Иными словами, должна иметься возможность расширять поведение программных сущностей без их изменения.

Это одна из основных причин, почему мы изучаем архитектуру программного обеспечения. Очевидно, если простое расширение требований ведет к значительным изменениям в программном обеспечении, значит, архитекторы этой программной системы потерпели сокрушительное фиаско.

![03](/CPP_from_LETI/LETI_03/img/03_08.jpg)

Представьте, что у нас есть финансовая сводка. Содержимое страницы прокручивается, и отрицательные значения выводятся красным цветом. Применяя принцип единственной ответственности, можно прийти к потоку данных, изображенному на рисунке выше. Некоторая процедура анализирует финансовые данные и производит данные для отчета, которые затем форматируются двумя процедурами формирования отчетов.

Самое важное, что нужно понять, — в данном примере в создание отчета вовлечены две отдельные ответственности: вычисление данных для отчета и представление этих данных в форме веб-отчета или распечатанного отчета

Сделав такое разделение, мы должны организовать зависимости в исходном коде так, чтобы изменения в одной из ответственностей не вызывали необходимости изменений в другой. Кроме того, новая организация должна гарантировать возможность расширения поведения без отмены изменений.

Этого можно добиться, выделив процессы в классы, а классы в компоненты, ограниченные двойными линиями. Компонент в левом верхнем углу на этом рисунке — контроллер. В правом верхнем углу — интерактор, или посредник. В правом нижнем углу — база данных. Наконец, в левом нижнем углу изображены четыре компонента — презентаторы и представления.

![03](/CPP_from_LETI/LETI_03/img/03_09.jpg)

Классы, отмеченные символами `<I>` — это интерфейсы; отмеченные символами `<DS>` — это структуры данных (`data structures`). Простые стрелки соответствуют отношениям использования. Стрелки с треугольным наконечником соответствуют отношениям реализации или наследования.

Первое, на что следует обратить внимание, — все зависимости определены на уровне исходного кода. Стрелка, направленная от класса `A` к классу `B`, означает, что в исходном коде класса `A` упоминается имя класса `B`, но в коде класса `B` не упоминается имя класса `A`. Так диспетчер финансовых данных знает о существовании шлюза через отношение реализации, а шлюз финансовых данных ничего не знает о диспетчере.

Также важно отметить, что каждая двойная линия пересекается только в одном направлении. Это означает, что все отношения компонентов однонаправлены, как показано на графе компонентов. Эти стрелки указывают на компоненты, которые мы стремимся защитить от изменения.

![03](/CPP_from_LETI/LETI_03/img/03_10.jpg)

Интерактор находится в позиции, лучше соответствующей принципу открытости/закрытости. Изменения в базе данных, или в контроллере, или в презентаторах, или в представлениях не должны влиять на интерактор.

Почему интерактор должен придерживаться такой привилегированной позиции? Потому что он реализует бизнес-правила. Интерактор реализует политики высшего уровня в приложении. Все другие компоненты решают второстепенные задачи. Интерактор решает самую главную задачу.

Несмотря на то что контроллер является не таким важным компонентом, как интерактор, он важнее презентаторов и представлений. А презентаторы, хотя и менее важные, чем контроллеры, в свою очередь, важнее представлений.

Обратите внимание, что в результате выстраивается иерархия защиты, основанная на понятии «уровня». Интеракторы занимают самый верхний уровень, поэтому они должны быть самыми защищенными. Представления занимают самый низкий уровень, поэтому они наименее защищены. Презентаторы находятся уровнем выше представлений, но ниже контроллера или интерактора.

Именно так работает принцип открытости/закрытости на архитектурном уровне. Архитекторы разделяют функциональные возможности, опираясь на то, как, почему и когда их может потребоваться изменить, и затем организуют их в иерархию компонентов. Компоненты, находящиеся на верхних уровнях в такой иерархии, защищаются от изменений в компонентах на нижних уровнях.

<hr>

[Содержание](#содержание)

## Принцип подстановки Барбары Лисков (LSP)

Соответствует букве `L` акронима `SOLID`.

Согласно этому принципу подтипы должны быть заменяемыми для супертипа. Другими словами, методы или функции, работающие с суперклассом, должны иметь возможность без проблем работать также и с его подклассами.

Представьте, что у нас есть класс с именем `License`, как показано на рисунке внизу. Этот класс имеет метод с именем `calcFee()`, который вызывается приложением `Billing`. Существует два «подтипа» класса `License:` `PersonalLicense` и `BusinessLicense`. Они реализуют разные алгоритмы расчета лицензионных отчислений.

![03](/CPP_from_LETI/LETI_03/img/03_11.jpg)

Этот дизайн соответствует принципу подстановки Барбары Лисков, потому что поведение приложения `Billing` не зависит от использования того или иного подтипа. Оба подтипа могут служить заменой для типа `License`.

<hr>

[Содержание](#содержание)

## Проблема квадрат/прямоугольник

Классическим примером нарушения принципа подстановки Барбары Лисков может служить известная проблема квадрат/прямоугольник.

![03](/CPP_from_LETI/LETI_03/img/03_12.jpg)

В этом примере класс `Square` (представляющий квадрат) неправильно определен как подтип класса `Rectangle` (представляющего прямоугольник), потому что высоту и ширину прямоугольника можно изменять независимо; а высоту и ширину квадрата можно изменять только вместе. Поскольку класс `User` полагает, что взаимодействует с экземпляром `Rectangle`, его легко можно ввести в заблуждение, как демонстрирует следующий код:

```c++
Rectangle r = ...
r.setW(5);
r.setH(2);
assert(r.area() == 10);
```

Если на место `...` подставить код, создающий экземпляр `Square`, тогда проверка `assert` потерпит неудачу. Единственный способ противостоять такому виду нарушений принципа `LSP` — добавить в класс `User` механизм (например, инструкцию `if`), определяющий ситуацию, когда прямоугольник фактически является квадратом. Так как поведение `User` зависит от используемых типов, эти типы не являются заменяемыми (совместимыми).

Более подробный пример: 

```c++
class Rectangle {
	
	protected int width = 0;
	protected int height = 0;
	
	public Rectangle() {
	}
	
	public int getWidth() {
		return width;
	}
	
	public int getHeight() {
		return height;
	}
	
	public void setWidth(int width) {
		this.width = width;
	}
	
	public void setHeight(int height) {
		this.height = height;
	}
	
	public int getArea(){
	    return this.width * this.height;
	}
	
}

class Square : public Rectangle {
	
	public Square() {
	}
	
	public void setWidth(int width) {
		this.width = width;
		this.height = width;
	}
	
	public void setHeight(int height) {
		this.height = height;
		this.width = height;
	}
	
}

static void resize(Rectangle r, int newWidth, int newHeight){
    r.setWidth(newWidth);
    r.setHeight(newHeight); 
}

int main() {
    Rectangle r = new Rectangle();
    Square s = new Square();
    resize(r,2,3);
    resize(s,2,3);
    std::cout << r.getArea();
    std::cout << s.getArea();
}
```

Функция `resize()` провоцирует неявную ошибку при работе с экземпляром класса `Square`, потому что позволяет устанавливать отличные друг от друга значения ширины и высоты. Согласно принципу `LSP`, функции, использующие ссылки на базовые классы, должны иметь возможность использовать объекты производных классов, не зная об этом. Поэтому для корректной работы функция `resize()` должна проверять, является ли передаваемый объект экземпляром класса `Square`, и в этом случае не позволять установить разные значения ширины и высоты. Отсюда идёт нарушение принципа.

<hr>

[Содержание](#содержание)

## Принцип разделения интерфейса (ISP)

Соответствует букве `I` акронима `SOLID`. Этот принцип подразумевает, что интерфейс, который не используется, не должен быть реализован.

![03](/CPP_from_LETI/LETI_03/img/03_13.jpg)

В основном это происходит, когда один интерфейс содержит несколько функциональностей, и клиенту нужна только одна из них, а другие — нет.

Написание интерфейса — сложная задача. Когда он готов, вы не сможете изменить его, не нарушив всю реализацию.

Ещё одно преимущество этого принципа заключается в том, что интерфейс имеет недостаток. Необходимо сначала реализовать все методы, прежде чем какой-либо класс сможет их использовать. Поэтому наличие единственной функциональности означает меньшее количество методов для реализации.

<hr>

[Содержание](#содержание)

## Принцип инверсии зависимостей (DIP)

Соответствует букве `D` акронима `SOLID`.

Прелесть этого принципа проектирования в том, что любой класс легко тестируется с помощью фиктивного объекта и проще в обслуживании, потому что код создания объекта централизован, а клиентский код не перегружен им.

Принцип инверсии зависимости утверждает, что наиболее гибкими получаются системы, в которых зависимости в исходном коде направлены на абстракции, а не на конкретные реализации.

В языках со статической системой типов это означает, что инструкции импорта модулей должны ссылаться только на модули с исходным кодом, содержащим интерфейсы, абстрактные классы и другие абстрактные объявления. Никаких зависимостей от конкретных реализаций не должно быть.

То же правило действует для языков с динамической системой типов, таких как `Ruby` или `Python`. Исходный код не должен зависеть от модулей с конкретной реализацией. Однако в этих языках труднее определить, что такое конкретный модуль. В частности, это любой модуль, в котором реализованы вызываемые функции.

По этим причинам мы склонны игнорировать стабильный фундамент операционной системы и платформы, рассуждая о принципе инверсии зависимости. Мы терпим эти конкретные зависимости, потому что уверенно можем положиться на их постоянство. Мы должны избегать зависимости от неустойчивых конкретных элементов системы. То есть от модулей, которые продолжают активно разрабатываться и претерпевают частые изменения.

Ниже приведён пример кода который нарушает принцип инверсии зависимости:

```c++
class EventLogWriter {
	
	public EventLogWriter() {
		// Конструктор
	}
	
	public write(std::String message) {
		// Конструктор
	}
}

class AppManager {
	
	EventLogWriter writer = null;
	
	public AppManager() {
		// Конструктор
	}
	
	void notify(String message) {
		
		if (writer == null) {
			
			writer = new EventLogWriter();
		}
		
		writer.write(message);
	}
}
```

Пример демонстрирует, что `AppManager` зависит от `EventLogWriter`. Если вам нужно использовать другой способ уведомления клиента (например `push`-уведомления, `SMS` или электронную почту), необходимо изменить класс `AppManager`.

Эту проблему можно решить с помощью принципа инверсии зависимостей. Вместо того, чтобы `AppManager` запрашивал `EventLogWriter`, последний следует внедрить в `AppManager` явно. Плюсом реализации общего интерфейса позволить внедрять любую реализацию для других способов уведомления.

![03](/CPP_from_LETI/LETI_03/img/03_14.PNG)

<hr>

[Содержание](#содержание)