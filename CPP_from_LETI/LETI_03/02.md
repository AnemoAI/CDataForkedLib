# 2.  Классы

## Содержание

+ [2.1 Описание классов и объектов](#21-описание-классов-и-объектов)
    + [Описание класса](#описание-класса)
    + [Поля класса:](#поля-класса)
    + [Описание объектов](#описание-объектов)
    + [Указатели на объекты классов](#указатели-на-объекты-классов)
    + [Указатель this](#указатель-this)
    + [Рекомендации по составу класса](#рекомендации-по-составу-класса)
    + [Отличия структур и объединений от классов](#отличия-структур-и-объединений-от-классов)
    + [Задачи](#задачи-1)
+ [2.2 Конструкторы и деструкторы](#22-конструкторы-и-деструкторы)
    + [Конструкторы](#конструкторы)
    + [Конструктор копирования](#конструктор-копирования)
    + [Деструкторы](#деструкторы)
    + [Задачи](#задачи-2)
+ [2.3 Статические элементы класса](#23-статические-элементы-класса)
    + [Статические элементы класса](#статические-элементы-класса)
    + [Статические поля](#статические-поля)
    + [Статические методы](#статические-методы)
    + [Задачи](#задачи-3)
+ [2.4 Дружественные функции и классы](#24-дружественные-функции-и-классы)
    + [Дружественные функции и классы](#дружественные-функции-и-классы)
    + [Дружественная функция](#дружественная-функция)
+ [2.5 Перегрузка операций](#25-перегрузка-операций)
    + [Перегрузка операций](#перегрузка-операций)
    + [Перегрузка унарных операций](#перегрузка-унарных-операций)
    + [Перегрузка бинарных операций](#перегрузка-бинарных-операций)
    + [Перегрузка операции присваивания](#перегрузка-операции-присваивания)
    + [Перегрузка операций new и delete](#перегрузка-операций-new-и-delete)
    + [Перегрузка операции приведения типа](#перегрузка-операции-приведения-типа)
    + [Перегрузка операции вызова функции](#перегрузка-операции-вызова-функции)
    + [Перегрузка операции индексирования](#перегрузка-операции-индексирования)
    + [Задачи, надо доделать](#todo-1)
+ [2.6 Обработки исключений](#26-обработки-исключений)
    + [Обработка исключений](#обработка-исключений)
    + [Общий механизм обработки исключений](#общий-механизм-обработки-исключений)
    + [Синтаксис исключений](#синтаксис-исключений)
    + [Перехват исключений](#перехват-исключений)
    + [Список исключений функции](#список-исключений-функции)
    + [Исключения в конструкторах и деструкторах](#исключения-в-конструкторах-и-деструкторах)
    + [Иерархии исключений](#иерархии-исключений)
    
[Оглавление](/CPP_from_LETI/LETI_03/README.md)

# 2.1 Описание классов и объектов

## Описание класса

Класс является абстрактным типом данных, определяемым пользователем, и представляет собой модель реального объекта в виде данных и функций для работы с ними.

Данные класса называются полями (по аналогии с полями структуры), а функции класса — методами. Поля и методы называются элементами класса. 

Класс может определять переменные и константы для хранения состояния объекта и функции для определения поведения объекта.

Например, определим простейший класс:

```c++
class Person {
 
};
```

Для определения класса применяется ключевое слово `class`, после которого идет собственно название класса. В данном случае класс называется `Person` и представляет человека. После названия класса идет блок кода, который определяет тело класса.

После определения класса мы можем создавать его переменные:

```c++
class Person {
 
};

int main() {
    Person person;
    return 0;
}
```

Описание класса в первом приближении выглядит так:

```c++
class <имя> {
    [ private: ]
    <описание скрытых элементов>
    public:
    <описание доступных элементов>
}; // Описание заканчивается точкой с запятой 
```

Спецификаторы доступа `private` и `public` управляют видимостью элементов класса. Элементы, описанные после служебного слова `private`, видимы только внутри класса. Этот вид доступа принят в классе по умолчанию. Интерфейс класса описывается после спецификатора `public`. Действие любого спецификатора распространяется до следующего спецификатора или до конца класса. Можно задавать несколько секций `private` и `public`, порядок их следования значения не имеет.


<hr>

[Содержание](#содержание)

## Поля класса:
+ могут иметь любой тип, кроме типа этого же класса (но могут быть указателями или ссылками на этот класс);
+ могут быть описаны с модификатором const, при этом они инициализируются только один раз (с помощью конструктора) и не могут изменяться;
+ могут быть описаны с модификатором static, но не как auto, extern и register.

Классы могут быть глобальными (объявленными вне любого блока) и локальными (объявленными внутри блока, например, функции или другого класса).

Ниже перечислены некоторые особенности локального класса:
+ внутри локального класса можно использовать типы, статические (`static`) и внешние (`extern`) переменные, внешние функции и элементы перечислений из области, в которой он описан; запрещается использовать автоматические переменные из этой области;
+ локальный класс не может иметь статических элементов;
+ методы этого класса могут быть описаны только внутри класса;
+ если один класс вложен в другой класс, они не имеют каких-либо особых прав доступа к элементам друг друга и могут обращаться к ним только по общим правилам.

В качестве примера создадим класс, моделирующий персонаж компьютерной игры. Для этого требуется задать его свойства (например, количество щупалец, силу или наличие гранатомета) и поведение. Естественно, пример будет схематичен, поскольку приводится лишь для демонстрации синтаксиса.

```c++
class monster {
    int health{0};
    int ammo{0};

   public:
    monster(int he = 100, int am = 10) {
        health = he;
        ammo = am;
    }
    void draw(int x, int y, int scale, int position);
    int getHealth() { return health; }
    int getAmmo() { return ammo; }
};
```

Все методы класса имеют непосредственный доступ к его скрытым полям, иными словами, тела функций класса входят в область видимости private элементов класса.

```c++
void monster::draw(int х, int у, int scale, int position) {
  /* тело метода */
} 
```

Метод можно определить как встроенный и вне класса с помощью директивы `inline` (как и для обычных функций, она носит рекомендательный характер):

```c++
inline int monster::get_ammo(){
  return ammo;
}
```

В каждом классе есть хотя бы один метод, имя которого совпадает с именем класса. Он называется конструктором и вызывается автоматически при создании объекта класса. Конструктор предназначен для инициализации объекта. Автоматический вызов конструктора позволяет избежать ошибок, связанных с использованием неинициализированных переменных. Мы подробно рассмотрим конструкторы в разделе «Конструкторы».

Типы данных `struct` и `union` являются видами класса, с ними вы уже сталкивались в прошлых курсах.

<hr>

[Содержание](#содержание)

## Описание объектов

Конкретные переменные типа «класс» называются экземплярами класса, или объектами. Время жизни и видимость объектов зависит от вида и места их описания и подчиняется общим правилам С++:

```c++
monster Vasia;                     // Объект класса monster с параметрами по умолчанию
monster Super(200, 300);           // Объект с явной инициализацией
monster stado[100];                // Массив объектов с параметрами по умолчанию
monster* beavis = new monster (10); // Динамический объект
                                  //(второй параметр задается по умолчанию)
monster& butthead = Vasia;         // Ссылка на объект
```

При создании каждого объекта выделяется память, достаточная для хранения всех полей, и автоматически вызывается конструктор, выполняющий их инициализацию. Методы класса не тиражируются. При выходе объекта из области действия он уничтожается, при этом автоматически вызывается деструктор.

Доступ к элементам объекта аналогичен доступу к полям структуры. Для этого используются операция . (точка) при обращении к элементу через имя объекта и операция -> при обращении через указатель, например:

```c++
int ammo = Vasid.getAmmo();
stado[5].draw;
std::cout << beavis -> getHealth(); 
```

Обратиться таким образом можно только к элементам со спецификаторам `public`. Получить или изменить значения элементов со спецификатором `private` можно только через обращение к соответствующим методам. Можно создать константный объект, значения полей которого изменять запрещается. К нему должны применяться только константные методы:

```c++
class monster{
int getHealth() const {return health;}
};
const monster Dead(0,0); // Константный объект
cout << Dead.getHealth();
```

Константный метод:
+ объявляется с ключевым словом const после списка параметров; а не может изменять значения полей класса;
+ может вызывать только константные методы;
+ может вызываться для любых (не только константных) объектов. Рекомендуется описывать как константные те методы, которые предназначены для получения значений полей.

<hr>

[Содержание](#содержание)

## Указатели на объекты классов

Рассмотрим пример.

```c++
#include <iostream>
#include <string>
using std::cout;
using std::string;

class Hero {
   public:
    string name;
    int armor;
    void move() { cout << name << " is moving" << '\n'; }
};
int main() {
    Hero hero;
    hero.name = "Tom";
    hero.armor = 100;
    cout << "Name: " << hero.name << "\tArmor: " << hero.armor << '\n';
    hero.move();

    return 0;
}
```

Класс `Hero` имеет две переменных `name` и `armor`, которые предназначены для хранения имени персонажа и количество его брони соответственно. Также класс определяет функцию `move`, которая выводит строку на консоль. Также стоит обратить внимание на модификатор доступа `public`:, который указывает, что идущие после него переменные и функции будут доступны извне, из внешнего кода.

На объекты классов, как и на объекты других типов, можно определять указатели. Затем через указатель можно обращаться к членам класса - переменным и методам. Однако если при обращении через обычную переменную используется символ точка, то для для обращения к членам класса через указатель применяется стрелка (`->`):

```c++
#include <iostream>
#include <string>
using std::string;
using std::cout;
 
class Hero
{
public:
    string name;
    int armor;
    void move() {
        cout << name << " is moving" << '\n';
    }
};

int main()
{
    Hero hero;
    Hero *ptr = &hero;
    ptr->name = "Tom";
    ptr->armor = 100;
    ptr->move();
    cout << "Name: " << ptr->name << "\tArmor: " << ptr->armor << '\n';
    cout << "Name: " << hero.name << "\tArmor: " << hero.armor << '\n';
 
    return 0;
}
```

Изменения по указателю `ptr` в данном случае приведут к изменениям объекта `hero`.

Ниже перечислены правила использования указателей на методы классов.
+ Указателю на метод можно присваивать только адреса методов, имеющих соответствующий заголовок.
+ Нельзя определить указатель на статический метод класса.
+ Нельзя преобразовать указатель па метод в указатель на обычную функцию, не являющуюся элементом класса.

Как и указатели на обычные функции, указатели на методы используются в том случае, когда возникает необходимость вызвать метод, имя которого неизвестно. Однако в отличие указателя на переменную или обычную функцию, указатель на метод не ссылается на определенный адрес памяти. Он больше похож на индекс в массиве, поскольку задает смещение. Конкретный адрес в памяти получается путем сочетания указателя на метод с указателем на определенный объект.

Методы, вызываемые через указатели, могут быть виртуальными. При этом вызывается метод, соответствующий типу объекта, к которому применялся указатель.

Формат указателя на поле класса:

```
тип_данных(иня_класса::*имя_указателя):
```

В определение указателя можно включить его инициализацию в форме:

```c++
&имя_класса: :имя_поля;// Поле должно быть public 
```

Обратите внимание на то, что указатели на поля классов не являются обычными указателями — ведь при присваивании им значений они не ссылаются на конкретный адрес памяти, поскольку память выделяется не под классы, а под объекты классов.

<hr>

[Содержание](#содержание)

## Указатель `this`

Каждый объект содержит свой экземпляр полей класса. Методы класса находятся в памяти в единственном экземпляре и используются всеми объектами совместно, поэтому необходимо обеспечить работу методов с полями именно того объекта, для которого они были вызваны. Это обеспечивается передачей в функцию скрытого параметра `this`, в котором хранится константный указатель на вызвавший функцию объект. Указатель `this` неявно используется внутри метода для ссылок на элементы объекта. В явном виде этот указатель применяется в основном для возвращения из метода указателя (`return this;`) или ссылки (`return *this`;) на вызвавший объект.

Для иллюстрации использования указателя `this` добавим в приведенный на 3 шаге класс `monster` новый метод, возвращающий ссылку на наиболее здорового (поле `health`) из двух монстров, один из которых вызывает метод, а другой передается ему в качестве параметра (метод нужно поместить в секцию `public` описания класса):

```c++
monster & theBest(monster &М){
  if (health > М.health)
    return *this:
  return M;
}

... monster Vasia(50).Super(200);
// Новый объект Best инициализируется значениями полей Super:
monster Best = Vasia.theBest(Super): 
```

Указатель `this` можно также применять для идентификации поля класса в том случае, когда его имя совпадает с именем формального параметра метода. Другой способ идентификации поля использует операцию доступа к области видимости:

```c++
void cure(int health, int ammo){
this -> health += health; // Использование this
monster::ammo += ammo;    // Использование операции :: 
}
```

<hr>

[Содержание](#содержание)

## Рекомендации по составу класса

Как правило, класс как тип, определенный пользователем, должен содержать скрытые (`private`) поля и следующие функции:
+ конструкторы, определяющие, как инициализируются объекты класса;
+ набор методов, реализующих свойства класса (при этом методы, возвращающие значения скрытых полей класса, описываются с модификатором `const`, указывающим, что они не должны изменять значения полей);
+ набор операций, позволяющих копировать, присваивать, сравнивать объекты и производить с ними другие действия, требующиеся по сути класса;
+ класс исключений, используемый для сообщений об ошибках с помощью генерации исключительных ситуаций.
 
Если существуют функции, которые работают с классом или несколькими классами через интерфейс (то есть доступ к скрытым полям им не требуется), можно описать их вне классов, чтобы не перегружать интерфейсы, а для обеспечения логической связи поместить их в общее с этими классами пространство имен, например:

```c++
namespace Staff{
  class Monster { /* ... */}:
  class Hero { /* ... */};
  void interact(Hero, Monster);
  ...
}
```

<hr>

[Содержание](#содержание)

## Отличия структур и объединений от классов

Структуры (`struct`) и объединения (`union`) представляют собой частные случаи классов.

Структуры отличаются от классов тем, что доступ к элементам, а также базовый класс при наследовании по умолчанию считаются `public`. Структуры предпочтительнее использовать для классов, все элементы которых доступны.

Отличия объединений от классов перечислены ниже:
+ доступ в объединениях по умолчанию `рublic`, кроме того, в них вообще нельзя явным образом использовать спецификаторы доступа;
+ объединение не может участвовать в иерархии классов;
+ элементами объединения не могут быть объекты, содержащие конструкторы и деструкторы;
+ объединение может иметь конструктор и другие методы, только не статические;
+ в анонимном объединении нельзя описывать методы. 

<hr>

[Содержание](#содержание)

## Задачи 1

Класс - это?

+ [ ] структура данных, для которой в программе имеются функции работы с нею
+ [ ] любой тип данных, определяемый пользователем
+ [x] абстрактный типом данных, определяемый пользователем, и представляет собой модель реального объекта в виде данных и функций для работы с ними

Членами класса могут быть

+ [ ] только переменные и функции, объявленные как private
+ [ ] только функции, объявленные как private
+ [ ] только переменные и функции, объявленные как public
+ [+] как переменные, так и функции, могут быть объявлены как private и как public
+ [ ] только переменные, объявленные как private

Объект - это

+ [x] экземпляр класса
+ [ ] класс, который содержит в себе данные и методы их обработки
+ [ ] переменная, содержащая указатель на класс
+ [ ] класс, содержащие абстрактное описание реального объекта

Выберите все подходящие ответы из списка

+ [x] По умолчанию все поля у класса private
+ [ ] Метод можно определить как встроенный и вне класса с помощью директивы include
+ [ ] Действие любого спецификатора распространяется до конца класса
+ [x] Все методы класса имеют непосредственный доступ к его private полям
+ [x] Спецификаторы доступа private и public управляют видимостью элементов класса

Поля класса

+ [x] могут быть описаны с модификатором static
+ [x] могут быть описаны с модификатором const, при этом они инициализируются только один раз (с помощью конструктора) и не могут изменяться
+ [x] могут иметь любой тип, кроме типа этого же класса
+ [x] могут быть указателями или ссылками на этот собственный класс

Выберите все подходящие ответы из списка

+ [ ] внутри локального класса можно использовать только статические (static) переменные
+ [x] внутри локального класса можно использовать типы, статические (static) и внешние (extern) переменные, внешние функции и элементы перечислений из области, в которой он описан
+ [ ] если один класс вложен в другой класс, они имеют полный доступа к элементам друг друга
+ [x] если один класс вложен в другой класс, они не имеют доступа к скрытым элементам друг друга

Указатель `this` неявно используется внутри метода для ссылок на элементы объекта.

<hr>

[Содержание](#содержание)

# 2.2 Конструкторы и деструкторы

## Конструкторы

Конструктор предназначен для инициализации объекта и вызывается автоматически при его создании. Ниже перечислены основные свойства конструкторов:
+ Конструктор не возвращает значение, даже типа `void`. Нельзя получить указатель на конструктор.
+ Класс может иметь несколько конструкторов с разными параметрами для разных видов инициализации (при этом используется механизм перегрузки).
+ Конструктор, вызываемый без параметров, называется конструктором по умолчанию.
+ Параметры конструктора могут иметь любой тип, кроме этого же класса. Можно задавать значения параметров по умолчанию. Их может содержать только один из конструкторов.
+ Если программист не указал ни одного конструктора, компилятор создает его автоматически. Такой конструктор вызывает конструкторы по умолчанию для полей класса и конструкторы по умолчанию базовых классов. В случае, когда класс содержит константы или ссылки, при попытке создания объекта класса будет выдана ошибка, поскольку их необходимо инициализировать конкретными значениями, а конструктор по умолчанию этого делать не умеет.
+ Конструкторы не наследуются.
+ Конструкторы нельзя описывать с модификаторами `const`, `virtual` и `static`.
+ Конструкторы глобальных объектов вызываются до вызова функции `main`. Локальные объекты создаются, как только становится активной область их действия. Конструктор запускается и при создании временного объекта (например, при передаче объекта из функции).
+ Конструктор вызывается, если в программе встретилась какая-либо из синтаксических конструкций:

```c++
ИмяКласса имяОбъекта [(список параметров)];
// Список параметров не должен быть пустым
ИмяКласса (список параметров);
// Создается объект без имени (список может быть пустым)
ИмяКласса имяОбъекта = выражение;
// Создается объект без имени и копируется 
```

Примеры:

```c++
monster Super(200, 300), Vas1a(50), Z;
monster X = monstr(1OOO);
monster Y = 500;
```

В первом операторе создаются три объекта. Значения не указанных параметров устанавливаются по умолчанию.

Во втором операторе создается безымянный объект со значением параметра `health` = `1000` (значение второго параметра устанавливается по умолчанию). Выделяется память под объект `X`, в которую копируется безымянный объект.

В последнем операторе создается безымянный объект со значением параметра `health` = `500` (значение второго параметра устанавливается по умолчанию). Выделяется память под объект `Y`, в которую копируется безымянный объект. Такая форма создания объекта возможна в том случае, если для инициализации объекта допускается задать один параметр.

В качестве примера класса с несколькими конструкторами усовершенствуем описанный ранее класс `monster`, добавив в него поля, задающие цвет (`skin`) и имя (`name`):

```c++
enum color { red, green, blue };  // Возможные значения цвета
class Monster {
    int health, ammo;
    color skin;
    char* name;

   public:
    Monster(int he = 100. int am = 10);
    Monster(color sk);
    Monster(char* nam);
    int get_health() { return health; }
    int get_ammo() { return ammo; }
    ...
};
//--------
Monster::Monster(int he, int am) {
    health = he;
    ammo = am;
    skin = red;
    name = 0;
}
//--------
Monster::Monster(color sk) {
    switch (sk) {
        case red:
            health = 100;
            ammo = 10;
            skin = red;
            name = 0;
            break;
        case green:
            health = 100;
            ammo = 20;
            skin = green;
            name = 0;
            break;
        case blue:
            health = 100;
            ammo = 40;
            skin = blue;
            name = 0;
            break;
    }
}
//--------
Monster::Monster(char* nam) {
    name = new char[strlen(nam) + 1];
    // К длине строки добавляется 1 для хранения нуль-символа
    strcpy(name, nam) : health = 100;
    ammo = 10;
    sk1n = red;
}
//--------
Monster* m = new monster("Ork") : Monster Green(green) :
```
Первый из приведенных выше конструкторов является конструктором по умолчанию, поскольку его можно вызвать без параметров. Объекты класса `monster` теперь можно инициализировать различными способами, требуемый конструктор будет вызван в зависимости от списка значений в скобках. При задании нескольких конструкторов следует соблюдать те же правила, что и при написании перегруженных функций — у компилятора должна быть возможность распознать нужный вариант.

__Конструктор не может возвратить значение, чтобы сообщить об ошибке во время инициализации. Для этого можно использовать механизм обработки исключительных ситуаций.__

<hr>

[Содержание](#содержание)

## Конструктор копирования

Конструктор копирования — это специальный вид конструктора, получающий в качестве единственного параметра указатель на объект этого же класса:

```c++
T::T(const Т&) { ... /* Тело конструктора */ }
```

где `Т` - имя класса.

Этот конструктор вызывается в тех случаях, когда новый объект создается путем копирования существующего:
+ при описании нового объекта с инициализацией другим объектом;
+ при передаче объекта в функцию по значению;
+ при возврате объекта из функции.

Если программист не указал ни одного конструктора копирования, компилятор создает его автоматически. Такой конструктор выполняет поэлементное копирование полей. Если класс содержит указатели или ссылки, это, скорее всего, будет неправильным, поскольку и копия, и оригинал будут указывать на одну и ту же область памяти.

Запишем конструктор копирования для класса `monster`. Поскольку в нем есть поле `name`, содержащее указатель на строку символов, конструктор копирования должен выделять память под новую строку и копировать в нее исходную:

```c++
Monster::Monster(const Monster &М){
  if (M.name){
    name = new char [strlen(M.name) + 1];
    strcpy(name. M.name);
  }
  else 
    name = 0;
    health = M.health;
    ammo = M.ammo;
    skin = M.skin;
}
...
monster Vasia (blue);
monster Super = Vasia; // Работает конструктор копирования
monster *m = new monster ("Ore");
monster Green = *m; // Работает конструктор копирования
```

Любой конструктор класса, принимающий один параметр какого-либо другого типа, называется конструктором преобразования, поскольку он осуществляет преобразование из типа параметра в тип этого класса.

<hr>

[Содержание](#содержание)

## Деструкторы

Деструктор — это особый вид метода, применяющийся для освобождения памяти, занимаемой объектом. Деструктор вызывается автоматически, когда объект выходит из области видимости:
+ для локальных объектов — при выходе из блока, в котором они объявлены;
+ для глобальных — как часть процедуры выхода из `main`;
+ для объектов, заданных через указатели - деструктор вызывается неявно при использовании операции `delete`;

При выходе из области действия указателя на объект автоматический вызов деструктора объекта не производится.

Имя деструктора начинается с тильды (`~`), непосредственно за которой следует имя класса. Деструктор:
+ не имеет аргументов и возвращаемого значения;
+ не может быть объявлен как `const` или `static`;
+ не наследуется;
+ может быть виртуальным;

Если деструктор явным образом не определен, компилятор автоматически создает пустой деструктор.

Описывать в классе деструктор явным образом требуется в случае, когда объект содержит указатели на память, выделяемую динамически, иначе при уничтожении объекта память, на которую ссылались его поля-указатели, не будет помечена как свободная. Указатель на деструктор определить нельзя.

Деструктор для рассматриваемого должен выглядеть так:

```c++
Monster::~Monster() {delete [ ] name;}
```

Деструктор можно вызвать явным образом путем указания полностью уточненного имени, например:

```c++
monster *m; ...
m -> ~Monster();
```

Это может понадобиться для объектов, которым с помощью перегруженной операции `new` выделялся конкретный адрес памяти. Без необходимости явно вызывать деструктор объекта не рекомендуется.

<hr>

[Содержание](#содержание)

## Задачи 2

Что называется конструктором?

+ [ ] метод, имя которого совпадает с именем класса и который необходимо явно вызывать из головной программы при объявлении объекта класса
+ [ ] метод, имя которого совпадает с именем класса и который вызывается автоматически при объявлении класса (до создания объекта класса)
+ [ ] метод, имя которого необязательно совпадает с именем класса и который вызывается при создании объекта класса
+ [x] метод, имя которого совпадает с именем класса и который вызывается автоматически при создании объекта класса

Что называется деструктором?

+ [ ] метод, который уничтожает объект
+ [ ] системная функция, которая освобождает память, занимаемую объектом
+ [ ] метод, который удаляет объект
+ [x] метод, который освобождает память, занимаемую объектом

Выберите правильное утверждение

+ [ ] деструктор - это метод класса, применяемый для удаления объекта
+ [x] деструктор - это метод класса, применяемый для освобождения памяти, занимаемой объектом
+ [ ] деструктор - это отдельная функция головной программы, применяемая для освобождения памяти, занимаемой объектом

Согласно стандарту С++17, каков результат этой программы?

```c++
#include <iostream>

class show_id {
   public:
    ~show_id() { std::cout << id; }
    int id;
};

int main() { delete[] new show_id[3]{{0}, {1}, {2}}; }
```

+ Если программа гарантированно выводит правильный ответ - напишите его в верный ответ.
+ Если программа имеет ошибку компиляции, напишите - `ошибка компиляци`и.
+ Если невозможно однозначно определить правильный ответ - `ответ невозможно определить`.
+ Если в результате работы программы возникает исключение - `исключение`. 

```
210
```

> Суть вопроса заключается в следующем: "В каком порядке уничтожаются объекты?". В C++ объекты обычно уничтожаются в порядке, обратном порядку их создания. `delete[]` не является исключением.
> В случае массива элементы будут уничтожаться в порядке убывания адреса (то есть в обратном порядке завершения их конструктора (...).)

Согласно стандарту С++17, каков результат этой программы?

```c++
#include <iostream>
using namespace std;

class C {
   public:
    explicit C(int) { std::cout << "i"; };
    C(double) { std::cout << "d"; };
};

int main() {
    C c1(7);
    C c2 = 7;
}
```

+ Если программа гарантированно выводит правильный ответ - напишите его в верный ответ.
+ Если программа имеет ошибку компиляции, напишите - `ошибка компиляци`и.
+ Если невозможно однозначно определить правильный ответ - `ответ невозможно определить`.
+ Если в результате работы программы возникает исключение - `исключение`. 

```
id
```

Это два примера инициализации. 
+ Первая форма C c1(7), называется прямой инициализацией,
+  вторая C c2 = 7, называется копией-инициализацией.

В большинстве случаев они эквивалентны, но в данном примере это не так, так `int` как конструктор является `explicit`.

Инициализация, которая происходит в формах
+ T x(a);
+ T x{a};
+ ( ... ),<br>
 называется прямой инициализацией.

Таким образом, `int` конструктором даже не рассматривается для инициализации во втором случае. <br>
Вместо этого используется стандартная последовательность преобразования для преобразования целочисленного литерала в `double`, а также `double` конструктор (единственный кандидат).

<hr>

[Содержание](#содержание)

# 2.3 Статические элементы класса

## Статические элементы класса

С помощью модификатора `static` можно описать статические поля и методы класса. Их можно рассматривать как глобальные переменные или функции, доступные только в пределах области класса.

<hr>

[Содержание](#содержание)

## Статические поля

Статические поля применяются для хранения данных, общих для всех объектов класса, например, количества объектов или ссылки на разделяемый всеми объектами ресурс. Эти поля существуют для всех объектов класса в единственном экземпляре, то есть не дублируются.

Ниже перечислены особенности статических полей.
+ Память под статическое поле выделяется один раз при его инициализации независимо от числа созданных объектов (и даже при их отсутствии) и инициализируется с помощью операции доступа к области действия, а не операции выбора (определение должно быть записано вне функций):
```c++
class А {
   public:
    static int count;  // Объявление в классе
};

int A::count;  // Определение в глобальной области
               // По умолчанию инициализируется нулем
// int A::count = 10; Пример инициализации произвольным значением
```

Статические поля доступны как через имя класса, так и через имя объекта:

```c++
А *а, b;
std::cout << A::count << a->count << b.count:
// Будет выведено одно и то же 
```

На статические поля распространяется действие спецификаторов доступа, поэтому статические поля, описанные как `private`, нельзя изменить с помощью операции доступа к области действия, как описано выше. Это можно сделать только с помощью статических методов.
Память, занимаемая статическим полем, не учитывается при определении размера объекта с помощью операции `sizeof`.

<hr>

[Содержание](#содержание)

## Статические методы

Статические методы предназначены для обращения к статическим полям класса. Они могут обращаться непосредственно только к статическим полям и вызывать только другие статические методы класса, потому что им не передается скрытый указатель `this`. Обращение к статическим методам производится так же, как к статическим полям — либо через имя класса, либо, если хотя бы один объект класса уже создан, через имя объекта.

```c++
class А {
    static int count;  // Поле count - скрытое
   public:
    static void incCount() { count++; }
};

...

    A::int count;  // Определение в глобальной области
void f() {
    А а;
    // a.count++ - нельзя, поле count скрытое
    // Изменение поля с помощью статического метода:
    a.inCount();  // или А::inCount();
}
```
Статические методы не могут быть константными (`const`) и виртуальными (`virtual`).

<hr>

[Содержание](#содержание)

## Задачи 3

С помощью модификатора `static` можно описать статические поля и методы класса

Выберите все подходящие ответы из списка

+ [ ] Статические поля доступны только через имя объекта
+ [ ] Статические методы могут быть константными (const) и виртуальными (virtual).
+ [ ] Память, занимаемая статическим полем, учитывается при определении размера объекта с помощью операции sizeof.
+ [x] Память под статическое поле выделяется один раз при его инициализации независимо от числа созданных объектов

<hr>

[Содержание](#содержание)

# 2.4 Дружественные функции и классы

## Дружественные функции и классы

Иногда желательно иметь непосредственный доступ извне к скрытым полям класса. Для этого служат дружественные функции и дружественные классы.

## Дружественная функция

Дружественные функции применяются для доступа к скрытым нолям класса и представляют собой альтернативу методам. Метод, как правило, используется для реализации свойств объекта, а в виде дружественных функций оформляются действия, не представляющие свойства класса, но концептуально входящие в его интерфейс и нуждающиеся в доступе к его скрытым полям, например, переопределенные операции вывода объектов.

Ниже перечислены правила описания и особенности дружественных функций.
+ Дружественная функция объявляется внутри класса, к элементам которого ей нужен доступ, с ключевым словом `friend`. В качестве параметра ей должен передаваться объект или ссылка на объект класса, поскольку указатель `this` ей не передается.
+ Дружественная функция может быть обычной функцией или методом другого ранее определенного класса. На нее не распространяется действие спецификаторов доступа, место размещения ее объявления в классе безразлично.
+ Одна функция может быть дружественной сразу нескольким классами.

В качестве примера ниже приведено описание двух функций, дружественных классу `monster`. Функция `kill` является методом класса `Hero`, а функция `stealAmmo` не принадлежит ни одному классу. Обеим функциям в качестве параметра передается ссылка на объект класса `Monster`.

```c++
class Monster; // Предварительное объявление класса 

class Hero {
public:
  void kill(Monster &);
  ...
};

class Monster {
friend int stealAmmo(Monster &);
friend void Hero::kill(Monster &);
// Класс Hero должен быть определен ранее
};

int stealAmmo(Monster &M){return --M.ammo;}
void Hero::kill(Monster &M){M.health = 0; M.ammo = 0;}
```

Использования дружественных функций нужно по возможности избегать, поскольку они нарушают принцип инкапсуляции и, таким образом, затрудняют отладку и модификацию программы.

<hr>

[Содержание](#содержание)

## Дружественный класс

Если все методы какого-либо класса должны иметь доступ к скрытым полям другого, весь класс объявляется дружественным с помощью ключевого слова `friend`. В приведенном ниже примере класс `Mistress` объявляется дружественным классу `Hero`:

```c++
class Hero {
  friend class Mistress;
}

class Mistress {
  ...
  void f1():
  void f2():
}
```

Функции `f1` и `f2` являются дружественными по отношению к классу `Hero` (хотя и описаны без ключевого слова `friend`) и имеют доступ ко всем его полям. Объявление `friend` не является спецификатором доступа и не наследуется.

Обратите внимание на то, что класс сам определяет, какие функции и классы являются дружественными, а какие нет.

Выберите все подходящие ответы из списка

+ [ ] В качестве параметра дружественной функции можно передать указатель this
+ [ ] На дружественную функцию распространяется действие спецификаторов доступа
+ [ ] Дружественная функция может быть только публичной
+ [x] Дружественные функции применяются для доступа к скрытым полям класса и представляют собой альтернативу методам

<hr>

[Содержание](#содержание)

# 2.5 Перегрузка операций

## Перегрузка операций

C++ позволяет переопределить действие большинства операций так, чтобы при использовании с объектами конкретного класса они выполняли заданные функции. Эта дает возможность использовать собственные типы данных точно так же, как стандартные. Обозначения собственных операций вводить нельзя. Можно перегружать любые операции, существующие в C++, за исключением:

```
. , * ?: # ## sizeof
```

Перегрузка операций осуществляется с помощью методов специального вида `{функций-операций}` и подчиняется следующим правилам:
+ при перегрузке операций сохраняются количество аргументов, приоритеты операций и правила ассоциации (справа налево или слева направо), используемые в стандартных типах данных;
+ для стандартных типов данных переопределять операции нельзя;
+ функции-операции не могут иметь аргументов по умолчанию;
+ функции-операции наследуются (за исключением `=`);
+ функции-операции не могут определяться как `static`.

Функцию-операцию можно определить тремя способами:
+ она должна быть либо методом класса, либо
+ дружественной функцией класса, либо
+ обычной функцией. 

В двух последних случаях функция должна принимать хотя бы один аргумент, имеющий тип класса, указателя или ссылки на класс.

Функция-операция содержит ключевое слово `operator`, за которым следует знак переопределяемой операции:

```
тип operator операция ( список параметров) { тело функции } 
```

<hr>

[Содержание](#содержание)

## Перегрузка унарных операций

Унарная функция-операция, определяемая внутри класса, должна быть представлена с помощью нестатического метода без параметров, при этом операндом является вызвавший ее объект, например:

```c++
class Monster {
    Monster& operator++() {
        ++health;
        return *this;
    }
};

Monster Vasia;
std::cout << (++Vasia).getHealth();
```

Если функция определяется вне класса, она должна иметь один параметр типа класса:

```c++
class Monster{
  friend Monster & operator ++( Monster &M);
};

Monster& operator ++(Monster &M) {++M.health; return M;} 
```

Если не описывать функцию внутри класса как дружественную, нужно учитывать доступность изменяемых полей. В данном случае поле `health` недоступно извне, так как описано со спецификатором `private`, поэтому для его изменения требуется использование соответствующего метода. Введем в описание класса `Monster` метод `changeHealth`, позволяющий изменить значение поля `health`.

```c++
void changeHealth(int he){ health = he; }
```

Тогда можно перегрузить операцию инкремента с помощью обычной функции, описанной вне класса:

```c++
Monster& operator ++(Monster &М){
    int h = M.getHealth(); 
    h++;
    M.changeHealth(h);
    return M;
}
```

Операции постфиксного инкремента и декремента должны иметь первый параметр типа `int`. Он используется только для того, чтобы отличить их от префиксной формы:

```c++
class Monster{
    Monster operator ++(int){
        Monster M(*this); 
        health++;
        return M;
    }
};

Monster Vasia;
std::cout << (Vasia++).getHealth();
```

<hr>

[Содержание](#содержание)

##  Перегрузка бинарных операций

Бинарная функция-операция, определяемая внутри класса, должна быть представлена с помощью нестатического метода с параметрами, при этом вызвавший ее объект считается первым операндом:

```c++
class Monster {
    ... 
    bool operator>(const Monster &M) {
        if (health > M.health) return true;
        return false;
    }
};

Если функция определяется вне класса, она должна иметь два параметра типа класса:

bool operator >(const Monster &M1, const Monster &M2){
    if( Ml.get_health() > M2.getHealth()) {
        return true;
    }
    return false;
}
```

<hr>

[Содержание](#содержание)

## Перегрузка операции присваивания

Операция присваивания определена в любом классе по умолчанию как поэлементное копирование. Эта операция вызывается каждый раз, когда одному существующему объекту присваивается значение другого. Если класс содержит поля, память под которые выделяется динамически, необходимо определить собственную операцию присваивания. Чтобы сохранить семантику присваивания, операция-функция должна возвращать ссылку на объект, для которого она вызвана, и принимать в качестве параметра единственный аргумент — ссылку на присваиваемый объект.

```c++
const Monster& operator=(const Monster& M) {
    // Проверка на самоприсваивание:
    if (&М == this) return this;
    if (name) delete[] name;
    if (M.name) {
        name = new char[strlen(M.name) + 1];
        strcpy(name.M.name);
    } else {
        name = 0;
    }
    health = M.health;
    ammo = M.ammo;
    skin = M.skin;
    return *this;
}
```
Возврат из функции указателя на объект делает возможной цепочку операций присваивания:

```c++
Monster А(10), В, С;
С = В = А;
```

Операцию присваивания можно определять только как метод класса. Она не наследуется.

<hr>

[Содержание](#содержание)

## Перегрузка операций new и delete

Чтобы обеспечить альтернативные варианты управления памятью, можно определять собственные варианты операций `new` и `new[]` для выделения динамической памяти под объект и массив объектов соответственно, а также операции `delete` и `delete []` для ее освобождения.

Эти функции-операции должны соответствовать следующим правилам:
+ им не требуется передавать параметр типа класса;
+ первым параметром функциям `new` и `new[]` должен передаваться размер объекта типа `size_t` (это тип, возвращаемый операцией `sizeof`, он определяется в заголовочном файле ); при вызове он передается в функции неявным образом;
+ они должны определяться с типом возвращаемого значения `void*`, даже если `return` возвращает указатель на другие типы (чаще всего на класс);
+ операция `delete` должна иметь тип возврата `void` и первый аргумент типа `void*`;
+ операции выделения и освобождения памяти являются статическими элементами класса.

Поведение перегруженных операций должно соответствовать действиям, выполняемым ими по умолчанию. Для операции `new` это означает, что она должна возвращать правильное значение, корректно обрабатывать запрос на выделение памяти нулевого размера и порождать исключение при невозможности выполнения запроса. 

Для операции `delete` следует соблюдать условие, что удаление нулевого указателя должно быть безопасным, поэтому внутри операции необходима проверка указателя на нуль и отсутствие каких-либо действий в случае равенства.

Стандартные операции выделения и освобождения памяти могут использоваться в области действия класса наряду с перегруженными (с помощью операции доступа к области видимости `::` для объектов этого класса и непосредственно — для любых других).

Перегрузка операции выделения памяти применяется для экономии памяти, повышения быстродействия программы или для размещения данных в некоторой конкретной области. Например, пусть описывается класс, содержащий указатель на некоторый объект:

```c++
class Obj {...}:
class pObj {
private:
    Obj *p:
};
```

При выделении памяти под объект типа `pObj` с помощью стандартной операции `new`

```c++
pObj *р = new pObj;
```

фактическое количество байтов будет превышать `sizeof(pObj)`, поскольку `new` обычно записывает в начало выделяемой области ее размер (для того чтобы правильно отрабатывала операция `delete`).

Для небольших объектов эти накладные расходы могут оказаться весьма значительными. Для экономии памяти можно написать собственную операцию `new` класса `pObj`, которая будет выделять большой блок памяти, а затем размещать в нем указатели на `Obj`. Для этого в объект `pObj` вводится статическое поле `headOfFree`, в котором хранится указатель на первую свободную ячейку блока для размещения очередного объекта.

Неиспользуемые ячейки связываются в список. Чтобы не занимать память под поле связи, используется объединение (`union`), с помощью которого одна и та же ячейка используется либо для размещения указателя на объект, либо для связи со следующей свободной ячейкой:

```c++
#include <iostream>

class Obj {...};
class pObj {
private:
  Obj *p:
};

class pObj {
   public:
    static void *operator new(size_t size);

   private:
    union {
        Obj *p;      // Указатель на объект
        pObj *next;  // Указатель на следующую свободную ячейку
    };
    static const int BLOCK_SIZE;  // Размер блока
    // Заголовок списка свободных ячеек:
    static pObj *headOfFree;
};

void *pObj::operator new(size_t size) {
    // Перенаправить запросы неверного количества памяти
    // стандартной операции new:
    if (size != sizeof(pObj)) return ::operator new(size);
    pObj *p = headOfFree;  // Указатель на первую свободную ячейку
    // Переместить указатель списка свободных ячеек:
    if (p) headOfFree = p->next;
    // Если свободной памяти нет, выделяем очередной блок:
    else {
        pObj *newblock = static_cast<pObj *>(::operator new(BLOCK_SIZE * sizeof(pObj)));
        // Bee ячейки свободны, кроме первой (она будет
        // занята), связываем их:
        for (int i = 1; i < BLOCK_SIZE - 1; ++i) {
            newblock[i].next = &newblock[i + 1];
        }
        newblock[BLOCK_SIZE - 1].next = 0;
        // Устанавливаем начало списка свободных ячеек:
        headOfFree = &newblock[1];
        p = newblock;
    }
    return p;  // Возвращаем указатель на выделенную память
}
```

Перегруженная операция `new` наследуется, поэтому она вызывается для производных объектов. Если их размер не соответствует размеру базового (а так, скорее всего, и есть), это может вызвать проблемы. Чтобы их избежать, в начале операции проверяется соответствие размеров. Если размер объекта не равен тому, для которого перегружена операция `new`, запрос на выделение памяти передается стандартной операции `new`.

В программе, использующей класс `pObj`, должна присутствовать инициализация его статических полей:

```c++
pObj *pObj::headOfFree; // Устанавливается в О по умолчанию
const int pObj::BLOCK_SIZE = 1024; 
```

Как видно из этого примера, помимо экономии памяти достигается еще и высокое быстродействие, ведь в большинстве случаев выделение памяти сводится к нескольким простым операторам. Естественно, что если операция `new` перегружена, то же самое должно быть выполнено и для операции `delete` (например, в нашем случае стандартная операция `delete` не найдет в начале объекта верной информации о его размерах, что приведет к неопределенному поведению программы). В рассмотренном примере операция `delete` должна добавлять освобожденную ячейку памяти к списку свободных ячеек:

```c++
void pObj::operator delete(void *ObjToDie, size_t size) {
    if (ObjToDie == 0) return;
    if (size != sizeof(pObj)) {
        ::operator delete(ObjToDie);
        return;
    }
    pObj *p = static_cast<p0bj *>(0bjToDie);
    p->next = headOfFree;
    headOfFree = p;
}
```

В операции `delete` выполнена проверка соответствия размеров объектов, аналогичная приведенной в операции `new`.

<hr>

[Содержание](#содержание)

## Перегрузка операции приведения типа

Можно определить функции-операции, которые будут осуществлять преобразование объекта класса к другому типу. Формат:

```c++
operator имя_нового_типа (); 
```

Тип возвращаемого значения и параметры указывать не требуется. Можно определять виртуальные функции преобразования типа.

Пример:

```c++
Monster::operator int(){return health;}
...
Monster Vasia; cout << int(Vasia):
```

<hr>

[Содержание](#содержание)

## Перегрузка операции вызова функции

Класс, в котором определена операция вызова функции, называется функциональным. От такого класса не требуется наличия других полей и методов:

```c++
class IfGreater{
  public:
    int operator () (int a, int b) const {
        return a > b;
    }
};
```

Использование такого класса имеет весьма специфический синтаксис. Рассмотрим пример:

```c++
IfGreater х;
std::cout << х(1, 5) << '/n'; // Результат - О
std::cout << IfGreater()(5, 1) << '/n'; // Результат - 1
```

Поскольку в классе `IfGreater` определена операция вызова функции с двумя параметрами, выражение `х(1, 5)` является допустимым (то же самое можно записать в виде `X.operator () (1. 5)`). Как видно из примера, объект функционального класса используется так, как если бы он был функцией.

Во втором операторе вывода выражение `IfGreater()` используется для вызова конструктора по умолчанию класса `IfGreater`. Результатом выполнения этого выражения является объект класса `IfGreater`. Далее, как и в предыдущем случае, для этого объекта вызывается функция с двумя аргументами, записанными в круглых скобках.

Операцию `()` можно определять только как метод класса. Можно определить перегруженные операции вызова функции с различным количеством аргументов. Функциональные объекты широко применяются в стандартной библиотеке C++.

<hr>

[Содержание](#содержание)

## Перегрузка операции индексирования

Операция индексирования `[ ]` обычно перегружается, когда тип класса представляет множество значений, для которого индексирование имеет смысл. Операция индексирования должна возвращать ссылку на элемент, содержащийся в множестве. Покажем это на примере класса `Vect`, предназначенного для хранения массива целых чисел и безопасной работы с ним:

```c++
#include <iostream>
#include <stdlib.h>

class Vect {
   public:
    explicit Vect(int n = 10);
    Vect(const int a[], int n);  // инициализация массивом
    ~Vect() { delete[] p; }
    int& operator[](int i);
    void Print();

   private:
    int* p;
    int size;
};

Vect::Vect(int n) : size(n) { p = new int[size]; }

Vect::Vect(const int a[], int n) : size(n) {
    p = new int[size];
    for (int i = 0; i < size; i++) p[i] = a[i];
}

// Перегрузка операции индексирования:
int& Vect::operator[](int i) {
    if (i < 0 || i >= size) {
        std::cout << "Неверный индекс (i = " << i << ") " << std::endl;
        std::cout << "Завершение программы" << std::endl;
        exit(O);
    }
    return p[i];
}
void Vect::Print() {
    for (int i = 0; i < size; i++) std::cout << p[i] << " ";
    std::cout << std::endl;
}

int ma1n() {
    int агг[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    Vect а(аrr, 10);
    a.Print();
    std::cout << a[5] << std::endl;
    std::cout << a[12] << std::endl;
    return 0;
}
```
Результат работы программы:

```
12345678 9 10
6
Неверный индекс (1 = 12)
Завершение программы 
```

Перегруженная операция индексирования получает целый аргумент и проверяет, лежит ли его значение в пределах диапазона массива. Если да, то возвращается адрес элемента, что соответствует семантике стандартной операции индексирования. В данном примере конструктор с параметром по умолчанию объявлен как `explicit` для того, чтобы он не являлся конструктором преобразования типа, вызываемым неявно. Ключевое слово `explicit` указывает на то, что этот конструктор будет вызываться только явным образом. Операцию `[]` можно определять только как метод класса.

<hr>

[Содержание](#содержание)

## Задачи 5

Выберите все подходящие ответы из списка

+ [x] Для стандартных типов данных переопределять операции нельзя
+ [x] Функции-операции наследуются ( за исключением = )
+ [ ] Чтобы переопределить . , * ?: # ## sizeof необходимо определить их как static
+ [ ] Функцию-операцию можно определить двумя способами: она должна либо унаследованной функцией класса, либо приватной функцией класса
+ [x] при перегрузке операций сохраняются количество аргументов, приоритеты операций и правила ассоциации (справа налево или слева направо), используемые в стандартных типах данных
+ [x] Операция присваивания определена в любом классе по умолчанию как поэлементное копирование

Выберите все подходящие ответы из списка

+ [x] Функции-операции `delete` и new должны определяться с типом возвращаемого значения `void*`, даже если `return` возвращает указатель на другие типы
+ [x] Перегрузка операции выделения памяти применяется для экономии памяти
+ [x] Операции выделения и освобождения памяти являются статическими элементами класса
+ [x] Перегрузка операции выделения памяти применяется повышения быстродействия программы
+ [x] Операция `delete` должна иметь тип возврата `void` и первый аргумент типа `void*`

<hr>

[Содержание](#содержание)

# TODO 1

Создайте класс для хранения комплексных чисел (КЧ). Класс должен иметь 2 поля: реальную и мнимую части. Объявите два комплексных переменных и получите их значения от пользователя.

Перегрузите операторы, необходимые для: 
+ вывода комплексного числа в формате (Re + Im, 4 + 5i)
+ сложения двух КЧ
+ разности двух КЧ
+ произведение двух КЧ
+ частное двух КЧ

Пользователь вводит два комплексных числа.

Необходимо вывести последовательно вывести сумму, разность, произведение и частное двух комплексных чисел.

Если одна из частей равняется 0, то выводить её не нужно, если обе - 0. Ответ нужно округлить до двух знаков после точки.<br>
Sample Input:<br>
4.42 - 74.83i<br>
-55.85 + 55.34i<br>
Sample Output:<br>
<br>
addition: 8.57 - 19.49i<br>
subtraction: 120.27 - 130.17i<br>
product: 543.24 + 7744.26i<br>
quotient: -1.25 + 0.1i<br>

```c++
#include <cmath>
#include <iostream>
#include <string>

class Complex {
   public:
    double re;
    double im;
    char oper;

    Complex() : re(0.0), im(0.0) {
        if (im < 0) {
            this->oper = '-';
        } else {
            this->oper = '+';
        }
    }
    Complex(double real) : re(real), im(0.0) {
        if (im < 0) {
            this->oper = '-';
        } else {
            this->oper = '+';
        }
    }
    Complex(double real, double imag) : re(real), im(imag) {
        if (im < 0) {
            this->oper = '-';
        } else {
            this->oper = '+';
        }
    }

    void get_data(double& re, double& im) {
        if (im < 0) {
            this->oper = '-';
        } else {
            this->oper = '+';
        }
        re = this->re;
        im = this->im;
    }

    void set_data() {
        char i;
        std::cin >> re >> oper >> im >> i;
        if (oper == '-') {
            im = -im;
        }
    }

    void out_data(std::string operation = "") {
        std::cout << operation;
        if (re == 0 && im == 0) {
            std::cout << '0' << std::endl;
            return;
        }
        if (re != 0) {
            if (re - (int)re == 0) {
                std::cout << (int)re << " ";
            } else {
                std::cout << re << " ";
            }
        }
        if (im != 0) {
            if (im < 0) {
                oper = '-';
            } else {
                oper = '+';
            }
            std::cout << oper << " ";

            if (oper == '-') {
                if (im - (int)im == 0) {
                    std::cout << -(int)im;
                } else {
                    std::cout << -im;
                }
            } else {
                if (im - (int)im == 0) {
                    std::cout << (int)im;
                } else {
                    std::cout << im;
                }
            }
            std::cout << 'i';
        }
        std::cout << std::endl;
    }

    const Complex& add(const Complex& other) {
        this->re += other.re;
        this->im += other.im;
        if (im < 0) {
            this->oper = '-';
        } else {
            this->oper = '+';
        }
        return *this;
    }

    const Complex& sub(const Complex& other) {
        this->re -= other.re;
        this->im -= other.im;
        if (im < 0) {
            this->oper = '-';
        } else {
            this->oper = '+';
        }
        return *this;
    }

    const Complex& prod(const Complex& other) {
        double temp_re = this->re * other.re - this->im * other.im;
        double temp_im = this->re * other.im + this->im * other.re;

        this->re = round(temp_re * 100) / 100.0;
        this->im = round(temp_im * 100) / 100.0;

        if (im < 0) {
            this->oper = '-';
        } else {
            this->oper = '+';
        }
        return *this;
    }

    const Complex& quot(const Complex& other) {
        double divisor = other.re * other.re + other.im * other.im;
        double temp_re = (this->re * other.re + this->im * other.im) / divisor;
        double temp_im = (this->im * other.re - this->re * other.im) / divisor;

        this->re = round(temp_re * 100) / 100.0;
        this->im = round(temp_im * 100) / 100.0;

        if (im < 0) {
            this->oper = '-';
        } else {
            this->oper = '+';
        }
        return *this;
    }
};

Complex addition(const Complex& first, const Complex& second) {
    Complex result = first;
    result.add(second);
    if (result.im < 0) {
        result.oper = '-';
    } else {
        result.oper = '+';
    }
    return result;
}

Complex subtraction(const Complex& first, const Complex& second) {
    Complex result = first;
    result.sub(second);
    if (result.im < 0) {
        result.oper = '-';
    } else {
        result.oper = '+';
    }
    return result;
}

Complex product(const Complex& first, const Complex& second) {
    Complex result = first;
    result.prod(second);
    if (result.im < 0) {
        result.oper = '-';
    } else {
        result.oper = '+';
    }
    return result;
}

Complex quotient(const Complex& first, const Complex& second) {
    Complex result = first;
    result.quot(second);
    if (result.im < 0) {
        result.oper = '-';
    } else {
        result.oper = '+';
    }
    return result;
}

int main() {
    Complex a, b;
    a.set_data();
    b.set_data();

    Complex c = addition(a, b);
    Complex d = subtraction(a, b);
    Complex e = product(a, b);
    Complex f = quotient(a, b);

    c.out_data("addition: ");
    d.out_data("subtraction: ");
    e.out_data("product: ");
    f.out_data("quotient: ");

    return 0;
}
```

<hr>

[Содержание](#содержание)

# 2.6 Обработки исключений

## Обработка исключений

Исключительная ситуация, или исключение — это возникновение непредвиденного или аварийного события, которое может порождаться некорректным использованием аппаратуры. Например, это деление на ноль или обращение по несуществующему адресу памяти. Обычно эти события приводят к завершению программы с системным сообщением об ошибке. C++ дает программисту возможность восстанавливать программу и продолжать ее выполнение.

Исключения C++ не поддерживают обработку асинхронных событий, таких, как ошибки оборудования или обработку прерываний, например, нажатие клавиш `Ctrl+C`. Механизм исключений предназначен только для событий, которые происходят в результате работы самой программы и указываются явным образом. Исключения возникают тогда, когда некоторая часть программы не смогла сделать то, что от нее требовалось. При этом другая часть программы может попытаться сделать что-нибудь иное.

Исключения позволяют логически разделить вычислительный процесс на две части — обнаружение аварийной ситуации и ее обработка. Это важно не только для лучшей структуризации программы. Главной причиной является то, что функция, обнаружившая ошибку, может не знать, что предпринимать для ее исправления, а использующий эту функцию код может знать, что делать, но не уметь определить место возникновения. Это особенно актуально при использовании библиотечных функций и программ, состоящих из многих модулей.

Другое достоинство исключений состоит в том, что для передачи информации об ошибке в вызывающую функцию не требуется применять возвращаемое значение, параметры или глобальные переменные, поэтому интерфейс функций не раздувается. Это особенно важно, например, для конструкторов, которые по синтаксису не могут возвращать значение.

В принципе, ничто не мешает рассматривать в качестве исключений не только ошибки, но и нормальные ситуации, возникающие при обработке данных, но это не имеет преимуществ перед другими решениями и не улучшает структуру и читаемость программы.

<hr>

[Содержание](#содержание)

## Общий механизм обработки исключений

Место, в котором может произойти ошибка, должно входить в контролируемый блок — составной оператор, перед которым записано ключевое слово `try`. Рассмотрим, каким образом реализуется обработка исключительных ситуаций.

+ Обработка исключения начинается с появления ошибки. Функция, в которой она возникла, генерирует исключение. Для этого используется ключевое слово `throw` с параметром, определяющим вид исключения. <br>
Параметр может быть константой, переменной или объектом и используется для передачи информации об исключении его обработчику.
+ Отыскивается соответствующий обработчик исключения и ему передается управление.
+ Если обработчик исключения не найден, вызывается стандартная функция `terminate`, которая вызывает функцию `abort`, аварийно завершающую текущий процесс. Можно установить собственную функцию завершения процесса.

При вызове каждой функции в стеке создается область памяти для хранения локальных переменных и адреса возврата в вызывающую функцию. 

Термин стек вызовов обозначает последовательность вызванных, но еще не завершившихся функций. 

Раскручиванием стека называется процесс освобождения памяти из-под локальных переменных и возврата управления вызывающей функции. 

Когда функция завершается, происходит естественное раскручивание стека. Тот же самый механизм используется и при обработке исключений. Поэтому после того, как исключение было зафиксировано, исполнение не может быть продолжено с точки генерации исключения. Подробнее этот механизм рассматривается в следующем разделе.

<hr>

[Содержание](#содержание)

## Синтаксис исключений

Ключевое слово `try` служит для обозначения контролируемого блока — кода, в котором может генерироваться исключение. Блок заключается в фигурные скобки:

```c++
try {
  ...
}
```

Все функции, прямо или косвенно вызываемые из `try`-блока, также считаются ему принадлежащими.

Генерация (порождение) исключения происходит по ключевому слову `throw`, которое употребляется либо с параметром, либо без него:

```c++
throw [ выражение ]; 
```

Тип выражения, стоящего после `throw`, определяет тип порождаемого исключения. При генерации исключения выполнение текущего блока прекращается, и происходит поиск соответствующего обработчика и передача ему управления. Как правило, исключение генерируется не непосредственно в `try`-блоке, а в функциях, прямо или косвенно в него вложенных.

Не всегда исключение, возникшее во внутреннем блоке, может быть сразу правильно обработано. В этом случае используются вложенные контролируемые блоки, и исключение передается на более высокий уровень с помощью ключевого слова `throw` без параметров.

Обработчики исключений начинаются с ключевого слова `catch`, за которым в скобках следует тип обрабатываемого исключения. Они должны располагаться непосредственно за `try`-блоком. Можно записать один или несколько обработчиков в соответствии с типами обрабатываемых исключений. Синтаксис обработчиков напоминает определение функции с одним параметром — типом исключения. Существует три формы записи:

```c++
catch(тип имя) { ... /* тело обработчика */ }
catch(тип) { ... /* тело обработчика */ }
catch(...) { ... /* тело обработчика */ } 
```

Первая форма применяется, когда имя параметра используется в теле обработчика для выполнения каких-либо действий — например, вывода информации об исключении. 

Вторая форма не предполагает использования информации об исключении, играет роль только его тип. Многоточие вместо параметра обозначает, что обработчик перехватывает все исключения. Так как обработчики просматриваются в том порядке, в котором они записаны, обработчик третьего типа следует помещать после всех остальных. Пример:

```c++
catch(int 1){
... // Обработка исключений типа int
}
catch(const char *){
... // Обработка исключений типа const char*
}
catch(Overflow){
... // Обработка исключений класса Overflow
}
catch(...){
... // Обработка всех необслуженных исключений
}
```

После обработки исключения управление передается первому оператору, находящемуся непосредственно за обработчиками исключений. Туда же, минуя код всех обработчиков, передается управление, если исключение в `try`-блоке не было сгенерировано.

<hr>

[Содержание](#содержание)

## Перехват исключений

Когда с помощью `throw` генерируется исключение, функции исполнительной библиотеки C++ выполняют следующие действия:
+ создают копию параметра `throw` в виде статического объекта, который существует до тех пор, пока исключение не будет обработано;
+ в поисках подходящего обработчика раскручивают стек, вызывая деструкторы локальных объектов, выходящих из области действия;
+ передают объект и управление обработчику, имеющему параметр, совместимый по типу с этим объектом.

При раскручивании стека все обработчики на каждом уровне просматриваются последовательно, от внутреннего блока к внешнему, пока не будет найден подходящий обработчик.

Обработчик считается найденным, если тип объекта, указанного после `throw`:
+ тот же, что и указанный в параметре `catch` (параметр может быть записан в форме `Т`, `const Т`. `Т&` или `const Т&`. где `Т`— тип исключения);
+ является производным от указанного в параметре `catch` (если наследование производилось с ключом доступа `public`);
+ является указателем, который может быть преобразован по стандартным правилам преобразования указателей к типу указателя в параметре `catch`.

Из вышеизложенного следует, что обработчики производных классов следует размещать до обработчиков базовых, поскольку в противном случае им никогда не будет передано управление. Обработчик указателя типа `void` автоматически скрывает указатель любого другого типа, поэтому его также следует размещать после обработчиков указателей конкретного типа.

Механизм исключений позволяет корректно уничтожать объекты при возникновении ошибочных ситуаций. Поэтому выделение и освобождение ресурсов полезно оформлять в виде классов, конструктор которых выделяет ресурс, а деструктор освобождает. В качестве примера можно привести класс для работы с файлом. Конструктор класса открывает файл, а деструктор — закрывает. В этом случае есть гарантия, что при возникновении ошибки файл будет корректно закрыт, и информация не будет утеряна.

Как уже упоминалось, исключение может быть как стандартного, так и определенного пользователем типа. При этом нет необходимости определять этот тип глобально — достаточно, чтобы он был известен в точке порождения исключения и в точке его обработки. Класс для представления исключения можно описать внутри класса, при работе с которым оно может возникать. Конструктор копирования этого класса должен быть объявлен как public, поскольку иначе будет невозможно создать копию объекта при генерации исключения (конструктор копирования, создаваемый по умолчанию, имеет спецификатор `public`).

<hr>

[Содержание](#содержание)

## Список исключений функции

В заголовке функции можно задать список исключений, которые она может прямо или косвенно порождать. Поскольку заголовок является интерфейсом функции, указание в нем списка исключений дает пользователям функции необходимую информацию для ее использования, а также гарантию, что при возникновении непредвиденного исключения эта ситуация будет обнаружена.

![02](/CPP_from_LETI/LETI_03/img/02_01.jpg)

Типы исключений перечисляются в скобках через запятую после ключевого слова `throw`, расположенного за списком параметров функции, например:

```c++
void fl() throw (int, const char*) { /* Тело функции */ }
void f2() throw (Oops*) { /* Тело функции */ } 
```

Если ключевое слово `throw` не указано, функция может генерировать любое исключение. Пустой список означает, что функция не должна порождать исключений:

```c++
void f() throw () {
  // Тело функции, не порождающей исключений
}
```

Исключения не входят в прототип функции. При переопределении в производном классе виртуальной функции можно задавать список исключений, такой же или более ограниченный, чем в соответствующей функции базового класса.

Указание списка исключений ни к чему не обязывает — функция может прямо или косвенно породить исключение, которое она обещала не использовать. Эта ситуация обнаруживается во время исполнения программы и приводит к вызову стандартной функции `unexpected`, которая по умолчанию просто вызывает функцию `terminate`. С помощью функции `set^unexpected` можно установить собственную функцию, которая будет вызываться вместо `terminate` и определять действие программы при возникновении непредвиденной исключительной ситуации.

Функция `terminate` по умолчанию вызывает функцию `abort`, которая завершает выполнение программы. С помощью функции `setTerminate` можно установить собственную функцию, которая будет вызываться вместо `abort` и определять способ завершения программы. Функции `setUnexpected` и `setTerminate` описаны в заголовочном файле.

<hr>

[Содержание](#содержание)

## Исключения в конструкторах и деструкторах

Язык C++ не позволяет возвращать значение из конструктора и деструктора. Механизм исключений дает возможность сообщить об ошибке, возникшей в конструкторе или деструкторе объекта. Для иллюстрации создадим класс `Vector`, в котором ограничивается количество запрашиваемой памяти:

```c++
class Vector {
public:
	class Size {}; // Класс исключения
	enum { max = 32000 }; // Максимальная длина вектора
		Vector(int n) // Конструктор
	{
			if (n<0 || n>max) throw Size(); ...
	}
	...
};
```

При использовании класса `Vector` можно предусмотреть перехват исключений типа `Size`:

```c++
try {
  Vector *р = new Vector(i);
} 
catch(Vector::Size) {
  ... / / Обработка ошибки размера вектора
}
```

В обработчике может использоваться стандартный набор основных способов выдачи сообщений об ошибке и восстановления. Внутри класса, определяющего исключение, может храниться информация об исключении, которая передается обработчику. Смысл этой техники заключается в том, чтобы обеспечить передачу информации об ошибке из точки ее обнаружения в место, где для обработки ошибки имеется достаточно возможностей.

Если в конструкторе объекта генерируется исключение, автоматически вызываются деструкторы для полностью созданных в этом блоке к текущему моменту объектов, а также для полей данных текущего объекта, являющихся объектами, и для его базовых классов. Например, если исключение возникло при создании массива объектов, деструкторы будут вызваны только для успешно созданных элементов.

Если объект создается в динамической памяти с помощью операции `new` и в конструкторе возникнет исключение, память из-под объекта корректно освобождается.

<hr>

[Содержание](#содержание)

## Иерархии исключений

Использование собственных классов исключений предпочтительнее применения стандартных типов данных. С помощью классов можно более гибко организовать передачу информации об исключении, легче дифференцировать обработку исключений, а кроме того, появляется возможность использовать иерархии классов.

Поскольку механизм управления исключениями позволяет создать обработчик для базового класса, родственные исключения часто можно представить в виде иерархии. Производя исключения от общего базового класса, можно в обработчике перехватывать ссылку или указатель на базовый класс, используя полиморфизм. Например, в математической библиотеке можно организовать классы следующим образом:

```c++
class Matherr{};
class Overflow: public Matherr{}; // Переполнение
class Underflow: public Matherr{}; // Исчезновение порядка
class ZeroDivide: public Matherr{}; // Деление на ноль
```

Для представления ошибок ввода/вывода могут использоваться следующие классы:

```c++
class IOerr{};
class Readerr: public IOerr{}; // Ошибка чтения
class Writerr: public IOerr{}; // Ошибка записи
class Seekerr: public IOerr{}; // Ошибка поиска
```

В зависимости от обстоятельств можно использовать либо обработчик исключений базового класса, который будет перехватывать и производные исключения, либо собственные обработчики производных классов.

Существует ряд стандартных исключений, которые генерируются операциями или функциями C++. Все они являются производными от библиотечного класса `exception`, описанного в заголовочном файле . Например, операция `new` при неудачном выделении памяти генерирует исключение типа `bаd_аlloc`.

Программист может определить собственные исключения, производные от стандартных.

<hr>

[Содержание](#содержание)
