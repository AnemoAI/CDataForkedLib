# 5. Проверка знаний

Согласно стандарту С++17, каков результат этой программы?

```c++
#include <iostream>

class A {
   public:
    A() { std::cout << 'a'; }
    ~A() { std::cout << 'A'; }
};

class B : public A {
   public:
    B() { std::cout << 'b'; }
    ~B() { std::cout << 'B'; }
};

int main() { B b; }
```

+ Если программа гарантированно выводит правильный ответ - напишите его в верный ответ.
+ Если программа имеет ошибку компиляции, напишите - `ошибка компиляции`.
+ Если невозможно однозначно определить правильный ответ - `ответ невозможно определить`.
+ Если в результате работы программы возникает исключение - `исключение`. 

```
abBA
```

Программа гарантированно выводится: `abBA`.

Конструктор производного класса `B()` сначала вызывает конструктор базового класса `A()`, а затем выполняет составной оператор (часть внутри `{}`) своего собственного тела.

Деструктор производного класса `~B()` сначала выполняет собственное тело, а затем вызывает деструктор базового класса `~A()`.

В конструкторе без делегирования инициализация происходит в следующем порядке:
+ (...)
+ Затем прямые базовые классы инициализируются в порядке объявления, как они появляются в списке базовых спецификаторов (независимо от порядка инициализаторов mem)
+ (...)
+ Наконец, выполняется составная инструкция тела конструктора.

После выполнения тела деструктора и уничтожения любых автоматических объектов, выделенных в теле, деструктор для класса `X` вызывает (...) деструкторы для невиртуальных прямых базовых классов `X`.

Каков результат этой программы?

```c++
#include <iostream>
class A {
   public:
    virtual void f() { std::cout << 1; }
};

class B : public A {
   public:
    void f() { std::cout << 2; }
};

void g(A a) { a.f(); }

int main() {
    B b;
    g(b);
}
```

```
1
```

`g(A a)` принимает объект типа `A` по значению, а не по ссылке или указателю. Это означает, что `A` конструктор копирования вызывается на переданном объекте `g()` (независимо от того, был ли переданный объект типа `B`), и мы получаем совершенно новый объект типа `A` внутри `g()`. 

Это обычно называют срезом (https://en.wikipedia.org/wiki/Object_slicing).

Согласно стандарту С++17, каков результат этой программы?

```c++
#include <iostream>

class X {
   public:
    int var1 : 3;
    int var2;
};

int main() {
    X x;
    std::cout << (&x.var1 < &x.var2);
}
```

+ Если программа гарантированно выводит правильный ответ - напишите его в верный ответ.
+ Если программа имеет ошибку компиляции, напишите - `ошибка компиляции`.
+ Если невозможно однозначно определить правильный ответ - `ответ невозможно определить`.
+ Если в результате работы программы возникает исключение - `исключение`. 

```
ошибка компиляции
```

`int var1 : 3;` объявляет битовое поле, и вы не можете обратиться с помощью `operator&` к битовому полю.

Оператор `address-of &` не должен применяться к битовому полю, поэтому указатели на битовые поля отсутствуют.