# 4. Паттерны проектирования

## Содержание

+ [4.1 Виды паттернов проектирования](#41-виды-паттернов-проектирования)
    + [Паттерны проектирования](#паттерны-проектирования)
    + [Классификация паттернов](#классификация-паттернов)
+ [4.2 Порождающие паттерны проектирования](#42-порождающие-паттерны-проектирования)
    + [Виды порождающих паттернов проектирования](#виды-порождающих-паттернов-проектирования)
    + [Порождающие паттерны проектирования](#порождающие-паттерны-проектирования)
        + [Фабричный метод](#фабричный-метод)
        + [Пример использования Фабричного метода (Factory Method)](#пример-использования-фабричного-метода-factory-method)
            + [Реализация паттерна `Factory Method` на основе обобщенного конструктора](#реализация-паттерна-factory-method-на-основе-обобщенного-конструктора)
            + [Классическая реализация паттерна `Factory Method`](#классическая-реализация-паттерна-factory-method)
        + [Абстрактная фабрика](#абстрактная-фабрика)
        + [Пример использования Абстрактной фабрики](#пример-использования-абстрактной-фабрики)
        + []()
+ [4.3 Структурные паттерны проектирования](#43-структурные-паттерны-проектирования)
+ [4.4 Поведенческие паттерны проектирования](#44-поведенческие-паттерны-проектирования)
+ [4.5 Задания на разработку](#45-задания-на-разработку)
+ [4.6 Курсовой проект](#46-курсовой-проект)

[Оглавление](/CPP_from_LETI/LETI_03/README.md)

# 4.1 Виды паттернов проектирования

## Паттерны проектирования

При создании программных систем перед разработчиками часто встает проблема выбора тех или иных проектных решений. В этих случаях на помощь приходят паттерны. 

Дело в том, что почти наверняка подобные задачи уже решались ранее и уже существуют хорошо продуманные элегантные решения, составленные экспертами. 

Если эти решения описать и систематизировать в каталоги, то они станут доступными менее опытным разработчикам, которые после изучения смогут использовать их как шаблоны или образцы для решения задач подобного класса. Паттерны как раз описывают решения таких повторяющихся задач.

Концепция создания программного обеспечения с использованием паттернов, несомненно, очень важная, но относительно молодая, быть может, поэтому до сих пор нет четкого определения, что же такое паттерн. Об этом свидетельствуют непрекращающиеся дискуссии в популярной литературе и на соответствующих форумах в сети.

Например, следует ли считать алгоритмы и структуры данных паттернами? 

По этому вопросу существуют противоположные мнения. 

Согласно одному из них, алгоритмы являются вычислительными паттернами, а хорошо известная фундаментальная монография Дональда Кнута "Искусство программирования" по сути, представляет собой каталог таких паттернов. 

Согласно другому мнению, алгоритмы не являются паттернами, так как решаемые ими проблемы слишком малы (оперируют такими понятиями как вычислительная сложность и потребление ресурсов), а область решения хорошо очерчена. 

Паттерны же решают проблемы большего масштаба, при этом паттерн дает не конкретное решение, а некий путь к решению, причем, выбор правильного паттерна - задача нетривиальная, предполагающая от архитектора наличие интуиции, опыта, определенного творчества.

<hr>

[Содержание](#содержание)

## Классификация паттернов

В настоящее время наиболее популярными паттернами являются паттерны проектирования. Одной из распространенных классификаций таких паттернов является классификация по степени детализации и уровню абстракции рассматриваемых систем. 

Паттерны проектирования программных систем делятся на следующие категории:
+ Архитектурные паттерны
+ Паттерны проектирования
+ Идиомы

__Архитектурные паттерны__, являясь наиболее высокоуровневыми паттернами, описывают структурную схему программной системы в целом. В данной схеме указываются отдельные функциональные составляющие системы, называемые подсистемами, а также взаимоотношения между ними. Примером архитектурного паттерна является хорошо известная программная парадигма "модель-представление-контроллер" (`model-view-controller` - `MVC`).

В свою очередь, подсистемы могут состоять из архитектурных единиц уровнем ниже. 

__Паттерны проектирования__ описывают схемы детализации программных подсистем и отношений между ними, при этом они не влияют на структуру программной системы в целом и сохраняют независимость от реализации языка программирования. 

Паттерны `GoF` относятся именно к этой категории. 

Под паттернами проектирования объектно-ориентированных систем понимается описание взаимодействия объектов и классов, адаптированных для решения общей задачи проектирования в конкретном контексте.

__Идиомы__, являясь низкоуровневыми паттернами, имеют дело с вопросами реализации какой-либо проблемы с учетом особенностей данного языка программирования. 

При этом часто одни и те же идиомы для разных языков программирования выглядят по-разному или не имеют смысла вовсе. 

Например, в C++ для устранения возможных утечек памяти могут использоваться интеллектуальные указатели. Интеллектуальный указатель содержит указатель на участок динамически выделенной памяти, который будет автоматически освобожден при выходе из зоны видимости. В среде Java такой проблемы просто не существует, так как там используется автоматическая сборка мусора. Обычно, для использования идиом нужно глубоко знать особенности применяемого языка программирования.

Следует отметить, что в программной области существуют и другие виды паттернов, не относящиеся к проектированию вообще, например, паттерны анализа, тестирования, документирования и др.

![04](/CPP_from_LETI/LETI_03/img/04_01.jpg)

Различают следующие паттерны проектирования: 
+ __Порождающие__. Отвечают за удобное и безопасное создание новых объектов или даже целых семейств объектов.
+ __Структурные__. Отвечают за построение удобных в поддержке иерархий классов.
+ __Поведенческие__. Решают задачи эффективного и безопасного взаимодействия между объектами программы. 

![04](/CPP_from_LETI/LETI_03/img/04_02.PNG)

![04](/CPP_from_LETI/LETI_03/img/04_03.PNG)

<hr>

[Содержание](#содержание)

# 4.2 Порождающие паттерны проектирования

## Виды порождающих паттернов проектирования

![04](/CPP_from_LETI/LETI_03/img/04_04.jpg)


<hr>

[Содержание](#содержание)

## Порождающие паттерны проектирования

Пожалуй, создание новых объектов является наиболее распространенной задачей, встающей перед разработчиками программных систем. Порождающие паттерны проектирования предназначены для создания объектов, позволяя системе оставаться независимой как от самого процесса порождения, так и от типов порождаемых объектов. Прежде чем рассматривать особенности каждого из порождающих паттернов, рассмотрим на примере типичные проблемы, встающие перед разработчиками при порождении в системе объектов новых типов.

Пусть мы разрабатываем многообещающую стратегическую игру, описывающую великое военное противостояние между Римской Республикой и Карфагеном (264 — 146 г. до н. э.). 

Персонажами игры могут быть воины трех типов:
+ пехота,
+ конница и
+ лучники. 

Каждый из этих видов обладает своими отличительными характеристиками, такими как внешний вид, боевая мощь, скорость передвижения и степень защиты. 

Несмотря на такие отличия, у всех видов боевых единиц есть общие черты. 

Например, все они могут передвигаться по игровому полю в различных направлениях, хотя всадники делают это быстрее всех. Или каждая боевая единица имеет свой уровень здоровья, и если он становится равным нулю, воин погибает. При этом уничтожить лучника значительно проще, чем другие виды воинов.

В будущем, если игра окажется успешной, мы будем развивать ее дальше. Например, мы могли бы добавить новые виды воинов, такие как боевые слоны, или усовершенствовать существующие, разделив пехоту на легковооруженных и тяжеловооруженных пехотинцев. 

Для внесения подобных изменений без модификации существующего кода, мы должны уже сейчас постараться сделать игру максимально независимой от конкретных типов персонажей. Казалось бы, для этого достаточно использовать следующую иерархию классов.

```c++
class Warrior {
  public:
    virtual void info() = 0;       
    virtual ~Warrior() {}
};
  
class Infantryman: public Warrior {
  public:
      void info() { cout << "Infantryman" << endl; }     
};
  
class Archer: public Warrior {
  public:
    void info() { cout << "Archer" << endl; }     
};
  
class Horseman: public Warrior {
  public:    
    void info() { cout << "Horseman" << endl; }     
};
```

Полиморфный базовый класс `Warrior` определяет общий интерфейс, а производные от него классы `Infantryman`, `Archer` и `Horseman` реализуют особенности каждого вида воина. 

Сложность заключается в том, что хотя код системы и оперирует готовыми объектами через соответствующие общие интерфейсы, в процессе игры требуется создавать новые персонажи, непосредственно указывая их конкретные типы. Если код их создания рассредоточен по всему приложению, то добавлять новые типы персонажей или заменять существующие будет затруднительно.

В таких случаях на помощь приходит фабрика объектов, локализующая создание объектов. Работа фабрики объектов напоминает функционирование виртуального конструктора, - мы можем создавать объекты нужных классов, не указывая напрямую их типы. В самом простом случае, для этого используются идентификаторы типов. Следующий пример демонстрирует простейший вариант фабрики объектов - фабричную функцию.

```c++
enum Warrior_ID { Infantryman_ID=0, Archer_ID, Horseman_ID };
  
Warrior * сreateWarrior( Warrior_ID id  )
{
    Warrior * p;
    switch (id)
    {
        case Infantryman_ID:
            p = new Infantryman();           
            break;      
        case Archer_ID:
            p = new Archer();           
            break;
        case Horseman_ID:
            p = new Horseman();           
            break;              
        default:
            assert( false);
    }
    return p;
}
```

Теперь, скрывая детали, код создания объектов разных типов игровых персонажей сосредоточен в одном месте, а именно, в фабричной функции `сreateWarrior()`. Эта функция получает в качестве аргумента тип объекта, который нужно создать, создает его и возвращает соответствующий указатель на базовый класс.

Несмотря на очевидные преимущества, у этого варианта фабрики также существуют недостатки. Например, для добавления нового вида боевой единицы необходимо сделать несколько шагов - завести новый идентификатор типа и модифицировать код фабричной функции `createWarrior( )`.

Познакомившись с основными проблемами, возникающими при создании объектов новых типов, кратко рассмотрим особенности каждого из порождающих паттернов (шаблонов).

<hr>

[Содержание](#содержание)

## Фабричный метод

__Фабричный метод__ — это порождающий паттерн проектирования, который определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов.

![04](/CPP_from_LETI/LETI_03/img/04_05.png)

__Проблема__

Представьте, что вы создаёте программу управления грузовыми перевозками. Сперва вы рассчитываете перевозить товары только на автомобилях. Поэтому весь ваш код работает с объектами класса `Грузовик`.

В какой-то момент ваша программа становится настолько известной, что морские перевозчики выстраиваются в очередь и просят добавить поддержку морской логистики в программу.

![04](/CPP_from_LETI/LETI_03/img/04_06.png)

Отличные новости, правда?! Но как насчёт кода? Большая часть существующего кода жёстко привязана к классам `Грузовиков`. Чтобы добавить в программу классы морских `Судов`, понадобится перелопатить всю программу. Более того, если вы потом решите добавить в программу ещё один вид транспорта, то всю эту работу придётся повторить.

В итоге вы получите ужасающий код, наполненный условными операторами, которые выполняют то или иное действие, в зависимости от класса транспорта.

__Решение__

Паттерн Фабричный метод предлагает создавать объекты не напрямую, используя оператор `new`, а через вызов особого _фабричного метода_. Не пугайтесь, объекты всё равно будут создаваться при помощи `new`, но делать это будет фабричный метод.

![04](/CPP_from_LETI/LETI_03/img/04_07.png)

На первый взгляд, это может показаться бессмысленным: мы просто переместили вызов конструктора из одного конца программы в другой. Но теперь вы сможете переопределить фабричный метод в подклассе, чтобы изменить тип создаваемого продукта.

Чтобы эта система заработала, все возвращаемые объекты должны иметь общий интерфейс. Подклассы смогут производить объекты различных классов, следующих одному и тому же интерфейсу.

![04](/CPP_from_LETI/LETI_03/img/04_08.png)

Например, классы `Грузовик` и `Судно` реализуют интерфейс `Транспорт` с методом доставить. Каждый из этих классов реализует метод по-своему: грузовики везут грузы по земле, а суда — по морю. Фабричный метод в классе `ДорожнойЛогистики` вернёт объект-грузовик, а класс `МорскойЛогистики` — объект-судно.

![04](/CPP_from_LETI/LETI_03/img/04_09.png)

Для клиента фабричного метода нет разницы между этими объектами, так как он будет трактовать их как некий абстрактный `Транспорт`. Для него будет важно, чтобы объект имел метод `доставить`, а как конкретно он работает — не важно.

__Структура__

![04](/CPP_from_LETI/LETI_03/img/04_10.png)

__Применимость__

+ Когда заранее неизвестны типы и зависимости объектов, с которыми должен работать ваш код. <br>
Фабричный метод отделяет код производства продуктов от остального кода, который эти продукты использует.<br>
Благодаря этому, код производства можно расширять, не трогая основной. Так, чтобы добавить поддержку нового продукта, вам нужно создать новый подкласс и определить в нём фабричный метод, возвращая оттуда экземпляр нового продукта.

+ Когда вы хотите дать возможность пользователям расширять части вашего фреймворка или библиотеки.<br>
Пользователи могут расширять классы вашего фреймворка через наследование. Но как сделать так, чтобы фреймворк создавал объекты из этих новых классов, а не из стандартных?<br>
Решением будет дать пользователям возможность расширять не только желаемые компоненты, но и классы, которые создают эти компоненты. А для этого создающие классы должны иметь конкретные создающие методы, которые можно определить.<br>
Например, вы используете готовый `UI`-фреймворк для своего приложения. Но вот беда — требуется иметь круглые кнопки, вместо стандартных прямоугольных. Вы создаёте класс `RoundButton`. Но как сказать главному классу фреймворка `UIFramework`, чтобы он теперь создавал круглые кнопки, вместо стандартных?<br>
Для этого вы создаёте подкласс `UIWithRoundButtons` из базового класса фреймворка, переопределяете в нём метод создания кнопки (а-ля `createButton`) и вписываете туда создание своего класса кнопок. Затем используете `UIWithRoundButtons` вместо стандартного `UIFramework`.

+ Когда вы хотите экономить системные ресурсы, повторно используя уже созданные объекты, вместо порождения новых.<br>
Такая проблема обычно возникает при работе с тяжёлыми ресурсоёмкими объектами, такими, как подключение к базе данных, файловой системе и т. д.

Представьте, сколько действий вам нужно совершить, чтобы повторно использовать существующие объекты:
1. Сначала вам следует создать общее хранилище, чтобы хранить в нём все создаваемые объекты.
2. При запросе нового объекта нужно будет заглянуть в хранилище и проверить, есть ли там неиспользуемый объект.
3. А затем вернуть его клиентскому коду.
4. Но если свободных объектов нет — создать новый, не забыв добавить его в хранилище.

Весь этот код нужно куда-то поместить, чтобы не засорять клиентский код.

Самым удобным местом был бы конструктор объекта, ведь все эти проверки нужны только при создании объектов. Но, увы, конструктор всегда создаёт __новые__ объекты, он не может вернуть существующий экземпляр.

Значит, нужен другой метод, который бы отдавал как существующие, так и новые объекты. Им и станет фабричный метод.

__Шаги реализации__

1. Приведите все создаваемые продукты к общему интерфейсу.
2. В классе, который производит продукты, создайте пустой фабричный метод. В качестве возвращаемого типа укажите общий интерфейс продукта.
3. Затем пройдитесь по коду класса и найдите все участки, создающие продукты. Поочерёдно замените эти участки вызовами фабричного метода, перенося в него код создания различных продуктов.<br>
В фабричный метод, возможно, придётся добавить несколько параметров, контролирующих, какой из продуктов нужно создать.<br>
На этом этапе фабричный метод, скорее всего, будет выглядеть удручающе. В нём будет жить большой условный оператор, выбирающий класс создаваемого продукта. Но не волнуйтесь, мы вот-вот исправим это.
4. Для каждого типа продуктов заведите подкласс и переопределите в нём фабричный метод. Переместите туда код создания соответствующего продукта из суперкласса.
5. Если создаваемых продуктов слишком много для существующих подклассов создателя, вы можете подумать о введении параметров в фабричный метод, которые позволят возвращать различные продукты в пределах одного подкласса.<br>
Например, у вас есть класс `Почта` с подклассами `АвиаПочта` и `НаземнаяПочта`, а также классы продуктов `Самолёт`, `Грузовик` и `Поезд`. `Авиа` соответствует `Самолётам`, но для `НаземнойПочты` есть сразу два продукта. Вы могли бы создать новый подкласс почты для поездов, но проблему можно решить и по-другому. Клиентский код может передавать в фабричный метод `НаземнойПочты` аргумент, контролирующий тип создаваемого продукта.
6. Если после всех перемещений фабричный метод стал пустым, можете сделать его абстрактным. Если в нём что-то осталось — не беда, это будет его реализацией по умолчанию.

__Преимущества и недостатки__

![04](/CPP_from_LETI/LETI_03/img/04_11.jpg)

__Отношения с другими паттернами__

+ Многие архитектуры начинаются с применения `Фабричного метода` (более простого и расширяемого через подклассы) и эволюционируют в сторону `Абстрактной фабрики`, `Прототипа` или `Строителя` (более гибких, но и более сложных).
+ Классы `Абстрактной фабрики` чаще всего реализуются с помощью `Фабричного метода`, хотя они могут быть построены и на основе `Прототипа`.
+ `Фабричный метод` можно использовать вместе с `Итератором`, чтобы подклассы коллекций могли создавать подходящие им итераторы.
+ `Прототип` не опирается на наследование, но ему нужна сложная операция инициализации. `Фабричный метод`, наоборот, построен на наследовании, но не требует сложной инициализации.
+ `Фабричный метод` можно рассматривать как частный случай `Шаблонного метода`. Кроме того, `Фабричный метод` нередко бывает частью большого класса с `Шаблонными методами`.

<hr>

[Содержание](#содержание)

## Пример использования Фабричного метода (Factory Method)

Для того, чтобы система оставалась независимой от различных типов объектов, паттерн `Factory Method` использует механизм полиморфизма - классы всех конечных типов наследуют от одного абстрактного базового класса, предназначенного для полиморфного использования. В этом базовом классе определяется единый интерфейс, через который пользователь будет оперировать объектами конечных типов.

Для обеспечения относительно простого добавления в систему новых типов паттерн `Factory Method` локализует создание объектов конкретных типов в специальном классе-фабрике. Методы этого класса, посредством которых создаются объекты конкретных классов, называются фабричными. Существуют две разновидности паттерна `Factory Method`:

_Обобщенный конструктор_, когда в том же самом полиморфном базовом классе, от которого наследуют производные классы всех создаваемых в системе типов, определяется статический фабричный метод. В качестве параметра в этот метод должен передаваться идентификатор типа создаваемого объекта.

<hr>

[Содержание](#содержание)

### Реализация паттерна `Factory Method` на основе обобщенного конструктора

```c++
#include <iostream>
#include <vector>
#include <cassert>

using namespace std;

enum Warrior_ID { Infantryman_ID = 0, Archer_ID, Horseman_ID };

// Иерархия классов игровых персонажей
class Warrior {
   public:
    virtual void info() = 0;
    virtual ~Warrior() {}
    // Параметризированный статический фабричный метод
    static Warrior* createWarrior(Warrior_ID id);
};

class Infantryman : public Warrior {
   public:
    void info() { cout << "Infantryman" << endl; }
};

class Archer : public Warrior {
   public:
    void info() { cout << "Archer" << endl; }
};

class Horseman : public Warrior {
   public:
    void info() { cout << "Horseman" << endl; }
};

// Реализация параметризированного фабричного метода
Warrior* Warrior::createWarrior(Warrior_ID id) {
    Warrior* p;
    switch (id) {
        case Infantryman_ID:
            p = new Infantryman();
            break;
        case Archer_ID:
            p = new Archer();
            break;
        case Horseman_ID:
            p = new Horseman();
            break;
        default:
            assert(false);
    }
    return p;
};

// Создание объектов при помощи параметризированного фабричного метода
int main() {
    vector<Warrior*> v;
    v.push_back(Warrior::createWarrior(Infantryman_ID));
    v.push_back(Warrior::createWarrior(Archer_ID));
    v.push_back(Warrior::createWarrior(Horseman_ID));

    for (int i = 0; i < v.size(); i++) v[i]->info();
    // ...
}
```

Представленный вариант паттерна `Factory Method` пользуется популярностью благодаря своей простоте. В нем статический фабричный метод `createWarrior()` определен непосредственно в полиморфном базовом классе `Warrior`. Этот фабричный метод является параметризированным, то есть для создания объекта некоторого типа в `createWarrior()` передается соответствующий идентификатор типа.

С точки зрения "чистоты" объектно-ориентированного кода у этого варианта есть следующие недостатки:
+ Так как код по созданию объектов всех возможных типов сосредоточен в статическом фабричном методе класса `Warrior`, то базовый класс `Warrior` обладает знанием обо всех производных от него классах, что является нетипичным для объектно-ориентированного подхода.
+ Подобное использование оператора `switch` (как в коде фабричного метода `createWarrior()`) в объектно-ориентированном программировании также не приветствуется.

Указанные недостатки отсутствуют в классической реализации паттерна `Factory Method`.

<hr>

[Содержание](#содержание)

### Классическая реализация паттерна `Factory Method`

```c++
#include <iostream>
#include <vector>

using namespace std;

// Иерархия классов игровых персонажей
class Warrior {
   public:
    virtual void info() = 0;
    virtual ~Warrior() {}
};

class Infantryman : public Warrior {
   public:
    void info() { cout << "Infantryman" << endl; };
};

class Archer : public Warrior {
   public:
    void info() { cout << "Archer" << endl; };
};

class Horseman : public Warrior {
   public:
    void info() { cout << "Horseman" << endl; };
};

// Фабрики объектов
class Factory {
   public:
    virtual Warrior* createWarrior() = 0;
    virtual ~Factory() {}
};

class InfantryFactory : public Factory {
   public:
    Warrior* createWarrior() { return new Infantryman; }
};

class ArchersFactory : public Factory {
   public:
    Warrior* createWarrior() { return new Archer; }
};

class CavalryFactory : public Factory {
   public:
    Warrior* createWarrior() { return new Horseman; }
};

// Создание объектов при помощи фабрик объектов
int main() {
    InfantryFactory* infantry_factory = new InfantryFactory;
    ArchersFactory* archers_factory = new ArchersFactory;
    CavalryFactory* cavalry_factory = new CavalryFactory;

    vector<Warrior*> v;
    v.push_back(infantry_factory->createWarrior());
    v.push_back(archers_factory->createWarrior());
    v.push_back(cavalry_factory->createWarrior());

    for (int i = 0; i < v.size(); i++) v[i]->info();
    // ...
}
```

Классический вариант паттерна `Factory Method` использует идею полиморфной фабрики. Специально выделенный для создания объектов полиморфный базовый класс `Factory` объявляет интерфейс фабричного метода `createWarrior()`, а производные классы его реализуют.

Представленный вариант паттерна `Factory Method` является наиболее распространенным, но не единственным. Возможны следующие вариации:
+ Класс `Factory` имеет реализацию фабричного метода `createWarrior()` по умолчанию.
+ Фабричный метод `createWarrior()` класса `Factory` параметризирован типом создаваемого объекта (как и у представленного ранее, простого варианта `Factory Method`) и имеет реализацию по умолчанию. В этом случае, производные от `Factory` классы необходимы лишь для того, чтобы определить нестандартное поведение `createWarrior()`.

<hr>

[Содержание](#содержание)

## Абстрактная фабрика

__Абстрактная фабрика__ — это порождающий паттерн проектирования, который позволяет создавать семейства связанных объектов, не привязываясь к конкретным классам создаваемых объектов.

![04](/CPP_from_LETI/LETI_03/img/04_12.png)

__Проблема__

Представьте, что вы пишете симулятор мебельного магазина. Ваш код содержит:

Семейство зависимых продуктов. Скажем, `Кресло` + `Диван` + `Столик`.

Несколько вариаций этого семейства. Например, продукты `Кресло`, `Диван` и `Столик` представлены в трёх разных стилях: `Арт-деко`, `Викторианском` и `Модерне`.

![04](/CPP_from_LETI/LETI_03/img/04_13.png)

Вам нужен такой способ создавать объекты продуктов, чтобы они сочетались с другими продуктами того же семейства. Это важно, так как клиенты расстраиваются, если получают несочетающуюся мебель.

![04](/CPP_from_LETI/LETI_03/img/04_14.png)

Кроме того, вы не хотите вносить изменения в существующий код при добавлении новых продуктов или семейств в программу. Поставщики часто обновляют свои каталоги, и вы бы не хотели менять уже написанный код каждый раз при получении новых моделей мебели.

__Решение__

Для начала паттерн `Абстрактная фабрика` предлагает выделить общие интерфейсы для отдельных продуктов, составляющих семейства. Так, все вариации кресел получат общий интерфейс `Кресло`, все диваны реализуют интерфейс `Диван` и так далее.

![04](/CPP_from_LETI/LETI_03/img/04_15.png)

Далее вы создаёте _абстрактную фабрику_ — общий интерфейс, который содержит методы создания всех продуктов семейства (например, `создатьКресло`, `создатьДиван` и `создатьСтолик`). Эти операции должны возвращать __абстрактные__ типы продуктов, представленные интерфейсами, которые мы выделили ранее — `Кресла`, `Диваны` и `Столики`.

![04](/CPP_from_LETI/LETI_03/img/04_16.png)

Как насчёт вариаций продуктов? Для каждой вариации семейства продуктов мы должны создать свою собственную фабрику, реализовав абстрактный интерфейс. Фабрики создают продукты одной вариации. Например, `ФабрикаМодерн` будет возвращать только `КреслаМодерн`,`ДиваныМодерн` и `СтоликиМодерн`.

Клиентский код должен работать как с фабриками, так и с продуктами только через их общие интерфейсы. Это позволит подавать в ваши классы любой тип фабрики и производить любые продукты, ничего не ломая.

![04](/CPP_from_LETI/LETI_03/img/04_17.png)

Например, клиентский код просит фабрику сделать стул. Он не знает, какого типа была эта фабрика. Он не знает, получит викторианский или модерновый стул. Для него важно, чтобы на стуле можно было сидеть и чтобы этот стул отлично смотрелся с диваном той же фабрики.

Осталось прояснить последний момент: кто создаёт объекты конкретных фабрик, если клиентский код работает только с интерфейсами фабрик? Обычно программа создаёт конкретный объект фабрики при запуске, причём тип фабрики выбирается, исходя из параметров окружения или конфигурации.

__Применимость__

+ Когда бизнес-логика программы должна работать с разными видами связанных друг с другом продуктов, не завися от конкретных классов продуктов.<br>
Абстрактная фабрика скрывает от клиентского кода подробности того, как и какие конкретно объекты будут созданы. Но при этом клиентский код может работать со всеми типами создаваемых продуктов, поскольку их общий интерфейс был заранее определён.
+ Когда в программе уже используется Фабричный метод, но очередные изменения предполагают введение новых типов продуктов.<br>
В хорошей программе каждый _класс отвечает только за одну вещь_. Если класс имеет слишком много фабричных методов, они способны затуманить его основную функцию. Поэтому имеет смысл вынести всю логику создания продуктов в отдельную иерархию классов, применив абстрактную фабрику.

__Шаги реализации__

1. Создайте таблицу соотношений типов продуктов к вариациям семейств продуктов.
2. Сведите все вариации продуктов к общим интерфейсам.
3. Определите интерфейс абстрактной фабрики. Он должен иметь фабричные методы для создания каждого из типов продуктов.
4. Создайте классы конкретных фабрик, реализовав интерфейс абстрактной фабрики. Этих классов должно быть столько же, сколько и вариаций семейств продуктов.
5. Измените код инициализации программы так, чтобы она создавала определённую фабрику и передавала её в клиентский код.
6. Замените в клиентском коде участки создания продуктов через конструктор вызовами соответствующих методов фабрики.

__Преимущества и недостатки__

![04](/CPP_from_LETI/LETI_03/img/04_18.jpg)

__Отношения с другими паттернами__

+ Многие архитектуры начинаются с применения `Фабричного метода` (более простого и расширяемого через подклассы) и эволюционируют в сторону `Абстрактной фабрики`, `Прототипа` или `Строителя` (более гибких, но и более сложных).
+ `Строитель` концентрируется на построении сложных объектов шаг за шагом. `Абстрактная фабрика` специализируется на создании семейств связанных продуктов. `Строитель` возвращает продукт только после выполнения всех шагов, а `Абстрактная фабрика` возвращает продукт сразу же.
+ Классы `Абстрактной фабрики` чаще всего реализуются с помощью `Фабричного метода`, хотя они могут быть построены и на основе `Прототипа`.
+ `Абстрактная фабрика` может быть использована вместо `Фасада` для того, чтобы скрыть платформо-зависимые классы.
+ `Абстрактная фабрика` может работать совместно с `Мостом`. Это особенно полезно, если у вас есть абстракции, которые могут работать только с некоторыми из реализаций. В этом случае фабрика будет определять типы создаваемых абстракций и реализаций.
+ `Абстрактная фабрика`, `Строитель` и `Прототип` могут быть реализованы при помощи `Одиночки`.

<hr>

[Содержание](#содержание)

## Пример использования Абстрактной фабрики

Любое семейство или группа взаимосвязанных объектов характеризуется несколькими общими типами создаваемых продуктов, при этом сами продукты таких типов будут различными для разных семейств. Например, для случая стратегической игры общими типами создаваемых продуктов будут пехота, лучники и конница, при этом каждый из этих родов войск римской армии может существенно отличаться по внешнему виду и боевым характеристикам от соответствующих родов войск армии Карфагена.

Для того чтобы система оставалась независимой от специфики того или иного семейства продуктов необходимо использовать общие интерфейсы для всех основных типов продуктов. В случае стратегической игры это означает, что необходимо использовать три абстрактных базовых класса для каждого типа воинов: пехоты, лучников и конницы. Производные от них классы будут реализовывать специфику соответствующего типа воинов той или иной армии.

Для решения задачи по созданию семейств взаимосвязанных объектов паттерн `Abstract Factory` вводит понятие абстрактной фабрики. 

Абстрактная фабрика представляет собой некоторый полиморфный базовый класс, назначением которого является объявление интерфейсов фабричных методов, служащих для создания продуктов всех основных типов (один фабричный метод на каждый тип продукта). Производные от него классы, реализующие эти интерфейсы, предназначены для создания продуктов всех типов внутри семейства или группы. В случае нашей игры базовый класс абстрактной фабрики должен определять интерфейс фабричных методов для создания пехотинцев, лучников и конницы, а два производных от него класса будут реализовывать этот интерфейс, создавая воинов всех родов войск для той или иной армии.

```c++
#include <iostream>
#include <vector>

using namespace std;

// Абстрактные базовые классы всех возможных видов воинов
class Infantryman {
   public:
    virtual void info() = 0;
    virtual ~Infantryman() {}
};

class Archer {
   public:
    virtual void info() = 0;
    virtual ~Archer() {}
};

class Horseman {
   public:
    virtual void info() = 0;
    virtual ~Horseman() {}
};

// Классы всех видов воинов Римской армии
class RomanInfantryman : public Infantryman {
   public:
    void info() { cout << "RomanInfantryman" << endl; }
};

class RomanArcher : public Archer {
   public:
    void info() { cout << "RomanArcher" << endl; }
};

class RomanHorseman : public Horseman {
   public:
    void info() { cout << "RomanHorseman" << endl; }
};

// Классы всех видов воинов армии Карфагена
class CarthaginianInfantryman : public Infantryman {
   public:
    void info() { cout << "CarthaginianInfantryman" << endl; }
};

class CarthaginianArcher : public Archer {
   public:
    void info() { cout << "CarthaginianArcher" << endl; }
};

class CarthaginianHorseman : public Horseman {
   public:
    void info() { cout << "CarthaginianHorseman" << endl; }
};

// Абстрактная фабрика для производства воинов
class ArmyFactory {
   public:
    virtual Infantryman* createInfantryman() = 0;
    virtual Archer* createArcher() = 0;
    virtual Horseman* createHorseman() = 0;
    virtual ~ArmyFactory() {}
};

// Фабрика для создания воинов Римской армии
class RomanArmyFactory : public ArmyFactory {
   public:
    Infantryman* createInfantryman() { return new RomanInfantryman; }
    Archer* createArcher() { return new RomanArcher; }
    Horseman* createHorseman() { return new RomanHorseman; }
};

// Фабрика для создания воинов армии Карфагена
class CarthaginianArmyFactory : public ArmyFactory {
   public:
    Infantryman* createInfantryman() { return new CarthaginianInfantryman; }
    Archer* createArcher() { return new CarthaginianArcher; }
    Horseman* createHorseman() { return new CarthaginianHorseman; }
};

// Класс, содержащий всех воинов той или иной армии
class Army {
   public:
    ~Army() {
        int i;
        for (i = 0; i < vi.size(); ++i) delete vi[i];
        for (i = 0; i < va.size(); ++i) delete va[i];
        for (i = 0; i < vh.size(); ++i) delete vh[i];
    }
    void info() {
        int i;
        for (i = 0; i < vi.size(); ++i) vi[i]->info();
        for (i = 0; i < va.size(); ++i) va[i]->info();
        for (i = 0; i < vh.size(); ++i) vh[i]->info();
    }
    vector<Infantryman*> vi;
    vector<Archer*> va;
    vector<Horseman*> vh;
};

// Здесь создается армия той или иной стороны
class Game {
   public:
    Army* createArmy(ArmyFactory& factory) {
        Army* p = new Army;
        p->vi.push_back(factory.createInfantryman());
        p->va.push_back(factory.createArcher());
        p->vh.push_back(factory.createHorseman());
        return p;
    }
};

int main() {
    Game game;
    RomanArmyFactory ra_factory;
    CarthaginianArmyFactory ca_factory;

    Army* ra = game.createArmy(ra_factory);
    Army* ca = game.createArmy(ca_factory);
    cout << "Roman army:" << endl;
    ra->info();
    cout << "\nCarthaginian army:" << endl;
    ca->info();
    // ...
}
```

Вывод программы будет следующим:

```
Roman army:
RomanInfantryman
RomanArcher
RomanHorseman
  
Carthaginian army:
CarthaginianInfantryman
CarthaginianArcher
CarthaginianHorseman
```

<hr>

[Содержание](#содержание)

## Строитель

__Строитель__ — это порождающий паттерн проектирования, который позволяет создавать сложные объекты пошагово. Строитель даёт возможность использовать один и тот же код строительства для получения разных представлений объектов.

<hr>

[Содержание](#содержание)

# 4.3 Структурные паттерны проектирования

<hr>

[Содержание](#содержание)

# 4.4 Поведенческие паттерны проектирования

<hr>

[Содержание](#содержание)

# 4.5 Задания на разработку

<hr>

[Содержание](#содержание)

# 4.6 Курсовой проект

<hr>

[Содержание](#содержание)

