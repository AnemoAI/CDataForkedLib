# 4. Паттерны проектирования

## Содержание

+ [4.1 Виды паттернов проектирования](#41-виды-паттернов-проектирования)
    + [Паттерны проектирования](#паттерны-проектирования)
    + [Классификация паттернов](#классификация-паттернов)
+ [4.2 Порождающие паттерны проектирования](#42-порождающие-паттерны-проектирования)
    + [Виды порождающих паттернов проектирования](#виды-порождающих-паттернов-проектирования)
    + [Порождающие паттерны проектирования](#порождающие-паттерны-проектирования)
    + [Фабричный метод](#фабричный-метод)
    + [Пример использования Фабричного метода (Factory Method)](#пример-использования-фабричного-метода-factory-method)
        + [Реализация паттерна `Factory Method` на основе обобщенного конструктора](#реализация-паттерна-factory-method-на-основе-обобщенного-конструктора)
        + [Классическая реализация паттерна `Factory Method`](#классическая-реализация-паттерна-factory-method)
    + [Абстрактная фабрика](#абстрактная-фабрика)
    + [Пример использования Абстрактной фабрики](#пример-использования-абстрактной-фабрики)
    + [Строитель](#строитель)
    + [Пример использования Строителя](#пример-использования-строителя)
    + [Прототип](#прототип)
    + [Пример использования Прототипа](#пример-использования-прототипа)
    + [Одиночка](#одиночка)
    + [Пример использования Одиночки](#пример-использования-одиночки)
        + [Рассмотрим наиболее часто встречающуюся реализацию паттерна `Singleton`.](#рассмотрим-наиболее-часто-встречающуюся-реализацию-паттерна-singleton)
        + [Singleton Мэйерса](#singleton-мэйерса)
        + [Улучшенная версия классической реализации Singleton](#улучшенная-версия-классической-реализации-singleton)
        + [Использование нескольких взаимозависимых одиночек](#использование-нескольких-взаимозависимых-одиночек)
    + [Вопросы](#вопросы)
+ [4.3 Структурные паттерны проектирования](#43-структурные-паттерны-проектирования)
    + [Виды структурных паттернов проектирования](#виды-структурных-паттернов-проектирования)
    + [Адаптер](#адаптер)
    + [Пример использования паттерна `Адаптер`](#пример-использования-паттерна-адаптер)
    + [Мост](#мост)
    + [Пример использования паттерна `Мост`](#пример-использования-паттерна-мост)
    + [Компоновщик](#компоновщик)
    + [Пример использования паттерна Компоновщик (Composite)](#пример-использования-паттерна-компоновщик-composite)
    + [Декоратор](#декоратор)
    + [Пример использования паттерна Компоновщик (Component)](#пример-использования-паттерна-компоновщик-component)
    + [Фасад](#фасад)
    + [Пример использования паттерна Фасад (Facade)](#пример-использования-паттерна-фасад-facade)
    + [Примеры реализации паттерна Легковес (Flyweight)](#примеры-реализации-паттерна-легковес-flyweight)
    + [Примеры использования паттерна Заместитель (Proxy)](#примеры-использования-паттерна-заместитель-proxy)
    + []()
+ [4.4 Поведенческие паттерны проектирования](#44-поведенческие-паттерны-проектирования)
+ [4.5 Задания на разработку](#45-задания-на-разработку)
+ [4.6 Курсовой проект](#46-курсовой-проект)

[Оглавление](/CPP_from_LETI/LETI_03/README.md)

# 4.1 Виды паттернов проектирования

## Паттерны проектирования

При создании программных систем перед разработчиками часто встает проблема выбора тех или иных проектных решений. В этих случаях на помощь приходят паттерны. 

Дело в том, что почти наверняка подобные задачи уже решались ранее и уже существуют хорошо продуманные элегантные решения, составленные экспертами. 

Если эти решения описать и систематизировать в каталоги, то они станут доступными менее опытным разработчикам, которые после изучения смогут использовать их как шаблоны или образцы для решения задач подобного класса. Паттерны как раз описывают решения таких повторяющихся задач.

Концепция создания программного обеспечения с использованием паттернов, несомненно, очень важная, но относительно молодая, быть может, поэтому до сих пор нет четкого определения, что же такое паттерн. Об этом свидетельствуют непрекращающиеся дискуссии в популярной литературе и на соответствующих форумах в сети.

Например, следует ли считать алгоритмы и структуры данных паттернами? 

По этому вопросу существуют противоположные мнения. 

Согласно одному из них, алгоритмы являются вычислительными паттернами, а хорошо известная фундаментальная монография Дональда Кнута "Искусство программирования" по сути, представляет собой каталог таких паттернов. 

Согласно другому мнению, алгоритмы не являются паттернами, так как решаемые ими проблемы слишком малы (оперируют такими понятиями как вычислительная сложность и потребление ресурсов), а область решения хорошо очерчена. 

Паттерны же решают проблемы большего масштаба, при этом паттерн дает не конкретное решение, а некий путь к решению, причем, выбор правильного паттерна - задача нетривиальная, предполагающая от архитектора наличие интуиции, опыта, определенного творчества.

<hr>

[Содержание](#содержание)

## Классификация паттернов

В настоящее время наиболее популярными паттернами являются паттерны проектирования. Одной из распространенных классификаций таких паттернов является классификация по степени детализации и уровню абстракции рассматриваемых систем. 

Паттерны проектирования программных систем делятся на следующие категории:
+ Архитектурные паттерны
+ Паттерны проектирования
+ Идиомы

__Архитектурные паттерны__, являясь наиболее высокоуровневыми паттернами, описывают структурную схему программной системы в целом. В данной схеме указываются отдельные функциональные составляющие системы, называемые подсистемами, а также взаимоотношения между ними. Примером архитектурного паттерна является хорошо известная программная парадигма "модель-представление-контроллер" (`model-view-controller` - `MVC`).

В свою очередь, подсистемы могут состоять из архитектурных единиц уровнем ниже. 

__Паттерны проектирования__ описывают схемы детализации программных подсистем и отношений между ними, при этом они не влияют на структуру программной системы в целом и сохраняют независимость от реализации языка программирования. 

Паттерны `GoF` относятся именно к этой категории. 

Под паттернами проектирования объектно-ориентированных систем понимается описание взаимодействия объектов и классов, адаптированных для решения общей задачи проектирования в конкретном контексте.

__Идиомы__, являясь низкоуровневыми паттернами, имеют дело с вопросами реализации какой-либо проблемы с учетом особенностей данного языка программирования. 

При этом часто одни и те же идиомы для разных языков программирования выглядят по-разному или не имеют смысла вовсе. 

Например, в C++ для устранения возможных утечек памяти могут использоваться интеллектуальные указатели. Интеллектуальный указатель содержит указатель на участок динамически выделенной памяти, который будет автоматически освобожден при выходе из зоны видимости. В среде Java такой проблемы просто не существует, так как там используется автоматическая сборка мусора. Обычно, для использования идиом нужно глубоко знать особенности применяемого языка программирования.

Следует отметить, что в программной области существуют и другие виды паттернов, не относящиеся к проектированию вообще, например, паттерны анализа, тестирования, документирования и др.

![04](/CPP_from_LETI/LETI_03/img/04_01.jpg)

Различают следующие паттерны проектирования: 
+ __Порождающие__. Отвечают за удобное и безопасное создание новых объектов или даже целых семейств объектов.
+ __Структурные__. Отвечают за построение удобных в поддержке иерархий классов.
+ __Поведенческие__. Решают задачи эффективного и безопасного взаимодействия между объектами программы. 

![04](/CPP_from_LETI/LETI_03/img/04_02.PNG)

![04](/CPP_from_LETI/LETI_03/img/04_03.PNG)

<hr>

[Содержание](#содержание)

# 4.2 Порождающие паттерны проектирования

## Виды порождающих паттернов проектирования

![04](/CPP_from_LETI/LETI_03/img/04_04.jpg)

<hr>

[Содержание](#содержание)

## Порождающие паттерны проектирования

Пожалуй, создание новых объектов является наиболее распространенной задачей, встающей перед разработчиками программных систем. Порождающие паттерны проектирования предназначены для создания объектов, позволяя системе оставаться независимой как от самого процесса порождения, так и от типов порождаемых объектов. Прежде чем рассматривать особенности каждого из порождающих паттернов, рассмотрим на примере типичные проблемы, встающие перед разработчиками при порождении в системе объектов новых типов.

Пусть мы разрабатываем многообещающую стратегическую игру, описывающую великое военное противостояние между Римской Республикой и Карфагеном (264 — 146 г. до н. э.). 

Персонажами игры могут быть воины трех типов:
+ пехота,
+ конница и
+ лучники. 

Каждый из этих видов обладает своими отличительными характеристиками, такими как внешний вид, боевая мощь, скорость передвижения и степень защиты. 

Несмотря на такие отличия, у всех видов боевых единиц есть общие черты. 

Например, все они могут передвигаться по игровому полю в различных направлениях, хотя всадники делают это быстрее всех. Или каждая боевая единица имеет свой уровень здоровья, и если он становится равным нулю, воин погибает. При этом уничтожить лучника значительно проще, чем другие виды воинов.

В будущем, если игра окажется успешной, мы будем развивать ее дальше. Например, мы могли бы добавить новые виды воинов, такие как боевые слоны, или усовершенствовать существующие, разделив пехоту на легковооруженных и тяжеловооруженных пехотинцев. 

Для внесения подобных изменений без модификации существующего кода, мы должны уже сейчас постараться сделать игру максимально независимой от конкретных типов персонажей. Казалось бы, для этого достаточно использовать следующую иерархию классов.

```c++
class Warrior {
  public:
    virtual void info() = 0;       
    virtual ~Warrior() {}
};
  
class Infantryman: public Warrior {
  public:
      void info() { cout << "Infantryman" << endl; }     
};
  
class Archer: public Warrior {
  public:
    void info() { cout << "Archer" << endl; }     
};
  
class Horseman: public Warrior {
  public:    
    void info() { cout << "Horseman" << endl; }     
};
```

Полиморфный базовый класс `Warrior` определяет общий интерфейс, а производные от него классы `Infantryman`, `Archer` и `Horseman` реализуют особенности каждого вида воина. 

Сложность заключается в том, что хотя код системы и оперирует готовыми объектами через соответствующие общие интерфейсы, в процессе игры требуется создавать новые персонажи, непосредственно указывая их конкретные типы. Если код их создания рассредоточен по всему приложению, то добавлять новые типы персонажей или заменять существующие будет затруднительно.

В таких случаях на помощь приходит фабрика объектов, локализующая создание объектов. Работа фабрики объектов напоминает функционирование виртуального конструктора, - мы можем создавать объекты нужных классов, не указывая напрямую их типы. В самом простом случае, для этого используются идентификаторы типов. Следующий пример демонстрирует простейший вариант фабрики объектов - фабричную функцию.

```c++
enum Warrior_ID { Infantryman_ID=0, Archer_ID, Horseman_ID };
  
Warrior * сreateWarrior( Warrior_ID id  )
{
    Warrior * p;
    switch (id)
    {
        case Infantryman_ID:
            p = new Infantryman();           
            break;      
        case Archer_ID:
            p = new Archer();           
            break;
        case Horseman_ID:
            p = new Horseman();           
            break;              
        default:
            assert( false);
    }
    return p;
}
```

Теперь, скрывая детали, код создания объектов разных типов игровых персонажей сосредоточен в одном месте, а именно, в фабричной функции `сreateWarrior()`. Эта функция получает в качестве аргумента тип объекта, который нужно создать, создает его и возвращает соответствующий указатель на базовый класс.

Несмотря на очевидные преимущества, у этого варианта фабрики также существуют недостатки. Например, для добавления нового вида боевой единицы необходимо сделать несколько шагов - завести новый идентификатор типа и модифицировать код фабричной функции `createWarrior( )`.

Познакомившись с основными проблемами, возникающими при создании объектов новых типов, кратко рассмотрим особенности каждого из порождающих паттернов (шаблонов).

<hr>

[Содержание](#содержание)

## Фабричный метод

__Фабричный метод__ — это порождающий паттерн проектирования, который определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов.

![04](/CPP_from_LETI/LETI_03/img/04_05.png)

__Проблема__

Представьте, что вы создаёте программу управления грузовыми перевозками. Сперва вы рассчитываете перевозить товары только на автомобилях. Поэтому весь ваш код работает с объектами класса `Грузовик`.

В какой-то момент ваша программа становится настолько известной, что морские перевозчики выстраиваются в очередь и просят добавить поддержку морской логистики в программу.

![04](/CPP_from_LETI/LETI_03/img/04_06.png)

Отличные новости, правда?! Но как насчёт кода? Большая часть существующего кода жёстко привязана к классам `Грузовиков`. Чтобы добавить в программу классы морских `Судов`, понадобится перелопатить всю программу. Более того, если вы потом решите добавить в программу ещё один вид транспорта, то всю эту работу придётся повторить.

В итоге вы получите ужасающий код, наполненный условными операторами, которые выполняют то или иное действие, в зависимости от класса транспорта.

__Решение__

Паттерн `Фабричный метод` предлагает создавать объекты не напрямую, используя оператор `new`, а через вызов особого _фабричного метода_. Не пугайтесь, объекты всё равно будут создаваться при помощи `new`, но делать это будет фабричный метод.

![04](/CPP_from_LETI/LETI_03/img/04_07.png)

На первый взгляд, это может показаться бессмысленным: мы просто переместили вызов конструктора из одного конца программы в другой. Но теперь вы сможете переопределить фабричный метод в подклассе, чтобы изменить тип создаваемого продукта.

Чтобы эта система заработала, все возвращаемые объекты должны иметь общий интерфейс. Подклассы смогут производить объекты различных классов, следующих одному и тому же интерфейсу.

![04](/CPP_from_LETI/LETI_03/img/04_08.png)

Например, классы `Грузовик` и `Судно` реализуют интерфейс `Транспорт` с методом доставить. Каждый из этих классов реализует метод по-своему: грузовики везут грузы по земле, а суда — по морю. Фабричный метод в классе `ДорожнойЛогистики` вернёт объект-грузовик, а класс `МорскойЛогистики` — объект-судно.

![04](/CPP_from_LETI/LETI_03/img/04_09.png)

Для клиента фабричного метода нет разницы между этими объектами, так как он будет трактовать их как некий абстрактный `Транспорт`. Для него будет важно, чтобы объект имел метод `доставить`, а как конкретно он работает — не важно.

__Структура__

![04](/CPP_from_LETI/LETI_03/img/04_10.png)

__Применимость__

+ Когда заранее неизвестны типы и зависимости объектов, с которыми должен работать ваш код. <br>
Фабричный метод отделяет код производства продуктов от остального кода, который эти продукты использует.<br>
Благодаря этому, код производства можно расширять, не трогая основной. Так, чтобы добавить поддержку нового продукта, вам нужно создать новый подкласс и определить в нём фабричный метод, возвращая оттуда экземпляр нового продукта.

+ Когда вы хотите дать возможность пользователям расширять части вашего фреймворка или библиотеки.<br>
Пользователи могут расширять классы вашего фреймворка через наследование. Но как сделать так, чтобы фреймворк создавал объекты из этих новых классов, а не из стандартных?<br>
Решением будет дать пользователям возможность расширять не только желаемые компоненты, но и классы, которые создают эти компоненты. А для этого создающие классы должны иметь конкретные создающие методы, которые можно определить.<br>
Например, вы используете готовый `UI`-фреймворк для своего приложения. Но вот беда — требуется иметь круглые кнопки, вместо стандартных прямоугольных. Вы создаёте класс `RoundButton`. Но как сказать главному классу фреймворка `UIFramework`, чтобы он теперь создавал круглые кнопки, вместо стандартных?<br>
Для этого вы создаёте подкласс `UIWithRoundButtons` из базового класса фреймворка, переопределяете в нём метод создания кнопки (а-ля `createButton`) и вписываете туда создание своего класса кнопок. Затем используете `UIWithRoundButtons` вместо стандартного `UIFramework`.

+ Когда вы хотите экономить системные ресурсы, повторно используя уже созданные объекты, вместо порождения новых.<br>
Такая проблема обычно возникает при работе с тяжёлыми ресурсоёмкими объектами, такими, как подключение к базе данных, файловой системе и т. д.

Представьте, сколько действий вам нужно совершить, чтобы повторно использовать существующие объекты:
1. Сначала вам следует создать общее хранилище, чтобы хранить в нём все создаваемые объекты.
2. При запросе нового объекта нужно будет заглянуть в хранилище и проверить, есть ли там неиспользуемый объект.
3. А затем вернуть его клиентскому коду.
4. Но если свободных объектов нет — создать новый, не забыв добавить его в хранилище.

Весь этот код нужно куда-то поместить, чтобы не засорять клиентский код.

Самым удобным местом был бы конструктор объекта, ведь все эти проверки нужны только при создании объектов. Но, увы, конструктор всегда создаёт __новые__ объекты, он не может вернуть существующий экземпляр.

Значит, нужен другой метод, который бы отдавал как существующие, так и новые объекты. Им и станет фабричный метод.

__Шаги реализации__

1. Приведите все создаваемые продукты к общему интерфейсу.
2. В классе, который производит продукты, создайте пустой фабричный метод. В качестве возвращаемого типа укажите общий интерфейс продукта.
3. Затем пройдитесь по коду класса и найдите все участки, создающие продукты. Поочерёдно замените эти участки вызовами фабричного метода, перенося в него код создания различных продуктов.<br>
В фабричный метод, возможно, придётся добавить несколько параметров, контролирующих, какой из продуктов нужно создать.<br>
На этом этапе фабричный метод, скорее всего, будет выглядеть удручающе. В нём будет жить большой условный оператор, выбирающий класс создаваемого продукта. Но не волнуйтесь, мы вот-вот исправим это.
4. Для каждого типа продуктов заведите подкласс и переопределите в нём фабричный метод. Переместите туда код создания соответствующего продукта из суперкласса.
5. Если создаваемых продуктов слишком много для существующих подклассов создателя, вы можете подумать о введении параметров в фабричный метод, которые позволят возвращать различные продукты в пределах одного подкласса.<br>
Например, у вас есть класс `Почта` с подклассами `АвиаПочта` и `НаземнаяПочта`, а также классы продуктов `Самолёт`, `Грузовик` и `Поезд`. `Авиа` соответствует `Самолётам`, но для `НаземнойПочты` есть сразу два продукта. Вы могли бы создать новый подкласс почты для поездов, но проблему можно решить и по-другому. Клиентский код может передавать в фабричный метод `НаземнойПочты` аргумент, контролирующий тип создаваемого продукта.
6. Если после всех перемещений фабричный метод стал пустым, можете сделать его абстрактным. Если в нём что-то осталось — не беда, это будет его реализацией по умолчанию.

__Преимущества и недостатки__

![04](/CPP_from_LETI/LETI_03/img/04_11.jpg)

__Отношения с другими паттернами__

+ Многие архитектуры начинаются с применения `Фабричного метода` (более простого и расширяемого через подклассы) и эволюционируют в сторону `Абстрактной фабрики`, `Прототипа` или `Строителя` (более гибких, но и более сложных).
+ Классы `Абстрактной фабрики` чаще всего реализуются с помощью `Фабричного метода`, хотя они могут быть построены и на основе `Прототипа`.
+ `Фабричный метод` можно использовать вместе с `Итератором`, чтобы подклассы коллекций могли создавать подходящие им итераторы.
+ `Прототип` не опирается на наследование, но ему нужна сложная операция инициализации. `Фабричный метод`, наоборот, построен на наследовании, но не требует сложной инициализации.
+ `Фабричный метод` можно рассматривать как частный случай `Шаблонного метода`. Кроме того, `Фабричный метод` нередко бывает частью большого класса с `Шаблонными методами`.

<hr>

[Содержание](#содержание)

## Пример использования Фабричного метода (Factory Method)

Для того, чтобы система оставалась независимой от различных типов объектов, паттерн `Factory Method` использует механизм полиморфизма - классы всех конечных типов наследуют от одного абстрактного базового класса, предназначенного для полиморфного использования. В этом базовом классе определяется единый интерфейс, через который пользователь будет оперировать объектами конечных типов.

Для обеспечения относительно простого добавления в систему новых типов паттерн `Factory Method` локализует создание объектов конкретных типов в специальном классе-фабрике. Методы этого класса, посредством которых создаются объекты конкретных классов, называются фабричными. Существуют две разновидности паттерна `Factory Method`:

_Обобщенный конструктор_, когда в том же самом полиморфном базовом классе, от которого наследуют производные классы всех создаваемых в системе типов, определяется статический фабричный метод. В качестве параметра в этот метод должен передаваться идентификатор типа создаваемого объекта.

<hr>

[Содержание](#содержание)

### Реализация паттерна `Factory Method` на основе обобщенного конструктора

```c++
#include <iostream>
#include <vector>
#include <cassert>

using namespace std;

enum Warrior_ID { Infantryman_ID = 0, Archer_ID, Horseman_ID };

// Иерархия классов игровых персонажей
class Warrior {
   public:
    virtual void info() = 0;
    virtual ~Warrior() {}
    // Параметризированный статический фабричный метод
    static Warrior* createWarrior(Warrior_ID id);
};

class Infantryman : public Warrior {
   public:
    void info() { cout << "Infantryman" << endl; }
};

class Archer : public Warrior {
   public:
    void info() { cout << "Archer" << endl; }
};

class Horseman : public Warrior {
   public:
    void info() { cout << "Horseman" << endl; }
};

// Реализация параметризированного фабричного метода
Warrior* Warrior::createWarrior(Warrior_ID id) {
    Warrior* p;
    switch (id) {
        case Infantryman_ID:
            p = new Infantryman();
            break;
        case Archer_ID:
            p = new Archer();
            break;
        case Horseman_ID:
            p = new Horseman();
            break;
        default:
            assert(false);
    }
    return p;
};

// Создание объектов при помощи параметризированного фабричного метода
int main() {
    vector<Warrior*> v;
    v.push_back(Warrior::createWarrior(Infantryman_ID));
    v.push_back(Warrior::createWarrior(Archer_ID));
    v.push_back(Warrior::createWarrior(Horseman_ID));

    for (int i = 0; i < v.size(); i++) v[i]->info();
    // ...
}
```

Представленный вариант паттерна `Factory Method` пользуется популярностью благодаря своей простоте. В нем статический фабричный метод `createWarrior()` определен непосредственно в полиморфном базовом классе `Warrior`. Этот фабричный метод является параметризированным, то есть для создания объекта некоторого типа в `createWarrior()` передается соответствующий идентификатор типа.

С точки зрения "чистоты" объектно-ориентированного кода у этого варианта есть следующие недостатки:
+ Так как код по созданию объектов всех возможных типов сосредоточен в статическом фабричном методе класса `Warrior`, то базовый класс `Warrior` обладает знанием обо всех производных от него классах, что является нетипичным для объектно-ориентированного подхода.
+ Подобное использование оператора `switch` (как в коде фабричного метода `createWarrior()`) в объектно-ориентированном программировании также не приветствуется.

Указанные недостатки отсутствуют в классической реализации паттерна `Factory Method`.

<hr>

[Содержание](#содержание)

### Классическая реализация паттерна `Factory Method`

```c++
#include <iostream>
#include <vector>

using namespace std;

// Иерархия классов игровых персонажей
class Warrior {
   public:
    virtual void info() = 0;
    virtual ~Warrior() {}
};

class Infantryman : public Warrior {
   public:
    void info() { cout << "Infantryman" << endl; };
};

class Archer : public Warrior {
   public:
    void info() { cout << "Archer" << endl; };
};

class Horseman : public Warrior {
   public:
    void info() { cout << "Horseman" << endl; };
};

// Фабрики объектов
class Factory {
   public:
    virtual Warrior* createWarrior() = 0;
    virtual ~Factory() {}
};

class InfantryFactory : public Factory {
   public:
    Warrior* createWarrior() { return new Infantryman; }
};

class ArchersFactory : public Factory {
   public:
    Warrior* createWarrior() { return new Archer; }
};

class CavalryFactory : public Factory {
   public:
    Warrior* createWarrior() { return new Horseman; }
};

// Создание объектов при помощи фабрик объектов
int main() {
    InfantryFactory* infantry_factory = new InfantryFactory;
    ArchersFactory* archers_factory = new ArchersFactory;
    CavalryFactory* cavalry_factory = new CavalryFactory;

    vector<Warrior*> v;
    v.push_back(infantry_factory->createWarrior());
    v.push_back(archers_factory->createWarrior());
    v.push_back(cavalry_factory->createWarrior());

    for (int i = 0; i < v.size(); i++) v[i]->info();
    // ...
}
```

Классический вариант паттерна `Factory Method` использует идею полиморфной фабрики. Специально выделенный для создания объектов полиморфный базовый класс `Factory` объявляет интерфейс фабричного метода `createWarrior()`, а производные классы его реализуют.

Представленный вариант паттерна `Factory Method` является наиболее распространенным, но не единственным. Возможны следующие вариации:
+ Класс `Factory` имеет реализацию фабричного метода `createWarrior()` по умолчанию.
+ Фабричный метод `createWarrior()` класса `Factory` параметризирован типом создаваемого объекта (как и у представленного ранее, простого варианта `Factory Method`) и имеет реализацию по умолчанию. В этом случае, производные от `Factory` классы необходимы лишь для того, чтобы определить нестандартное поведение `createWarrior()`.

<hr>

[Содержание](#содержание)

## Абстрактная фабрика

__Абстрактная фабрика__ — это порождающий паттерн проектирования, который позволяет создавать семейства связанных объектов, не привязываясь к конкретным классам создаваемых объектов.

![04](/CPP_from_LETI/LETI_03/img/04_12.png)

__Проблема__

Представьте, что вы пишете симулятор мебельного магазина. Ваш код содержит:

Семейство зависимых продуктов. Скажем, `Кресло` + `Диван` + `Столик`.

Несколько вариаций этого семейства. Например, продукты `Кресло`, `Диван` и `Столик` представлены в трёх разных стилях: `Арт-деко`, `Викторианском` и `Модерне`.

![04](/CPP_from_LETI/LETI_03/img/04_13.png)

Вам нужен такой способ создавать объекты продуктов, чтобы они сочетались с другими продуктами того же семейства. Это важно, так как клиенты расстраиваются, если получают несочетающуюся мебель.

![04](/CPP_from_LETI/LETI_03/img/04_14.png)

Кроме того, вы не хотите вносить изменения в существующий код при добавлении новых продуктов или семейств в программу. Поставщики часто обновляют свои каталоги, и вы бы не хотели менять уже написанный код каждый раз при получении новых моделей мебели.

__Решение__

Для начала паттерн `Абстрактная фабрика` предлагает выделить общие интерфейсы для отдельных продуктов, составляющих семейства. Так, все вариации кресел получат общий интерфейс `Кресло`, все диваны реализуют интерфейс `Диван` и так далее.

![04](/CPP_from_LETI/LETI_03/img/04_15.png)

Далее вы создаёте _абстрактную фабрику_ — общий интерфейс, который содержит методы создания всех продуктов семейства (например, `создатьКресло`, `создатьДиван` и `создатьСтолик`). Эти операции должны возвращать __абстрактные__ типы продуктов, представленные интерфейсами, которые мы выделили ранее — `Кресла`, `Диваны` и `Столики`.

![04](/CPP_from_LETI/LETI_03/img/04_16.png)

Как насчёт вариаций продуктов? Для каждой вариации семейства продуктов мы должны создать свою собственную фабрику, реализовав абстрактный интерфейс. Фабрики создают продукты одной вариации. Например, `ФабрикаМодерн` будет возвращать только `КреслаМодерн`,`ДиваныМодерн` и `СтоликиМодерн`.

Клиентский код должен работать как с фабриками, так и с продуктами только через их общие интерфейсы. Это позволит подавать в ваши классы любой тип фабрики и производить любые продукты, ничего не ломая.

![04](/CPP_from_LETI/LETI_03/img/04_17.png)

Например, клиентский код просит фабрику сделать стул. Он не знает, какого типа была эта фабрика. Он не знает, получит викторианский или модерновый стул. Для него важно, чтобы на стуле можно было сидеть и чтобы этот стул отлично смотрелся с диваном той же фабрики.

Осталось прояснить последний момент: кто создаёт объекты конкретных фабрик, если клиентский код работает только с интерфейсами фабрик? Обычно программа создаёт конкретный объект фабрики при запуске, причём тип фабрики выбирается, исходя из параметров окружения или конфигурации.

__Применимость__

+ Когда бизнес-логика программы должна работать с разными видами связанных друг с другом продуктов, не завися от конкретных классов продуктов.<br>
Абстрактная фабрика скрывает от клиентского кода подробности того, как и какие конкретно объекты будут созданы. Но при этом клиентский код может работать со всеми типами создаваемых продуктов, поскольку их общий интерфейс был заранее определён.
+ Когда в программе уже используется Фабричный метод, но очередные изменения предполагают введение новых типов продуктов.<br>
В хорошей программе каждый _класс отвечает только за одну вещь_. Если класс имеет слишком много фабричных методов, они способны затуманить его основную функцию. Поэтому имеет смысл вынести всю логику создания продуктов в отдельную иерархию классов, применив абстрактную фабрику.

__Шаги реализации__

1. Создайте таблицу соотношений типов продуктов к вариациям семейств продуктов.
2. Сведите все вариации продуктов к общим интерфейсам.
3. Определите интерфейс абстрактной фабрики. Он должен иметь фабричные методы для создания каждого из типов продуктов.
4. Создайте классы конкретных фабрик, реализовав интерфейс абстрактной фабрики. Этих классов должно быть столько же, сколько и вариаций семейств продуктов.
5. Измените код инициализации программы так, чтобы она создавала определённую фабрику и передавала её в клиентский код.
6. Замените в клиентском коде участки создания продуктов через конструктор вызовами соответствующих методов фабрики.

__Преимущества и недостатки__

![04](/CPP_from_LETI/LETI_03/img/04_18.jpg)

__Отношения с другими паттернами__

+ Многие архитектуры начинаются с применения `Фабричного метода` (более простого и расширяемого через подклассы) и эволюционируют в сторону `Абстрактной фабрики`, `Прототипа` или `Строителя` (более гибких, но и более сложных).
+ `Строитель` концентрируется на построении сложных объектов шаг за шагом. `Абстрактная фабрика` специализируется на создании семейств связанных продуктов. `Строитель` возвращает продукт только после выполнения всех шагов, а `Абстрактная фабрика` возвращает продукт сразу же.
+ Классы `Абстрактной фабрики` чаще всего реализуются с помощью `Фабричного метода`, хотя они могут быть построены и на основе `Прототипа`.
+ `Абстрактная фабрика` может быть использована вместо `Фасада` для того, чтобы скрыть платформо-зависимые классы.
+ `Абстрактная фабрика` может работать совместно с `Мостом`. Это особенно полезно, если у вас есть абстракции, которые могут работать только с некоторыми из реализаций. В этом случае фабрика будет определять типы создаваемых абстракций и реализаций.
+ `Абстрактная фабрика`, `Строитель` и `Прототип` могут быть реализованы при помощи `Одиночки`.

<hr>

[Содержание](#содержание)

## Пример использования Абстрактной фабрики

Любое семейство или группа взаимосвязанных объектов характеризуется несколькими общими типами создаваемых продуктов, при этом сами продукты таких типов будут различными для разных семейств. Например, для случая стратегической игры общими типами создаваемых продуктов будут пехота, лучники и конница, при этом каждый из этих родов войск римской армии может существенно отличаться по внешнему виду и боевым характеристикам от соответствующих родов войск армии Карфагена.

Для того чтобы система оставалась независимой от специфики того или иного семейства продуктов необходимо использовать общие интерфейсы для всех основных типов продуктов. В случае стратегической игры это означает, что необходимо использовать три абстрактных базовых класса для каждого типа воинов: пехоты, лучников и конницы. Производные от них классы будут реализовывать специфику соответствующего типа воинов той или иной армии.

Для решения задачи по созданию семейств взаимосвязанных объектов паттерн `Abstract Factory` вводит понятие абстрактной фабрики. 

Абстрактная фабрика представляет собой некоторый полиморфный базовый класс, назначением которого является объявление интерфейсов фабричных методов, служащих для создания продуктов всех основных типов (один фабричный метод на каждый тип продукта). Производные от него классы, реализующие эти интерфейсы, предназначены для создания продуктов всех типов внутри семейства или группы. В случае нашей игры базовый класс абстрактной фабрики должен определять интерфейс фабричных методов для создания пехотинцев, лучников и конницы, а два производных от него класса будут реализовывать этот интерфейс, создавая воинов всех родов войск для той или иной армии.

```c++
#include <iostream>
#include <vector>

using namespace std;

// Абстрактные базовые классы всех возможных видов воинов
class Infantryman {
   public:
    virtual void info() = 0;
    virtual ~Infantryman() {}
};

class Archer {
   public:
    virtual void info() = 0;
    virtual ~Archer() {}
};

class Horseman {
   public:
    virtual void info() = 0;
    virtual ~Horseman() {}
};

// Классы всех видов воинов Римской армии
class RomanInfantryman : public Infantryman {
   public:
    void info() { cout << "RomanInfantryman" << endl; }
};

class RomanArcher : public Archer {
   public:
    void info() { cout << "RomanArcher" << endl; }
};

class RomanHorseman : public Horseman {
   public:
    void info() { cout << "RomanHorseman" << endl; }
};

// Классы всех видов воинов армии Карфагена
class CarthaginianInfantryman : public Infantryman {
   public:
    void info() { cout << "CarthaginianInfantryman" << endl; }
};

class CarthaginianArcher : public Archer {
   public:
    void info() { cout << "CarthaginianArcher" << endl; }
};

class CarthaginianHorseman : public Horseman {
   public:
    void info() { cout << "CarthaginianHorseman" << endl; }
};

// Абстрактная фабрика для производства воинов
class ArmyFactory {
   public:
    virtual Infantryman* createInfantryman() = 0;
    virtual Archer* createArcher() = 0;
    virtual Horseman* createHorseman() = 0;
    virtual ~ArmyFactory() {}
};

// Фабрика для создания воинов Римской армии
class RomanArmyFactory : public ArmyFactory {
   public:
    Infantryman* createInfantryman() { return new RomanInfantryman; }
    Archer* createArcher() { return new RomanArcher; }
    Horseman* createHorseman() { return new RomanHorseman; }
};

// Фабрика для создания воинов армии Карфагена
class CarthaginianArmyFactory : public ArmyFactory {
   public:
    Infantryman* createInfantryman() { return new CarthaginianInfantryman; }
    Archer* createArcher() { return new CarthaginianArcher; }
    Horseman* createHorseman() { return new CarthaginianHorseman; }
};

// Класс, содержащий всех воинов той или иной армии
class Army {
   public:
    ~Army() {
        int i;
        for (i = 0; i < vi.size(); ++i) delete vi[i];
        for (i = 0; i < va.size(); ++i) delete va[i];
        for (i = 0; i < vh.size(); ++i) delete vh[i];
    }
    void info() {
        int i;
        for (i = 0; i < vi.size(); ++i) vi[i]->info();
        for (i = 0; i < va.size(); ++i) va[i]->info();
        for (i = 0; i < vh.size(); ++i) vh[i]->info();
    }
    vector<Infantryman*> vi;
    vector<Archer*> va;
    vector<Horseman*> vh;
};

// Здесь создается армия той или иной стороны
class Game {
   public:
    Army* createArmy(ArmyFactory& factory) {
        Army* p = new Army;
        p->vi.push_back(factory.createInfantryman());
        p->va.push_back(factory.createArcher());
        p->vh.push_back(factory.createHorseman());
        return p;
    }
};

int main() {
    Game game;
    RomanArmyFactory ra_factory;
    CarthaginianArmyFactory ca_factory;

    Army* ra = game.createArmy(ra_factory);
    Army* ca = game.createArmy(ca_factory);
    cout << "Roman army:" << endl;
    ra->info();
    cout << "\nCarthaginian army:" << endl;
    ca->info();
    // ...
}
```

Вывод программы будет следующим:

```
Roman army:
RomanInfantryman
RomanArcher
RomanHorseman
  
Carthaginian army:
CarthaginianInfantryman
CarthaginianArcher
CarthaginianHorseman
```

<hr>

[Содержание](#содержание)

## Строитель

__Строитель__ — это порождающий паттерн проектирования, который позволяет создавать сложные объекты пошагово. Строитель даёт возможность использовать один и тот же код строительства для получения разных представлений объектов.

![04](/CPP_from_LETI/LETI_03/img/04_18.png)

__Проблема__

Представьте сложный объект, требующий кропотливой пошаговой инициализации множества полей и вложенных объектов. Код инициализации таких объектов обычно спрятан внутри монструозного конструктора с десятком параметров. Либо ещё хуже — распылён по всему клиентскому коду.

![04](/CPP_from_LETI/LETI_03/img/04_19.png)

Например, давайте подумаем о том, как создать объект `Дом`. Чтобы построить стандартный дом, нужно поставить 4 стены, установить двери, вставить пару окон и положить крышу. Но что, если вы хотите дом побольше да посветлее, имеющий сад, бассейн и прочее добро?

Самое простое решение — расширить класс `Дом`, создав подклассы для всех комбинаций параметров дома. Проблема такого подхода — это громадное количество классов, которые вам придётся создать. Каждый новый параметр, вроде цвета обоев или материала кровли, заставит вас создавать всё больше и больше классов для перечисления всех возможных вариантов.

Чтобы не плодить подклассы, вы можете подойти к решению с другой стороны. Вы можете создать гигантский конструктор `Дома`, принимающий уйму параметров для контроля над создаваемым продуктом. Действительно, это избавит вас от подклассов, но приведёт к другой проблеме.

![04](/CPP_from_LETI/LETI_03/img/04_20.png)

Большая часть этих параметров будет простаивать, а вызовы конструктора будут выглядеть монструозно из-за длинного списка параметров. К примеру, далеко не каждый дом имеет бассейн, поэтому параметры, связанные с бассейнами, будут простаивать бесполезно в 99% случаев.

__Решение__

Паттерн `Строитель` предлагает вынести конструирование объекта за пределы его собственного класса, поручив это дело отдельным объектам, называемым _строителями_.

![04](/CPP_from_LETI/LETI_03/img/04_21.png)

Паттерн предлагает разбить процесс конструирования объекта на отдельные шаги (например, `построитьСтены`, `вставитьДвери` и другие). Чтобы создать объект, вам нужно поочерёдно вызывать методы строителя. Причём не нужно запускать все шаги, а только те, что нужны для производства объекта определённой конфигурации.

Зачастую один и тот же шаг строительства может отличаться для разных вариаций производимых объектов. Например, деревянный дом потребует строительства стен из дерева, а каменный — из камня.

В этом случае вы можете создать несколько классов строителей, выполняющих одни и те же шаги по-разному. Используя этих строителей в одном и том же строительном процессе, вы сможете получать на выходе различные объекты.

![04](/CPP_from_LETI/LETI_03/img/04_22.png)

Например, один строитель делает стены из дерева и стекла, другой из камня и железа, третий из золота и бриллиантов. Вызвав одни и те же шаги строительства, в первом случае вы получите обычный жилой дом, во втором — маленькую крепость, а в третьем — роскошное жилище. Замечу, что код, который вызывает шаги строительства, должен работать со строителями через общий интерфейс, чтобы их можно было свободно взаимозаменять.

Вы можете пойти дальше и выделить вызовы методов строителя в отдельный класс, называемый _директором_. В этом случае директор будет задавать порядок шагов строительства, а строитель — выполнять их.

![04](/CPP_from_LETI/LETI_03/img/04_23.png)

Отдельный класс директора не является строго обязательным. Вы можете вызывать методы строителя и напрямую из клиентского кода. Тем не менее, директор полезен, если у вас есть несколько способов конструирования продуктов, отличающихся порядком и наличием шагов конструирования. В этом случае вы сможете объединить всю эту логику в одном классе.

Такая структура классов полностью скроет от клиентского кода процесс конструирования объектов. Клиенту останется только привязать желаемого строителя к директору, а затем получить у строителя готовый результат.

__Структура__

![04](/CPP_from_LETI/LETI_03/img/04_24.png)

__Применимость__

+ Когда вы хотите избавиться от «телескопического конструктора».<br>
Допустим, у вас есть один конструктор с десятью опциональными параметрами. Его неудобно вызывать, поэтому вы создали ещё десять конструкторов с меньшим количеством параметров. Всё, что они делают — это переадресуют вызов к базовому конструктору, подавая какие-то значения по умолчанию в параметры, которые пропущены в них самих.
```c++
class Pizza {
    Pizza(int size) { ... }
    Pizza(int size, boolean cheese) { ... }
    Pizza(int size, boolean cheese, boolean pepperoni) { ... }
    // ...
}
```

Паттерн `Строитель` позволяет собирать объекты пошагово, вызывая только те шаги, которые вам нужны. А значит, больше не нужно пытаться «запихнуть» в конструктор все возможные опции продукта.

+ Когда ваш код должен создавать разные представления какого-то объекта. Например, деревянные и железобетонные дома.<br>
Строитель можно применить, если создание нескольких представлений объекта состоит из одинаковых этапов, которые отличаются в деталях.<br>
Интерфейс строителей определит все возможные этапы конструирования. Каждому представлению будет соответствовать собственный класс-строитель. А порядок этапов строительства будет задавать класс-директор.
+ Когда вам нужно собирать сложные составные объекты, например, деревья `Компоновщика`.<br>
Строитель конструирует объекты пошагово, а не за один проход. Более того, шаги строительства можно выполнять рекурсивно. А без этого не построить древовидную структуру, вроде `Компоновщика`.

Заметьте, что `Строитель` не позволяет посторонним объектам иметь доступ к конструируемому объекту, пока тот не будет полностью готов. Это предохраняет клиентский код от получения незаконченных «битых» объектов.

__Шаги реализации__

1. Убедитесь в том, что создание разных представлений объекта можно свести к общим шагам.
2. Опишите эти шаги в общем интерфейсе строителей.
3. Для каждого из представлений объекта-продукта создайте по одному классу-строителю и реализуйте их методы строительства.<br>
Не забудьте про метод получения результата. Обычно конкретные строители определяют собственные методы получения результата строительства. Вы не можете описать эти методы в интерфейсе строителей, поскольку продукты не обязательно должны иметь общий базовый класс или интерфейс. Но вы всегда сможете добавить метод получения результата в общий интерфейс, если ваши строители производят однородные продукты с общим предком.
4. Подумайте о создании класса директора. Его методы будут создавать различные конфигурации продуктов, вызывая разные шаги одного и того же строителя.
5. Клиентский код должен будет создавать и объекты строителей, и объект директора. Перед началом строительства клиент должен связать определённого строителя с директором. Это можно сделать либо через конструктор, либо через сеттер, либо подав строителя напрямую в строительный метод директора.
6. Результат строительства можно вернуть из директора, но только если метод возврата продукта удалось поместить в общий интерфейс строителей. Иначе вы жёстко привяжете директора к конкретным классам строителей.

__Преимущества и недостатки__

![04](/CPP_from_LETI/LETI_03/img/04_25.jpg)

__Отношения с другими паттернами__

+ Многие архитектуры начинаются с применения `Фабричного метода` (более простого и расширяемого через подклассы) и эволюционируют в сторону `Абстрактной фабрики`, `Прототипа` или `Строителя` (более гибких, но и более сложных).
+ `Строитель` концентрируется на построении сложных объектов шаг за шагом. `Абстрактная фабрика` специализируется на создании семейств связанных продуктов. `Строитель` возвращает продукт только после выполнения всех шагов, а `Абстрактная фабрика` возвращает продукт сразу же.
+ `Строитель` позволяет пошагово сооружать дерево `Компоновщика`.
+ Паттерн `Строитель` может быть построен в виде `Моста`: директор будет играть роль абстракции, а строители — реализации.
+ `Абстрактная фабрика`, `Строитель` и `Прототип` могут быть реализованы при помощи `Одиночки`.

<hr>

[Содержание](#содержание)

## Пример использования Строителя

Для того чтобы не нагромождать код лишними подробностями будем полагать, что такие рода войск как пехота, лучники и конница для обеих армий идентичны. А с целью демонстрации возможностей паттерна `Builder` введем новые виды боевых единиц:
+ Катапульты для армии Рима.
+ Боевые слоны для армии Карфагена.

```c++
#include <iostream>
#include <vector>

using namespace std;

// Классы всех возможных родов войск
class Infantryman {
   public:
    void info() { cout << "Infantryman" << endl; }
};

class Archer {
   public:
    void info() { cout << "Archer" << endl; }
};

class Horseman {
   public:
    void info() { cout << "Horseman" << endl; }
};

class Catapult {
   public:
    void info() { cout << "Catapult" << endl; }
};

class Elephant {
   public:
    void info() { cout << "Elephant" << endl; }
};

// Класс "Армия", содержащий все типы боевых единиц
class Army {
   public:
    vector<Infantryman> vi;
    vector<Archer> va;
    vector<Horseman> vh;
    vector<Catapult> vc;
    vector<Elephant> ve;
    void info() {
        int i;
        for (i = 0; i < vi.size(); ++i) vi[i].info();
        for (i = 0; i < va.size(); ++i) va[i].info();
        for (i = 0; i < vh.size(); ++i) vh[i].info();
        for (i = 0; i < vc.size(); ++i) vc[i].info();
        for (i = 0; i < ve.size(); ++i) ve[i].info();
    }
};

// Базовый класс ArmyBuilder объявляет интерфейс для поэтапного
// построения армии и предусматривает его реализацию по умолчанию

class ArmyBuilder {
   protected:
    Army* p;

   public:
    ArmyBuilder() : p(0) {}
    virtual ~ArmyBuilder() {}
    virtual void createArmy() {}
    virtual void buildInfantryman() {}
    virtual void buildArcher() {}
    virtual void buildHorseman() {}
    virtual void buildCatapult() {}
    virtual void buildElephant() {}
    virtual Army* getArmy() { return p; }
};

// Римская армия имеет все типы боевых единиц кроме боевых слонов
class RomanArmyBuilder : public ArmyBuilder {
   public:
    void createArmy() { p = new Army; }
    void buildInfantryman() { p->vi.push_back(Infantryman()); }
    void buildArcher() { p->va.push_back(Archer()); }
    void buildHorseman() { p->vh.push_back(Horseman()); }
    void buildCatapult() { p->vc.push_back(Catapult()); }
};

// Армия Карфагена имеет все типы боевых единиц кроме катапульт
class CarthaginianArmyBuilder : public ArmyBuilder {
   public:
    void createArmy() { p = new Army; }
    void buildInfantryman() { p->vi.push_back(Infantryman()); }
    void buildArcher() { p->va.push_back(Archer()); }
    void buildHorseman() { p->vh.push_back(Horseman()); }
    void buildElephant() { p->ve.push_back(Elephant()); }
};

// Класс-распорядитель, поэтапно создающий армию той или иной стороны.
// Именно здесь определен алгоритм построения армии.
class Director {
   public:
    Army* createArmy(ArmyBuilder& builder) {
        builder.createArmy();
        builder.buildInfantryman();
        builder.buildArcher();
        builder.buildHorseman();
        builder.buildCatapult();
        builder.buildElephant();
        return (builder.getArmy());
    }
};

int main() {
    Director dir;
    RomanArmyBuilder ra_builder;
    CarthaginianArmyBuilder ca_builder;

    Army* ra = dir.createArmy(ra_builder);
    Army* ca = dir.createArmy(ca_builder);
    cout << "Roman army:" << endl;
    ra->info();
    cout << "\nCarthaginian army:" << endl;
    ca->info();
    // ...

    return 0;
}
```

Вывод программы будет следующим:

```
Roman army:
Infantryman
Archer
Horseman
Catapult
  
Carthaginian army:
Infantryman
Archer
Horseman
Elephant
```

Очень часто базовый класс строителя (в коде выше это `ArmyBuilder`) не только объявляет интерфейс для построения частей продукта, но и определяет ничего не делающую реализацию по умолчанию. Тогда соответствующие подклассы (`RomanArmyBuilder`, `CarthaginianArmyBuilder`) переопределяют только те методы, которые участвуют в построении текущего объекта. Так класс `RomanArmyBuilder` не определяет метод `buildElephant`, поэтому Римская армия не может иметь слонов. А в классе `CarthaginianArmyBuilder` не определен `buildCatapult()`, поэтому армия Карфагена не может иметь катапульты.

Интересно сравнить приведенный код с кодом создания армии в реализации паттерна `Abstract Factory`, который также может использоваться для создания сложных продуктов. Если паттерн `Abstract Factory` акцентирует внимание на создании семейств некоторых объектов, то паттерн `Builder` подчеркивает поэтапное построение продукта. При этом класс `Builder` скрывает все подробности построения сложного продукта так, что `Director` ничего не знает о его составных частях.

<hr>

[Содержание](#содержание)

## Прототип

`Прототип` — это порождающий паттерн проектирования, который позволяет копировать объекты, не вдаваясь в подробности их реализации.

![04](/CPP_from_LETI/LETI_03/img/04_26.png)

__Проблема__

У вас есть объект, который нужно скопировать. Как это сделать? Нужно создать пустой объект такого же класса, а затем поочерёдно скопировать значения всех полей из старого объекта в новый.

Прекрасно! Но есть нюанс. Не каждый объект удастся скопировать таким образом, ведь часть его состояния может быть приватной, а значит — недоступной для остального кода программы.

![04](/CPP_from_LETI/LETI_03/img/04_27.png)

Но есть и другая проблема. Копирующий код станет зависим от классов копируемых объектов. Ведь, чтобы перебрать все поля объекта, нужно привязаться к его классу. Из-за этого вы не сможете копировать объекты, зная только их интерфейсы, а не конкретные классы.

__Решение__

Паттерн `Прототип` поручает создание копий самим копируемым объектам. Он вводит общий интерфейс для всех объектов, поддерживающих клонирование. Это позволяет копировать объекты, не привязываясь к их конкретным классам. Обычно такой интерфейс имеет всего один метод `clone`.

Реализация этого метода в разных классах очень схожа. Метод создаёт новый объект текущего класса и копирует в него значения всех полей собственного объекта. Так получится скопировать даже приватные поля, так как большинство языков программирования разрешает доступ к приватным полям любого объекта текущего класса.

Объект, который копируют, называется прототипом (откуда и название паттерна). Когда объекты программы содержат сотни полей и тысячи возможных конфигураций, прототипы могут служить своеобразной альтернативой созданию подклассов.

![04](/CPP_from_LETI/LETI_03/img/04_28.png)

В этом случае все возможные прототипы заготавливаются и настраиваются на этапе инициализации программы. Потом, когда программе нужен новый объект, она создаёт копию из приготовленного прототипа.

__Аналогия из жизни__

В промышленном производстве прототипы создаются перед основной партией продуктов для проведения всевозможных испытаний. При этом прототип не участвует в последующем производстве, отыгрывая пассивную роль.

![04](/CPP_from_LETI/LETI_03/img/04_29.png)

Прототип на производстве не делает копию самого себя, поэтому более близкий пример паттерна — деление клеток. После митозного деления клеток образуются две совершенно идентичные клетки. Оригинальная клетка отыгрывает роль прототипа, принимая активное участие в создании нового объекта.

__Структура__

__*Базовая реализация*__

![04](/CPP_from_LETI/LETI_03/img/04_30.png)

__*Реализация с общим хранилищем прототипов*__

![04](/CPP_from_LETI/LETI_03/img/04_31.png)

__Применимость__

+ Когда ваш код не должен зависеть от классов копируемых объектов.<br>
Такое часто бывает, если ваш код работает с объектами, поданными извне через какой-то общий интерфейс. Вы не можете привязаться к их классам, даже если бы хотели, поскольку их конкретные классы неизвестны.<br>
Паттерн прототип предоставляет клиенту общий интерфейс для работы со всеми прототипами. Клиенту не нужно зависеть от всех классов копируемых объектов, а только от интерфейса клонирования.
+ Когда вы имеете уйму подклассов, которые отличаются начальными значениями полей. Кто-то мог создать все эти классы, чтобы иметь возможность легко порождать объекты с определённой конфигурацией.<br>
Паттерн прототип предлагает использовать набор прототипов, вместо создания подклассов для описания популярных конфигураций объектов.

Таким образом, вместо порождения объектов из подклассов, вы будете копировать существующие объекты-прототипы, в которых уже настроено внутреннее состояние. Это позволит избежать взрывного роста количества классов в программе и уменьшить её сложность.

__Шаги реализации__

1. Создайте интерфейс прототипов с единственным методом `clone`. Если у вас уже есть иерархия продуктов, метод клонирования можно объявить непосредственно в каждом из её классов.
2. Добавьте в классы будущих прототипов альтернативный конструктор, принимающий в качестве аргумента объект текущего класса. Этот конструктор должен скопировать из поданного объекта значения всех полей, объявленных в рамках текущего класса, а затем передать выполнение родительскому конструктору, чтобы тот позаботился о полях, объявленных в суперклассе.<br>
Если ваш язык программирования не поддерживает перегрузку методов, то вам не удастся создать несколько версий конструктора. В этом случае копирование значений можно проводить и в другом методе, специально созданном для этих целей. Конструктор удобнее тем, что позволяет клонировать объект за один вызов.
3. Метод клонирования обычно состоит всего из одной строки: вызова оператора `new` с конструктором прототипа. Все классы, поддерживающие клонирование, должны явно определить метод `clone`, чтобы использовать собственный класс с оператором `new`. В обратном случае результатом клонирования станет объект родительского класса.
4. Опционально, создайте центральное хранилище прототипов. В нём удобно хранить вариации объектов, возможно, даже одного класса, но по-разному настроенных.<br>
Вы можете разместить это хранилище либо в новом фабричном классе, либо в фабричном методе базового класса прототипов. Такой фабричный метод должен на основании входящих аргументов искать в хранилище прототипов подходящий экземпляр, а затем вызывать его метод клонирования и возвращать полученный объект.<br>
Наконец, нужно избавиться от прямых вызовов конструкторов объектов, заменив их вызовами фабричного метода хранилища прототипов.

__Преимущества и недостатки__

![04](/CPP_from_LETI/LETI_03/img/04_32.jpg)

__Отношения с другими паттернами__

+ Многие архитектуры начинаются с применения `Фабричного метода` (более простого и расширяемого через подклассы) и эволюционируют в сторону `Абстрактной фабрики`, `Прототипа` или `Строителя` (более гибких, но и более сложных).
+ Классы `Абстрактной фабрики` чаще всего реализуются с помощью `Фабричного метода`, хотя они могут быть построены и на основе `Прототипа`.
+ Если Команду нужно копировать перед вставкой в историю выполненных команд, вам может помочь `Прототип`.
+ Архитектура, построенная на `Компоновщиках` и `Декораторах`, часто может быть улучшена за счёт внедрения `Прототипа`. Он позволяет клонировать сложные структуры объектов, а не собирать их заново.
+ `Прототип` не опирается на наследование, но ему нужна сложная операция инициализации. `Фабричный метод`, наоборот, построен на наследовании, но не требует сложной инициализации.
+ `Снимок` иногда можно заменить `Прототипом`, если объект, состояние которого требуется сохранять в истории, довольно простой, не имеет активных ссылок на внешние ресурсы либо их можно легко восстановить.
+ `Абстрактная фабрика`, `Строитель` и `Прототип` могут быть реализованы при помощи `Одиночки`.

<hr>

[Содержание](#содержание)

## Пример использования Прототипа

Приведем реализацию паттерна `Prototype` на примере построения армий для военной стратегии. Для упрощения демонстрационного кода будем создавать военные персонажи для некой абстрактной армии без учета особенностей воюющих сторон.

Также как и для паттерна `Factory Method` приведем две возможные реализации паттерна `Prototype`, а именно:
1. В виде обобщенного конструктора на основе прототипов, когда в полиморфном базовом классе `Prototype` определяется статический метод, предназначенный для создания объектов. При этом в качестве параметра в этот метод должен передаваться идентификатор типа создаваемого объекта.
2. На базе специально выделенного класса-фабрики.

__Реализация паттерна `Ptototype` на основе обобщенного конструктора__

```c++
#include <iostream>
#include <map>
#include <vector>

using namespace std;

// Идентификаторы всех родов войск
enum Warrior_ID { Infantryman_ID, Archer_ID, Horseman_ID };

class Warrior;  // Опережающее объявление
typedef map<Warrior_ID, Warrior*> Registry;

// Реестр прототипов определен в виде Singleton Мэйерса
Registry& getRegistry() {
    static Registry _instance;
    return _instance;
}

// Единственное назначение этого класса - помощь в выборе нужного
// конструктора при создании прототипов
class Dummy {};

// Полиморфный базовый класс. Здесь также определен статический
// обобщенный конструктор для создания боевых единиц всех родов войск
class Warrior {
   public:
    virtual Warrior* clone() = 0;
    virtual void info() = 0;
    virtual ~Warrior() {}
    // Параметризированный статический метод для создания воинов
    // всех родов войск
    static Warrior* createWarrior(Warrior_ID id) {
        Registry& r = getRegistry();
        if (r.find(id) != r.end()) return r[id]->clone();
        return 0;
    }

   protected:
    // Добавление прототипа в множество прототипов
    static void addPrototype(Warrior_ID id, Warrior* prototype) {
        Registry& r = getRegistry();
        r[id] = prototype;
    }
    // Удаление прототипа из множества прототипов
    static void removePrototype(Warrior_ID id) {
        Registry& r = getRegistry();
        r.erase(r.find(id));
    }
};

// В производных классах различных родов войск в виде статических
// членов-данных определяются соответствующие прототипы
class Infantryman : public Warrior {
   public:
    Warrior* clone() { return new Infantryman(*this); }
    void info() { cout << "Infantryman" << endl; }

   private:
    Infantryman(Dummy) { Warrior::addPrototype(Infantryman_ID, this); }
    Infantryman() {}
    static Infantryman prototype;
};

class Archer : public Warrior {
   public:
    Warrior* clone() { return new Archer(*this); }
    void info() { cout << "Archer" << endl; }

   private:
    Archer(Dummy) { addPrototype(Archer_ID, this); }
    Archer() {}
    static Archer prototype;
};

class Horseman : public Warrior {
   public:
    Warrior* clone() { return new Horseman(*this); }
    void info() { cout << "Horseman" << endl; }

   private:
    Horseman(Dummy) { addPrototype(Horseman_ID, this); }
    Horseman() {}
    static Horseman prototype;
};

Infantryman Infantryman::prototype = Infantryman(Dummy());
Archer Archer::prototype = Archer(Dummy());
Horseman Horseman::prototype = Horseman(Dummy());

int main() {
    vector<Warrior*> v;
    v.push_back(Warrior::createWarrior(Infantryman_ID));
    v.push_back(Warrior::createWarrior(Archer_ID));
    v.push_back(Warrior::createWarrior(Horseman_ID));

    for (int i = 0; i < v.size(); i++) v[i]->info();
    // ...
}
```

В приведенной реализации классы всех создаваемых военных единиц, таких как лучники, пехотинцы и конница, являются подклассами абстрактного базового класса `Warrior`. В этом классе определен обобщенный конструктор в виде статического метода `createWarrior(Warrior_ID id)`. Передавая в этот метод в качестве параметра тип боевой единицы, можно создавать воинов нужных родов войск. Для этого обобщенный конструктор использует реестр прототипов, реализованный в виде ассоциативного массива `std::map`, каждый элемент которого представляет собой пару "идентификатор типа воина" - "его прототип".

Добавление прототипов в реестр происходит автоматически. Сделано это следующим образом. В подклассах `Infantryman`, `Archer`, `Horseman`, прототипы определяются в виде статических членов данных тех же типов. При создании такого прототипа будет вызываться конструктор с параметром типа `Dummy`, который и добавит этот прототип в реестр прототипов с помощью метода `addPrototype()` базового класса `Warrior`. Важно, чтобы к этому моменту сам объект реестра был полностью сконструирован, именно поэтому он выполнен в виде `singleton` Мэйерса.

Для приведенной реализации паттерна `Prototype` можно отметить следующие особенности:
+ Создавать новых воинов можно только при помощи обобщенного конструктора. Их непосредственное создание невозможно, так как соответствующие конструкторы объявлены со спецификатором доступа `private`.
+ Отсутствует недостаток реализации на базе обобщенного конструктора для паттерна `Factory Method`, а именно базовый класс `Warrior` ничего не знает о своих подклассах.

__Реализация паттерна Prototype с помощью выделенного класса-фабрики__

```c++
#include <iostream>
#include <vector>

using namespace std;
  
// Иерархия классов игровых персонажей
// Полиморфный базовый класс
class Warrior
{
  public:   
    virtual Warrior* clone() = 0;
    virtual void info() = 0;        
    virtual ~Warrior() {}
};
  
  
// Производные классы различных родов войск
class Infantryman: public Warrior
{
    friend class PrototypeFactory;
  public:   
    Warrior* clone() { 
      return new Infantryman( *this); 
    }
    void info() { 
      cout << "Infantryman" << endl; 
    } 
  private:
    Infantryman() {}    
};
  
class Archer: public Warrior
{
    friend class PrototypeFactory;
  public:   
    Warrior* clone() { 
      return new Archer( *this); 
    }  
    void info() { 
      cout << "Archer" << endl; 
    }
  private:  
    Archer() {} 
};
  
class Horseman: public Warrior
{
    friend class PrototypeFactory;
  public:    
    Warrior* clone() { 
      return new Horseman( *this); 
    }
    void info() { 
      cout << "Horseman" << endl; 
    }
  private:  
    Horseman() {}
};
  
  
// Фабрика для создания боевых единиц всех родов войск
class PrototypeFactory
{
  public:   
    Warrior* createInfantryman() {       
      static Infantryman prototype;
      return prototype.clone();
    }
    Warrior* createArcher() {       
      static Archer prototype;
      return prototype.clone();
    }
    Warrior* createHorseman() {     
      static Horseman prototype;
      return prototype.clone();
    }
};
  
  
int main()
{    
  PrototypeFactory factory;
  vector<Warrior*> v;
  v.push_back( factory.createInfantryman());
  v.push_back( factory.createArcher());
  v.push_back( factory.createHorseman());   
  
  for(int i=0; i<v.size(); i++)
    v[i]->info();
    // ...
}
```

В приведенной реализации для упрощения кода реестр прототипов не ведется. Воины всех родов войск создаются при помощи соответствующих методов фабричного класса `PrototypeFactory`, где и определены прототипы в виде статических переменных.

<hr>

[Содержание](#содержание)

## Одиночка

`Одиночка` — это порождающий паттерн проектирования, который гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа.

![03](/CPP_from_LETI/LETI_03/img/04_33.png)

__Проблема__

`Одиночка` решает сразу две проблемы, нарушая _принцип единственной ответственности_ класса.

__Гарантирует наличие единственного экземпляра класса__. Чаще всего это полезно для доступа к какому-то общему ресурсу, например, базе данных.

Представьте, что вы создали объект, а через некоторое время пробуете создать ещё один. В этом случае хотелось бы получить старый объект, вместо создания нового.

Такое поведение невозможно реализовать с помощью обычного конструктора, так как конструктор класса __всегда__ возвращает новый объект.

![03](/CPP_from_LETI/LETI_03/img/04_34.png)

__Предоставляет глобальную точку доступа.__ Это не просто глобальная переменная, через которую можно достучаться к определённому объекту. Глобальные переменные не защищены от записи, поэтому любой код может подменять их значения без вашего ведома.

Но есть и другой нюанс. Неплохо бы хранить в одном месте и код, который решает проблему №1, а также иметь к нему простой и доступный интерфейс.

Интересно, что в наше время паттерн стал настолько известен, что теперь люди называют «одиночками» даже те классы, которые решают лишь одну из проблем, перечисленных выше.

__Решение__

Все реализации одиночки сводятся к тому, чтобы скрыть конструктор по умолчанию и создать публичный статический метод, который и будет контролировать жизненный цикл объекта-одиночки.

Если у вас есть доступ к классу одиночки, значит, будет доступ и к этому статическому методу. Из какой точки кода вы бы его ни вызвали, он всегда будет отдавать один и тот же объект.

__Аналогия из жизни__

Правительство государства — хороший пример одиночки. В государстве может быть только одно официальное правительство. Вне зависимости от того, кто конкретно заседает в правительстве, оно имеет глобальную точку доступа «Правительство страны N».

__Структура__

![03](/CPP_from_LETI/LETI_03/img/04_35.png)

__Применимость__

+ Когда в программе должен быть единственный экземпляр какого-то класса, доступный всем клиентам (например, общий доступ к базе данных из разных частей программы).<br>
`Одиночка` скрывает от клиентов все способы создания нового объекта, кроме специального метода. Этот метод либо создаёт объект, либо отдаёт существующий объект, если он уже был создан.<br>
Когда вам хочется иметь больше контроля над глобальными переменными.
+ В отличие от глобальных переменных, `Одиночка` гарантирует, что никакой другой код не заменит созданный экземпляр класса, поэтому вы всегда уверены в наличии лишь одного объекта-одиночки.<br>
Тем не менее, в любой момент вы можете расширить это ограничение и позволить любое количество объектов-одиночек, поменяв код в одном месте (метод `getInstance`).

__Шаги реализации__

1. Добавьте в класс приватное статическое поле, которое будет содержать одиночный объект.
2. Объявите статический создающий метод, который будет использоваться для получения одиночки.
3. Добавьте «ленивую инициализацию» (создание объекта при первом вызове метода) в создающий метод одиночки.
4. Сделайте конструктор класса приватным.
5. В клиентском коде замените вызовы конструктора одиночка вызовами его создающего метода.

__Преимущества и недостатки__

![03](/CPP_from_LETI/LETI_03/img/04_36.png)

__Отношения с другими паттернами__

+ `Фасад` можно сделать `Одиночкой`, так как обычно нужен только один объект-фасад.
+ Паттерн `Легковес` может напоминать `Одиночку`, если для конкретной задачи у вас получилось свести количество объектов к одному. Но помните, что между паттернами есть два кардинальных отличия:
    1. В отличие от `Одиночки`, вы можете иметь множество объектов-легковесов.
    2. Объекты-легковесы должны быть неизменяемыми, тогда как объект-одиночка допускает изменение своего состояния.
+ `Абстрактная фабрика`, `Строитель` и `Прототип` могут быть реализованы при помощи `Одиночки`.

<hr>

[Содержание](#содержание)

## Пример использования Одиночки

Несмотря на кажущуюся простоту паттерна `Singleton` (используется всего один класс), его реализация не является тривиальной.

### Рассмотрим наиболее часто встречающуюся реализацию паттерна `Singleton`.

```c++
// Singleton.h
class Singleton {
   private:
    static Singleton* p_instance;
    // Конструкторы и оператор присваивания недоступны клиентам
    Singleton() {}
    Singleton(const Singleton&);
    Singleton& operator=(Singleton&);

   public:
    static Singleton* getInstance() {
        if (!p_instance) p_instance = new Singleton();
        return p_instance;
    }
};

// Singleton.cpp
#include "Singleton.h"

Singleton* Singleton::p_instance = 0;
```

Клиенты запрашивают единственный объект класса через статическую функцию-член `getInstance()`, которая при первом запросе динамически выделяет память под этот объект и затем возвращает указатель на этот участок памяти. В дальнейшем клиенты должны сами позаботиться об освобождении памяти при помощи оператора `delete`.

Последняя особенность является серьезным недостатком классической реализации шаблона `Singleton`. Так как класс сам контролирует создание единственного объекта, было бы логичным возложить на него ответственность и за разрушение объекта. Этот недостаток отсутствует в реализации `Singleton`, впервые предложенной Скоттом Мэйерсом.

<hr>

[Содержание](#содержание)

### Singleton Мэйерса

```c++
// Singleton.h
class Singleton {
   private:
    Singleton() {}
    Singleton(const Singleton&);
    Singleton& operator=(Singleton&);

   public:
    static Singleton& getInstance() {
        static Singleton instance;
        return instance;
    }
};
```

Внутри `getInstance()` используется статический экземпляр нужного класса. Стандарт языка программирования C++ гарантирует автоматическое уничтожение статических объектов при завершении программы. Досрочного уничтожения и не требуется, так как объекты `Singleton` обычно являются долгоживущими объектами. Статическая функция-член `getInstance()` возвращает не указатель, а ссылку на этот объект, тем самым, затрудняя возможность ошибочного освобождения памяти клиентами.

Приведенная реализация паттерна `Singleton` использует так называемую отложенную инициализацию (`lazy initialization`) объекта, когда объект класса инициализируется не при старте программы, а при первом вызове `getInstance()`. В данном случае это обеспечивается тем, что статическая переменная `instance` объявлена внутри функции - члена класса `getInstance()`, а не как статический член данных этого класса. Отложенную инициализацию, в первую очередь, имеет смысл использовать в тех случаях, когда инициализация объекта представляет собой дорогостоящую операцию и не всегда используется.

К сожалению, у реализации Мэйерса есть недостатки:
+ сложности создания объектов производных классов и
+ невозможность безопасного доступа нескольких клиентов к единственному объекту в многопоточной среде.

<hr>

[Содержание](#содержание)

### Улучшенная версия классической реализации Singleton

С учетом всего вышесказанного классическая реализация паттерна `Singleton` может быть улучшена.

```c++
// Singleton.h
class Singleton;  // опережающее объявление

class SingletonDestroyer {
   private:
    Singleton* p_instance;

   public:
    ~SingletonDestroyer();
    void initialize(Singleton* p);
};

class Singleton {
   private:
    static Singleton* p_instance;
    static SingletonDestroyer destroyer;

   protected:
    Singleton() {}
    Singleton(const Singleton&);
    Singleton& operator=(Singleton&);
    ~Singleton() {}
    friend class SingletonDestroyer;

   public:
    static Singleton& getInstance();
};

// Singleton.cpp
#include "Singleton.h"

Singleton* Singleton::p_instance = 0;
SingletonDestroyer Singleton::destroyer;

SingletonDestroyer::~SingletonDestroyer() { delete p_instance; }
void SingletonDestroyer::initialize(Singleton* p) { p_instance = p; }
Singleton& Singleton::getInstance() {
    if (!p_instance) {
        p_instance = new Singleton();
        destroyer.initialize(p_instance);
    }
    return *p_instance;
}
```

Ключевой особенностью этой реализации является наличие класса `SingletonDestroyer`, предназначенного для автоматического разрушения объекта `Singleton`. Класс `Singleton` имеет статический член `SingletonDestroyer`, который инициализируется при первом вызове `Singleton::getInstance()` создаваемым объектом `Singleton`. При завершении программы этот объект будет автоматически разрушен деструктором `SingletonDestroyer` (для этого `SingletonDestroyer` объявлен другом класса `Singleton`).

Для предотвращения случайного удаления пользователями объекта класса `Singleton`, деструктор теперь уже не является общедоступным как ранее. Он объявлен защищенным.

<hr>

[Содержание](#содержание)

### Использование нескольких взаимозависимых одиночек

До сих пор предполагалось, что в программе используется один одиночка либо несколько несвязанных между собой. При использовании взаимосвязанных одиночек появляются новые вопросы:
+ Как гарантировать, что к моменту использования одного одиночки, экземпляр другого зависимого уже создан?
+ Как обеспечить возможность безопасного использования одного одиночки другим при завершении программы? <br>
Другими словами, как гарантировать, что в момент разрушения первого одиночки в его деструкторе еще возможно использование второго зависимого одиночки (то есть второй одиночка к этому моменту еще не разрушен)?

Управлять порядком создания одиночек относительно просто. Следующий код демонстрирует один из возможных методов.

```c++
// Singleton.h
class Singleton1 {
   private:
    Singleton1() {}
    Singleton1(const Singleton1&);
    Singleton1& operator=(Singleton1&);

   public:
    static Singleton1& getInstance() {
        static Singleton1 instance;
        return instance;
    }
};

class Singleton2 {
   private:
    Singleton2(Singleton1& instance) : s1(instance) {}
    Singleton2(const Singleton2&);
    Singleton2& operator=(Singleton2&);
    Singleton1& s1;

   public:
    static Singleton2& getInstance() {
        static Singleton2 instance(Singleton1::getInstance());
        return instance;
    }
};

// main.cpp
#include "Singleton.h"

int main() {
    Singleton2& s = Singleton2::getInstance();
    return 0;
}
```

Объект `Singleton1` гарантированно инициализируется раньше объекта `Singleton2`, так как в момент создания объекта `Singleton2` происходит вызов `Singleton1::getInstance()`.

Гораздо сложнее управлять временем жизни одиночек. Существует несколько способов это сделать, каждый из них обладает своими достоинствами и недостатками и заслуживают отдельного рассмотрения. Обсуждение этой непростой темы остается за рамками проекта.

<hr>

[Содержание](#содержание)

## Вопросы

Сопоставьте значения из двух списков

![03](/CPP_from_LETI/LETI_03/img/04_37.PNG)

Представьте, что вы создаёте программу управления грузовыми перевозками. Сперва вы рассчитываете перевозить товары только на автомобилях. Поэтому весь ваш код работает с объектами класса `Грузовик`.

В какой-то момент ваша программа становится настолько известной, что морские перевозчики выстраиваются в очередь и просят добавить поддержку морской логистики в программу.

![03](/CPP_from_LETI/LETI_03/img/04_06.png)

Отличные новости, правда?! Но как насчёт кода? Большая часть существующего кода жёстко привязана к классам `Грузовиков`. Чтобы добавить в программу классы морских `Судов`, понадобится перелопатить всю программу. Более того, если вы потом решите добавить в программу ещё один вид транспорта, то всю эту работу придётся повторить.

В итоге вы получите ужасающий код, наполненный условными операторами, которые выполняют то или иное действие, в зависимости от класса транспорта.

Какой паттерн проектирования вы бы использовали для решения данной проблемы?


+ [x] Фабричный метод
+ [ ] Состояние
+ [ ] Посетитель
+ [ ] Наблюдатель
+ [ ] Снимок

Представьте сложный объект, требующий кропотливой пошаговой инициализации множества полей и вложенных объектов. Код инициализации таких объектов обычно спрятан внутри монструозного конструктора с десятком параметров. Либо ещё хуже — распылён по всему клиентскому коду.

![03](/CPP_from_LETI/LETI_03/img/04_19.png)

Например, давайте подумаем о том, как создать объект `Дом`. Чтобы построить стандартный дом, нужно поставить 4 стены, установить двери, вставить пару окон и положить крышу. Но что, если вы хотите дом побольше да посветлее, имеющий сад, бассейн и прочее добро?

Самое простое решение — расширить класс `Дом`, создав подклассы для всех комбинаций параметров дома. Проблема такого подхода — это громадное количество классов, которые вам придётся создать. Каждый новый параметр, вроде цвета обоев или материала кровли, заставит вас создавать всё больше и больше классов для перечисления всех возможных вариантов.

Чтобы не плодить подклассы, вы можете подойти к решению с другой стороны. Вы можете создать гигантский конструктор `Дома`, принимающий уйму параметров для контроля над создаваемым продуктом. Действительно, это избавит вас от подклассов, но приведёт к другой проблеме.

![03](/CPP_from_LETI/LETI_03/img/04_20.png)

Большая часть этих параметров будет простаивать, а вызовы конструктора будут выглядеть монструозно из-за длинного списка параметров. К примеру, далеко не каждый дом имеет бассейн, поэтому параметры, связанные с бассейнами, будут простаивать бесполезно в 99% случаев.

Какой паттерн проектирования вы бы использовали для решения данной проблемы?


+ [ ] Наблюдатель
+ [ ] Мост
+ [x] Строитель
+ [ ] Легковес
+ [ ] Посетитель

<hr>

[Содержание](#содержание)

# 4.3 Структурные паттерны проектирования

## Виды структурных паттернов проектирования

![03](/CPP_from_LETI/LETI_03/img/04_38.jpg)

__Структурные паттерны проектирования__

Структурные паттерны рассматривают вопросы о компоновке системы на основе классов и объектов. При этом могут использоваться следующие механизмы:
+ Наследование, когда базовый класс определяет интерфейс, а подклассы - реализацию. Структуры на основе наследования получаются статичными.
+ Композиция, когда структуры строятся путем объединения объектов некоторых классов. Композиция позволяет получать структуры, которые можно изменять во время выполнения.

<hr>

[Содержание](#содержание)

## Адаптер

`Адаптер` — это структурный паттерн проектирования, который позволяет объектам с несовместимыми интерфейсами работать вместе.

![03](/CPP_from_LETI/LETI_03/img/04_39.png)

__Проблема__

Представьте, что вы делаете приложение для торговли на бирже. Ваше приложение скачивает биржевые котировки из нескольких источников в `XML`, а затем рисует красивые графики.

В какой-то момент вы решаете улучшить приложение, применив стороннюю библиотеку аналитики. Но вот беда — библиотека поддерживает только формат данных `JSON`, несовместимый с вашим приложением.

![03](/CPP_from_LETI/LETI_03/img/04_40.png)

Вы смогли бы переписать библиотеку, чтобы та поддерживала формат `XML`. Но, во-первых, это может нарушить работу существующего кода, который уже зависит от библиотеки. А во-вторых, у вас может просто не быть доступа к её исходному коду.

__Решение__

Вы можете создать адаптер. Это объект-переводчик, который трансформирует интерфейс или данные одного объекта в такой вид, чтобы он стал понятен другому объекту.

При этом адаптер оборачивает один из объектов, так что другой объект даже не знает о наличии первого. Например, вы можете обернуть объект, работающий в метрах, адаптером, который бы конвертировал данные в футы.

Адаптеры могут не только переводить данные из одного формата в другой, но и помогать объектам с разными интерфейсами работать сообща. Это работает так:
1. Адаптер имеет интерфейс, который совместим с одним из объектов.
2. Поэтому этот объект может свободно вызывать методы адаптера.
3. Адаптер получает эти вызовы и перенаправляет их второму объекту, но уже в том формате и последовательности, которые понятны второму объекту.

Иногда возможно создать даже двухсторонний адаптер, который работал бы в обе стороны.

![03](/CPP_from_LETI/LETI_03/img/04_41.png)

Таким образом, в приложении биржевых котировок вы могли бы создать класс `XML_To_JSON_Adapter`, который бы оборачивал объект того или иного класса библиотеки аналитики. Ваш код посылал бы адаптеру запросы в формате `XML`, а адаптер сначала транслировал входящие данные в формат `JSON`, а затем передавал бы их методам обёрнутого объекта аналитики.

__Аналогия из жизни__

![03](/CPP_from_LETI/LETI_03/img/04_42.png)

Когда вы в первый раз летите за границу, вас может ждать сюрприз при попытке зарядить ноутбук. Стандарты розеток в разных странах отличаются. Ваша европейская зарядка будет бесполезна в США без специального адаптера, позволяющего подключиться к розетке другого типа.

__Структура__

__Адаптер объектов__

Эта реализация использует агрегацию: объект адаптера «оборачивает», то есть содержит ссылку на служебный объект. Такой подход работает во всех языках программирования.

![03](/CPP_from_LETI/LETI_03/img/04_43.jpg)

__Адаптер классов__

Эта реализация базируется на наследовании: адаптер наследует оба интерфейса одновременно. Такой подход возможен только в языках, поддерживающих множественное наследование, например, C++.

![03](/CPP_from_LETI/LETI_03/img/04_44.jpg)

__Применимость__

+ Когда вы хотите использовать сторонний класс, но его интерфейс не соответствует остальному коду приложения.<br>
Адаптер позволяет создать объект-прокладку, который будет превращать вызовы приложения в формат, понятный стороннему классу.
+ Когда вам нужно использовать несколько существующих подклассов, но в них не хватает какой-то общей функциональности, причём расширить суперкласс вы не можете.<br>
Вы могли бы создать ещё один уровень подклассов и добавить в них недостающую функциональность. Но при этом придётся дублировать один и тот же код в обеих ветках подклассов.<br>
Более элегантным решением было бы поместить недостающую функциональность в адаптер и приспособить его для работы с суперклассом. Такой адаптер сможет работать со всеми подклассами иерархии. Это решение будет сильно напоминать паттерн Декоратор.

__Шаги реализации__

1. Убедитесь, что у вас есть два класса с несовместимыми интерфейсами:
    + полезный сервис — служебный класс, который вы не можете изменять (он либо сторонний, либо от него зависит другой код);
    + один или несколько клиентов — существующих классов приложения, несовместимых с сервисом из-за неудобного или несовпадающего интерфейса.
2. Опишите клиентский интерфейс, через который классы приложения смогли бы использовать класс сервиса.
3. Создайте класс адаптера, реализовав этот интерфейс.
4. Поместите в адаптер поле, которое будет хранить ссылку на объект сервиса. Обычно это поле заполняют объектом, переданным в конструктор адаптера. В случае простой адаптации этот объект можно передавать через параметры методов адаптера.
5. Реализуйте все методы клиентского интерфейса в адаптере. Адаптер должен делегировать основную работу сервису.
6. Приложение должно использовать адаптер только через клиентский интерфейс. Это позволит легко изменять и добавлять адаптеры в будущем.

__Преимущества и недостатки__

![03](/CPP_from_LETI/LETI_03/img/04_45.jpg)

__Отношения с другими паттернами__
+ `Мост` проектируют загодя, чтобы развивать большие части приложения отдельно друг от друга. `Адаптер` применяется постфактум, чтобы заставить несовместимые классы работать вместе.
+ `Адаптер` меняет интерфейс существующего объекта. `Декоратор` улучшает другой объект без изменения его интерфейса. Причём `Декоратор` поддерживает рекурсивную вложенность, чего не скажешь об `Адаптере`.
+ `Адаптер` предоставляет классу альтернативный интерфейс. `Декоратор` предоставляет расширенный интерфейс. `Заместитель` предоставляет тот же интерфейс.
+ `Фасад` задаёт новый интерфейс, тогда как `Адаптер` повторно использует старый. `Адаптер` оборачивает только один класс, а `Фасад` оборачивает целую подсистему. Кроме того, `Адаптер` позволяет двум существующим интерфейсам работать сообща, вместо того, чтобы задать полностью новый.
+ `Мост`, `Стратегия` и `Состояние` (а также слегка и `Адаптер`) имеют схожие структуры классов — все они построены на принципе «композиции», то есть делегирования работы другим объектам. Тем не менее, они отличаются тем, что решают разные проблемы. Помните, что паттерны — это не только рецепт построения кода определённым образом, но и описание проблем, которые привели к данному решению.

<hr>

[Содержание](#содержание)

## Пример использования паттерна `Адаптер`

Для примера адаптируем показания температурного датчика системы климат-контроля, переведя их из градусов Фаренгейта в градусы Цельсия (предполагается, что код этого датчика недоступен для модификации).

```c++
#include <iostream>

using namespace std;

// Уже существующий класс температурного датчика окружающей среды
class FahrenheitSensor {
   public:
    // Получить показания температуры в градусах Фаренгейта
    float getFahrenheitTemp() {
        float t = 32.0;
        // ... какой то код
        return t;
    }
};

class Sensor {
   public:
    virtual ~Sensor() {}
    virtual float getTemperature() = 0;
};

class Adapter : public Sensor {
   public:
    Adapter(FahrenheitSensor* p) : p_fsensor(p) {}
    ~Adapter() { delete p_fsensor; }
    float getTemperature() { return (p_fsensor->getFahrenheitTemp() - 32.0) * 5.0 / 9.0; }

   private:
    FahrenheitSensor* p_fsensor;
};

int main() {
    Sensor* p = new Adapter(new FahrenheitSensor);
    cout << "Celsius temperature = " << p->getTemperature() << endl;
    delete p;
    return 0;
}
```

__Реализация паттерна Adapter на основе закрытого наследования__

Пусть наш температурный датчик системы климат-контроля поддерживает функцию юстировки для получения более точных показаний. Эта функция не является обязательной для использования, возможно, поэтому соответствующий метод `adjust()` объявлен разработчиками защищенным в существующем классе `FahrenheitSensor`.

Разрабатываемая нами система должна поддерживать настройку измерений. Так как доступ к защищенному методу через указатель или ссылку запрещен, то классическая реализация паттерна `Adapter` здесь уже не подходит. Единственное решение - наследовать от класса `FahrenheitSensor`. Интерфейс этого класса должен оставаться недоступным пользователю, поэтому наследование должно быть закрытым.

Цели, преследуемые при использовании открытого и закрытого наследования различны. Если открытое наследование применяется для наследования интерфейса и реализации, то закрытое наследование - только для наследования реализации.

```c++
#include <iostream>

using namespace std;

class FahrenheitSensor {
   public:
    float getFahrenheitTemp() {
        float t = 32.0;
        // ...
        return t;
    }

   protected:
    void adjust() {}  // Настройка датчика (защищенный метод)
};

class Sensor {
   public:
    virtual ~Sensor() {}
    virtual float getTemperature() = 0;
    virtual void adjust() = 0;
};

class Adapter : public Sensor, private FahrenheitSensor {
   public:
    Adapter() {}
    float getTemperature() { return (getFahrenheitTemp() - 32.0) * 5.0 / 9.0; }
    void adjust() { FahrenheitSensor::adjust(); }
};

int main() {
    Sensor* p = new Adapter();
    p->adjust();
    cout << "Celsius temperature = " << p->getTemperature() << endl;
    delete p;
    return 0;
}
```

<hr>

[Содержание](#содержание)

## Мост

Мост — это структурный паттерн проектирования, который разделяет один или несколько классов на две отдельные иерархии — абстракцию и реализацию, позволяя изменять их независимо друг от друга.

![04](/CPP_from_LETI/LETI_03/img/04_46.png)

__Проблема__

_Абстракция? Реализация?!_ Звучит пугающе! Чтобы понять, о чём идёт речь, давайте разберём очень простой пример.

У вас есть класс геометрических `Фигур`, который имеет подклассы `Круг` и `Квадрат`. Вы хотите расширить иерархию фигур по цвету, то есть иметь `Красные` и `Синие` фигуры. Но чтобы всё это объединить, вам придётся создать 4 комбинации подклассов, вроде `СиниеКруги` и `КрасныеКвадраты`.

При добавлении новых видов фигур и цветов количество комбинаций будет расти в геометрической прогрессии. Например, чтобы ввести в программу фигуры треугольников, придётся создать сразу два новых подкласса треугольников под каждый цвет. После этого новый цвет потребует создания уже трёх классов для всех видов фигур. Чем дальше, тем хуже.

__Решение__

Корень проблемы заключается в том, что мы пытаемся расширить классы фигур сразу в двух независимых плоскостях — по виду и по цвету. Именно это приводит к разрастанию дерева классов.

Паттерн `Мост` предлагает заменить наследование агрегацией или композицией. Для этого нужно выделить одну из таких «плоскостей» в отдельную иерархию и ссылаться на объект этой иерархии, вместо хранения его состояния и поведения внутри одного класса.

![04](/CPP_from_LETI/LETI_03/img/04_47.png)

Таким образом, мы можем сделать `Цвет` отдельным классом с подклассами `Красный` и `Синий`. Класс `Фигур` получит ссылку на объект `Цвета` и сможет делегировать ему работу, если потребуется. Такая связь и станет мостом между `Фигурами` и `Цветом`. При добавлении новых классов цветов не потребуется трогать классы фигур и наоборот.

__Абстракция и Реализация__

Эти термины были введены в книге `GoF`  при описании `Моста`. На мой взгляд, они выглядят слишком академичными, делая описание паттерна сложнее, чем он есть на самом деле. Помня о примере с фигурами и цветами, давайте все же разберёмся, что имели в виду авторы паттерна.

Итак, __*абстракция*__ (или _интерфейс_) — это образный слой управления чем-либо. Он не делает работу самостоятельно, а делегирует её слою __*реализации*__ (иногда называемому _платформой_).

Если говорить о реальных программах, то абстракцией может выступать графический интерфейс программы (`GUI`), а реализацией — низкоуровневый код операционной системы (`API`), к которому графический интерфейс обращается по реакции на действия пользователя.

Вы можете развивать программу в двух разных направлениях:
+ иметь несколько видов GUI (например, для простых пользователей и администраторов);
+ поддерживать много видов API (например, работать под Windows, Linux и macOS).

Такая программа может выглядеть как один большой клубок кода, в котором намешаны условные операторы слоёв GUI и API.

![04](/CPP_from_LETI/LETI_03/img/04_48.png)

Вы можете попытаться структурировать этот хаос, создав для каждой вариации интерфейса-платформы свои подклассы. Но такой подход приведёт к росту классов комбинаций, и с каждой новой платформой их будет всё больше.

Мы можем решить эту проблему, применив `Мост`. Паттерн предлагает распутать этот код, разделив его на две части:
+ __Абстракцию__: слой графического интерфейса приложения.
+ __Реализацию__: слой взаимодействия с операционной системой.

![04](/CPP_from_LETI/LETI_03/img/04_49.png)

Абстракция будет делегировать работу одному из объектов реализаций. Причём, реализации можно будет взаимозаменять, но только при условии, что все они будут следовать общему интерфейсу.

Таким образом, вы сможете изменять графический интерфейс приложения, не трогая низкоуровневый код работы с операционной системой. И наоборот, вы сможете добавлять поддержку новых операционных систем, создавая подклассы реализации, без необходимости менять классы графического интерфейса.

__Структура__

![04](/CPP_from_LETI/LETI_03/img/04_50.jpg)

__Применимость__

+ Когда вы хотите разделить монолитный класс, который содержит несколько различных реализаций какой-то функциональности (например, если класс может работать с разными системами баз данных).<br>
Чем больше класс, тем тяжелее разобраться в его коде, и тем больше это затягивает разработку. Кроме того, изменения, вносимые в одну из реализаций, приводят к редактированию всего класса, что может привести к внесению случайных ошибок в код.<br>
`Мост` позволяет разделить монолитный класс на несколько отдельных иерархий. После этого вы можете менять их код независимо друг от друга. Это упрощает работу над кодом и уменьшает вероятность внесения ошибок.
+ Когда класс нужно расширять в двух независимых плоскостях.<br>
`Мост` предлагает выделить одну из таких плоскостей в отдельную иерархию классов, храня ссылку на один из её объектов в первоначальном классе.
+ Когда вы хотите, чтобы реализацию можно было бы изменять во время выполнения программы.
`Мост` позволяет заменять реализацию даже во время выполнения программы, так как конкретная реализация не «вшита» в класс абстракции.<br>
Кстати, из-за этого пункта `Мост` часто путают со `Стратегией`. Обратите внимание, что у `Моста` этот пункт стоит на последнем месте по значимости, поскольку его главная задача — структурная.

__Шаги реализации__
1. Определите, существует ли в ваших классах два непересекающихся измерения. Это может быть функциональность/платформа, предметная-область/инфраструктура, фронт-энд/бэк-энд или интерфейс/реализация.
2. Продумайте, какие операции будут нужны клиентам, и опишите их в базовом классе абстракции.
3. Определите поведения, доступные на всех платформах, и выделите из них ту часть, которая нужна абстракции. На основании этого опишите общий интерфейс реализации.
4. Для каждой платформы создайте свой класс конкретной реализации. Все они должны следовать общему интерфейсу, который мы выделили перед этим.
5. Добавьте в класс абстракции ссылку на объект реализации. Реализуйте методы абстракции, делегируя основную работу связанному объекту реализации.
6. Если у вас есть несколько вариаций абстракции, создайте для каждой из них свой подкласс.
7. Клиент должен подать объект реализации в конструктор абстракции, чтобы связать их воедино. После этого он может свободно использовать объект абстракции, забыв о реализации.

__Преимущества и недостатки__

![04](/CPP_from_LETI/LETI_03/img/04_51.jpg)

__Отношения с другими паттернами__

+ `Мост` проектируют загодя, чтобы развивать большие части приложения отдельно друг от друга. `Адаптер` применяется постфактум, чтобы заставить несовместимые классы работать вместе.
+ `Мост`, `Стратегия` и `Состояние` (а также слегка и `Адаптер`) имеют схожие структуры классов — все они построены на принципе «композиции», то есть делегирования работы другим объектам. Тем не менее, они отличаются тем, что решают разные проблемы. Помните, что паттерны — это не только рецепт построения кода определённым образом, но и описание проблем, которые привели к данному решению.
+ `Абстрактная фабрика` может работать совместно с `Мостом`. Это особенно полезно, если у вас есть абстракции, которые могут работать только с некоторыми из реализаций. В этом случае фабрика будет определять типы создаваемых абстракций и реализаций.
+ Паттерн `Строитель` может быть построен в виде `Моста`: директор будет играть роль абстракции, а строители — реализации.

<hr>

[Содержание](#содержание)

## Пример использования паттерна `Мост`

```c++
#include <iostream>

using namespace std;

class Implementation {
   public:
    virtual ~Implementation() {}
    virtual std::string OperationImplementation() const = 0;
};

/**
 * Каждая Конкретная Реализация соответствует определённой платформе и реализует
 * интерфейс Реализации с использованием API этой платформы.
 */
class ConcreteImplementationA : public Implementation {
   public:
    std::string OperationImplementation() const override {
        return "ConcreteImplementationA: Here's the result on the platform A.\n";
    }
};
class ConcreteImplementationB : public Implementation {
   public:
    std::string OperationImplementation() const override {
        return "ConcreteImplementationB: Here's the result on the platform B.\n";
    }
};

/**
 * Абстракция устанавливает интерфейс для «управляющей» части двух иерархий
 * классов. Она содержит ссылку на объект из иерархии Реализации и делегирует
 * ему всю настоящую работу.
 */

class Abstraction {
    /**
     * @var Implementation
     */
   protected:
    Implementation* implementation_;

   public:
    Abstraction(Implementation* implementation) : implementation_(implementation) {}

    virtual ~Abstraction() {}

    virtual std::string Operation() const {
        return "Abstraction: Base operation with:\n" + this->implementation_->OperationImplementation();
    }
};
/**
 * Можно расширить Абстракцию без изменения классов Реализации.
 */
class ExtendedAbstraction : public Abstraction {
   public:
    ExtendedAbstraction(Implementation* implementation) : Abstraction(implementation) {}
    std::string Operation() const override {
        return "ExtendedAbstraction: Extended operation with:\n" +
               this->implementation_->OperationImplementation();
    }
};

/**
 * За исключением этапа инициализации, когда объект Абстракции связывается с
 * определённым объектом Реализации, клиентский код должен зависеть только от
 * класса Абстракции. Таким образом, клиентский код может поддерживать любую
 * комбинацию абстракции и реализации.
 */
void ClientCode(const Abstraction& abstraction) {
    // ...
    std::cout << abstraction.Operation();
    // ...
}
/**
 * Клиентский код должен работать с любой предварительно сконфигурированной
 * комбинацией абстракции и реализации.
 */

int main() {
    Implementation* implementation = new ConcreteImplementationA;
    Abstraction* abstraction = new Abstraction(implementation);
    ClientCode(*abstraction);
    std::cout << std::endl;
    delete implementation;
    delete abstraction;

    implementation = new ConcreteImplementationB;
    abstraction = new ExtendedAbstraction(implementation);
    ClientCode(*abstraction);

    delete implementation;
    delete abstraction;

    return 0;
}
```

Результат выполнения

```
Abstraction: Base operation with:
ConcreteImplementationA: Here's the result on the platform A.

ExtendedAbstraction: Extended operation with:
ConcreteImplementationB: Here's the result on the platform B.
```

<hr>

[Содержание](#содержание)

## Компоновщик

`Компоновщик` — это структурный паттерн проектирования, который позволяет сгруппировать множество объектов в древовидную структуру, а затем работать с ней так, как будто это единичный объект.

![04](/CPP_from_LETI/LETI_03/img/04_52.png)

__Проблема__

Паттерн `Компоновщик` имеет смысл только тогда, когда основная модель вашей программы может быть структурирована в виде дерева.

Например, есть два объекта: `Продукт` и `Коробка`. `Коробка` может содержать несколько `Продуктов` и других `Коробок` поменьше. Те, в свою очередь, тоже содержат либо `Продукты`, либо `Коробки` и так далее.

Теперь предположим, ваши `Продукты` и `Коробки` могут быть частью заказов. Каждый заказ может содержать как простые `Продукты` без упаковки, так и составные `Коробки`. Ваша задача состоит в том, чтобы узнать цену всего заказа.

![04](/CPP_from_LETI/LETI_03/img/04_53.png)

Если решать задачу в лоб, то вам потребуется открыть все коробки заказа, перебрать все продукты и посчитать их суммарную стоимость. Но это слишком хлопотно, так как типы коробок и их содержимое могут быть вам неизвестны. Кроме того, наперёд неизвестно и количество уровней вложенности коробок, поэтому перебрать коробки простым циклом не выйдет.

__Решение__

`Компоновщик` предлагает рассматривать `Продукт` и `Коробку` через единый интерфейс с общим методом получения стоимости.

`Продукт` просто вернёт свою цену. `Коробка` спросит цену каждого предмета внутри себя и вернёт сумму результатов. Если одним из внутренних предметов окажется коробка поменьше, она тоже будет перебирать своё содержимое, и так далее, пока не будут посчитаны все составные части.

![04](/CPP_from_LETI/LETI_03/img/04_54.png)

Для вас, клиента, главное, что теперь не нужно ничего знать о структуре заказов. Вы вызываете метод получения цены, он возвращает цифру, а вы не тонете в горах картона и скотча.

__Аналогия из жизни__

![04](/CPP_from_LETI/LETI_03/img/04_55.png)

Армии большинства государств могут быть представлены в виде перевёрнутых деревьев. На нижнем уровне у вас есть солдаты, затем взводы, затем полки, а затем целые армии. Приказы отдаются сверху и спускаются вниз по структуре командования, пока не доходят до конкретного солдата.

__Структура__

![04](/CPP_from_LETI/LETI_03/img/04_56.jpg)

__Применимость__

+ Когда вам нужно представить древовидную структуру объектов.<br>
Паттерн `Компоновщик` предлагает хранить в составных объектах ссылки на другие простые или составные объекты. Те, в свою очередь, тоже могут хранить свои вложенные объекты и так далее. В итоге вы можете строить сложную древовидную структуру данных, используя всего две основные разновидности объектов.
+ Когда клиенты должны единообразно трактовать простые и составные объекты.<br>
Благодаря тому, что простые и составные объекты реализуют общий интерфейс, клиенту безразлично, с каким именно объектом ему предстоит работать.

__Шаги реализации__

1. Убедитесь, что вашу бизнес-логику можно представить как древовидную структуру. Попытайтесь разбить её на простые компоненты и контейнеры. Помните, что контейнеры могут содержать как простые компоненты, так и другие вложенные контейнеры.
2. Создайте общий интерфейс компонентов, который объединит операции контейнеров и простых компонентов дерева. Интерфейс будет удачным, если вы сможете использовать его, чтобы взаимно заменять простые и составные компоненты без потери смысла.
3. Создайте класс компонентов-листьев, не имеющих дальнейших ответвлений. Имейте в виду, что программа может содержать несколько таких классов.
4. Создайте класс компонентов-контейнеров и добавьте в него массив для хранения ссылок на вложенные компоненты. Этот массив должен быть способен содержать как простые, так и составные компоненты, поэтому убедитесь, что он объявлен с типом интерфейса компонентов.
5. Реализуйте в контейнере методы интерфейса компонентов, помня о том, что контейнеры должны делегировать основную работу своим дочерним компонентам.
6. Добавьте операции добавления и удаления дочерних компонентов в класс контейнеров.
7. Имейте в виду, что методы добавления/удаления дочерних компонентов можно поместить и в интерфейс компонентов. Да, это нарушит принцип разделения интерфейса, так как реализации методов будут пустыми в компонентах-листьях. Но зато все компоненты дерева станут действительно одинаковыми для клиента.

__Преимущества и недостатки__

![04](/CPP_from_LETI/LETI_03/img/04_57.jpg)

__Отношения с другими паттернами__

+ `Строитель` позволяет пошагово сооружать дерево `Компоновщика`.
+ `Цепочку обязанностей` часто используют вместе с `Компоновщиком`. В этом случае запрос передаётся от дочерних компонентов к их родителям.
+ Вы можете обходить дерево `Компоновщика`, используя `Итератор`.
+ Вы можете выполнить какое-то действие над всем деревом `Компоновщика` при помощи `Посетителя`.
+ `Компоновщик` часто совмещают с `Легковесом`, чтобы реализовать общие ветки дерева и сэкономить при этом память.
+ `Компоновщик` и `Декоратор` имеют похожие структуры классов из-за того, что оба построены на рекурсивной вложенности. Она позволяет связать в одну структуру бесконечное количество объектов.
+ `Декоратор` оборачивает только один объект, а узел `Компоновщика` может иметь много детей. `Декоратор` добавляет вложенному объекту новую функциональность, а `Компоновщик` не добавляет ничего нового, но «суммирует» результаты всех своих детей.
+ Но они могут и сотрудничать: `Компоновщик` может использовать `Декоратор`, чтобы переопределить функции отдельных частей дерева компонентов.
+ `Архитектура`, построенная на `Компоновщиках` и `Декораторах`, часто может быть улучшена за счёт внедрения `Прототипа`. Он позволяет клонировать сложные структуры объектов, а не собирать их заново.

<hr>

[Содержание](#содержание)

## Пример использования паттерна Компоновщик (Composite)

Применим паттерн `Composite` для стратегической игры. Сначала сформируем различные военные соединения римской армии, а затем рассчитаем разрушающую силу.

```c++
#include <assert.h>

#include <iostream>
#include <vector>

using namespace std;

// Component
class Unit {
   public:
    virtual int getStrength() = 0;
    virtual void addUnit(Unit* p) { assert(false); }
    virtual ~Unit() {}
};

// Primitives
class Archer : public Unit {
   public:
    virtual int getStrength() { return 1; }
};

class Infantryman : public Unit {
   public:
    virtual int getStrength() { return 2; }
};

class Horseman : public Unit {
   public:
    virtual int getStrength() { return 3; }
};

// Composite
class CompositeUnit : public Unit {
   public:
    int getStrength() {
        int total = 0;
        for (int i = 0; i < c.size(); ++i) total += c[i]->getStrength();
        return total;
    }
    void addUnit(Unit* p) { c.push_back(p); }
    ~CompositeUnit() {
        for (int i = 0; i < c.size(); ++i) delete c[i];
    }

   private:
    std::vector<Unit*> c;
};

// Вспомогательная функция для создания легиона
CompositeUnit* createLegion() {
    // Римский легион содержит:
    CompositeUnit* legion = new CompositeUnit;
    // 3000 тяжелых пехотинцев
    for (int i = 0; i < 3000; ++i) legion->addUnit(new Infantryman);
    // 1200 легких пехотинцев
    for (int i = 0; i < 1200; ++i) legion->addUnit(new Archer);
    // 300 всадников
    for (int i = 0; i < 300; ++i) legion->addUnit(new Horseman);

    return legion;
}

int main() {
    // Римская армия состоит из 4-х легионов
    CompositeUnit* army = new CompositeUnit;
    for (int i = 0; i < 4; ++i) army->addUnit(createLegion());

    cout << "Roman army damaging strength is " << army->getStrength() << endl;
    // …
    delete army;
    return 0;
}
Следует обратить внимание на один важный момент. Абстрактный базовый класс Unit объявляет интерфейс для добавления новых боевых единиц addUnit(), несмотря на то, что объектам примитивных типов (Archer, Infantryman, Horseman) подобная операция не нужна. Сделано это в угоду прозрачности системы в ущерб ее безопасности. Клиент знает, что объект типа Unit всегда будет иметь метод addUnit(). Однако его вызов для примитивных объектов считается ошибочным и небезопасным.

Можно сделать систему более безопасной, переместив метод addUnit() в составной объект CompositeUnit. Однако при этом возникает следующая проблема: мы не знаем, содержит ли объект Unit метод addUnit().

Рассмотрим следующий фрагмент кода.

class Unit
{
  public:
    virtual CompositeUnit* getComposite() {
      return 0;
    }
    // …
};
 
// Composite
class CompositeUnit: public Unit
{
  public:
   void addUnit(Unit* p);
    CompositeUnit* getComposite() {
      return this;
    }
    // …
};
```

В абстрактном базовом классе `Unit` появился новый виртуальный метод `getComposite()` с реализацией по умолчанию, которая возвращает `0`. Класс `CompositeUnit` переопределяет этот метод, возвращая указатель на самого себя. Благодаря этому методу можно запросить у компонента его тип. Если он составной, то можно применить операцию `addUnit()`.

```c++
if (unit->getComposite()) {
   unit->getComposite()->addUnit( new Archer);
}
```

<hr>

[Содержание](#содержание)

## Декоратор

`Декоратор` — это структурный паттерн проектирования, который позволяет динамически добавлять объектам новую функциональность, оборачивая их в полезные «обёртки».

__Проблема__

Вы работаете над библиотекой оповещений, которую можно подключать к разнообразным программам, чтобы получать уведомления о важных событиях.

Основой библиотеки является класс `Notifier` с методом `send`, который принимает на вход строку-сообщение и высылает её всем администраторам по электронной почте. Сторонняя программа должна создать и настроить этот объект, указав кому отправлять оповещения, а затем использовать его каждый раз, когда что-то случается.

![04](/CPP_from_LETI/LETI_03/img/04_58.png)


В какой-то момент стало понятно, что одних `email`-оповещений пользователям мало. Некоторые из них хотели бы получать извещения о критических проблемах через `SMS`. Другие хотели бы получать их в виде сообщений Facebook. Корпоративные пользователи хотели бы видеть сообщения в `Slack`.

![04](/CPP_from_LETI/LETI_03/img/04_59.png)

Сначала вы добавили каждый из этих типов оповещений в программу, унаследовав их от базового класса `Notifier`. Теперь пользователь выбирал один из типов оповещений, который и использовался в дальнейшем.

Но затем кто-то резонно спросил, почему нельзя выбрать несколько типов оповещений сразу? Ведь если вдруг в вашем доме начался пожар, вы бы хотели получить оповещения по всем каналам, не так ли?

Вы попытались реализовать все возможные комбинации подклассов оповещений. Но после того как вы добавили первый десяток классов, стало ясно, что такой подход невероятно раздувает код программы.

![04](/CPP_from_LETI/LETI_03/img/04_60.png)

Итак, нужен какой-то другой способ комбинирования поведения объектов, который не приводит к взрыву количества подклассов.

__Решение__

Наследование — это первое, что приходит в голову многим программистам, когда нужно расширить какое-то существующее поведение. Но механизм наследования имеет несколько досадных проблем.
+ Он __статичен__. Вы не можете изменить поведение существующего объекта. Для этого вам надо создать новый объект, выбрав другой подкласс.
+ Он __не разрешает наследовать поведение нескольких классов одновременно__. Из-за этого вам приходится создавать множество подклассов-комбинаций для получения совмещённого поведения.

Одним из способов обойти эти проблемы является замена наследования агрегацией либо композицией . Это когда один объект содержит ссылку на другой и делегирует ему работу, вместо того чтобы самому наследовать его поведение. Как раз на этом принципе построен паттерн `Декоратор`.

![04](/CPP_from_LETI/LETI_03/img/04_61.png)

Декоратор имеет альтернативное название — _обёртка_. 

Оно более точно описывает суть паттерна: вы помещаете целевой объект в другой объект-обёртку, который запускает базовое поведение объекта, а затем добавляет к результату что-то своё.

Оба объекта имеют общий интерфейс, поэтому для пользователя нет никакой разницы, с каким объектом работать — чистым или обёрнутым. Вы можете использовать несколько разных обёрток одновременно — результат будет иметь объединённое поведение всех обёрток сразу.

В примере с оповещениями мы оставим в базовом классе простую отправку по электронной почте, а расширенные способы отправки сделаем декораторами.

![04](/CPP_from_LETI/LETI_03/img/04_62.png)

Сторонняя программа, выступающая клиентом, во время первичной настройки будет заворачивать объект оповещений в те обёртки, которые соответствуют желаемому способу оповещения.

![04](/CPP_from_LETI/LETI_03/img/04_63.png)

Последняя обёртка в списке и будет тем объектом, с которым клиент будет работать в остальное время. Для остального клиентского кода, по сути, ничего не изменится, ведь все обёртки имеют точно такой же интерфейс, что и базовый класс оповещений.

Таким же образом можно изменять не только способ доставки оповещений, но и форматирование, список адресатов и так далее. К тому же клиент может «дообернуть» объект любыми другими обёртками, когда ему захочется.

__Аналогия из жизни__

![04](/CPP_from_LETI/LETI_03/img/04_64.png)

Любая одежда — это аналог `Декоратора`. Применяя `Декоратор`, вы не меняете первоначальный класс и не создаёте дочерних классов. Так и с одеждой — надевая свитер, вы не перестаёте быть собой, но получаете новое свойство — защиту от холода. Вы можете пойти дальше и надеть сверху ещё один декоратор — плащ, чтобы защититься и от дождя.

__Структура__

![04](/CPP_from_LETI/LETI_03/img/04_65.jpg)

__Применимость__

+ Когда вам нужно добавлять обязанности объектам на лету, незаметно для кода, который их использует.<br>
Объекты помещают в обёртки, имеющие дополнительные поведения. Обёртки и сами объекты имеют одинаковый интерфейс, поэтому клиентам без разницы, с чем работать — с обычным объектом данных или с обёрнутым.
+ Когда нельзя расширить обязанности объекта с помощью наследования.<br>
Во многих языках программирования есть ключевое слово `final`, которое может заблокировать наследование класса. Расширить такие классы можно только с помощью `Декоратора`.

__Шаги реализации__

1. Убедитесь, что в вашей задаче есть один основной компонент и несколько опциональных дополнений или надстроек над ним.
2. Создайте интерфейс компонента, который описывал бы общие методы как для основного компонента, так и для его дополнений.
3. Создайте класс конкретного компонента и поместите в него основную бизнес-логику.
4. Создайте базовый класс декораторов. Он должен иметь поле для хранения ссылки на вложенный объект-компонент. Все методы базового декоратора должны делегировать действие вложенному объекту.
5. И конкретный компонент, и базовый декоратор должны следовать одному и тому же интерфейсу компонента.
6. Теперь создайте классы конкретных декораторов, наследуя их от базового декоратора. Конкретный декоратор должен выполнять свою добавочную функцию, а затем (или перед этим) вызывать эту же операцию обёрнутого объекта.
7. Клиент берёт на себя ответственность за конфигурацию и порядок обёртывания объектов.

__Преимущества и недостатки__

![04](/CPP_from_LETI/LETI_03/img/04_66.jpg)

__Отношения с другими паттернами__

+ `Адаптер` меняет интерфейс существующего объекта. `Декоратор` улучшает другой объект без изменения его интерфейса. Причём `Декоратор` поддерживает рекурсивную вложенность, чего не скажешь об `Адаптере`.
+ `Адаптер` предоставляет классу альтернативный интерфейс. `Декоратор` предоставляет расширенный интерфейс. `Заместитель` предоставляет тот же интерфейс.
+ `Цепочка обязанностей` и `Декоратор` имеют очень похожие структуры. Оба паттерна базируются на принципе рекурсивного выполнения операции через серию связанных объектов. Но есть и несколько важных отличий.
+ Обработчики в `Цепочке обязанностей` могут выполнять произвольные действия, независимые друг от друга, а также в любой момент прерывать дальнейшую передачу по цепочке. С другой стороны `Декораторы` расширяют какое-то определённое действие, не ломая интерфейс базовой операции и не прерывая выполнение остальных декораторов.
+ `Компоновщик` и `Декоратор` имеют похожие структуры классов из-за того, что оба построены на рекурсивной вложенности. Она позволяет связать в одну структуру бесконечное количество объектов.
+ `Декоратор` оборачивает только один объект, а узел `Компоновщика` может иметь много детей. `Декоратор` добавляет вложенному объекту новую функциональность, а `Компоновщик` не добавляет ничего нового, но «суммирует» результаты всех своих детей.
+ Но они могут и сотрудничать: `Компоновщик` может использовать `Декоратор`, чтобы переопределить функции отдельных частей дерева компонентов.
+ `Архитектура`, построенная на `Компоновщиках` и `Декораторах`, часто может быть улучшена за счёт внедрения `Прототипа`. Он позволяет клонировать сложные структуры объектов, а не собирать их заново.
+ `Стратегия` меняет поведение объекта «изнутри», а `Декоратор` изменяет его «снаружи».
+ `Декоратор` и `Заместитель` имеют схожие структуры, но разные назначения. Они похожи тем, что оба построены на принципе композиции и делегируют работу другим объектам. Паттерны отличаются тем, что `Заместитель` сам управляет жизнью сервисного объекта, а обёртывание `Декораторов` контролируется клиентом.

<hr>

[Содержание](#содержание)

## Пример использования паттерна Компоновщик (Component)

```c++
#include <iostream>
#include <string>
#include <vector>


using namespace std;
/**
 * Базовый интерфейс Компонента определяет поведение, которое изменяется
 * декораторами.
 */
class Component {
   public:
    virtual ~Component() {}
    virtual std::string Operation() const = 0;
};
/**
 * Конкретные Компоненты предоставляют реализации поведения по умолчанию. Может
 * быть несколько вариаций этих классов.
 */
class ConcreteComponent : public Component {
   public:
    std::string Operation() const override { return "ConcreteComponent"; }
};
/**
 * Базовый класс Декоратора следует тому же интерфейсу, что и другие компоненты.
 * Основная цель этого класса - определить интерфейс обёртки для всех конкретных
 * декораторов. Реализация кода обёртки по умолчанию может включать в себя поле
 * для хранения завёрнутого компонента и средства его инициализации.
 */
class Decorator : public Component {
    /**
     * @var Component
     */
   protected:
    Component* component_;

   public:
    Decorator(Component* component) : component_(component) {}
    /**
     * Декоратор делегирует всю работу обёрнутому компоненту.
     */
    std::string Operation() const override { return this->component_->Operation(); }
};
/**
 * Конкретные Декораторы вызывают обёрнутый объект и изменяют его результат
 * некоторым образом.
 */
class ConcreteDecoratorA : public Decorator {
    /**
     * Декораторы могут вызывать родительскую реализацию операции, вместо того,
     * чтобы вызвать обёрнутый объект напрямую. Такой подход упрощает расширение
     * классов декораторов.
     */
   public:
    ConcreteDecoratorA(Component* component) : Decorator(component) {}
    std::string Operation() const override { return "ConcreteDecoratorA(" + Decorator::Operation() + ")"; }
};
/**
 * Декораторы могут выполнять своё поведение до или после вызова обёрнутого
 * объекта.
 */
class ConcreteDecoratorB : public Decorator {
   public:
    ConcreteDecoratorB(Component* component) : Decorator(component) {}

    std::string Operation() const override { return "ConcreteDecoratorB(" + Decorator::Operation() + ")"; }
};
/**
 * Клиентский код работает со всеми объектами, используя интерфейс Компонента.
 * Таким образом, он остаётся независимым от конкретных классов компонентов, с
 * которыми работает.
 */
void ClientCode(Component* component) {
    // ...
    std::cout << "RESULT: " << component->Operation();
    // ...
}

int main() {
    /**
     * Таким образом, клиентский код может поддерживать как простые компоненты...
     */
    Component* simple = new ConcreteComponent;
    std::cout << "Client: I've got a simple component:\n";
    ClientCode(simple);
    std::cout << "\n\n";
    /**
     * ...так и декорированные.
     *
     * Обратите внимание, что декораторы могут обёртывать не только простые
     * компоненты, но и другие декораторы.
     */
    Component* decorator1 = new ConcreteDecoratorA(simple);
    Component* decorator2 = new ConcreteDecoratorB(decorator1);
    std::cout << "Client: Now I've got a decorated component:\n";
    ClientCode(decorator2);
    std::cout << "\n";

    delete simple;
    delete decorator1;
    delete decorator2;

    return 0;
}
```

Результат выполнения

```
Client: I've got a simple component:
RESULT: ConcreteComponent

Client: Now I've got a decorated component:
RESULT: ConcreteDecoratorB(ConcreteDecoratorA(ConcreteComponent))
```

<hr>

[Содержание](#содержание)

## Фасад

`Фасад` — это структурный паттерн проектирования, который предоставляет простой интерфейс к сложной системе классов, библиотеке или фреймворку.

![04](/CPP_from_LETI/LETI_03/img/04_67.png)

__Проблема__

Вашему коду приходится работать с большим количеством объектов некой сложной библиотеки или фреймворка. Вы должны самостоятельно инициализировать эти объекты, следить за правильным порядком зависимостей и так далее.

В результате бизнес-логика ваших классов тесно переплетается с деталями реализации сторонних классов. Такой код довольно сложно понимать и поддерживать.

__Решение__

`Фасад` — это простой интерфейс для работы со сложной подсистемой, содержащей множество классов. `Фасад` может иметь урезанный интерфейс, не имеющий 100% функциональности, которой можно достичь, используя сложную подсистему напрямую. Но он предоставляет именно те фичи, которые нужны клиенту, и скрывает все остальные.

`Фасад` полезен, если вы используете какую-то сложную библиотеку со множеством подвижных частей, но вам нужна только часть её возможностей.

К примеру, программа, заливающая видео котиков в социальные сети, может использовать профессиональную библиотеку сжатия видео. Но все, что нужно клиентскому коду этой программы — простой метод `encode(filename, format)`. Создав класс с таким методом, вы реализуете свой первый фасад.

__Аналогия из жизни__

![04](/CPP_from_LETI/LETI_03/img/04_68.png)

Когда вы звоните в магазин и делаете заказ по телефону, сотрудник службы поддержки является вашим фасадом ко всем службам и отделам магазина. Он предоставляет вам упрощённый интерфейс к системе создания заказа, платёжной системе и отделу доставки.

__Структура__

![04](/CPP_from_LETI/LETI_03/img/04_69.jpg)

__Применимость__
+ Когда вам нужно представить простой или урезанный интерфейс к сложной подсистеме.<br>
Часто подсистемы усложняются по мере развития программы. Применение большинства паттернов приводит к появлению меньших классов, но в бóльшем количестве. Такую подсистему проще повторно использовать, настраивая её каждый раз под конкретные нужды, но вместе с тем, применять подсистему без настройки становится труднее. Фасад предлагает определённый вид системы по умолчанию, устраивающий большинство клиентов.
+ Когда вы хотите разложить подсистему на отдельные слои.<br>
Используйте фасады для определения точек входа на каждый уровень подсистемы. Если подсистемы зависят друг от друга, то зависимость можно упростить, разрешив подсистемам обмениваться информацией только через фасады.<br>
Например, возьмём ту же сложную систему видеоконвертации. Вы хотите разбить её на слои работы с аудио и видео. Для каждой из этих частей можно попытаться создать фасад и заставить классы аудио и видео обработки общаться друг с другом через эти фасады, а не напрямую.

__Шаги реализации__
1. Определите, можно ли создать более простой интерфейс, чем тот, который предоставляет сложная подсистема. Вы на правильном пути, если этот интерфейс избавит клиента от необходимости знать о подробностях подсистемы.
2. Создайте класс фасада, реализующий этот интерфейс. Он должен переадресовывать вызовы клиента нужным объектам подсистемы. Фасад должен будет позаботиться о том, чтобы правильно инициализировать объекты подсистемы.
3. Вы получите максимум пользы, если клиент будет работать только с фасадом. В этом случае изменения в подсистеме будут затрагивать только код фасада, а клиентский код останется рабочим.
4. Если ответственность фасада начинает размываться, подумайте о введении дополнительных фасадов.

__Преимущества и недостатки__

![04](/CPP_from_LETI/LETI_03/img/04_70.jpg)

__`Божественный объект` — антипаттерн объектно-ориентированного программирования, описывающий объект, который хранит в себе «слишком много» или делает «слишком много».__

__Отношения с другими паттернами__

+ `Фасад` задаёт новый интерфейс, тогда как `Адаптер` повторно использует старый. `Адаптер` оборачивает только один класс, а `Фасад` оборачивает целую подсистему. Кроме того, `Адаптер` позволяет двум существующим интерфейсам работать сообща, вместо того, чтобы задать полностью новый.
+ `Абстрактная фабрика` может быть использована вместо `Фасада` для того, чтобы скрыть платформо-зависимые классы.
+ `Легковес` показывает, как создавать много мелких объектов, а `Фасад` показывает, как создать один объект, который отображает целую подсистему.
+ `Посредник` и `Фасад` похожи тем, что пытаются организовать работу множества существующих классов.
+ `Фасад` создаёт упрощённый интерфейс к подсистеме, не внося в неё никакой добавочной функциональности. Сама подсистема не знает о существовании `Фасада`. Классы подсистемы общаются друг с другом напрямую.
+ `Посредник` централизует общение между компонентами системы. Компоненты системы знают только о существовании `Посредника`, у них нет прямого доступа к другим компонентам.
+ `Фасад` можно сделать `Одиночкой`, так как обычно нужен только один объект-фасад.
+ `Фасад` похож на `Заместитель` тем, что замещает сложную подсистему и может сам её инициализировать. Но в отличие от `Фасада`, `Заместитель` имеет тот же интерфейс, что его служебный объект, благодаря чему их можно взаимно заменять.

<hr>

[Содержание](#содержание)

## Пример использования паттерна Фасад (Facade).

Разбиение системы на компоненты позволяет снизить ее сложность. Ослабить связи между компонентами системы можно с помощью паттерна `Facade`. Объект "фасад" предоставляет единый упрощенный интерфейс к компонентам системы.

В примере ниже моделируется система сетевого обслуживания. Фасад `FacilitiesFacade` скрывает внутреннюю структуру системы. Пользователь, сделав однажды запрос на обслуживание, затем 1-2 раза в неделю в течение 5 месяцев справляется о ходе выполнения работ до тех пор, пока его запрос не будет полностью обслужен.

```c++
#include <iostream>
#include <string>
#include <vector>

using namespace std;

/**
 * Подсистема может принимать запросы либо от фасада, либо от клиента напрямую.
 * В любом случае, для Подсистемы Фасад – это еще один клиент, и он не является
 * частью Подсистемы.
 */
class Subsystem1 {
   public:
    std::string Operation1() const { return "Subsystem1: Ready!\n"; }
    // ...
    std::string OperationN() const { return "Subsystem1: Go!\n"; }
};
/**
 * Некоторые фасады могут работать с разными подсистемами одновременно.
 */
class Subsystem2 {
   public:
    std::string Operation1() const { return "Subsystem2: Get ready!\n"; }
    // ...
    std::string OperationZ() const { return "Subsystem2: Fire!\n"; }
};

/**
 * Класс Фасада предоставляет простой интерфейс для сложной логики одной или
 * нескольких подсистем. Фасад делегирует запросы клиентов соответствующим
 * объектам внутри подсистемы. Фасад также отвечает за управление их жизненным
 * циклом. Все это защищает клиента от нежелательной сложности подсистемы.
 */
class Facade {
   protected:
    Subsystem1 *subsystem1_;
    Subsystem2 *subsystem2_;
    /**
     * В зависимости от потребностей вашего приложения вы можете предоставить
     * Фасаду существующие объекты подсистемы или заставить Фасад создать их
     * самостоятельно.
     */
   public:
    /**
     * In this case we will delegate the memory ownership to Facade Class
     */
    Facade(Subsystem1 *subsystem1 = nullptr, Subsystem2 *subsystem2 = nullptr) {
        this->subsystem1_ = subsystem1 ?: new Subsystem1;
        this->subsystem2_ = subsystem2 ?: new Subsystem2;
    }
    ~Facade() {
        delete subsystem1_;
        delete subsystem2_;
    }
    /**
     * Методы Фасада удобны для быстрого доступа к сложной функциональности
     * подсистем. Однако клиенты получают только часть возможностей подсистемы.
     */
    std::string Operation() {
        std::string result = "Facade initializes subsystems:\n";
        result += this->subsystem1_->Operation1();
        result += this->subsystem2_->Operation1();
        result += "Facade orders subsystems to perform the action:\n";
        result += this->subsystem1_->OperationN();
        result += this->subsystem2_->OperationZ();
        return result;
    }
};

/**
 * Клиентский код работает со сложными подсистемами через простой интерфейс,
 * предоставляемый Фасадом. Когда фасад управляет жизненным циклом подсистемы,
 * клиент может даже не знать о существовании подсистемы. Такой подход позволяет
 * держать сложность под контролем.
 */
void ClientCode(Facade *facade) {
    // ...
    std::cout << facade->Operation();
    // ...
}
/**
 * В клиентском коде могут быть уже созданы некоторые объекты подсистемы. В этом
 * случае может оказаться целесообразным инициализировать Фасад с этими
 * объектами вместо того, чтобы позволить Фасаду создавать новые экземпляры.
 */

int main() {
    Subsystem1 *subsystem1 = new Subsystem1;
    Subsystem2 *subsystem2 = new Subsystem2;
    Facade *facade = new Facade(subsystem1, subsystem2);
    ClientCode(facade);

    delete facade;

    return 0;
}
```

Вывод программы:

```
Facade initializes subsystems:
Subsystem1: Ready!
Subsystem2: Get ready!
Facade orders subsystems to perform the action:
Subsystem1: Go!
Subsystem2: Fire!
```

<hr>

[Содержание](#содержание)

## Легковес 
`Легковес` — это структурный паттерн проектирования, который позволяет вместить бóльшее количество объектов в отведённую оперативную память. `Легковес` экономит память, разделяя общее состояние объектов между собой, вместо хранения одинаковых данных в каждом объекте.

![04](/CPP_from_LETI/LETI_03/img/04_71.png)

__Проблема__

На досуге вы решили написать небольшую игру, в которой игроки перемещаются по карте и стреляют друг в друга. Фишкой игры должна была стать реалистичная система частиц. Пули, снаряды, осколки от взрывов — всё это должно красиво летать и радовать взгляд.

Игра отлично работала на вашем мощном компьютере. Однако ваш друг сообщил, что игра начинает тормозить и вылетает через несколько минут после запуска. Покопавшись в логах, вы обнаружили, что игра вылетает из-за недостатка оперативной памяти. У вашего друга компьютер значительно менее «прокачанный», поэтому проблема у него и проявляется так быстро.

И действительно, каждая частица представлена собственным объектом, имеющим множество данных. В определённый момент, когда побоище на экране достигает кульминации, новые объекты частиц уже не вмещаются в оперативную память компьютера, и программа вылетает.

![04](/CPP_from_LETI/LETI_03/img/04_72.png)

__Решение__

Если внимательно посмотреть на класс частиц, то можно заметить, что цвет и спрайт занимают больше всего памяти. Более того, они хранятся в каждом объекте, хотя фактически их значения одинаковы для большинства частиц.

![04](/CPP_from_LETI/LETI_03/img/04_73.png)

Остальное состояние объектов — координаты, вектор движения и скорость — отличаются для всех частиц. Таким образом, эти поля можно рассматривать как контекст, в котором частица используется. А цвет и спрайт — это данные, не изменяющиеся во времени.

Неизменяемые данные объекта принято называть «внутренним состоянием». Все остальные данные — это «внешнее состояние».

Паттерн `Легковес` предлагает не хранить в классе внешнее состояние, а передавать его в те или иные методы через параметры. Таким образом, одни и те же объекты можно будет повторно использовать в различных контекстах. Но главное — понадобится гораздо меньше объектов, ведь теперь они будут отличаться только внутренним состоянием, а оно имеет не так много вариаций.

![04](/CPP_from_LETI/LETI_03/img/04_74.png)

В нашем примере с частицами достаточно будет оставить всего три объекта с отличающимися спрайтами и цветом — для пуль, снарядов и осколков. Несложно догадаться, что такие облегчённые объекты называют легковéсами .

__Хранилище внешнего состояния__

Но куда переедет внешнее состояние? Ведь кто-то должен его хранить. Чаще всего, его перемещают в контейнер, который управлял объектами до применения паттерна.

В нашем случае это был главный объект игры. Вы могли бы добавить в его класс поля-массивы для хранения координат, векторов и скоростей частиц. Кроме этого, понадобится ещё один массив для хранения ссылок на объекты-легковесы, соответствующие той или иной частице.

![04](/CPP_from_LETI/LETI_03/img/04_75.png)

Но более элегантным решением было бы создать дополнительный класс-контекст, который бы связывал внешнее состояние с тем или иным легковесом. Это позволит обойтись только одним полем-массивом в классе контейнера.

«Но погодите-ка, нам потребуется столько же этих объектов, сколько было в самом начале!», — скажете вы и будете правы! Но дело в том, что объекты-контексты занимают намного меньше места, чем первоначальные. Ведь самые тяжёлые поля остались в легковесах (простите за каламбур), и сейчас мы будем ссылаться на эти объекты из контекстов, вместо того, чтобы повторно хранить дублирующееся состояние.

__Неизменяемость Легковесов__

Так как объекты легковесов будут использованы в разных контекстах, вы должны быть уверены в том, что их состояние невозможно изменить после создания. Всё внутреннее состояние легковес должен получать через параметры конструктора. Он не должен иметь сеттеров и публичных полей.

__Фабрика Легковесов__

Для удобства работы с легковесами и контекстами можно создать `фабричный метод`, принимающий в параметрах всё внутреннее (а иногда и внешнее) состояние желаемого объекта.

Главная польза от этого метода в том, чтобы искать уже созданные легковесы с таким же внутренним состоянием, что и требуемое. Если легковес находится, его можно повторно использовать. Если нет — просто создаём новый. Обычно этот метод добавляют в контейнер легковесов либо создают отдельный класс-фабрику. Его даже можно сделать статическим и поместить в класс легковесов.

Структура

![04](/CPP_from_LETI/LETI_03/img/04_76.jpg)

__Применимость__

+ Когда не хватает оперативной памяти для поддержки всех нужных объектов.

Эффективность паттерна `Легковес` во многом зависит от того, как и где он используется. Применяйте этот паттерн, когда выполнены все перечисленные условия:
+ в приложении используется большое число объектов;
+ из-за этого высоки расходы оперативной памяти;
+ большую часть состояния объектов можно вынести за пределы их классов;
+ большие группы объектов можно заменить относительно небольшим количеством разделяемых объектов, поскольку внешнее состояние вынесено.

__Шаги реализации__

1. Разделите поля класса, который станет легковесом, на две части:
    + внутреннее состояние: значения этих полей одинаковы для большого числа объектов;
    + внешнее состояние (контекст): значения полей уникальны для каждого объекта.
2. Оставьте поля внутреннего состояния в классе, но убедитесь, что их значения неизменяемы. Эти поля должны инициализироваться только через конструктор.
3. Превратите поля внешнего состояния в параметры методов, где эти поля использовались. Затем удалите поля из класса.
4. Создайте фабрику, которая будет кешировать и повторно отдавать уже созданные объекты. Клиент должен запрашивать из этой фабрики легковеса с определённым внутренним состоянием, а не создавать его напрямую.
5. Клиент должен хранить или вычислять значения внешнего состояния (контекст) и передавать его в методы объекта легковеса.

__Преимущества и недостатки__

![04](/CPP_from_LETI/LETI_03/img/04_77.jpg)

__Отношения с другими паттернами__
+ `Компоновщик` часто совмещают с `Легковесом`, чтобы реализовать общие ветки дерева и сэкономить при этом память.
+ `Легковес` показывает, как создавать много мелких объектов, а `Фасад` показывает, как создать один объект, который отображает целую подсистему.
+ Паттерн `Легковес` может напоминать `Одиночку`, если для конкретной задачи у вас получилось свести количество объектов к одному. Но помните, что между паттернами есть два кардинальных отличия:
    + В отличие от `Одиночки`, вы можете иметь множество объектов-легковесов.
    + Объекты-легковесы должны быть неизменяемыми, тогда как объект-одиночка допускает изменение своего состояния.

<hr>

[Содержание](#содержание)

## Примеры реализации паттерна Легковес (Flyweight)

```c++
#include <iostream>
#include <string>
#include <unordered_map>
#include <vector>


/**
 * Паттерн Легковес
 *
 * Назначение: Позволяет вместить бóльшее количество объектов в отведённую
 * оперативную память. Легковес экономит память, разделяя общее состояние
 * объектов между собой, вместо хранения одинаковых данных в каждом объекте.
 */

struct SharedState {
    std::string brand_;
    std::string model_;
    std::string color_;

    SharedState(const std::string &brand, const std::string &model, const std::string &color)
        : brand_(brand), model_(model), color_(color) {}

    friend std::ostream &operator<<(std::ostream &os, const SharedState &ss) {
        return os << "[ " << ss.brand_ << " , " << ss.model_ << " , " << ss.color_ << " ]";
    }
};

struct UniqueState {
    std::string owner_;
    std::string plates_;

    UniqueState(const std::string &owner, const std::string &plates) : owner_(owner), plates_(plates) {}

    friend std::ostream &operator<<(std::ostream &os, const UniqueState &us) {
        return os << "[ " << us.owner_ << " , " << us.plates_ << " ]";
    }
};

/**
 * Легковес хранит общую часть состояния (также называемую внутренним
 * состоянием), которая принадлежит нескольким реальным бизнес-объектам.
 * Легковес принимает оставшуюся часть состояния (внешнее состояние, уникальное
 * для каждого объекта)  через его параметры метода.
 */
class Flyweight {
   private:
    SharedState *shared_state_;

   public:
    Flyweight(const SharedState *shared_state) : shared_state_(new SharedState(*shared_state)) {}
    Flyweight(const Flyweight &other) : shared_state_(new SharedState(*other.shared_state_)) {}
    ~Flyweight() { delete shared_state_; }
    SharedState *shared_state() const { return shared_state_; }
    void Operation(const UniqueState &unique_state) const {
        std::cout << "Flyweight: Displaying shared (" << *shared_state_ << ") and unique (" << unique_state
                  << ") state.\n";
    }
};
/**
 * Фабрика Легковесов создает объекты-Легковесы и управляет ими. Она
 * обеспечивает правильное разделение легковесов. Когда клиент запрашивает
 * легковес, фабрика либо возвращает существующий экземпляр, либо создает новый,
 * если он ещё не существует.
 */
class FlyweightFactory {
    /**
     * @var Flyweight[]
     */
   private:
    std::unordered_map<std::string, Flyweight> flyweights_;
    /**
     * Возвращает хеш строки Легковеса для данного состояния.
     */
    std::string GetKey(const SharedState &ss) const { return ss.brand_ + "_" + ss.model_ + "_" + ss.color_; }

   public:
    FlyweightFactory(std::initializer_list<SharedState> share_states) {
        for (const SharedState &ss : share_states) {
            this->flyweights_.insert(
                std::make_pair<std::string, Flyweight>(this->GetKey(ss), Flyweight(&ss)));
        }
    }

    /**
     * Возвращает существующий Легковес с заданным состоянием или создает новый.
     */
    Flyweight GetFlyweight(const SharedState &shared_state) {
        std::string key = this->GetKey(shared_state);
        if (this->flyweights_.find(key) == this->flyweights_.end()) {
            std::cout << "FlyweightFactory: Can't find a flyweight, creating new one.\n";
            this->flyweights_.insert(std::make_pair(key, Flyweight(&shared_state)));
        } else {
            std::cout << "FlyweightFactory: Reusing existing flyweight.\n";
        }
        return this->flyweights_.at(key);
    }
    void ListFlyweights() const {
        size_t count = this->flyweights_.size();
        std::cout << "\nFlyweightFactory: I have " << count << " flyweights:\n";
        for (std::pair<std::string, Flyweight> pair : this->flyweights_) {
            std::cout << pair.first << "\n";
        }
    }
};

// ...
void AddCarToPoliceDatabase(FlyweightFactory &ff, const std::string &plates, const std::string &owner,
                            const std::string &brand, const std::string &model, const std::string &color) {
    std::cout << "\nClient: Adding a car to database.\n";
    const Flyweight &flyweight = ff.GetFlyweight({brand, model, color});
    // Клиентский код либо сохраняет, либо вычисляет внешнее состояние и
    // передает его методам легковеса.
    flyweight.Operation({owner, plates});
}

/**
 * Клиентский код обычно создает кучу предварительно заполненных легковесов на
 * этапе инициализации приложения.
 */

int main() {
    FlyweightFactory *factory = new FlyweightFactory({{"Chevrolet", "Camaro2018", "pink"},
                                                      {"Mercedes Benz", "C300", "black"},
                                                      {"Mercedes Benz", "C500", "red"},
                                                      {"BMW", "M5", "red"},
                                                      {"BMW", "X6", "white"}});
    factory->ListFlyweights();

    AddCarToPoliceDatabase(*factory, "CL234IR", "James Doe", "BMW", "M5", "red");

    AddCarToPoliceDatabase(*factory, "CL234IR", "James Doe", "BMW", "X1", "red");
    factory->ListFlyweights();
    delete factory;

    return 0;
}
```

Результат выполнения:

```
FlyweightFactory: I have 5 flyweights:
BMW_X6_white
Mercedes Benz_C500_red
Mercedes Benz_C300_black
BMW_M5_red
Chevrolet_Camaro2018_pink

Client: Adding a car to database.
FlyweightFactory: Reusing existing flyweight.
Flyweight: Displaying shared ([ BMW , M5 , red ]) and unique ([ CL234IR , James Doe ]) state.

Client: Adding a car to database.
FlyweightFactory: Can't find a flyweight, creating new one.
Flyweight: Displaying shared ([ BMW , X1 , red ]) and unique ([ CL234IR , James Doe ]) state.

FlyweightFactory: I have 6 flyweights:
BMW_X1_red
Mercedes Benz_C300_black
BMW_X6_white
Mercedes Benz_C500_red
BMW_M5_red
Chevrolet_Camaro2018_pink
```

<hr>

[Содержание](#содержание)

## Заместитель

__Заместитель__ — это структурный паттерн проектирования, который позволяет подставлять вместо реальных объектов специальные объекты-заменители. Эти объекты перехватывают вызовы к оригинальному объекту, позволяя сделать что-то до или после передачи вызова оригиналу.

![04](/CPP_from_LETI/LETI_03/img/04_78.png)

__Проблема__

Для чего вообще контролировать доступ к объектам? Рассмотрим такой пример: у вас есть внешний ресурсоёмкий объект, который нужен не все время, а изредка.

![04](/CPP_from_LETI/LETI_03/img/04_79.png)

Мы могли бы создавать этот объект не в самом начале программы, а только тогда, когда он кому-то реально понадобится. Каждый клиент объекта получил бы некий код отложенной инициализации. Но, вероятно, это привело бы к множественному дублированию кода.

В идеале, этот код хотелось бы поместить прямо в служебный класс, но это не всегда возможно. Например, код класса может находиться в закрытой сторонней библиотеке.

__Решение__

Паттерн `Заместитель` предлагает создать новый класс-дублёр, имеющий тот же интерфейс, что и оригинальный служебный объект. При получении запроса от клиента объект-заместитель сам бы создавал экземпляр служебного объекта и переадресовывал бы ему всю реальную работу.

![04](/CPP_from_LETI/LETI_03/img/04_80.png)

Но в чём же здесь польза? Вы могли бы поместить в класс заместителя какую-то промежуточную логику, которая выполнялась бы до (или после) вызовов этих же методов в настоящем объекте. А благодаря одинаковому интерфейсу, объект-заместитель можно передать в любой код, ожидающий сервисный объект.

__Аналогия из жизни__

![04](/CPP_from_LETI/LETI_03/img/04_81.png)

Платёжная карточка — это заместитель пачки наличных. И карточка, и наличные имеют общий интерфейс — ими можно оплачивать товары. Для покупателя польза в том, что не надо таскать с собой тонны наличных, а владелец магазина рад, что ему не нужно делать дорогостоящую инкассацию наличности в банк — деньги поступают к нему на счёт напрямую.

__Структура__

![04](/CPP_from_LETI/LETI_03/img/04_82.jpg)

__Применимость__

+ Ленивая инициализация (виртуальный прокси). Когда у вас есть тяжёлый объект, грузящий данные из файловой системы или базы данных.<br>
Вместо того, чтобы грузить данные сразу после старта программы, можно сэкономить ресурсы и создать объект тогда, когда он действительно понадобится.
+ Защита доступа (защищающий прокси). Когда в программе есть разные типы пользователей, и вам хочется защищать объект от неавторизованного доступа. Например, если ваши объекты — это важная часть операционной системы, а пользователи — сторонние программы (хорошие или вредоносные).<br>
Прокси может проверять доступ при каждом вызове и передавать выполнение служебному объекту, если доступ разрешён.
+ Локальный запуск сервиса (удалённый прокси). Когда настоящий сервисный объект находится на удалённом сервере.<br>
В этом случае заместитель транслирует запросы клиента в вызовы по сети в протоколе, понятном удалённому сервису.
+ Логирование запросов (логирующий прокси). Когда требуется хранить историю обращений к сервисному объекту.<br>
`Заместитель` может сохранять историю обращения клиента к сервисному объекту.
+ Кеширование объектов («умная» ссылка). Когда нужно кешировать результаты запросов клиентов и управлять их жизненным циклом.<br>
`Заместитель` может подсчитывать количество ссылок на сервисный объект, которые были отданы клиенту и остаются активными. Когда все ссылки освобождаются, можно будет освободить и сам сервисный объект (например, закрыть подключение к базе данных).<br>
Кроме того, `Заместитель` может отслеживать, не менял ли клиент сервисный объект. Это позволит использовать объекты повторно и здóрово экономить ресурсы, особенно если речь идёт о больших прожорливых сервисах.

__Шаги реализации__
1. Определите интерфейс, который бы сделал заместитель и оригинальный объект взаимозаменяемыми.
2. Создайте класс заместителя. Он должен содержать ссылку на сервисный объект. Чаще всего, сервисный объект создаётся самим заместителем. В редких случаях заместитель получает готовый сервисный объект от клиента через конструктор.
3. Реализуйте методы заместителя в зависимости от его предназначения. В большинстве случаев, проделав какую-то полезную работу, методы заместителя должны передать запрос сервисному объекту.
4. Подумайте о введении фабрики, которая решала бы, какой из объектов создавать — заместитель или реальный сервисный объект. Но, с другой стороны, эта логика может быть помещена в создающий метод самого заместителя.
5. Подумайте, не реализовать ли вам ленивую инициализацию сервисного объекта при первом обращении клиента к методам заместителя.

__Преимущества и недостатки__

![04](/CPP_from_LETI/LETI_03/img/04_83.jpg)

__Отношения с другими паттернами__

+ `Адаптер` предоставляет классу альтернативный интерфейс. `Декоратор` предоставляет расширенный интерфейс. `Заместитель` предоставляет тот же интерфейс.
+ `Фасад` похож на `Заместитель` тем, что замещает сложную подсистему и может сам её инициализировать. Но в отличие от `Фасада`, `Заместитель` имеет тот же интерфейс, что его служебный объект, благодаря чему их можно взаимно заменять.
+ `Декоратор` и `Заместитель` имеют схожие структуры, но разные назначения. Они похожи тем, что оба построены на принципе композиции и делегируют работу другим объектам. Паттерны отличаются тем, что `Заместитель` сам управляет жизнью сервисного объекта, а обёртывание `Декораторов` контролируется клиентом.

<hr>

[Содержание](#содержание)

## Примеры использования паттерна Заместитель (Proxy)

```c++
#include <iostream>
#include <string>
#include <unordered_map>
#include <vector>

/**
 * Интерфейс Субъекта объявляет общие операции как для Реального Субъекта, так и
 * для Заместителя. Пока клиент работает с Реальным Субъектом, используя этот
 * интерфейс, вы сможете передать ему заместителя вместо реального субъекта.
 */
class Subject {
   public:
    virtual void Request() const = 0;
};
/**
 * Реальный Субъект содержит некоторую базовую бизнес-логику. Как правило,
 * Реальные Субъекты способны выполнять некоторую полезную работу, которая к
 * тому же может быть очень медленной или точной – например, коррекция входных
 * данных. Заместитель может решить эти задачи без каких-либо изменений в коде
 * Реального Субъекта.
 */
class RealSubject : public Subject {
   public:
    void Request() const override { std::cout << "RealSubject: Handling request.\n"; }
};
/**
 * Интерфейс Заместителя идентичен интерфейсу Реального Субъекта.
 */
class Proxy : public Subject {
    /**
     * @var RealSubject
     */
   private:
    RealSubject *real_subject_;

    bool CheckAccess() const {
        // Некоторые реальные проверки должны проходить здесь.
        std::cout << "Proxy: Checking access prior to firing a real request.\n";
        return true;
    }
    void LogAccess() const { std::cout << "Proxy: Logging the time of request.\n"; }

    /**
     * Заместитель хранит ссылку на объект класса РеальныйСубъект. Клиент может
     * либо лениво загрузить его, либо передать Заместителю.
     */
   public:
    Proxy(RealSubject *real_subject) : real_subject_(new RealSubject(*real_subject)) {}

    ~Proxy() { delete real_subject_; }
    /**
     * Наиболее распространёнными областями применения паттерна Заместитель
     * являются ленивая загрузка, кэширование, контроль доступа, ведение журнала и
     * т.д. Заместитель может выполнить одну из этих задач, а затем, в зависимости
     * от результата, передать выполнение одноимённому методу в связанном объекте
     * класса Реального Субъект.
     */
    void Request() const override {
        if (this->CheckAccess()) {
            this->real_subject_->Request();
            this->LogAccess();
        }
    }
};
/**
 * Клиентский код должен работать со всеми объектами (как с реальными, так и
 * заместителями) через интерфейс Субъекта, чтобы поддерживать как реальные
 * субъекты, так и заместителей. В реальной жизни, однако, клиенты в основном
 * работают с реальными субъектами напрямую. В этом случае, для более простой
 * реализации паттерна, можно расширить заместителя из класса реального
 * субъекта.
 */
void ClientCode(const Subject &subject) {
    // ...
    subject.Request();
    // ...
}

int main() {
    std::cout << "Client: Executing the client code with a real subject:\n";
    RealSubject *real_subject = new RealSubject;
    ClientCode(*real_subject);
    std::cout << "\n";
    std::cout << "Client: Executing the same client code with a proxy:\n";
    Proxy *proxy = new Proxy(real_subject);
    ClientCode(*proxy);

    delete real_subject;
    delete proxy;
    return 0;
}
```

Результат выполнения:

```
Client: Executing the client code with a real subject:
RealSubject: Handling request.

Client: Executing the same client code with a proxy:
Proxy: Checking access prior to firing a real request.
RealSubject: Handling request.
Proxy: Logging the time of request.
```

<hr>

[Содержание](#содержание)

## Вопросы 3

Сопоставьте значения из двух списков

![04](/CPP_from_LETI/LETI_03/img/04_84.PNG)

Вашему коду приходится работать с большим количеством объектов некой сложной библиотеки или фреймворка. Вы должны самостоятельно инициализировать эти объекты, следить за правильным порядком зависимостей и так далее.

В результате бизнес-логика ваших классов тесно переплетается с деталями реализации сторонних классов. Такой код довольно сложно понимать и поддерживать.

Какой паттерн (паттерны) проектирования вы бы использовали для решения данной проблемы?

<hr>

[Содержание](#содержание)

# 4.4 Поведенческие паттерны проектирования

<hr>

[Содержание](#содержание)

# 4.5 Задания на разработку

<hr>

[Содержание](#содержание)

# 4.6 Курсовой проект

<hr>

[Содержание](#содержание)

