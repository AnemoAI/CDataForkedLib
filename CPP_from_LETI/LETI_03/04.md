# 4. Паттерны проектирования

## Содержание

+ [4.1 Виды паттернов проектирования](#41-виды-паттернов-проектирования)
    + [Паттерны проектирования](#паттерны-проектирования)
    + [Классификация паттернов](#классификация-паттернов)
+ [4.2 Порождающие паттерны проектирования](#42-порождающие-паттерны-проектирования)
    + [Виды порождающих паттернов проектирования](#виды-порождающих-паттернов-проектирования)
    + [Порождающие паттерны проектирования](#порождающие-паттерны-проектирования)
    + [Фабричный метод](#фабричный-метод)
    + [Пример использования Фабричного метода (Factory Method)](#пример-использования-фабричного-метода-factory-method)
        + [Реализация паттерна `Factory Method` на основе обобщенного конструктора](#реализация-паттерна-factory-method-на-основе-обобщенного-конструктора)
        + [Классическая реализация паттерна `Factory Method`](#классическая-реализация-паттерна-factory-method)
    + [Абстрактная фабрика](#абстрактная-фабрика)
    + [Пример использования Абстрактной фабрики](#пример-использования-абстрактной-фабрики)
    + [Строитель](#строитель)
    + [Пример использования Строителя](#пример-использования-строителя)
    + [Прототип](#прототип)
    + [Пример использования Прототипа](#пример-использования-прототипа)
    + [Одиночка](#одиночка)
    + [Пример использования Одиночки](#пример-использования-одиночки)
        + [Рассмотрим наиболее часто встречающуюся реализацию паттерна `Singleton`.](#рассмотрим-наиболее-часто-встречающуюся-реализацию-паттерна-singleton)
        + [Singleton Мэйерса](#singleton-мэйерса)
        + [Улучшенная версия классической реализации Singleton](#улучшенная-версия-классической-реализации-singleton)
        + [Использование нескольких взаимозависимых одиночек](#использование-нескольких-взаимозависимых-одиночек)
    + [Вопросы](#вопросы)
+ [4.3 Структурные паттерны проектирования](#43-структурные-паттерны-проектирования)
    + [Виды структурных паттернов проектирования](#виды-структурных-паттернов-проектирования)
    + [Адаптер](#адаптер)
    + [Пример использования паттерна `Адаптер`](#пример-использования-паттерна-адаптер)
    + [Мост](#мост)
    + [Пример использования паттерна `Мост`](#пример-использования-паттерна-мост)
    + [Компоновщик](#компоновщик)
    + [Пример использования паттерна Компоновщик (Composite)](#пример-использования-паттерна-компоновщик-composite)
    + [Декоратор](#декоратор)
    + [Пример использования паттерна Компоновщик (Component)](#пример-использования-паттерна-компоновщик-component)
    + [Фасад](#фасад)
    + [Пример использования паттерна Фасад (Facade)](#пример-использования-паттерна-фасад-facade)
    + [Примеры реализации паттерна Легковес (Flyweight)](#примеры-реализации-паттерна-легковес-flyweight)
    + [Примеры использования паттерна Заместитель (Proxy)](#примеры-использования-паттерна-заместитель-proxy)
    + [Вопросы](#вопросы-3)
+ [4.4 Поведенческие паттерны проектирования](#44-поведенческие-паттерны-проектирования)
    + [Виды поведенческих паттернов проектирования](#виды-поведенческих-паттернов-проектирования)
    + [Цепочка обязанностей](#цепочка-обязанностей)
    + [Итератор](#итератор)
    + [Пример использования паттерна Итератор (Iterator)](#пример-использования-паттерна-итератор-iterator)
    + [Посредник](#посредник)
    + [Пример использования паттерна Посредник (Mediator)](#пример-использования-паттерна-посредник-mediator)
    + [Пример использования паттерна Снимок (Memento)](#пример-использования-паттерна-снимок-memento)
    + [Состояние](#состояние)
    + [Примеры использования паттерна Состояние (State)](#примеры-использования-паттерна-состояние-state)
    + [Пример использования паттерна Стратегия (Strategy)](#пример-использования-паттерна-стратегия-strategy)
    + [Шаблонный метод](#шаблонный-метод)
    + [Примеры реализации паттерна Шаблонный метод (TemplateMethod)](#примеры-реализации-паттерна-шаблонный-метод-templatemethod)
    + [Посетитель](#посетитель)
    + [Примеры реализации паттерна Посетитель (Visitor)](#примеры-реализации-паттерна-посетитель-visitor)
    + [Вопросы](#вопросы-4)
+ [4.5 Задания на разработку](#45-задания-на-разработку)
    + [Введение в ООП: создание классов, конструкторов классов, методов классов; наследование ](#введение-в-ооп-создание-классов-конструкторов-классов-методов-классов-наследование)
    + [Интерфейсы классов, взаимодействие классов, перегрузка операций](#интерфейсы-классов-взаимодействие-классов-перегрузка-операций)
    + [Логическое разделение классов](#логическое-разделение-классов)
    + [Полиморфизм](#полиморфизм)
    + [Сериализация состояния программы](#сериализация-состояния-программы)
    + [Шаблонные классы](#шаблонные-классы)
+ [4.6 Курсовой проект](#46-курсовой-проект)

[Оглавление](/CPP_from_LETI/LETI_03/README.md)

# 4.1 Виды паттернов проектирования

## Паттерны проектирования

При создании программных систем перед разработчиками часто встает проблема выбора тех или иных проектных решений. В этих случаях на помощь приходят паттерны. 

Дело в том, что почти наверняка подобные задачи уже решались ранее и уже существуют хорошо продуманные элегантные решения, составленные экспертами. 

Если эти решения описать и систематизировать в каталоги, то они станут доступными менее опытным разработчикам, которые после изучения смогут использовать их как шаблоны или образцы для решения задач подобного класса. Паттерны как раз описывают решения таких повторяющихся задач.

Концепция создания программного обеспечения с использованием паттернов, несомненно, очень важная, но относительно молодая, быть может, поэтому до сих пор нет четкого определения, что же такое паттерн. Об этом свидетельствуют непрекращающиеся дискуссии в популярной литературе и на соответствующих форумах в сети.

Например, следует ли считать алгоритмы и структуры данных паттернами? 

По этому вопросу существуют противоположные мнения. 

Согласно одному из них, алгоритмы являются вычислительными паттернами, а хорошо известная фундаментальная монография Дональда Кнута "Искусство программирования" по сути, представляет собой каталог таких паттернов. 

Согласно другому мнению, алгоритмы не являются паттернами, так как решаемые ими проблемы слишком малы (оперируют такими понятиями как вычислительная сложность и потребление ресурсов), а область решения хорошо очерчена. 

Паттерны же решают проблемы большего масштаба, при этом паттерн дает не конкретное решение, а некий путь к решению, причем, выбор правильного паттерна - задача нетривиальная, предполагающая от архитектора наличие интуиции, опыта, определенного творчества.

<hr>

[Содержание](#содержание)

## Классификация паттернов

В настоящее время наиболее популярными паттернами являются паттерны проектирования. Одной из распространенных классификаций таких паттернов является классификация по степени детализации и уровню абстракции рассматриваемых систем. 

Паттерны проектирования программных систем делятся на следующие категории:
+ Архитектурные паттерны
+ Паттерны проектирования
+ Идиомы

__Архитектурные паттерны__, являясь наиболее высокоуровневыми паттернами, описывают структурную схему программной системы в целом. В данной схеме указываются отдельные функциональные составляющие системы, называемые подсистемами, а также взаимоотношения между ними. Примером архитектурного паттерна является хорошо известная программная парадигма "модель-представление-контроллер" (`model-view-controller` - `MVC`).

В свою очередь, подсистемы могут состоять из архитектурных единиц уровнем ниже. 

__Паттерны проектирования__ описывают схемы детализации программных подсистем и отношений между ними, при этом они не влияют на структуру программной системы в целом и сохраняют независимость от реализации языка программирования. 

Паттерны `GoF` относятся именно к этой категории. 

Под паттернами проектирования объектно-ориентированных систем понимается описание взаимодействия объектов и классов, адаптированных для решения общей задачи проектирования в конкретном контексте.

__Идиомы__, являясь низкоуровневыми паттернами, имеют дело с вопросами реализации какой-либо проблемы с учетом особенностей данного языка программирования. 

При этом часто одни и те же идиомы для разных языков программирования выглядят по-разному или не имеют смысла вовсе. 

Например, в C++ для устранения возможных утечек памяти могут использоваться интеллектуальные указатели. Интеллектуальный указатель содержит указатель на участок динамически выделенной памяти, который будет автоматически освобожден при выходе из зоны видимости. В среде Java такой проблемы просто не существует, так как там используется автоматическая сборка мусора. Обычно, для использования идиом нужно глубоко знать особенности применяемого языка программирования.

Следует отметить, что в программной области существуют и другие виды паттернов, не относящиеся к проектированию вообще, например, паттерны анализа, тестирования, документирования и др.

![04](/CPP_from_LETI/LETI_03/img/04_01.jpg)

Различают следующие паттерны проектирования: 
+ __Порождающие__. Отвечают за удобное и безопасное создание новых объектов или даже целых семейств объектов.
+ __Структурные__. Отвечают за построение удобных в поддержке иерархий классов.
+ __Поведенческие__. Решают задачи эффективного и безопасного взаимодействия между объектами программы. 

![04](/CPP_from_LETI/LETI_03/img/04_02.PNG)

![04](/CPP_from_LETI/LETI_03/img/04_03.PNG)

<hr>

[Содержание](#содержание)

# 4.2 Порождающие паттерны проектирования

## Виды порождающих паттернов проектирования

![04](/CPP_from_LETI/LETI_03/img/04_04.jpg)

<hr>

[Содержание](#содержание)

## Порождающие паттерны проектирования

Пожалуй, создание новых объектов является наиболее распространенной задачей, встающей перед разработчиками программных систем. Порождающие паттерны проектирования предназначены для создания объектов, позволяя системе оставаться независимой как от самого процесса порождения, так и от типов порождаемых объектов. Прежде чем рассматривать особенности каждого из порождающих паттернов, рассмотрим на примере типичные проблемы, встающие перед разработчиками при порождении в системе объектов новых типов.

Пусть мы разрабатываем многообещающую стратегическую игру, описывающую великое военное противостояние между Римской Республикой и Карфагеном (264 — 146 г. до н. э.). 

Персонажами игры могут быть воины трех типов:
+ пехота,
+ конница и
+ лучники. 

Каждый из этих видов обладает своими отличительными характеристиками, такими как внешний вид, боевая мощь, скорость передвижения и степень защиты. 

Несмотря на такие отличия, у всех видов боевых единиц есть общие черты. 

Например, все они могут передвигаться по игровому полю в различных направлениях, хотя всадники делают это быстрее всех. Или каждая боевая единица имеет свой уровень здоровья, и если он становится равным нулю, воин погибает. При этом уничтожить лучника значительно проще, чем другие виды воинов.

В будущем, если игра окажется успешной, мы будем развивать ее дальше. Например, мы могли бы добавить новые виды воинов, такие как боевые слоны, или усовершенствовать существующие, разделив пехоту на легковооруженных и тяжеловооруженных пехотинцев. 

Для внесения подобных изменений без модификации существующего кода, мы должны уже сейчас постараться сделать игру максимально независимой от конкретных типов персонажей. Казалось бы, для этого достаточно использовать следующую иерархию классов.

```c++
class Warrior {
  public:
    virtual void info() = 0;       
    virtual ~Warrior() {}
};
  
class Infantryman: public Warrior {
  public:
      void info() { cout << "Infantryman" << endl; }     
};
  
class Archer: public Warrior {
  public:
    void info() { cout << "Archer" << endl; }     
};
  
class Horseman: public Warrior {
  public:    
    void info() { cout << "Horseman" << endl; }     
};
```

Полиморфный базовый класс `Warrior` определяет общий интерфейс, а производные от него классы `Infantryman`, `Archer` и `Horseman` реализуют особенности каждого вида воина. 

Сложность заключается в том, что хотя код системы и оперирует готовыми объектами через соответствующие общие интерфейсы, в процессе игры требуется создавать новые персонажи, непосредственно указывая их конкретные типы. Если код их создания рассредоточен по всему приложению, то добавлять новые типы персонажей или заменять существующие будет затруднительно.

В таких случаях на помощь приходит фабрика объектов, локализующая создание объектов. Работа фабрики объектов напоминает функционирование виртуального конструктора, - мы можем создавать объекты нужных классов, не указывая напрямую их типы. В самом простом случае, для этого используются идентификаторы типов. Следующий пример демонстрирует простейший вариант фабрики объектов - фабричную функцию.

```c++
enum Warrior_ID { Infantryman_ID=0, Archer_ID, Horseman_ID };
  
Warrior * сreateWarrior( Warrior_ID id  )
{
    Warrior * p;
    switch (id)
    {
        case Infantryman_ID:
            p = new Infantryman();           
            break;      
        case Archer_ID:
            p = new Archer();           
            break;
        case Horseman_ID:
            p = new Horseman();           
            break;              
        default:
            assert( false);
    }
    return p;
}
```

Теперь, скрывая детали, код создания объектов разных типов игровых персонажей сосредоточен в одном месте, а именно, в фабричной функции `сreateWarrior()`. Эта функция получает в качестве аргумента тип объекта, который нужно создать, создает его и возвращает соответствующий указатель на базовый класс.

Несмотря на очевидные преимущества, у этого варианта фабрики также существуют недостатки. Например, для добавления нового вида боевой единицы необходимо сделать несколько шагов - завести новый идентификатор типа и модифицировать код фабричной функции `createWarrior( )`.

Познакомившись с основными проблемами, возникающими при создании объектов новых типов, кратко рассмотрим особенности каждого из порождающих паттернов (шаблонов).

<hr>

[Содержание](#содержание)

## Фабричный метод

__Фабричный метод__ — это порождающий паттерн проектирования, который определяет общий интерфейс для создания объектов в суперклассе, позволяя подклассам изменять тип создаваемых объектов.

![04](/CPP_from_LETI/LETI_03/img/04_05.png)

__Проблема__

Представьте, что вы создаёте программу управления грузовыми перевозками. Сперва вы рассчитываете перевозить товары только на автомобилях. Поэтому весь ваш код работает с объектами класса `Грузовик`.

В какой-то момент ваша программа становится настолько известной, что морские перевозчики выстраиваются в очередь и просят добавить поддержку морской логистики в программу.

![04](/CPP_from_LETI/LETI_03/img/04_06.png)

Отличные новости, правда?! Но как насчёт кода? Большая часть существующего кода жёстко привязана к классам `Грузовиков`. Чтобы добавить в программу классы морских `Судов`, понадобится перелопатить всю программу. Более того, если вы потом решите добавить в программу ещё один вид транспорта, то всю эту работу придётся повторить.

В итоге вы получите ужасающий код, наполненный условными операторами, которые выполняют то или иное действие, в зависимости от класса транспорта.

__Решение__

Паттерн `Фабричный метод` предлагает создавать объекты не напрямую, используя оператор `new`, а через вызов особого _фабричного метода_. Не пугайтесь, объекты всё равно будут создаваться при помощи `new`, но делать это будет фабричный метод.

![04](/CPP_from_LETI/LETI_03/img/04_07.png)

На первый взгляд, это может показаться бессмысленным: мы просто переместили вызов конструктора из одного конца программы в другой. Но теперь вы сможете переопределить фабричный метод в подклассе, чтобы изменить тип создаваемого продукта.

Чтобы эта система заработала, все возвращаемые объекты должны иметь общий интерфейс. Подклассы смогут производить объекты различных классов, следующих одному и тому же интерфейсу.

![04](/CPP_from_LETI/LETI_03/img/04_08.png)

Например, классы `Грузовик` и `Судно` реализуют интерфейс `Транспорт` с методом доставить. Каждый из этих классов реализует метод по-своему: грузовики везут грузы по земле, а суда — по морю. Фабричный метод в классе `ДорожнойЛогистики` вернёт объект-грузовик, а класс `МорскойЛогистики` — объект-судно.

![04](/CPP_from_LETI/LETI_03/img/04_09.png)

Для клиента фабричного метода нет разницы между этими объектами, так как он будет трактовать их как некий абстрактный `Транспорт`. Для него будет важно, чтобы объект имел метод `доставить`, а как конкретно он работает — не важно.

__Структура__

![04](/CPP_from_LETI/LETI_03/img/04_10.png)

__Применимость__

+ Когда заранее неизвестны типы и зависимости объектов, с которыми должен работать ваш код. <br>
Фабричный метод отделяет код производства продуктов от остального кода, который эти продукты использует.<br>
Благодаря этому, код производства можно расширять, не трогая основной. Так, чтобы добавить поддержку нового продукта, вам нужно создать новый подкласс и определить в нём фабричный метод, возвращая оттуда экземпляр нового продукта.

+ Когда вы хотите дать возможность пользователям расширять части вашего фреймворка или библиотеки.<br>
Пользователи могут расширять классы вашего фреймворка через наследование. Но как сделать так, чтобы фреймворк создавал объекты из этих новых классов, а не из стандартных?<br>
Решением будет дать пользователям возможность расширять не только желаемые компоненты, но и классы, которые создают эти компоненты. А для этого создающие классы должны иметь конкретные создающие методы, которые можно определить.<br>
Например, вы используете готовый `UI`-фреймворк для своего приложения. Но вот беда — требуется иметь круглые кнопки, вместо стандартных прямоугольных. Вы создаёте класс `RoundButton`. Но как сказать главному классу фреймворка `UIFramework`, чтобы он теперь создавал круглые кнопки, вместо стандартных?<br>
Для этого вы создаёте подкласс `UIWithRoundButtons` из базового класса фреймворка, переопределяете в нём метод создания кнопки (а-ля `createButton`) и вписываете туда создание своего класса кнопок. Затем используете `UIWithRoundButtons` вместо стандартного `UIFramework`.

+ Когда вы хотите экономить системные ресурсы, повторно используя уже созданные объекты, вместо порождения новых.<br>
Такая проблема обычно возникает при работе с тяжёлыми ресурсоёмкими объектами, такими, как подключение к базе данных, файловой системе и т. д.

Представьте, сколько действий вам нужно совершить, чтобы повторно использовать существующие объекты:
1. Сначала вам следует создать общее хранилище, чтобы хранить в нём все создаваемые объекты.
2. При запросе нового объекта нужно будет заглянуть в хранилище и проверить, есть ли там неиспользуемый объект.
3. А затем вернуть его клиентскому коду.
4. Но если свободных объектов нет — создать новый, не забыв добавить его в хранилище.

Весь этот код нужно куда-то поместить, чтобы не засорять клиентский код.

Самым удобным местом был бы конструктор объекта, ведь все эти проверки нужны только при создании объектов. Но, увы, конструктор всегда создаёт __новые__ объекты, он не может вернуть существующий экземпляр.

Значит, нужен другой метод, который бы отдавал как существующие, так и новые объекты. Им и станет фабричный метод.

__Шаги реализации__

1. Приведите все создаваемые продукты к общему интерфейсу.
2. В классе, который производит продукты, создайте пустой фабричный метод. В качестве возвращаемого типа укажите общий интерфейс продукта.
3. Затем пройдитесь по коду класса и найдите все участки, создающие продукты. Поочерёдно замените эти участки вызовами фабричного метода, перенося в него код создания различных продуктов.<br>
В фабричный метод, возможно, придётся добавить несколько параметров, контролирующих, какой из продуктов нужно создать.<br>
На этом этапе фабричный метод, скорее всего, будет выглядеть удручающе. В нём будет жить большой условный оператор, выбирающий класс создаваемого продукта. Но не волнуйтесь, мы вот-вот исправим это.
4. Для каждого типа продуктов заведите подкласс и переопределите в нём фабричный метод. Переместите туда код создания соответствующего продукта из суперкласса.
5. Если создаваемых продуктов слишком много для существующих подклассов создателя, вы можете подумать о введении параметров в фабричный метод, которые позволят возвращать различные продукты в пределах одного подкласса.<br>
Например, у вас есть класс `Почта` с подклассами `АвиаПочта` и `НаземнаяПочта`, а также классы продуктов `Самолёт`, `Грузовик` и `Поезд`. `Авиа` соответствует `Самолётам`, но для `НаземнойПочты` есть сразу два продукта. Вы могли бы создать новый подкласс почты для поездов, но проблему можно решить и по-другому. Клиентский код может передавать в фабричный метод `НаземнойПочты` аргумент, контролирующий тип создаваемого продукта.
6. Если после всех перемещений фабричный метод стал пустым, можете сделать его абстрактным. Если в нём что-то осталось — не беда, это будет его реализацией по умолчанию.

__Преимущества и недостатки__

![04](/CPP_from_LETI/LETI_03/img/04_11.jpg)

__Отношения с другими паттернами__

+ Многие архитектуры начинаются с применения `Фабричного метода` (более простого и расширяемого через подклассы) и эволюционируют в сторону `Абстрактной фабрики`, `Прототипа` или `Строителя` (более гибких, но и более сложных).
+ Классы `Абстрактной фабрики` чаще всего реализуются с помощью `Фабричного метода`, хотя они могут быть построены и на основе `Прототипа`.
+ `Фабричный метод` можно использовать вместе с `Итератором`, чтобы подклассы коллекций могли создавать подходящие им итераторы.
+ `Прототип` не опирается на наследование, но ему нужна сложная операция инициализации. `Фабричный метод`, наоборот, построен на наследовании, но не требует сложной инициализации.
+ `Фабричный метод` можно рассматривать как частный случай `Шаблонного метода`. Кроме того, `Фабричный метод` нередко бывает частью большого класса с `Шаблонными методами`.

<hr>

[Содержание](#содержание)

## Пример использования Фабричного метода (Factory Method)

Для того, чтобы система оставалась независимой от различных типов объектов, паттерн `Factory Method` использует механизм полиморфизма - классы всех конечных типов наследуют от одного абстрактного базового класса, предназначенного для полиморфного использования. В этом базовом классе определяется единый интерфейс, через который пользователь будет оперировать объектами конечных типов.

Для обеспечения относительно простого добавления в систему новых типов паттерн `Factory Method` локализует создание объектов конкретных типов в специальном классе-фабрике. Методы этого класса, посредством которых создаются объекты конкретных классов, называются фабричными. Существуют две разновидности паттерна `Factory Method`:

_Обобщенный конструктор_, когда в том же самом полиморфном базовом классе, от которого наследуют производные классы всех создаваемых в системе типов, определяется статический фабричный метод. В качестве параметра в этот метод должен передаваться идентификатор типа создаваемого объекта.

<hr>

[Содержание](#содержание)

### Реализация паттерна `Factory Method` на основе обобщенного конструктора

```c++
#include <iostream>
#include <vector>
#include <cassert>

using namespace std;

enum Warrior_ID { Infantryman_ID = 0, Archer_ID, Horseman_ID };

// Иерархия классов игровых персонажей
class Warrior {
   public:
    virtual void info() = 0;
    virtual ~Warrior() {}
    // Параметризированный статический фабричный метод
    static Warrior* createWarrior(Warrior_ID id);
};

class Infantryman : public Warrior {
   public:
    void info() { cout << "Infantryman" << endl; }
};

class Archer : public Warrior {
   public:
    void info() { cout << "Archer" << endl; }
};

class Horseman : public Warrior {
   public:
    void info() { cout << "Horseman" << endl; }
};

// Реализация параметризированного фабричного метода
Warrior* Warrior::createWarrior(Warrior_ID id) {
    Warrior* p;
    switch (id) {
        case Infantryman_ID:
            p = new Infantryman();
            break;
        case Archer_ID:
            p = new Archer();
            break;
        case Horseman_ID:
            p = new Horseman();
            break;
        default:
            assert(false);
    }
    return p;
};

// Создание объектов при помощи параметризированного фабричного метода
int main() {
    vector<Warrior*> v;
    v.push_back(Warrior::createWarrior(Infantryman_ID));
    v.push_back(Warrior::createWarrior(Archer_ID));
    v.push_back(Warrior::createWarrior(Horseman_ID));

    for (int i = 0; i < v.size(); i++) v[i]->info();
    // ...
}
```

Представленный вариант паттерна `Factory Method` пользуется популярностью благодаря своей простоте. В нем статический фабричный метод `createWarrior()` определен непосредственно в полиморфном базовом классе `Warrior`. Этот фабричный метод является параметризированным, то есть для создания объекта некоторого типа в `createWarrior()` передается соответствующий идентификатор типа.

С точки зрения "чистоты" объектно-ориентированного кода у этого варианта есть следующие недостатки:
+ Так как код по созданию объектов всех возможных типов сосредоточен в статическом фабричном методе класса `Warrior`, то базовый класс `Warrior` обладает знанием обо всех производных от него классах, что является нетипичным для объектно-ориентированного подхода.
+ Подобное использование оператора `switch` (как в коде фабричного метода `createWarrior()`) в объектно-ориентированном программировании также не приветствуется.

Указанные недостатки отсутствуют в классической реализации паттерна `Factory Method`.

<hr>

[Содержание](#содержание)

### Классическая реализация паттерна `Factory Method`

```c++
#include <iostream>
#include <vector>

using namespace std;

// Иерархия классов игровых персонажей
class Warrior {
   public:
    virtual void info() = 0;
    virtual ~Warrior() {}
};

class Infantryman : public Warrior {
   public:
    void info() { cout << "Infantryman" << endl; };
};

class Archer : public Warrior {
   public:
    void info() { cout << "Archer" << endl; };
};

class Horseman : public Warrior {
   public:
    void info() { cout << "Horseman" << endl; };
};

// Фабрики объектов
class Factory {
   public:
    virtual Warrior* createWarrior() = 0;
    virtual ~Factory() {}
};

class InfantryFactory : public Factory {
   public:
    Warrior* createWarrior() { return new Infantryman; }
};

class ArchersFactory : public Factory {
   public:
    Warrior* createWarrior() { return new Archer; }
};

class CavalryFactory : public Factory {
   public:
    Warrior* createWarrior() { return new Horseman; }
};

// Создание объектов при помощи фабрик объектов
int main() {
    InfantryFactory* infantry_factory = new InfantryFactory;
    ArchersFactory* archers_factory = new ArchersFactory;
    CavalryFactory* cavalry_factory = new CavalryFactory;

    vector<Warrior*> v;
    v.push_back(infantry_factory->createWarrior());
    v.push_back(archers_factory->createWarrior());
    v.push_back(cavalry_factory->createWarrior());

    for (int i = 0; i < v.size(); i++) v[i]->info();
    // ...
}
```

Классический вариант паттерна `Factory Method` использует идею полиморфной фабрики. Специально выделенный для создания объектов полиморфный базовый класс `Factory` объявляет интерфейс фабричного метода `createWarrior()`, а производные классы его реализуют.

Представленный вариант паттерна `Factory Method` является наиболее распространенным, но не единственным. Возможны следующие вариации:
+ Класс `Factory` имеет реализацию фабричного метода `createWarrior()` по умолчанию.
+ Фабричный метод `createWarrior()` класса `Factory` параметризирован типом создаваемого объекта (как и у представленного ранее, простого варианта `Factory Method`) и имеет реализацию по умолчанию. В этом случае, производные от `Factory` классы необходимы лишь для того, чтобы определить нестандартное поведение `createWarrior()`.

<hr>

[Содержание](#содержание)

## Абстрактная фабрика

__Абстрактная фабрика__ — это порождающий паттерн проектирования, который позволяет создавать семейства связанных объектов, не привязываясь к конкретным классам создаваемых объектов.

![04](/CPP_from_LETI/LETI_03/img/04_12.png)

__Проблема__

Представьте, что вы пишете симулятор мебельного магазина. Ваш код содержит:

Семейство зависимых продуктов. Скажем, `Кресло` + `Диван` + `Столик`.

Несколько вариаций этого семейства. Например, продукты `Кресло`, `Диван` и `Столик` представлены в трёх разных стилях: `Арт-деко`, `Викторианском` и `Модерне`.

![04](/CPP_from_LETI/LETI_03/img/04_13.png)

Вам нужен такой способ создавать объекты продуктов, чтобы они сочетались с другими продуктами того же семейства. Это важно, так как клиенты расстраиваются, если получают несочетающуюся мебель.

![04](/CPP_from_LETI/LETI_03/img/04_14.png)

Кроме того, вы не хотите вносить изменения в существующий код при добавлении новых продуктов или семейств в программу. Поставщики часто обновляют свои каталоги, и вы бы не хотели менять уже написанный код каждый раз при получении новых моделей мебели.

__Решение__

Для начала паттерн `Абстрактная фабрика` предлагает выделить общие интерфейсы для отдельных продуктов, составляющих семейства. Так, все вариации кресел получат общий интерфейс `Кресло`, все диваны реализуют интерфейс `Диван` и так далее.

![04](/CPP_from_LETI/LETI_03/img/04_15.png)

Далее вы создаёте _абстрактную фабрику_ — общий интерфейс, который содержит методы создания всех продуктов семейства (например, `создатьКресло`, `создатьДиван` и `создатьСтолик`). Эти операции должны возвращать __абстрактные__ типы продуктов, представленные интерфейсами, которые мы выделили ранее — `Кресла`, `Диваны` и `Столики`.

![04](/CPP_from_LETI/LETI_03/img/04_16.png)

Как насчёт вариаций продуктов? Для каждой вариации семейства продуктов мы должны создать свою собственную фабрику, реализовав абстрактный интерфейс. Фабрики создают продукты одной вариации. Например, `ФабрикаМодерн` будет возвращать только `КреслаМодерн`,`ДиваныМодерн` и `СтоликиМодерн`.

Клиентский код должен работать как с фабриками, так и с продуктами только через их общие интерфейсы. Это позволит подавать в ваши классы любой тип фабрики и производить любые продукты, ничего не ломая.

![04](/CPP_from_LETI/LETI_03/img/04_17.png)

Например, клиентский код просит фабрику сделать стул. Он не знает, какого типа была эта фабрика. Он не знает, получит викторианский или модерновый стул. Для него важно, чтобы на стуле можно было сидеть и чтобы этот стул отлично смотрелся с диваном той же фабрики.

Осталось прояснить последний момент: кто создаёт объекты конкретных фабрик, если клиентский код работает только с интерфейсами фабрик? Обычно программа создаёт конкретный объект фабрики при запуске, причём тип фабрики выбирается, исходя из параметров окружения или конфигурации.

__Применимость__

+ Когда бизнес-логика программы должна работать с разными видами связанных друг с другом продуктов, не завися от конкретных классов продуктов.<br>
Абстрактная фабрика скрывает от клиентского кода подробности того, как и какие конкретно объекты будут созданы. Но при этом клиентский код может работать со всеми типами создаваемых продуктов, поскольку их общий интерфейс был заранее определён.
+ Когда в программе уже используется Фабричный метод, но очередные изменения предполагают введение новых типов продуктов.<br>
В хорошей программе каждый _класс отвечает только за одну вещь_. Если класс имеет слишком много фабричных методов, они способны затуманить его основную функцию. Поэтому имеет смысл вынести всю логику создания продуктов в отдельную иерархию классов, применив абстрактную фабрику.

__Шаги реализации__

1. Создайте таблицу соотношений типов продуктов к вариациям семейств продуктов.
2. Сведите все вариации продуктов к общим интерфейсам.
3. Определите интерфейс абстрактной фабрики. Он должен иметь фабричные методы для создания каждого из типов продуктов.
4. Создайте классы конкретных фабрик, реализовав интерфейс абстрактной фабрики. Этих классов должно быть столько же, сколько и вариаций семейств продуктов.
5. Измените код инициализации программы так, чтобы она создавала определённую фабрику и передавала её в клиентский код.
6. Замените в клиентском коде участки создания продуктов через конструктор вызовами соответствующих методов фабрики.

__Преимущества и недостатки__

![04](/CPP_from_LETI/LETI_03/img/04_18.jpg)

__Отношения с другими паттернами__

+ Многие архитектуры начинаются с применения `Фабричного метода` (более простого и расширяемого через подклассы) и эволюционируют в сторону `Абстрактной фабрики`, `Прототипа` или `Строителя` (более гибких, но и более сложных).
+ `Строитель` концентрируется на построении сложных объектов шаг за шагом. `Абстрактная фабрика` специализируется на создании семейств связанных продуктов. `Строитель` возвращает продукт только после выполнения всех шагов, а `Абстрактная фабрика` возвращает продукт сразу же.
+ Классы `Абстрактной фабрики` чаще всего реализуются с помощью `Фабричного метода`, хотя они могут быть построены и на основе `Прототипа`.
+ `Абстрактная фабрика` может быть использована вместо `Фасада` для того, чтобы скрыть платформо-зависимые классы.
+ `Абстрактная фабрика` может работать совместно с `Мостом`. Это особенно полезно, если у вас есть абстракции, которые могут работать только с некоторыми из реализаций. В этом случае фабрика будет определять типы создаваемых абстракций и реализаций.
+ `Абстрактная фабрика`, `Строитель` и `Прототип` могут быть реализованы при помощи `Одиночки`.

<hr>

[Содержание](#содержание)

## Пример использования Абстрактной фабрики

Любое семейство или группа взаимосвязанных объектов характеризуется несколькими общими типами создаваемых продуктов, при этом сами продукты таких типов будут различными для разных семейств. Например, для случая стратегической игры общими типами создаваемых продуктов будут пехота, лучники и конница, при этом каждый из этих родов войск римской армии может существенно отличаться по внешнему виду и боевым характеристикам от соответствующих родов войск армии Карфагена.

Для того чтобы система оставалась независимой от специфики того или иного семейства продуктов необходимо использовать общие интерфейсы для всех основных типов продуктов. В случае стратегической игры это означает, что необходимо использовать три абстрактных базовых класса для каждого типа воинов: пехоты, лучников и конницы. Производные от них классы будут реализовывать специфику соответствующего типа воинов той или иной армии.

Для решения задачи по созданию семейств взаимосвязанных объектов паттерн `Abstract Factory` вводит понятие абстрактной фабрики. 

Абстрактная фабрика представляет собой некоторый полиморфный базовый класс, назначением которого является объявление интерфейсов фабричных методов, служащих для создания продуктов всех основных типов (один фабричный метод на каждый тип продукта). Производные от него классы, реализующие эти интерфейсы, предназначены для создания продуктов всех типов внутри семейства или группы. В случае нашей игры базовый класс абстрактной фабрики должен определять интерфейс фабричных методов для создания пехотинцев, лучников и конницы, а два производных от него класса будут реализовывать этот интерфейс, создавая воинов всех родов войск для той или иной армии.

```c++
#include <iostream>
#include <vector>

using namespace std;

// Абстрактные базовые классы всех возможных видов воинов
class Infantryman {
   public:
    virtual void info() = 0;
    virtual ~Infantryman() {}
};

class Archer {
   public:
    virtual void info() = 0;
    virtual ~Archer() {}
};

class Horseman {
   public:
    virtual void info() = 0;
    virtual ~Horseman() {}
};

// Классы всех видов воинов Римской армии
class RomanInfantryman : public Infantryman {
   public:
    void info() { cout << "RomanInfantryman" << endl; }
};

class RomanArcher : public Archer {
   public:
    void info() { cout << "RomanArcher" << endl; }
};

class RomanHorseman : public Horseman {
   public:
    void info() { cout << "RomanHorseman" << endl; }
};

// Классы всех видов воинов армии Карфагена
class CarthaginianInfantryman : public Infantryman {
   public:
    void info() { cout << "CarthaginianInfantryman" << endl; }
};

class CarthaginianArcher : public Archer {
   public:
    void info() { cout << "CarthaginianArcher" << endl; }
};

class CarthaginianHorseman : public Horseman {
   public:
    void info() { cout << "CarthaginianHorseman" << endl; }
};

// Абстрактная фабрика для производства воинов
class ArmyFactory {
   public:
    virtual Infantryman* createInfantryman() = 0;
    virtual Archer* createArcher() = 0;
    virtual Horseman* createHorseman() = 0;
    virtual ~ArmyFactory() {}
};

// Фабрика для создания воинов Римской армии
class RomanArmyFactory : public ArmyFactory {
   public:
    Infantryman* createInfantryman() { return new RomanInfantryman; }
    Archer* createArcher() { return new RomanArcher; }
    Horseman* createHorseman() { return new RomanHorseman; }
};

// Фабрика для создания воинов армии Карфагена
class CarthaginianArmyFactory : public ArmyFactory {
   public:
    Infantryman* createInfantryman() { return new CarthaginianInfantryman; }
    Archer* createArcher() { return new CarthaginianArcher; }
    Horseman* createHorseman() { return new CarthaginianHorseman; }
};

// Класс, содержащий всех воинов той или иной армии
class Army {
   public:
    ~Army() {
        int i;
        for (i = 0; i < vi.size(); ++i) delete vi[i];
        for (i = 0; i < va.size(); ++i) delete va[i];
        for (i = 0; i < vh.size(); ++i) delete vh[i];
    }
    void info() {
        int i;
        for (i = 0; i < vi.size(); ++i) vi[i]->info();
        for (i = 0; i < va.size(); ++i) va[i]->info();
        for (i = 0; i < vh.size(); ++i) vh[i]->info();
    }
    vector<Infantryman*> vi;
    vector<Archer*> va;
    vector<Horseman*> vh;
};

// Здесь создается армия той или иной стороны
class Game {
   public:
    Army* createArmy(ArmyFactory& factory) {
        Army* p = new Army;
        p->vi.push_back(factory.createInfantryman());
        p->va.push_back(factory.createArcher());
        p->vh.push_back(factory.createHorseman());
        return p;
    }
};

int main() {
    Game game;
    RomanArmyFactory ra_factory;
    CarthaginianArmyFactory ca_factory;

    Army* ra = game.createArmy(ra_factory);
    Army* ca = game.createArmy(ca_factory);
    cout << "Roman army:" << endl;
    ra->info();
    cout << "\nCarthaginian army:" << endl;
    ca->info();
    // ...
}
```

Вывод программы будет следующим:

```
Roman army:
RomanInfantryman
RomanArcher
RomanHorseman
  
Carthaginian army:
CarthaginianInfantryman
CarthaginianArcher
CarthaginianHorseman
```

<hr>

[Содержание](#содержание)

## Строитель

__Строитель__ — это порождающий паттерн проектирования, который позволяет создавать сложные объекты пошагово. Строитель даёт возможность использовать один и тот же код строительства для получения разных представлений объектов.

![04](/CPP_from_LETI/LETI_03/img/04_18.png)

__Проблема__

Представьте сложный объект, требующий кропотливой пошаговой инициализации множества полей и вложенных объектов. Код инициализации таких объектов обычно спрятан внутри монструозного конструктора с десятком параметров. Либо ещё хуже — распылён по всему клиентскому коду.

![04](/CPP_from_LETI/LETI_03/img/04_19.png)

Например, давайте подумаем о том, как создать объект `Дом`. Чтобы построить стандартный дом, нужно поставить 4 стены, установить двери, вставить пару окон и положить крышу. Но что, если вы хотите дом побольше да посветлее, имеющий сад, бассейн и прочее добро?

Самое простое решение — расширить класс `Дом`, создав подклассы для всех комбинаций параметров дома. Проблема такого подхода — это громадное количество классов, которые вам придётся создать. Каждый новый параметр, вроде цвета обоев или материала кровли, заставит вас создавать всё больше и больше классов для перечисления всех возможных вариантов.

Чтобы не плодить подклассы, вы можете подойти к решению с другой стороны. Вы можете создать гигантский конструктор `Дома`, принимающий уйму параметров для контроля над создаваемым продуктом. Действительно, это избавит вас от подклассов, но приведёт к другой проблеме.

![04](/CPP_from_LETI/LETI_03/img/04_20.png)

Большая часть этих параметров будет простаивать, а вызовы конструктора будут выглядеть монструозно из-за длинного списка параметров. К примеру, далеко не каждый дом имеет бассейн, поэтому параметры, связанные с бассейнами, будут простаивать бесполезно в 99% случаев.

__Решение__

Паттерн `Строитель` предлагает вынести конструирование объекта за пределы его собственного класса, поручив это дело отдельным объектам, называемым _строителями_.

![04](/CPP_from_LETI/LETI_03/img/04_21.png)

Паттерн предлагает разбить процесс конструирования объекта на отдельные шаги (например, `построитьСтены`, `вставитьДвери` и другие). Чтобы создать объект, вам нужно поочерёдно вызывать методы строителя. Причём не нужно запускать все шаги, а только те, что нужны для производства объекта определённой конфигурации.

Зачастую один и тот же шаг строительства может отличаться для разных вариаций производимых объектов. Например, деревянный дом потребует строительства стен из дерева, а каменный — из камня.

В этом случае вы можете создать несколько классов строителей, выполняющих одни и те же шаги по-разному. Используя этих строителей в одном и том же строительном процессе, вы сможете получать на выходе различные объекты.

![04](/CPP_from_LETI/LETI_03/img/04_22.png)

Например, один строитель делает стены из дерева и стекла, другой из камня и железа, третий из золота и бриллиантов. Вызвав одни и те же шаги строительства, в первом случае вы получите обычный жилой дом, во втором — маленькую крепость, а в третьем — роскошное жилище. Замечу, что код, который вызывает шаги строительства, должен работать со строителями через общий интерфейс, чтобы их можно было свободно взаимозаменять.

Вы можете пойти дальше и выделить вызовы методов строителя в отдельный класс, называемый _директором_. В этом случае директор будет задавать порядок шагов строительства, а строитель — выполнять их.

![04](/CPP_from_LETI/LETI_03/img/04_23.png)

Отдельный класс директора не является строго обязательным. Вы можете вызывать методы строителя и напрямую из клиентского кода. Тем не менее, директор полезен, если у вас есть несколько способов конструирования продуктов, отличающихся порядком и наличием шагов конструирования. В этом случае вы сможете объединить всю эту логику в одном классе.

Такая структура классов полностью скроет от клиентского кода процесс конструирования объектов. Клиенту останется только привязать желаемого строителя к директору, а затем получить у строителя готовый результат.

__Структура__

![04](/CPP_from_LETI/LETI_03/img/04_24.png)

__Применимость__

+ Когда вы хотите избавиться от «телескопического конструктора».<br>
Допустим, у вас есть один конструктор с десятью опциональными параметрами. Его неудобно вызывать, поэтому вы создали ещё десять конструкторов с меньшим количеством параметров. Всё, что они делают — это переадресуют вызов к базовому конструктору, подавая какие-то значения по умолчанию в параметры, которые пропущены в них самих.
```c++
class Pizza {
    Pizza(int size) { ... }
    Pizza(int size, boolean cheese) { ... }
    Pizza(int size, boolean cheese, boolean pepperoni) { ... }
    // ...
}
```

Паттерн `Строитель` позволяет собирать объекты пошагово, вызывая только те шаги, которые вам нужны. А значит, больше не нужно пытаться «запихнуть» в конструктор все возможные опции продукта.

+ Когда ваш код должен создавать разные представления какого-то объекта. Например, деревянные и железобетонные дома.<br>
Строитель можно применить, если создание нескольких представлений объекта состоит из одинаковых этапов, которые отличаются в деталях.<br>
Интерфейс строителей определит все возможные этапы конструирования. Каждому представлению будет соответствовать собственный класс-строитель. А порядок этапов строительства будет задавать класс-директор.
+ Когда вам нужно собирать сложные составные объекты, например, деревья `Компоновщика`.<br>
Строитель конструирует объекты пошагово, а не за один проход. Более того, шаги строительства можно выполнять рекурсивно. А без этого не построить древовидную структуру, вроде `Компоновщика`.

Заметьте, что `Строитель` не позволяет посторонним объектам иметь доступ к конструируемому объекту, пока тот не будет полностью готов. Это предохраняет клиентский код от получения незаконченных «битых» объектов.

__Шаги реализации__

1. Убедитесь в том, что создание разных представлений объекта можно свести к общим шагам.
2. Опишите эти шаги в общем интерфейсе строителей.
3. Для каждого из представлений объекта-продукта создайте по одному классу-строителю и реализуйте их методы строительства.<br>
Не забудьте про метод получения результата. Обычно конкретные строители определяют собственные методы получения результата строительства. Вы не можете описать эти методы в интерфейсе строителей, поскольку продукты не обязательно должны иметь общий базовый класс или интерфейс. Но вы всегда сможете добавить метод получения результата в общий интерфейс, если ваши строители производят однородные продукты с общим предком.
4. Подумайте о создании класса директора. Его методы будут создавать различные конфигурации продуктов, вызывая разные шаги одного и того же строителя.
5. Клиентский код должен будет создавать и объекты строителей, и объект директора. Перед началом строительства клиент должен связать определённого строителя с директором. Это можно сделать либо через конструктор, либо через сеттер, либо подав строителя напрямую в строительный метод директора.
6. Результат строительства можно вернуть из директора, но только если метод возврата продукта удалось поместить в общий интерфейс строителей. Иначе вы жёстко привяжете директора к конкретным классам строителей.

__Преимущества и недостатки__

![04](/CPP_from_LETI/LETI_03/img/04_25.jpg)

__Отношения с другими паттернами__

+ Многие архитектуры начинаются с применения `Фабричного метода` (более простого и расширяемого через подклассы) и эволюционируют в сторону `Абстрактной фабрики`, `Прототипа` или `Строителя` (более гибких, но и более сложных).
+ `Строитель` концентрируется на построении сложных объектов шаг за шагом. `Абстрактная фабрика` специализируется на создании семейств связанных продуктов. `Строитель` возвращает продукт только после выполнения всех шагов, а `Абстрактная фабрика` возвращает продукт сразу же.
+ `Строитель` позволяет пошагово сооружать дерево `Компоновщика`.
+ Паттерн `Строитель` может быть построен в виде `Моста`: директор будет играть роль абстракции, а строители — реализации.
+ `Абстрактная фабрика`, `Строитель` и `Прототип` могут быть реализованы при помощи `Одиночки`.

<hr>

[Содержание](#содержание)

## Пример использования Строителя

Для того чтобы не нагромождать код лишними подробностями будем полагать, что такие рода войск как пехота, лучники и конница для обеих армий идентичны. А с целью демонстрации возможностей паттерна `Builder` введем новые виды боевых единиц:
+ Катапульты для армии Рима.
+ Боевые слоны для армии Карфагена.

```c++
#include <iostream>
#include <vector>

using namespace std;

// Классы всех возможных родов войск
class Infantryman {
   public:
    void info() { cout << "Infantryman" << endl; }
};

class Archer {
   public:
    void info() { cout << "Archer" << endl; }
};

class Horseman {
   public:
    void info() { cout << "Horseman" << endl; }
};

class Catapult {
   public:
    void info() { cout << "Catapult" << endl; }
};

class Elephant {
   public:
    void info() { cout << "Elephant" << endl; }
};

// Класс "Армия", содержащий все типы боевых единиц
class Army {
   public:
    vector<Infantryman> vi;
    vector<Archer> va;
    vector<Horseman> vh;
    vector<Catapult> vc;
    vector<Elephant> ve;
    void info() {
        int i;
        for (i = 0; i < vi.size(); ++i) vi[i].info();
        for (i = 0; i < va.size(); ++i) va[i].info();
        for (i = 0; i < vh.size(); ++i) vh[i].info();
        for (i = 0; i < vc.size(); ++i) vc[i].info();
        for (i = 0; i < ve.size(); ++i) ve[i].info();
    }
};

// Базовый класс ArmyBuilder объявляет интерфейс для поэтапного
// построения армии и предусматривает его реализацию по умолчанию

class ArmyBuilder {
   protected:
    Army* p;

   public:
    ArmyBuilder() : p(0) {}
    virtual ~ArmyBuilder() {}
    virtual void createArmy() {}
    virtual void buildInfantryman() {}
    virtual void buildArcher() {}
    virtual void buildHorseman() {}
    virtual void buildCatapult() {}
    virtual void buildElephant() {}
    virtual Army* getArmy() { return p; }
};

// Римская армия имеет все типы боевых единиц кроме боевых слонов
class RomanArmyBuilder : public ArmyBuilder {
   public:
    void createArmy() { p = new Army; }
    void buildInfantryman() { p->vi.push_back(Infantryman()); }
    void buildArcher() { p->va.push_back(Archer()); }
    void buildHorseman() { p->vh.push_back(Horseman()); }
    void buildCatapult() { p->vc.push_back(Catapult()); }
};

// Армия Карфагена имеет все типы боевых единиц кроме катапульт
class CarthaginianArmyBuilder : public ArmyBuilder {
   public:
    void createArmy() { p = new Army; }
    void buildInfantryman() { p->vi.push_back(Infantryman()); }
    void buildArcher() { p->va.push_back(Archer()); }
    void buildHorseman() { p->vh.push_back(Horseman()); }
    void buildElephant() { p->ve.push_back(Elephant()); }
};

// Класс-распорядитель, поэтапно создающий армию той или иной стороны.
// Именно здесь определен алгоритм построения армии.
class Director {
   public:
    Army* createArmy(ArmyBuilder& builder) {
        builder.createArmy();
        builder.buildInfantryman();
        builder.buildArcher();
        builder.buildHorseman();
        builder.buildCatapult();
        builder.buildElephant();
        return (builder.getArmy());
    }
};

int main() {
    Director dir;
    RomanArmyBuilder ra_builder;
    CarthaginianArmyBuilder ca_builder;

    Army* ra = dir.createArmy(ra_builder);
    Army* ca = dir.createArmy(ca_builder);
    cout << "Roman army:" << endl;
    ra->info();
    cout << "\nCarthaginian army:" << endl;
    ca->info();
    // ...

    return 0;
}
```

Вывод программы будет следующим:

```
Roman army:
Infantryman
Archer
Horseman
Catapult
  
Carthaginian army:
Infantryman
Archer
Horseman
Elephant
```

Очень часто базовый класс строителя (в коде выше это `ArmyBuilder`) не только объявляет интерфейс для построения частей продукта, но и определяет ничего не делающую реализацию по умолчанию. Тогда соответствующие подклассы (`RomanArmyBuilder`, `CarthaginianArmyBuilder`) переопределяют только те методы, которые участвуют в построении текущего объекта. Так класс `RomanArmyBuilder` не определяет метод `buildElephant`, поэтому Римская армия не может иметь слонов. А в классе `CarthaginianArmyBuilder` не определен `buildCatapult()`, поэтому армия Карфагена не может иметь катапульты.

Интересно сравнить приведенный код с кодом создания армии в реализации паттерна `Abstract Factory`, который также может использоваться для создания сложных продуктов. Если паттерн `Abstract Factory` акцентирует внимание на создании семейств некоторых объектов, то паттерн `Builder` подчеркивает поэтапное построение продукта. При этом класс `Builder` скрывает все подробности построения сложного продукта так, что `Director` ничего не знает о его составных частях.

<hr>

[Содержание](#содержание)

## Прототип

`Прототип` — это порождающий паттерн проектирования, который позволяет копировать объекты, не вдаваясь в подробности их реализации.

![04](/CPP_from_LETI/LETI_03/img/04_26.png)

__Проблема__

У вас есть объект, который нужно скопировать. Как это сделать? Нужно создать пустой объект такого же класса, а затем поочерёдно скопировать значения всех полей из старого объекта в новый.

Прекрасно! Но есть нюанс. Не каждый объект удастся скопировать таким образом, ведь часть его состояния может быть приватной, а значит — недоступной для остального кода программы.

![04](/CPP_from_LETI/LETI_03/img/04_27.png)

Но есть и другая проблема. Копирующий код станет зависим от классов копируемых объектов. Ведь, чтобы перебрать все поля объекта, нужно привязаться к его классу. Из-за этого вы не сможете копировать объекты, зная только их интерфейсы, а не конкретные классы.

__Решение__

Паттерн `Прототип` поручает создание копий самим копируемым объектам. Он вводит общий интерфейс для всех объектов, поддерживающих клонирование. Это позволяет копировать объекты, не привязываясь к их конкретным классам. Обычно такой интерфейс имеет всего один метод `clone`.

Реализация этого метода в разных классах очень схожа. Метод создаёт новый объект текущего класса и копирует в него значения всех полей собственного объекта. Так получится скопировать даже приватные поля, так как большинство языков программирования разрешает доступ к приватным полям любого объекта текущего класса.

Объект, который копируют, называется прототипом (откуда и название паттерна). Когда объекты программы содержат сотни полей и тысячи возможных конфигураций, прототипы могут служить своеобразной альтернативой созданию подклассов.

![04](/CPP_from_LETI/LETI_03/img/04_28.png)

В этом случае все возможные прототипы заготавливаются и настраиваются на этапе инициализации программы. Потом, когда программе нужен новый объект, она создаёт копию из приготовленного прототипа.

__Аналогия из жизни__

В промышленном производстве прототипы создаются перед основной партией продуктов для проведения всевозможных испытаний. При этом прототип не участвует в последующем производстве, отыгрывая пассивную роль.

![04](/CPP_from_LETI/LETI_03/img/04_29.png)

Прототип на производстве не делает копию самого себя, поэтому более близкий пример паттерна — деление клеток. После митозного деления клеток образуются две совершенно идентичные клетки. Оригинальная клетка отыгрывает роль прототипа, принимая активное участие в создании нового объекта.

__Структура__

__*Базовая реализация*__

![04](/CPP_from_LETI/LETI_03/img/04_30.png)

__*Реализация с общим хранилищем прототипов*__

![04](/CPP_from_LETI/LETI_03/img/04_31.png)

__Применимость__

+ Когда ваш код не должен зависеть от классов копируемых объектов.<br>
Такое часто бывает, если ваш код работает с объектами, поданными извне через какой-то общий интерфейс. Вы не можете привязаться к их классам, даже если бы хотели, поскольку их конкретные классы неизвестны.<br>
Паттерн прототип предоставляет клиенту общий интерфейс для работы со всеми прототипами. Клиенту не нужно зависеть от всех классов копируемых объектов, а только от интерфейса клонирования.
+ Когда вы имеете уйму подклассов, которые отличаются начальными значениями полей. Кто-то мог создать все эти классы, чтобы иметь возможность легко порождать объекты с определённой конфигурацией.<br>
Паттерн прототип предлагает использовать набор прототипов, вместо создания подклассов для описания популярных конфигураций объектов.

Таким образом, вместо порождения объектов из подклассов, вы будете копировать существующие объекты-прототипы, в которых уже настроено внутреннее состояние. Это позволит избежать взрывного роста количества классов в программе и уменьшить её сложность.

__Шаги реализации__

1. Создайте интерфейс прототипов с единственным методом `clone`. Если у вас уже есть иерархия продуктов, метод клонирования можно объявить непосредственно в каждом из её классов.
2. Добавьте в классы будущих прототипов альтернативный конструктор, принимающий в качестве аргумента объект текущего класса. Этот конструктор должен скопировать из поданного объекта значения всех полей, объявленных в рамках текущего класса, а затем передать выполнение родительскому конструктору, чтобы тот позаботился о полях, объявленных в суперклассе.<br>
Если ваш язык программирования не поддерживает перегрузку методов, то вам не удастся создать несколько версий конструктора. В этом случае копирование значений можно проводить и в другом методе, специально созданном для этих целей. Конструктор удобнее тем, что позволяет клонировать объект за один вызов.
3. Метод клонирования обычно состоит всего из одной строки: вызова оператора `new` с конструктором прототипа. Все классы, поддерживающие клонирование, должны явно определить метод `clone`, чтобы использовать собственный класс с оператором `new`. В обратном случае результатом клонирования станет объект родительского класса.
4. Опционально, создайте центральное хранилище прототипов. В нём удобно хранить вариации объектов, возможно, даже одного класса, но по-разному настроенных.<br>
Вы можете разместить это хранилище либо в новом фабричном классе, либо в фабричном методе базового класса прототипов. Такой фабричный метод должен на основании входящих аргументов искать в хранилище прототипов подходящий экземпляр, а затем вызывать его метод клонирования и возвращать полученный объект.<br>
Наконец, нужно избавиться от прямых вызовов конструкторов объектов, заменив их вызовами фабричного метода хранилища прототипов.

__Преимущества и недостатки__

![04](/CPP_from_LETI/LETI_03/img/04_32.jpg)

__Отношения с другими паттернами__

+ Многие архитектуры начинаются с применения `Фабричного метода` (более простого и расширяемого через подклассы) и эволюционируют в сторону `Абстрактной фабрики`, `Прототипа` или `Строителя` (более гибких, но и более сложных).
+ Классы `Абстрактной фабрики` чаще всего реализуются с помощью `Фабричного метода`, хотя они могут быть построены и на основе `Прототипа`.
+ Если Команду нужно копировать перед вставкой в историю выполненных команд, вам может помочь `Прототип`.
+ Архитектура, построенная на `Компоновщиках` и `Декораторах`, часто может быть улучшена за счёт внедрения `Прототипа`. Он позволяет клонировать сложные структуры объектов, а не собирать их заново.
+ `Прототип` не опирается на наследование, но ему нужна сложная операция инициализации. `Фабричный метод`, наоборот, построен на наследовании, но не требует сложной инициализации.
+ `Снимок` иногда можно заменить `Прототипом`, если объект, состояние которого требуется сохранять в истории, довольно простой, не имеет активных ссылок на внешние ресурсы либо их можно легко восстановить.
+ `Абстрактная фабрика`, `Строитель` и `Прототип` могут быть реализованы при помощи `Одиночки`.

<hr>

[Содержание](#содержание)

## Пример использования Прототипа

Приведем реализацию паттерна `Prototype` на примере построения армий для военной стратегии. Для упрощения демонстрационного кода будем создавать военные персонажи для некой абстрактной армии без учета особенностей воюющих сторон.

Также как и для паттерна `Factory Method` приведем две возможные реализации паттерна `Prototype`, а именно:
1. В виде обобщенного конструктора на основе прототипов, когда в полиморфном базовом классе `Prototype` определяется статический метод, предназначенный для создания объектов. При этом в качестве параметра в этот метод должен передаваться идентификатор типа создаваемого объекта.
2. На базе специально выделенного класса-фабрики.

__Реализация паттерна `Ptototype` на основе обобщенного конструктора__

```c++
#include <iostream>
#include <map>
#include <vector>

using namespace std;

// Идентификаторы всех родов войск
enum Warrior_ID { Infantryman_ID, Archer_ID, Horseman_ID };

class Warrior;  // Опережающее объявление
typedef map<Warrior_ID, Warrior*> Registry;

// Реестр прототипов определен в виде Singleton Мэйерса
Registry& getRegistry() {
    static Registry _instance;
    return _instance;
}

// Единственное назначение этого класса - помощь в выборе нужного
// конструктора при создании прототипов
class Dummy {};

// Полиморфный базовый класс. Здесь также определен статический
// обобщенный конструктор для создания боевых единиц всех родов войск
class Warrior {
   public:
    virtual Warrior* clone() = 0;
    virtual void info() = 0;
    virtual ~Warrior() {}
    // Параметризированный статический метод для создания воинов
    // всех родов войск
    static Warrior* createWarrior(Warrior_ID id) {
        Registry& r = getRegistry();
        if (r.find(id) != r.end()) return r[id]->clone();
        return 0;
    }

   protected:
    // Добавление прототипа в множество прототипов
    static void addPrototype(Warrior_ID id, Warrior* prototype) {
        Registry& r = getRegistry();
        r[id] = prototype;
    }
    // Удаление прототипа из множества прототипов
    static void removePrototype(Warrior_ID id) {
        Registry& r = getRegistry();
        r.erase(r.find(id));
    }
};

// В производных классах различных родов войск в виде статических
// членов-данных определяются соответствующие прототипы
class Infantryman : public Warrior {
   public:
    Warrior* clone() { return new Infantryman(*this); }
    void info() { cout << "Infantryman" << endl; }

   private:
    Infantryman(Dummy) { Warrior::addPrototype(Infantryman_ID, this); }
    Infantryman() {}
    static Infantryman prototype;
};

class Archer : public Warrior {
   public:
    Warrior* clone() { return new Archer(*this); }
    void info() { cout << "Archer" << endl; }

   private:
    Archer(Dummy) { addPrototype(Archer_ID, this); }
    Archer() {}
    static Archer prototype;
};

class Horseman : public Warrior {
   public:
    Warrior* clone() { return new Horseman(*this); }
    void info() { cout << "Horseman" << endl; }

   private:
    Horseman(Dummy) { addPrototype(Horseman_ID, this); }
    Horseman() {}
    static Horseman prototype;
};

Infantryman Infantryman::prototype = Infantryman(Dummy());
Archer Archer::prototype = Archer(Dummy());
Horseman Horseman::prototype = Horseman(Dummy());

int main() {
    vector<Warrior*> v;
    v.push_back(Warrior::createWarrior(Infantryman_ID));
    v.push_back(Warrior::createWarrior(Archer_ID));
    v.push_back(Warrior::createWarrior(Horseman_ID));

    for (int i = 0; i < v.size(); i++) v[i]->info();
    // ...
}
```

В приведенной реализации классы всех создаваемых военных единиц, таких как лучники, пехотинцы и конница, являются подклассами абстрактного базового класса `Warrior`. В этом классе определен обобщенный конструктор в виде статического метода `createWarrior(Warrior_ID id)`. Передавая в этот метод в качестве параметра тип боевой единицы, можно создавать воинов нужных родов войск. Для этого обобщенный конструктор использует реестр прототипов, реализованный в виде ассоциативного массива `std::map`, каждый элемент которого представляет собой пару "идентификатор типа воина" - "его прототип".

Добавление прототипов в реестр происходит автоматически. Сделано это следующим образом. В подклассах `Infantryman`, `Archer`, `Horseman`, прототипы определяются в виде статических членов данных тех же типов. При создании такого прототипа будет вызываться конструктор с параметром типа `Dummy`, который и добавит этот прототип в реестр прототипов с помощью метода `addPrototype()` базового класса `Warrior`. Важно, чтобы к этому моменту сам объект реестра был полностью сконструирован, именно поэтому он выполнен в виде `singleton` Мэйерса.

Для приведенной реализации паттерна `Prototype` можно отметить следующие особенности:
+ Создавать новых воинов можно только при помощи обобщенного конструктора. Их непосредственное создание невозможно, так как соответствующие конструкторы объявлены со спецификатором доступа `private`.
+ Отсутствует недостаток реализации на базе обобщенного конструктора для паттерна `Factory Method`, а именно базовый класс `Warrior` ничего не знает о своих подклассах.

__Реализация паттерна Prototype с помощью выделенного класса-фабрики__

```c++
#include <iostream>
#include <vector>

using namespace std;
  
// Иерархия классов игровых персонажей
// Полиморфный базовый класс
class Warrior
{
  public:   
    virtual Warrior* clone() = 0;
    virtual void info() = 0;        
    virtual ~Warrior() {}
};
  
  
// Производные классы различных родов войск
class Infantryman: public Warrior
{
    friend class PrototypeFactory;
  public:   
    Warrior* clone() { 
      return new Infantryman( *this); 
    }
    void info() { 
      cout << "Infantryman" << endl; 
    } 
  private:
    Infantryman() {}    
};
  
class Archer: public Warrior
{
    friend class PrototypeFactory;
  public:   
    Warrior* clone() { 
      return new Archer( *this); 
    }  
    void info() { 
      cout << "Archer" << endl; 
    }
  private:  
    Archer() {} 
};
  
class Horseman: public Warrior
{
    friend class PrototypeFactory;
  public:    
    Warrior* clone() { 
      return new Horseman( *this); 
    }
    void info() { 
      cout << "Horseman" << endl; 
    }
  private:  
    Horseman() {}
};
  
  
// Фабрика для создания боевых единиц всех родов войск
class PrototypeFactory
{
  public:   
    Warrior* createInfantryman() {       
      static Infantryman prototype;
      return prototype.clone();
    }
    Warrior* createArcher() {       
      static Archer prototype;
      return prototype.clone();
    }
    Warrior* createHorseman() {     
      static Horseman prototype;
      return prototype.clone();
    }
};
  
  
int main()
{    
  PrototypeFactory factory;
  vector<Warrior*> v;
  v.push_back( factory.createInfantryman());
  v.push_back( factory.createArcher());
  v.push_back( factory.createHorseman());   
  
  for(int i=0; i<v.size(); i++)
    v[i]->info();
    // ...
}
```

В приведенной реализации для упрощения кода реестр прототипов не ведется. Воины всех родов войск создаются при помощи соответствующих методов фабричного класса `PrototypeFactory`, где и определены прототипы в виде статических переменных.

<hr>

[Содержание](#содержание)

## Одиночка

`Одиночка` — это порождающий паттерн проектирования, который гарантирует, что у класса есть только один экземпляр, и предоставляет к нему глобальную точку доступа.

![03](/CPP_from_LETI/LETI_03/img/04_33.png)

__Проблема__

`Одиночка` решает сразу две проблемы, нарушая _принцип единственной ответственности_ класса.

__Гарантирует наличие единственного экземпляра класса__. Чаще всего это полезно для доступа к какому-то общему ресурсу, например, базе данных.

Представьте, что вы создали объект, а через некоторое время пробуете создать ещё один. В этом случае хотелось бы получить старый объект, вместо создания нового.

Такое поведение невозможно реализовать с помощью обычного конструктора, так как конструктор класса __всегда__ возвращает новый объект.

![03](/CPP_from_LETI/LETI_03/img/04_34.png)

__Предоставляет глобальную точку доступа.__ Это не просто глобальная переменная, через которую можно достучаться к определённому объекту. Глобальные переменные не защищены от записи, поэтому любой код может подменять их значения без вашего ведома.

Но есть и другой нюанс. Неплохо бы хранить в одном месте и код, который решает проблему №1, а также иметь к нему простой и доступный интерфейс.

Интересно, что в наше время паттерн стал настолько известен, что теперь люди называют «одиночками» даже те классы, которые решают лишь одну из проблем, перечисленных выше.

__Решение__

Все реализации одиночки сводятся к тому, чтобы скрыть конструктор по умолчанию и создать публичный статический метод, который и будет контролировать жизненный цикл объекта-одиночки.

Если у вас есть доступ к классу одиночки, значит, будет доступ и к этому статическому методу. Из какой точки кода вы бы его ни вызвали, он всегда будет отдавать один и тот же объект.

__Аналогия из жизни__

Правительство государства — хороший пример одиночки. В государстве может быть только одно официальное правительство. Вне зависимости от того, кто конкретно заседает в правительстве, оно имеет глобальную точку доступа «Правительство страны N».

__Структура__

![03](/CPP_from_LETI/LETI_03/img/04_35.png)

__Применимость__

+ Когда в программе должен быть единственный экземпляр какого-то класса, доступный всем клиентам (например, общий доступ к базе данных из разных частей программы).<br>
`Одиночка` скрывает от клиентов все способы создания нового объекта, кроме специального метода. Этот метод либо создаёт объект, либо отдаёт существующий объект, если он уже был создан.<br>
Когда вам хочется иметь больше контроля над глобальными переменными.
+ В отличие от глобальных переменных, `Одиночка` гарантирует, что никакой другой код не заменит созданный экземпляр класса, поэтому вы всегда уверены в наличии лишь одного объекта-одиночки.<br>
Тем не менее, в любой момент вы можете расширить это ограничение и позволить любое количество объектов-одиночек, поменяв код в одном месте (метод `getInstance`).

__Шаги реализации__

1. Добавьте в класс приватное статическое поле, которое будет содержать одиночный объект.
2. Объявите статический создающий метод, который будет использоваться для получения одиночки.
3. Добавьте «ленивую инициализацию» (создание объекта при первом вызове метода) в создающий метод одиночки.
4. Сделайте конструктор класса приватным.
5. В клиентском коде замените вызовы конструктора одиночка вызовами его создающего метода.

__Преимущества и недостатки__

![03](/CPP_from_LETI/LETI_03/img/04_36.png)

__Отношения с другими паттернами__

+ `Фасад` можно сделать `Одиночкой`, так как обычно нужен только один объект-фасад.
+ Паттерн `Легковес` может напоминать `Одиночку`, если для конкретной задачи у вас получилось свести количество объектов к одному. Но помните, что между паттернами есть два кардинальных отличия:
    1. В отличие от `Одиночки`, вы можете иметь множество объектов-легковесов.
    2. Объекты-легковесы должны быть неизменяемыми, тогда как объект-одиночка допускает изменение своего состояния.
+ `Абстрактная фабрика`, `Строитель` и `Прототип` могут быть реализованы при помощи `Одиночки`.

<hr>

[Содержание](#содержание)

## Пример использования Одиночки

Несмотря на кажущуюся простоту паттерна `Singleton` (используется всего один класс), его реализация не является тривиальной.

### Рассмотрим наиболее часто встречающуюся реализацию паттерна `Singleton`.

```c++
// Singleton.h
class Singleton {
   private:
    static Singleton* p_instance;
    // Конструкторы и оператор присваивания недоступны клиентам
    Singleton() {}
    Singleton(const Singleton&);
    Singleton& operator=(Singleton&);

   public:
    static Singleton* getInstance() {
        if (!p_instance) p_instance = new Singleton();
        return p_instance;
    }
};

// Singleton.cpp
#include "Singleton.h"

Singleton* Singleton::p_instance = 0;
```

Клиенты запрашивают единственный объект класса через статическую функцию-член `getInstance()`, которая при первом запросе динамически выделяет память под этот объект и затем возвращает указатель на этот участок памяти. В дальнейшем клиенты должны сами позаботиться об освобождении памяти при помощи оператора `delete`.

Последняя особенность является серьезным недостатком классической реализации шаблона `Singleton`. Так как класс сам контролирует создание единственного объекта, было бы логичным возложить на него ответственность и за разрушение объекта. Этот недостаток отсутствует в реализации `Singleton`, впервые предложенной Скоттом Мэйерсом.

<hr>

[Содержание](#содержание)

### Singleton Мэйерса

```c++
// Singleton.h
class Singleton {
   private:
    Singleton() {}
    Singleton(const Singleton&);
    Singleton& operator=(Singleton&);

   public:
    static Singleton& getInstance() {
        static Singleton instance;
        return instance;
    }
};
```

Внутри `getInstance()` используется статический экземпляр нужного класса. Стандарт языка программирования C++ гарантирует автоматическое уничтожение статических объектов при завершении программы. Досрочного уничтожения и не требуется, так как объекты `Singleton` обычно являются долгоживущими объектами. Статическая функция-член `getInstance()` возвращает не указатель, а ссылку на этот объект, тем самым, затрудняя возможность ошибочного освобождения памяти клиентами.

Приведенная реализация паттерна `Singleton` использует так называемую отложенную инициализацию (`lazy initialization`) объекта, когда объект класса инициализируется не при старте программы, а при первом вызове `getInstance()`. В данном случае это обеспечивается тем, что статическая переменная `instance` объявлена внутри функции - члена класса `getInstance()`, а не как статический член данных этого класса. Отложенную инициализацию, в первую очередь, имеет смысл использовать в тех случаях, когда инициализация объекта представляет собой дорогостоящую операцию и не всегда используется.

К сожалению, у реализации Мэйерса есть недостатки:
+ сложности создания объектов производных классов и
+ невозможность безопасного доступа нескольких клиентов к единственному объекту в многопоточной среде.

<hr>

[Содержание](#содержание)

### Улучшенная версия классической реализации Singleton

С учетом всего вышесказанного классическая реализация паттерна `Singleton` может быть улучшена.

```c++
// Singleton.h
class Singleton;  // опережающее объявление

class SingletonDestroyer {
   private:
    Singleton* p_instance;

   public:
    ~SingletonDestroyer();
    void initialize(Singleton* p);
};

class Singleton {
   private:
    static Singleton* p_instance;
    static SingletonDestroyer destroyer;

   protected:
    Singleton() {}
    Singleton(const Singleton&);
    Singleton& operator=(Singleton&);
    ~Singleton() {}
    friend class SingletonDestroyer;

   public:
    static Singleton& getInstance();
};

// Singleton.cpp
#include "Singleton.h"

Singleton* Singleton::p_instance = 0;
SingletonDestroyer Singleton::destroyer;

SingletonDestroyer::~SingletonDestroyer() { delete p_instance; }
void SingletonDestroyer::initialize(Singleton* p) { p_instance = p; }
Singleton& Singleton::getInstance() {
    if (!p_instance) {
        p_instance = new Singleton();
        destroyer.initialize(p_instance);
    }
    return *p_instance;
}
```

Ключевой особенностью этой реализации является наличие класса `SingletonDestroyer`, предназначенного для автоматического разрушения объекта `Singleton`. Класс `Singleton` имеет статический член `SingletonDestroyer`, который инициализируется при первом вызове `Singleton::getInstance()` создаваемым объектом `Singleton`. При завершении программы этот объект будет автоматически разрушен деструктором `SingletonDestroyer` (для этого `SingletonDestroyer` объявлен другом класса `Singleton`).

Для предотвращения случайного удаления пользователями объекта класса `Singleton`, деструктор теперь уже не является общедоступным как ранее. Он объявлен защищенным.

<hr>

[Содержание](#содержание)

### Использование нескольких взаимозависимых одиночек

До сих пор предполагалось, что в программе используется один одиночка либо несколько несвязанных между собой. При использовании взаимосвязанных одиночек появляются новые вопросы:
+ Как гарантировать, что к моменту использования одного одиночки, экземпляр другого зависимого уже создан?
+ Как обеспечить возможность безопасного использования одного одиночки другим при завершении программы? <br>
Другими словами, как гарантировать, что в момент разрушения первого одиночки в его деструкторе еще возможно использование второго зависимого одиночки (то есть второй одиночка к этому моменту еще не разрушен)?

Управлять порядком создания одиночек относительно просто. Следующий код демонстрирует один из возможных методов.

```c++
// Singleton.h
class Singleton1 {
   private:
    Singleton1() {}
    Singleton1(const Singleton1&);
    Singleton1& operator=(Singleton1&);

   public:
    static Singleton1& getInstance() {
        static Singleton1 instance;
        return instance;
    }
};

class Singleton2 {
   private:
    Singleton2(Singleton1& instance) : s1(instance) {}
    Singleton2(const Singleton2&);
    Singleton2& operator=(Singleton2&);
    Singleton1& s1;

   public:
    static Singleton2& getInstance() {
        static Singleton2 instance(Singleton1::getInstance());
        return instance;
    }
};

// main.cpp
#include "Singleton.h"

int main() {
    Singleton2& s = Singleton2::getInstance();
    return 0;
}
```

Объект `Singleton1` гарантированно инициализируется раньше объекта `Singleton2`, так как в момент создания объекта `Singleton2` происходит вызов `Singleton1::getInstance()`.

Гораздо сложнее управлять временем жизни одиночек. Существует несколько способов это сделать, каждый из них обладает своими достоинствами и недостатками и заслуживают отдельного рассмотрения. Обсуждение этой непростой темы остается за рамками проекта.

<hr>

[Содержание](#содержание)

## Вопросы

Сопоставьте значения из двух списков

![03](/CPP_from_LETI/LETI_03/img/04_37.PNG)

Представьте, что вы создаёте программу управления грузовыми перевозками. Сперва вы рассчитываете перевозить товары только на автомобилях. Поэтому весь ваш код работает с объектами класса `Грузовик`.

В какой-то момент ваша программа становится настолько известной, что морские перевозчики выстраиваются в очередь и просят добавить поддержку морской логистики в программу.

![03](/CPP_from_LETI/LETI_03/img/04_06.png)

Отличные новости, правда?! Но как насчёт кода? Большая часть существующего кода жёстко привязана к классам `Грузовиков`. Чтобы добавить в программу классы морских `Судов`, понадобится перелопатить всю программу. Более того, если вы потом решите добавить в программу ещё один вид транспорта, то всю эту работу придётся повторить.

В итоге вы получите ужасающий код, наполненный условными операторами, которые выполняют то или иное действие, в зависимости от класса транспорта.

Какой паттерн проектирования вы бы использовали для решения данной проблемы?


+ [x] Фабричный метод
+ [ ] Состояние
+ [ ] Посетитель
+ [ ] Наблюдатель
+ [ ] Снимок

Представьте сложный объект, требующий кропотливой пошаговой инициализации множества полей и вложенных объектов. Код инициализации таких объектов обычно спрятан внутри монструозного конструктора с десятком параметров. Либо ещё хуже — распылён по всему клиентскому коду.

![03](/CPP_from_LETI/LETI_03/img/04_19.png)

Например, давайте подумаем о том, как создать объект `Дом`. Чтобы построить стандартный дом, нужно поставить 4 стены, установить двери, вставить пару окон и положить крышу. Но что, если вы хотите дом побольше да посветлее, имеющий сад, бассейн и прочее добро?

Самое простое решение — расширить класс `Дом`, создав подклассы для всех комбинаций параметров дома. Проблема такого подхода — это громадное количество классов, которые вам придётся создать. Каждый новый параметр, вроде цвета обоев или материала кровли, заставит вас создавать всё больше и больше классов для перечисления всех возможных вариантов.

Чтобы не плодить подклассы, вы можете подойти к решению с другой стороны. Вы можете создать гигантский конструктор `Дома`, принимающий уйму параметров для контроля над создаваемым продуктом. Действительно, это избавит вас от подклассов, но приведёт к другой проблеме.

![03](/CPP_from_LETI/LETI_03/img/04_20.png)

Большая часть этих параметров будет простаивать, а вызовы конструктора будут выглядеть монструозно из-за длинного списка параметров. К примеру, далеко не каждый дом имеет бассейн, поэтому параметры, связанные с бассейнами, будут простаивать бесполезно в 99% случаев.

Какой паттерн проектирования вы бы использовали для решения данной проблемы?


+ [ ] Наблюдатель
+ [ ] Мост
+ [x] Строитель
+ [ ] Легковес
+ [ ] Посетитель

<hr>

[Содержание](#содержание)

# 4.3 Структурные паттерны проектирования

## Виды структурных паттернов проектирования

![03](/CPP_from_LETI/LETI_03/img/04_38.jpg)

__Структурные паттерны проектирования__

Структурные паттерны рассматривают вопросы о компоновке системы на основе классов и объектов. При этом могут использоваться следующие механизмы:
+ Наследование, когда базовый класс определяет интерфейс, а подклассы - реализацию. Структуры на основе наследования получаются статичными.
+ Композиция, когда структуры строятся путем объединения объектов некоторых классов. Композиция позволяет получать структуры, которые можно изменять во время выполнения.

<hr>

[Содержание](#содержание)

## Адаптер

`Адаптер` — это структурный паттерн проектирования, который позволяет объектам с несовместимыми интерфейсами работать вместе.

![03](/CPP_from_LETI/LETI_03/img/04_39.png)

__Проблема__

Представьте, что вы делаете приложение для торговли на бирже. Ваше приложение скачивает биржевые котировки из нескольких источников в `XML`, а затем рисует красивые графики.

В какой-то момент вы решаете улучшить приложение, применив стороннюю библиотеку аналитики. Но вот беда — библиотека поддерживает только формат данных `JSON`, несовместимый с вашим приложением.

![03](/CPP_from_LETI/LETI_03/img/04_40.png)

Вы смогли бы переписать библиотеку, чтобы та поддерживала формат `XML`. Но, во-первых, это может нарушить работу существующего кода, который уже зависит от библиотеки. А во-вторых, у вас может просто не быть доступа к её исходному коду.

__Решение__

Вы можете создать адаптер. Это объект-переводчик, который трансформирует интерфейс или данные одного объекта в такой вид, чтобы он стал понятен другому объекту.

При этом адаптер оборачивает один из объектов, так что другой объект даже не знает о наличии первого. Например, вы можете обернуть объект, работающий в метрах, адаптером, который бы конвертировал данные в футы.

Адаптеры могут не только переводить данные из одного формата в другой, но и помогать объектам с разными интерфейсами работать сообща. Это работает так:
1. Адаптер имеет интерфейс, который совместим с одним из объектов.
2. Поэтому этот объект может свободно вызывать методы адаптера.
3. Адаптер получает эти вызовы и перенаправляет их второму объекту, но уже в том формате и последовательности, которые понятны второму объекту.

Иногда возможно создать даже двухсторонний адаптер, который работал бы в обе стороны.

![03](/CPP_from_LETI/LETI_03/img/04_41.png)

Таким образом, в приложении биржевых котировок вы могли бы создать класс `XML_To_JSON_Adapter`, который бы оборачивал объект того или иного класса библиотеки аналитики. Ваш код посылал бы адаптеру запросы в формате `XML`, а адаптер сначала транслировал входящие данные в формат `JSON`, а затем передавал бы их методам обёрнутого объекта аналитики.

__Аналогия из жизни__

![03](/CPP_from_LETI/LETI_03/img/04_42.png)

Когда вы в первый раз летите за границу, вас может ждать сюрприз при попытке зарядить ноутбук. Стандарты розеток в разных странах отличаются. Ваша европейская зарядка будет бесполезна в США без специального адаптера, позволяющего подключиться к розетке другого типа.

__Структура__

__Адаптер объектов__

Эта реализация использует агрегацию: объект адаптера «оборачивает», то есть содержит ссылку на служебный объект. Такой подход работает во всех языках программирования.

![03](/CPP_from_LETI/LETI_03/img/04_43.jpg)

__Адаптер классов__

Эта реализация базируется на наследовании: адаптер наследует оба интерфейса одновременно. Такой подход возможен только в языках, поддерживающих множественное наследование, например, C++.

![03](/CPP_from_LETI/LETI_03/img/04_44.jpg)

__Применимость__

+ Когда вы хотите использовать сторонний класс, но его интерфейс не соответствует остальному коду приложения.<br>
Адаптер позволяет создать объект-прокладку, который будет превращать вызовы приложения в формат, понятный стороннему классу.
+ Когда вам нужно использовать несколько существующих подклассов, но в них не хватает какой-то общей функциональности, причём расширить суперкласс вы не можете.<br>
Вы могли бы создать ещё один уровень подклассов и добавить в них недостающую функциональность. Но при этом придётся дублировать один и тот же код в обеих ветках подклассов.<br>
Более элегантным решением было бы поместить недостающую функциональность в адаптер и приспособить его для работы с суперклассом. Такой адаптер сможет работать со всеми подклассами иерархии. Это решение будет сильно напоминать паттерн Декоратор.

__Шаги реализации__

1. Убедитесь, что у вас есть два класса с несовместимыми интерфейсами:
    + полезный сервис — служебный класс, который вы не можете изменять (он либо сторонний, либо от него зависит другой код);
    + один или несколько клиентов — существующих классов приложения, несовместимых с сервисом из-за неудобного или несовпадающего интерфейса.
2. Опишите клиентский интерфейс, через который классы приложения смогли бы использовать класс сервиса.
3. Создайте класс адаптера, реализовав этот интерфейс.
4. Поместите в адаптер поле, которое будет хранить ссылку на объект сервиса. Обычно это поле заполняют объектом, переданным в конструктор адаптера. В случае простой адаптации этот объект можно передавать через параметры методов адаптера.
5. Реализуйте все методы клиентского интерфейса в адаптере. Адаптер должен делегировать основную работу сервису.
6. Приложение должно использовать адаптер только через клиентский интерфейс. Это позволит легко изменять и добавлять адаптеры в будущем.

__Преимущества и недостатки__

![03](/CPP_from_LETI/LETI_03/img/04_45.jpg)

__Отношения с другими паттернами__
+ `Мост` проектируют загодя, чтобы развивать большие части приложения отдельно друг от друга. `Адаптер` применяется постфактум, чтобы заставить несовместимые классы работать вместе.
+ `Адаптер` меняет интерфейс существующего объекта. `Декоратор` улучшает другой объект без изменения его интерфейса. Причём `Декоратор` поддерживает рекурсивную вложенность, чего не скажешь об `Адаптере`.
+ `Адаптер` предоставляет классу альтернативный интерфейс. `Декоратор` предоставляет расширенный интерфейс. `Заместитель` предоставляет тот же интерфейс.
+ `Фасад` задаёт новый интерфейс, тогда как `Адаптер` повторно использует старый. `Адаптер` оборачивает только один класс, а `Фасад` оборачивает целую подсистему. Кроме того, `Адаптер` позволяет двум существующим интерфейсам работать сообща, вместо того, чтобы задать полностью новый.
+ `Мост`, `Стратегия` и `Состояние` (а также слегка и `Адаптер`) имеют схожие структуры классов — все они построены на принципе «композиции», то есть делегирования работы другим объектам. Тем не менее, они отличаются тем, что решают разные проблемы. Помните, что паттерны — это не только рецепт построения кода определённым образом, но и описание проблем, которые привели к данному решению.

<hr>

[Содержание](#содержание)

## Пример использования паттерна `Адаптер`

Для примера адаптируем показания температурного датчика системы климат-контроля, переведя их из градусов Фаренгейта в градусы Цельсия (предполагается, что код этого датчика недоступен для модификации).

```c++
#include <iostream>

using namespace std;

// Уже существующий класс температурного датчика окружающей среды
class FahrenheitSensor {
   public:
    // Получить показания температуры в градусах Фаренгейта
    float getFahrenheitTemp() {
        float t = 32.0;
        // ... какой то код
        return t;
    }
};

class Sensor {
   public:
    virtual ~Sensor() {}
    virtual float getTemperature() = 0;
};

class Adapter : public Sensor {
   public:
    Adapter(FahrenheitSensor* p) : p_fsensor(p) {}
    ~Adapter() { delete p_fsensor; }
    float getTemperature() { return (p_fsensor->getFahrenheitTemp() - 32.0) * 5.0 / 9.0; }

   private:
    FahrenheitSensor* p_fsensor;
};

int main() {
    Sensor* p = new Adapter(new FahrenheitSensor);
    cout << "Celsius temperature = " << p->getTemperature() << endl;
    delete p;
    return 0;
}
```

__Реализация паттерна Adapter на основе закрытого наследования__

Пусть наш температурный датчик системы климат-контроля поддерживает функцию юстировки для получения более точных показаний. Эта функция не является обязательной для использования, возможно, поэтому соответствующий метод `adjust()` объявлен разработчиками защищенным в существующем классе `FahrenheitSensor`.

Разрабатываемая нами система должна поддерживать настройку измерений. Так как доступ к защищенному методу через указатель или ссылку запрещен, то классическая реализация паттерна `Adapter` здесь уже не подходит. Единственное решение - наследовать от класса `FahrenheitSensor`. Интерфейс этого класса должен оставаться недоступным пользователю, поэтому наследование должно быть закрытым.

Цели, преследуемые при использовании открытого и закрытого наследования различны. Если открытое наследование применяется для наследования интерфейса и реализации, то закрытое наследование - только для наследования реализации.

```c++
#include <iostream>

using namespace std;

class FahrenheitSensor {
   public:
    float getFahrenheitTemp() {
        float t = 32.0;
        // ...
        return t;
    }

   protected:
    void adjust() {}  // Настройка датчика (защищенный метод)
};

class Sensor {
   public:
    virtual ~Sensor() {}
    virtual float getTemperature() = 0;
    virtual void adjust() = 0;
};

class Adapter : public Sensor, private FahrenheitSensor {
   public:
    Adapter() {}
    float getTemperature() { return (getFahrenheitTemp() - 32.0) * 5.0 / 9.0; }
    void adjust() { FahrenheitSensor::adjust(); }
};

int main() {
    Sensor* p = new Adapter();
    p->adjust();
    cout << "Celsius temperature = " << p->getTemperature() << endl;
    delete p;
    return 0;
}
```

<hr>

[Содержание](#содержание)

## Мост

Мост — это структурный паттерн проектирования, который разделяет один или несколько классов на две отдельные иерархии — абстракцию и реализацию, позволяя изменять их независимо друг от друга.

![04](/CPP_from_LETI/LETI_03/img/04_46.png)

__Проблема__

_Абстракция? Реализация?!_ Звучит пугающе! Чтобы понять, о чём идёт речь, давайте разберём очень простой пример.

У вас есть класс геометрических `Фигур`, который имеет подклассы `Круг` и `Квадрат`. Вы хотите расширить иерархию фигур по цвету, то есть иметь `Красные` и `Синие` фигуры. Но чтобы всё это объединить, вам придётся создать 4 комбинации подклассов, вроде `СиниеКруги` и `КрасныеКвадраты`.

При добавлении новых видов фигур и цветов количество комбинаций будет расти в геометрической прогрессии. Например, чтобы ввести в программу фигуры треугольников, придётся создать сразу два новых подкласса треугольников под каждый цвет. После этого новый цвет потребует создания уже трёх классов для всех видов фигур. Чем дальше, тем хуже.

__Решение__

Корень проблемы заключается в том, что мы пытаемся расширить классы фигур сразу в двух независимых плоскостях — по виду и по цвету. Именно это приводит к разрастанию дерева классов.

Паттерн `Мост` предлагает заменить наследование агрегацией или композицией. Для этого нужно выделить одну из таких «плоскостей» в отдельную иерархию и ссылаться на объект этой иерархии, вместо хранения его состояния и поведения внутри одного класса.

![04](/CPP_from_LETI/LETI_03/img/04_47.png)

Таким образом, мы можем сделать `Цвет` отдельным классом с подклассами `Красный` и `Синий`. Класс `Фигур` получит ссылку на объект `Цвета` и сможет делегировать ему работу, если потребуется. Такая связь и станет мостом между `Фигурами` и `Цветом`. При добавлении новых классов цветов не потребуется трогать классы фигур и наоборот.

__Абстракция и Реализация__

Эти термины были введены в книге `GoF`  при описании `Моста`. На мой взгляд, они выглядят слишком академичными, делая описание паттерна сложнее, чем он есть на самом деле. Помня о примере с фигурами и цветами, давайте все же разберёмся, что имели в виду авторы паттерна.

Итак, __*абстракция*__ (или _интерфейс_) — это образный слой управления чем-либо. Он не делает работу самостоятельно, а делегирует её слою __*реализации*__ (иногда называемому _платформой_).

Если говорить о реальных программах, то абстракцией может выступать графический интерфейс программы (`GUI`), а реализацией — низкоуровневый код операционной системы (`API`), к которому графический интерфейс обращается по реакции на действия пользователя.

Вы можете развивать программу в двух разных направлениях:
+ иметь несколько видов GUI (например, для простых пользователей и администраторов);
+ поддерживать много видов API (например, работать под Windows, Linux и macOS).

Такая программа может выглядеть как один большой клубок кода, в котором намешаны условные операторы слоёв GUI и API.

![04](/CPP_from_LETI/LETI_03/img/04_48.png)

Вы можете попытаться структурировать этот хаос, создав для каждой вариации интерфейса-платформы свои подклассы. Но такой подход приведёт к росту классов комбинаций, и с каждой новой платформой их будет всё больше.

Мы можем решить эту проблему, применив `Мост`. Паттерн предлагает распутать этот код, разделив его на две части:
+ __Абстракцию__: слой графического интерфейса приложения.
+ __Реализацию__: слой взаимодействия с операционной системой.

![04](/CPP_from_LETI/LETI_03/img/04_49.png)

Абстракция будет делегировать работу одному из объектов реализаций. Причём, реализации можно будет взаимозаменять, но только при условии, что все они будут следовать общему интерфейсу.

Таким образом, вы сможете изменять графический интерфейс приложения, не трогая низкоуровневый код работы с операционной системой. И наоборот, вы сможете добавлять поддержку новых операционных систем, создавая подклассы реализации, без необходимости менять классы графического интерфейса.

__Структура__

![04](/CPP_from_LETI/LETI_03/img/04_50.jpg)

__Применимость__

+ Когда вы хотите разделить монолитный класс, который содержит несколько различных реализаций какой-то функциональности (например, если класс может работать с разными системами баз данных).<br>
Чем больше класс, тем тяжелее разобраться в его коде, и тем больше это затягивает разработку. Кроме того, изменения, вносимые в одну из реализаций, приводят к редактированию всего класса, что может привести к внесению случайных ошибок в код.<br>
`Мост` позволяет разделить монолитный класс на несколько отдельных иерархий. После этого вы можете менять их код независимо друг от друга. Это упрощает работу над кодом и уменьшает вероятность внесения ошибок.
+ Когда класс нужно расширять в двух независимых плоскостях.<br>
`Мост` предлагает выделить одну из таких плоскостей в отдельную иерархию классов, храня ссылку на один из её объектов в первоначальном классе.
+ Когда вы хотите, чтобы реализацию можно было бы изменять во время выполнения программы.
`Мост` позволяет заменять реализацию даже во время выполнения программы, так как конкретная реализация не «вшита» в класс абстракции.<br>
Кстати, из-за этого пункта `Мост` часто путают со `Стратегией`. Обратите внимание, что у `Моста` этот пункт стоит на последнем месте по значимости, поскольку его главная задача — структурная.

__Шаги реализации__
1. Определите, существует ли в ваших классах два непересекающихся измерения. Это может быть функциональность/платформа, предметная-область/инфраструктура, фронт-энд/бэк-энд или интерфейс/реализация.
2. Продумайте, какие операции будут нужны клиентам, и опишите их в базовом классе абстракции.
3. Определите поведения, доступные на всех платформах, и выделите из них ту часть, которая нужна абстракции. На основании этого опишите общий интерфейс реализации.
4. Для каждой платформы создайте свой класс конкретной реализации. Все они должны следовать общему интерфейсу, который мы выделили перед этим.
5. Добавьте в класс абстракции ссылку на объект реализации. Реализуйте методы абстракции, делегируя основную работу связанному объекту реализации.
6. Если у вас есть несколько вариаций абстракции, создайте для каждой из них свой подкласс.
7. Клиент должен подать объект реализации в конструктор абстракции, чтобы связать их воедино. После этого он может свободно использовать объект абстракции, забыв о реализации.

__Преимущества и недостатки__

![04](/CPP_from_LETI/LETI_03/img/04_51.jpg)

__Отношения с другими паттернами__

+ `Мост` проектируют загодя, чтобы развивать большие части приложения отдельно друг от друга. `Адаптер` применяется постфактум, чтобы заставить несовместимые классы работать вместе.
+ `Мост`, `Стратегия` и `Состояние` (а также слегка и `Адаптер`) имеют схожие структуры классов — все они построены на принципе «композиции», то есть делегирования работы другим объектам. Тем не менее, они отличаются тем, что решают разные проблемы. Помните, что паттерны — это не только рецепт построения кода определённым образом, но и описание проблем, которые привели к данному решению.
+ `Абстрактная фабрика` может работать совместно с `Мостом`. Это особенно полезно, если у вас есть абстракции, которые могут работать только с некоторыми из реализаций. В этом случае фабрика будет определять типы создаваемых абстракций и реализаций.
+ Паттерн `Строитель` может быть построен в виде `Моста`: директор будет играть роль абстракции, а строители — реализации.

<hr>

[Содержание](#содержание)

## Пример использования паттерна `Мост`

```c++
#include <iostream>

using namespace std;

class Implementation {
   public:
    virtual ~Implementation() {}
    virtual std::string OperationImplementation() const = 0;
};

/**
 * Каждая Конкретная Реализация соответствует определённой платформе и реализует
 * интерфейс Реализации с использованием API этой платформы.
 */
class ConcreteImplementationA : public Implementation {
   public:
    std::string OperationImplementation() const override {
        return "ConcreteImplementationA: Here's the result on the platform A.\n";
    }
};
class ConcreteImplementationB : public Implementation {
   public:
    std::string OperationImplementation() const override {
        return "ConcreteImplementationB: Here's the result on the platform B.\n";
    }
};

/**
 * Абстракция устанавливает интерфейс для «управляющей» части двух иерархий
 * классов. Она содержит ссылку на объект из иерархии Реализации и делегирует
 * ему всю настоящую работу.
 */

class Abstraction {
    /**
     * @var Implementation
     */
   protected:
    Implementation* implementation_;

   public:
    Abstraction(Implementation* implementation) : implementation_(implementation) {}

    virtual ~Abstraction() {}

    virtual std::string Operation() const {
        return "Abstraction: Base operation with:\n" + this->implementation_->OperationImplementation();
    }
};
/**
 * Можно расширить Абстракцию без изменения классов Реализации.
 */
class ExtendedAbstraction : public Abstraction {
   public:
    ExtendedAbstraction(Implementation* implementation) : Abstraction(implementation) {}
    std::string Operation() const override {
        return "ExtendedAbstraction: Extended operation with:\n" +
               this->implementation_->OperationImplementation();
    }
};

/**
 * За исключением этапа инициализации, когда объект Абстракции связывается с
 * определённым объектом Реализации, клиентский код должен зависеть только от
 * класса Абстракции. Таким образом, клиентский код может поддерживать любую
 * комбинацию абстракции и реализации.
 */
void ClientCode(const Abstraction& abstraction) {
    // ...
    std::cout << abstraction.Operation();
    // ...
}
/**
 * Клиентский код должен работать с любой предварительно сконфигурированной
 * комбинацией абстракции и реализации.
 */

int main() {
    Implementation* implementation = new ConcreteImplementationA;
    Abstraction* abstraction = new Abstraction(implementation);
    ClientCode(*abstraction);
    std::cout << std::endl;
    delete implementation;
    delete abstraction;

    implementation = new ConcreteImplementationB;
    abstraction = new ExtendedAbstraction(implementation);
    ClientCode(*abstraction);

    delete implementation;
    delete abstraction;

    return 0;
}
```

Результат выполнения

```
Abstraction: Base operation with:
ConcreteImplementationA: Here's the result on the platform A.

ExtendedAbstraction: Extended operation with:
ConcreteImplementationB: Here's the result on the platform B.
```

<hr>

[Содержание](#содержание)

## Компоновщик

`Компоновщик` — это структурный паттерн проектирования, который позволяет сгруппировать множество объектов в древовидную структуру, а затем работать с ней так, как будто это единичный объект.

![04](/CPP_from_LETI/LETI_03/img/04_52.png)

__Проблема__

Паттерн `Компоновщик` имеет смысл только тогда, когда основная модель вашей программы может быть структурирована в виде дерева.

Например, есть два объекта: `Продукт` и `Коробка`. `Коробка` может содержать несколько `Продуктов` и других `Коробок` поменьше. Те, в свою очередь, тоже содержат либо `Продукты`, либо `Коробки` и так далее.

Теперь предположим, ваши `Продукты` и `Коробки` могут быть частью заказов. Каждый заказ может содержать как простые `Продукты` без упаковки, так и составные `Коробки`. Ваша задача состоит в том, чтобы узнать цену всего заказа.

![04](/CPP_from_LETI/LETI_03/img/04_53.png)

Если решать задачу в лоб, то вам потребуется открыть все коробки заказа, перебрать все продукты и посчитать их суммарную стоимость. Но это слишком хлопотно, так как типы коробок и их содержимое могут быть вам неизвестны. Кроме того, наперёд неизвестно и количество уровней вложенности коробок, поэтому перебрать коробки простым циклом не выйдет.

__Решение__

`Компоновщик` предлагает рассматривать `Продукт` и `Коробку` через единый интерфейс с общим методом получения стоимости.

`Продукт` просто вернёт свою цену. `Коробка` спросит цену каждого предмета внутри себя и вернёт сумму результатов. Если одним из внутренних предметов окажется коробка поменьше, она тоже будет перебирать своё содержимое, и так далее, пока не будут посчитаны все составные части.

![04](/CPP_from_LETI/LETI_03/img/04_54.png)

Для вас, клиента, главное, что теперь не нужно ничего знать о структуре заказов. Вы вызываете метод получения цены, он возвращает цифру, а вы не тонете в горах картона и скотча.

__Аналогия из жизни__

![04](/CPP_from_LETI/LETI_03/img/04_55.png)

Армии большинства государств могут быть представлены в виде перевёрнутых деревьев. На нижнем уровне у вас есть солдаты, затем взводы, затем полки, а затем целые армии. Приказы отдаются сверху и спускаются вниз по структуре командования, пока не доходят до конкретного солдата.

__Структура__

![04](/CPP_from_LETI/LETI_03/img/04_56.jpg)

__Применимость__

+ Когда вам нужно представить древовидную структуру объектов.<br>
Паттерн `Компоновщик` предлагает хранить в составных объектах ссылки на другие простые или составные объекты. Те, в свою очередь, тоже могут хранить свои вложенные объекты и так далее. В итоге вы можете строить сложную древовидную структуру данных, используя всего две основные разновидности объектов.
+ Когда клиенты должны единообразно трактовать простые и составные объекты.<br>
Благодаря тому, что простые и составные объекты реализуют общий интерфейс, клиенту безразлично, с каким именно объектом ему предстоит работать.

__Шаги реализации__

1. Убедитесь, что вашу бизнес-логику можно представить как древовидную структуру. Попытайтесь разбить её на простые компоненты и контейнеры. Помните, что контейнеры могут содержать как простые компоненты, так и другие вложенные контейнеры.
2. Создайте общий интерфейс компонентов, который объединит операции контейнеров и простых компонентов дерева. Интерфейс будет удачным, если вы сможете использовать его, чтобы взаимно заменять простые и составные компоненты без потери смысла.
3. Создайте класс компонентов-листьев, не имеющих дальнейших ответвлений. Имейте в виду, что программа может содержать несколько таких классов.
4. Создайте класс компонентов-контейнеров и добавьте в него массив для хранения ссылок на вложенные компоненты. Этот массив должен быть способен содержать как простые, так и составные компоненты, поэтому убедитесь, что он объявлен с типом интерфейса компонентов.
5. Реализуйте в контейнере методы интерфейса компонентов, помня о том, что контейнеры должны делегировать основную работу своим дочерним компонентам.
6. Добавьте операции добавления и удаления дочерних компонентов в класс контейнеров.
7. Имейте в виду, что методы добавления/удаления дочерних компонентов можно поместить и в интерфейс компонентов. Да, это нарушит принцип разделения интерфейса, так как реализации методов будут пустыми в компонентах-листьях. Но зато все компоненты дерева станут действительно одинаковыми для клиента.

__Преимущества и недостатки__

![04](/CPP_from_LETI/LETI_03/img/04_57.jpg)

__Отношения с другими паттернами__

+ `Строитель` позволяет пошагово сооружать дерево `Компоновщика`.
+ `Цепочку обязанностей` часто используют вместе с `Компоновщиком`. В этом случае запрос передаётся от дочерних компонентов к их родителям.
+ Вы можете обходить дерево `Компоновщика`, используя `Итератор`.
+ Вы можете выполнить какое-то действие над всем деревом `Компоновщика` при помощи `Посетителя`.
+ `Компоновщик` часто совмещают с `Легковесом`, чтобы реализовать общие ветки дерева и сэкономить при этом память.
+ `Компоновщик` и `Декоратор` имеют похожие структуры классов из-за того, что оба построены на рекурсивной вложенности. Она позволяет связать в одну структуру бесконечное количество объектов.
+ `Декоратор` оборачивает только один объект, а узел `Компоновщика` может иметь много детей. `Декоратор` добавляет вложенному объекту новую функциональность, а `Компоновщик` не добавляет ничего нового, но «суммирует» результаты всех своих детей.
+ Но они могут и сотрудничать: `Компоновщик` может использовать `Декоратор`, чтобы переопределить функции отдельных частей дерева компонентов.
+ `Архитектура`, построенная на `Компоновщиках` и `Декораторах`, часто может быть улучшена за счёт внедрения `Прототипа`. Он позволяет клонировать сложные структуры объектов, а не собирать их заново.

<hr>

[Содержание](#содержание)

## Пример использования паттерна Компоновщик (Composite)

Применим паттерн `Composite` для стратегической игры. Сначала сформируем различные военные соединения римской армии, а затем рассчитаем разрушающую силу.

```c++
#include <assert.h>

#include <iostream>
#include <vector>

using namespace std;

// Component
class Unit {
   public:
    virtual int getStrength() = 0;
    virtual void addUnit(Unit* p) { assert(false); }
    virtual ~Unit() {}
};

// Primitives
class Archer : public Unit {
   public:
    virtual int getStrength() { return 1; }
};

class Infantryman : public Unit {
   public:
    virtual int getStrength() { return 2; }
};

class Horseman : public Unit {
   public:
    virtual int getStrength() { return 3; }
};

// Composite
class CompositeUnit : public Unit {
   public:
    int getStrength() {
        int total = 0;
        for (int i = 0; i < c.size(); ++i) total += c[i]->getStrength();
        return total;
    }
    void addUnit(Unit* p) { c.push_back(p); }
    ~CompositeUnit() {
        for (int i = 0; i < c.size(); ++i) delete c[i];
    }

   private:
    std::vector<Unit*> c;
};

// Вспомогательная функция для создания легиона
CompositeUnit* createLegion() {
    // Римский легион содержит:
    CompositeUnit* legion = new CompositeUnit;
    // 3000 тяжелых пехотинцев
    for (int i = 0; i < 3000; ++i) legion->addUnit(new Infantryman);
    // 1200 легких пехотинцев
    for (int i = 0; i < 1200; ++i) legion->addUnit(new Archer);
    // 300 всадников
    for (int i = 0; i < 300; ++i) legion->addUnit(new Horseman);

    return legion;
}

int main() {
    // Римская армия состоит из 4-х легионов
    CompositeUnit* army = new CompositeUnit;
    for (int i = 0; i < 4; ++i) army->addUnit(createLegion());

    cout << "Roman army damaging strength is " << army->getStrength() << endl;
    // …
    delete army;
    return 0;
}
Следует обратить внимание на один важный момент. Абстрактный базовый класс Unit объявляет интерфейс для добавления новых боевых единиц addUnit(), несмотря на то, что объектам примитивных типов (Archer, Infantryman, Horseman) подобная операция не нужна. Сделано это в угоду прозрачности системы в ущерб ее безопасности. Клиент знает, что объект типа Unit всегда будет иметь метод addUnit(). Однако его вызов для примитивных объектов считается ошибочным и небезопасным.

Можно сделать систему более безопасной, переместив метод addUnit() в составной объект CompositeUnit. Однако при этом возникает следующая проблема: мы не знаем, содержит ли объект Unit метод addUnit().

Рассмотрим следующий фрагмент кода.

class Unit
{
  public:
    virtual CompositeUnit* getComposite() {
      return 0;
    }
    // …
};
 
// Composite
class CompositeUnit: public Unit
{
  public:
   void addUnit(Unit* p);
    CompositeUnit* getComposite() {
      return this;
    }
    // …
};
```

В абстрактном базовом классе `Unit` появился новый виртуальный метод `getComposite()` с реализацией по умолчанию, которая возвращает `0`. Класс `CompositeUnit` переопределяет этот метод, возвращая указатель на самого себя. Благодаря этому методу можно запросить у компонента его тип. Если он составной, то можно применить операцию `addUnit()`.

```c++
if (unit->getComposite()) {
   unit->getComposite()->addUnit( new Archer);
}
```

<hr>

[Содержание](#содержание)

## Декоратор

`Декоратор` — это структурный паттерн проектирования, который позволяет динамически добавлять объектам новую функциональность, оборачивая их в полезные «обёртки».

__Проблема__

Вы работаете над библиотекой оповещений, которую можно подключать к разнообразным программам, чтобы получать уведомления о важных событиях.

Основой библиотеки является класс `Notifier` с методом `send`, который принимает на вход строку-сообщение и высылает её всем администраторам по электронной почте. Сторонняя программа должна создать и настроить этот объект, указав кому отправлять оповещения, а затем использовать его каждый раз, когда что-то случается.

![04](/CPP_from_LETI/LETI_03/img/04_58.png)


В какой-то момент стало понятно, что одних `email`-оповещений пользователям мало. Некоторые из них хотели бы получать извещения о критических проблемах через `SMS`. Другие хотели бы получать их в виде сообщений Facebook. Корпоративные пользователи хотели бы видеть сообщения в `Slack`.

![04](/CPP_from_LETI/LETI_03/img/04_59.png)

Сначала вы добавили каждый из этих типов оповещений в программу, унаследовав их от базового класса `Notifier`. Теперь пользователь выбирал один из типов оповещений, который и использовался в дальнейшем.

Но затем кто-то резонно спросил, почему нельзя выбрать несколько типов оповещений сразу? Ведь если вдруг в вашем доме начался пожар, вы бы хотели получить оповещения по всем каналам, не так ли?

Вы попытались реализовать все возможные комбинации подклассов оповещений. Но после того как вы добавили первый десяток классов, стало ясно, что такой подход невероятно раздувает код программы.

![04](/CPP_from_LETI/LETI_03/img/04_60.png)

Итак, нужен какой-то другой способ комбинирования поведения объектов, который не приводит к взрыву количества подклассов.

__Решение__

Наследование — это первое, что приходит в голову многим программистам, когда нужно расширить какое-то существующее поведение. Но механизм наследования имеет несколько досадных проблем.
+ Он __статичен__. Вы не можете изменить поведение существующего объекта. Для этого вам надо создать новый объект, выбрав другой подкласс.
+ Он __не разрешает наследовать поведение нескольких классов одновременно__. Из-за этого вам приходится создавать множество подклассов-комбинаций для получения совмещённого поведения.

Одним из способов обойти эти проблемы является замена наследования агрегацией либо композицией . Это когда один объект содержит ссылку на другой и делегирует ему работу, вместо того чтобы самому наследовать его поведение. Как раз на этом принципе построен паттерн `Декоратор`.

![04](/CPP_from_LETI/LETI_03/img/04_61.png)

Декоратор имеет альтернативное название — _обёртка_. 

Оно более точно описывает суть паттерна: вы помещаете целевой объект в другой объект-обёртку, который запускает базовое поведение объекта, а затем добавляет к результату что-то своё.

Оба объекта имеют общий интерфейс, поэтому для пользователя нет никакой разницы, с каким объектом работать — чистым или обёрнутым. Вы можете использовать несколько разных обёрток одновременно — результат будет иметь объединённое поведение всех обёрток сразу.

В примере с оповещениями мы оставим в базовом классе простую отправку по электронной почте, а расширенные способы отправки сделаем декораторами.

![04](/CPP_from_LETI/LETI_03/img/04_62.png)

Сторонняя программа, выступающая клиентом, во время первичной настройки будет заворачивать объект оповещений в те обёртки, которые соответствуют желаемому способу оповещения.

![04](/CPP_from_LETI/LETI_03/img/04_63.png)

Последняя обёртка в списке и будет тем объектом, с которым клиент будет работать в остальное время. Для остального клиентского кода, по сути, ничего не изменится, ведь все обёртки имеют точно такой же интерфейс, что и базовый класс оповещений.

Таким же образом можно изменять не только способ доставки оповещений, но и форматирование, список адресатов и так далее. К тому же клиент может «дообернуть» объект любыми другими обёртками, когда ему захочется.

__Аналогия из жизни__

![04](/CPP_from_LETI/LETI_03/img/04_64.png)

Любая одежда — это аналог `Декоратора`. Применяя `Декоратор`, вы не меняете первоначальный класс и не создаёте дочерних классов. Так и с одеждой — надевая свитер, вы не перестаёте быть собой, но получаете новое свойство — защиту от холода. Вы можете пойти дальше и надеть сверху ещё один декоратор — плащ, чтобы защититься и от дождя.

__Структура__

![04](/CPP_from_LETI/LETI_03/img/04_65.jpg)

__Применимость__

+ Когда вам нужно добавлять обязанности объектам на лету, незаметно для кода, который их использует.<br>
Объекты помещают в обёртки, имеющие дополнительные поведения. Обёртки и сами объекты имеют одинаковый интерфейс, поэтому клиентам без разницы, с чем работать — с обычным объектом данных или с обёрнутым.
+ Когда нельзя расширить обязанности объекта с помощью наследования.<br>
Во многих языках программирования есть ключевое слово `final`, которое может заблокировать наследование класса. Расширить такие классы можно только с помощью `Декоратора`.

__Шаги реализации__

1. Убедитесь, что в вашей задаче есть один основной компонент и несколько опциональных дополнений или надстроек над ним.
2. Создайте интерфейс компонента, который описывал бы общие методы как для основного компонента, так и для его дополнений.
3. Создайте класс конкретного компонента и поместите в него основную бизнес-логику.
4. Создайте базовый класс декораторов. Он должен иметь поле для хранения ссылки на вложенный объект-компонент. Все методы базового декоратора должны делегировать действие вложенному объекту.
5. И конкретный компонент, и базовый декоратор должны следовать одному и тому же интерфейсу компонента.
6. Теперь создайте классы конкретных декораторов, наследуя их от базового декоратора. Конкретный декоратор должен выполнять свою добавочную функцию, а затем (или перед этим) вызывать эту же операцию обёрнутого объекта.
7. Клиент берёт на себя ответственность за конфигурацию и порядок обёртывания объектов.

__Преимущества и недостатки__

![04](/CPP_from_LETI/LETI_03/img/04_66.jpg)

__Отношения с другими паттернами__

+ `Адаптер` меняет интерфейс существующего объекта. `Декоратор` улучшает другой объект без изменения его интерфейса. Причём `Декоратор` поддерживает рекурсивную вложенность, чего не скажешь об `Адаптере`.
+ `Адаптер` предоставляет классу альтернативный интерфейс. `Декоратор` предоставляет расширенный интерфейс. `Заместитель` предоставляет тот же интерфейс.
+ `Цепочка обязанностей` и `Декоратор` имеют очень похожие структуры. Оба паттерна базируются на принципе рекурсивного выполнения операции через серию связанных объектов. Но есть и несколько важных отличий.
+ Обработчики в `Цепочке обязанностей` могут выполнять произвольные действия, независимые друг от друга, а также в любой момент прерывать дальнейшую передачу по цепочке. С другой стороны `Декораторы` расширяют какое-то определённое действие, не ломая интерфейс базовой операции и не прерывая выполнение остальных декораторов.
+ `Компоновщик` и `Декоратор` имеют похожие структуры классов из-за того, что оба построены на рекурсивной вложенности. Она позволяет связать в одну структуру бесконечное количество объектов.
+ `Декоратор` оборачивает только один объект, а узел `Компоновщика` может иметь много детей. `Декоратор` добавляет вложенному объекту новую функциональность, а `Компоновщик` не добавляет ничего нового, но «суммирует» результаты всех своих детей.
+ Но они могут и сотрудничать: `Компоновщик` может использовать `Декоратор`, чтобы переопределить функции отдельных частей дерева компонентов.
+ `Архитектура`, построенная на `Компоновщиках` и `Декораторах`, часто может быть улучшена за счёт внедрения `Прототипа`. Он позволяет клонировать сложные структуры объектов, а не собирать их заново.
+ `Стратегия` меняет поведение объекта «изнутри», а `Декоратор` изменяет его «снаружи».
+ `Декоратор` и `Заместитель` имеют схожие структуры, но разные назначения. Они похожи тем, что оба построены на принципе композиции и делегируют работу другим объектам. Паттерны отличаются тем, что `Заместитель` сам управляет жизнью сервисного объекта, а обёртывание `Декораторов` контролируется клиентом.

<hr>

[Содержание](#содержание)

## Пример использования паттерна Компоновщик (Component)

```c++
#include <iostream>
#include <string>
#include <vector>


using namespace std;
/**
 * Базовый интерфейс Компонента определяет поведение, которое изменяется
 * декораторами.
 */
class Component {
   public:
    virtual ~Component() {}
    virtual std::string Operation() const = 0;
};
/**
 * Конкретные Компоненты предоставляют реализации поведения по умолчанию. Может
 * быть несколько вариаций этих классов.
 */
class ConcreteComponent : public Component {
   public:
    std::string Operation() const override { return "ConcreteComponent"; }
};
/**
 * Базовый класс Декоратора следует тому же интерфейсу, что и другие компоненты.
 * Основная цель этого класса - определить интерфейс обёртки для всех конкретных
 * декораторов. Реализация кода обёртки по умолчанию может включать в себя поле
 * для хранения завёрнутого компонента и средства его инициализации.
 */
class Decorator : public Component {
    /**
     * @var Component
     */
   protected:
    Component* component_;

   public:
    Decorator(Component* component) : component_(component) {}
    /**
     * Декоратор делегирует всю работу обёрнутому компоненту.
     */
    std::string Operation() const override { return this->component_->Operation(); }
};
/**
 * Конкретные Декораторы вызывают обёрнутый объект и изменяют его результат
 * некоторым образом.
 */
class ConcreteDecoratorA : public Decorator {
    /**
     * Декораторы могут вызывать родительскую реализацию операции, вместо того,
     * чтобы вызвать обёрнутый объект напрямую. Такой подход упрощает расширение
     * классов декораторов.
     */
   public:
    ConcreteDecoratorA(Component* component) : Decorator(component) {}
    std::string Operation() const override { return "ConcreteDecoratorA(" + Decorator::Operation() + ")"; }
};
/**
 * Декораторы могут выполнять своё поведение до или после вызова обёрнутого
 * объекта.
 */
class ConcreteDecoratorB : public Decorator {
   public:
    ConcreteDecoratorB(Component* component) : Decorator(component) {}

    std::string Operation() const override { return "ConcreteDecoratorB(" + Decorator::Operation() + ")"; }
};
/**
 * Клиентский код работает со всеми объектами, используя интерфейс Компонента.
 * Таким образом, он остаётся независимым от конкретных классов компонентов, с
 * которыми работает.
 */
void ClientCode(Component* component) {
    // ...
    std::cout << "RESULT: " << component->Operation();
    // ...
}

int main() {
    /**
     * Таким образом, клиентский код может поддерживать как простые компоненты...
     */
    Component* simple = new ConcreteComponent;
    std::cout << "Client: I've got a simple component:\n";
    ClientCode(simple);
    std::cout << "\n\n";
    /**
     * ...так и декорированные.
     *
     * Обратите внимание, что декораторы могут обёртывать не только простые
     * компоненты, но и другие декораторы.
     */
    Component* decorator1 = new ConcreteDecoratorA(simple);
    Component* decorator2 = new ConcreteDecoratorB(decorator1);
    std::cout << "Client: Now I've got a decorated component:\n";
    ClientCode(decorator2);
    std::cout << "\n";

    delete simple;
    delete decorator1;
    delete decorator2;

    return 0;
}
```

Результат выполнения

```
Client: I've got a simple component:
RESULT: ConcreteComponent

Client: Now I've got a decorated component:
RESULT: ConcreteDecoratorB(ConcreteDecoratorA(ConcreteComponent))
```

<hr>

[Содержание](#содержание)

## Фасад

`Фасад` — это структурный паттерн проектирования, который предоставляет простой интерфейс к сложной системе классов, библиотеке или фреймворку.

![04](/CPP_from_LETI/LETI_03/img/04_67.png)

__Проблема__

Вашему коду приходится работать с большим количеством объектов некой сложной библиотеки или фреймворка. Вы должны самостоятельно инициализировать эти объекты, следить за правильным порядком зависимостей и так далее.

В результате бизнес-логика ваших классов тесно переплетается с деталями реализации сторонних классов. Такой код довольно сложно понимать и поддерживать.

__Решение__

`Фасад` — это простой интерфейс для работы со сложной подсистемой, содержащей множество классов. `Фасад` может иметь урезанный интерфейс, не имеющий 100% функциональности, которой можно достичь, используя сложную подсистему напрямую. Но он предоставляет именно те фичи, которые нужны клиенту, и скрывает все остальные.

`Фасад` полезен, если вы используете какую-то сложную библиотеку со множеством подвижных частей, но вам нужна только часть её возможностей.

К примеру, программа, заливающая видео котиков в социальные сети, может использовать профессиональную библиотеку сжатия видео. Но все, что нужно клиентскому коду этой программы — простой метод `encode(filename, format)`. Создав класс с таким методом, вы реализуете свой первый фасад.

__Аналогия из жизни__

![04](/CPP_from_LETI/LETI_03/img/04_68.png)

Когда вы звоните в магазин и делаете заказ по телефону, сотрудник службы поддержки является вашим фасадом ко всем службам и отделам магазина. Он предоставляет вам упрощённый интерфейс к системе создания заказа, платёжной системе и отделу доставки.

__Структура__

![04](/CPP_from_LETI/LETI_03/img/04_69.jpg)

__Применимость__
+ Когда вам нужно представить простой или урезанный интерфейс к сложной подсистеме.<br>
Часто подсистемы усложняются по мере развития программы. Применение большинства паттернов приводит к появлению меньших классов, но в бóльшем количестве. Такую подсистему проще повторно использовать, настраивая её каждый раз под конкретные нужды, но вместе с тем, применять подсистему без настройки становится труднее. Фасад предлагает определённый вид системы по умолчанию, устраивающий большинство клиентов.
+ Когда вы хотите разложить подсистему на отдельные слои.<br>
Используйте фасады для определения точек входа на каждый уровень подсистемы. Если подсистемы зависят друг от друга, то зависимость можно упростить, разрешив подсистемам обмениваться информацией только через фасады.<br>
Например, возьмём ту же сложную систему видеоконвертации. Вы хотите разбить её на слои работы с аудио и видео. Для каждой из этих частей можно попытаться создать фасад и заставить классы аудио и видео обработки общаться друг с другом через эти фасады, а не напрямую.

__Шаги реализации__
1. Определите, можно ли создать более простой интерфейс, чем тот, который предоставляет сложная подсистема. Вы на правильном пути, если этот интерфейс избавит клиента от необходимости знать о подробностях подсистемы.
2. Создайте класс фасада, реализующий этот интерфейс. Он должен переадресовывать вызовы клиента нужным объектам подсистемы. Фасад должен будет позаботиться о том, чтобы правильно инициализировать объекты подсистемы.
3. Вы получите максимум пользы, если клиент будет работать только с фасадом. В этом случае изменения в подсистеме будут затрагивать только код фасада, а клиентский код останется рабочим.
4. Если ответственность фасада начинает размываться, подумайте о введении дополнительных фасадов.

__Преимущества и недостатки__

![04](/CPP_from_LETI/LETI_03/img/04_70.jpg)

__`Божественный объект` — антипаттерн объектно-ориентированного программирования, описывающий объект, который хранит в себе «слишком много» или делает «слишком много».__

__Отношения с другими паттернами__

+ `Фасад` задаёт новый интерфейс, тогда как `Адаптер` повторно использует старый. `Адаптер` оборачивает только один класс, а `Фасад` оборачивает целую подсистему. Кроме того, `Адаптер` позволяет двум существующим интерфейсам работать сообща, вместо того, чтобы задать полностью новый.
+ `Абстрактная фабрика` может быть использована вместо `Фасада` для того, чтобы скрыть платформо-зависимые классы.
+ `Легковес` показывает, как создавать много мелких объектов, а `Фасад` показывает, как создать один объект, который отображает целую подсистему.
+ `Посредник` и `Фасад` похожи тем, что пытаются организовать работу множества существующих классов.
+ `Фасад` создаёт упрощённый интерфейс к подсистеме, не внося в неё никакой добавочной функциональности. Сама подсистема не знает о существовании `Фасада`. Классы подсистемы общаются друг с другом напрямую.
+ `Посредник` централизует общение между компонентами системы. Компоненты системы знают только о существовании `Посредника`, у них нет прямого доступа к другим компонентам.
+ `Фасад` можно сделать `Одиночкой`, так как обычно нужен только один объект-фасад.
+ `Фасад` похож на `Заместитель` тем, что замещает сложную подсистему и может сам её инициализировать. Но в отличие от `Фасада`, `Заместитель` имеет тот же интерфейс, что его служебный объект, благодаря чему их можно взаимно заменять.

<hr>

[Содержание](#содержание)

## Пример использования паттерна Фасад (Facade).

Разбиение системы на компоненты позволяет снизить ее сложность. Ослабить связи между компонентами системы можно с помощью паттерна `Facade`. Объект "фасад" предоставляет единый упрощенный интерфейс к компонентам системы.

В примере ниже моделируется система сетевого обслуживания. Фасад `FacilitiesFacade` скрывает внутреннюю структуру системы. Пользователь, сделав однажды запрос на обслуживание, затем 1-2 раза в неделю в течение 5 месяцев справляется о ходе выполнения работ до тех пор, пока его запрос не будет полностью обслужен.

```c++
#include <iostream>
#include <string>
#include <vector>

using namespace std;

/**
 * Подсистема может принимать запросы либо от фасада, либо от клиента напрямую.
 * В любом случае, для Подсистемы Фасад – это еще один клиент, и он не является
 * частью Подсистемы.
 */
class Subsystem1 {
   public:
    std::string Operation1() const { return "Subsystem1: Ready!\n"; }
    // ...
    std::string OperationN() const { return "Subsystem1: Go!\n"; }
};
/**
 * Некоторые фасады могут работать с разными подсистемами одновременно.
 */
class Subsystem2 {
   public:
    std::string Operation1() const { return "Subsystem2: Get ready!\n"; }
    // ...
    std::string OperationZ() const { return "Subsystem2: Fire!\n"; }
};

/**
 * Класс Фасада предоставляет простой интерфейс для сложной логики одной или
 * нескольких подсистем. Фасад делегирует запросы клиентов соответствующим
 * объектам внутри подсистемы. Фасад также отвечает за управление их жизненным
 * циклом. Все это защищает клиента от нежелательной сложности подсистемы.
 */
class Facade {
   protected:
    Subsystem1 *subsystem1_;
    Subsystem2 *subsystem2_;
    /**
     * В зависимости от потребностей вашего приложения вы можете предоставить
     * Фасаду существующие объекты подсистемы или заставить Фасад создать их
     * самостоятельно.
     */
   public:
    /**
     * In this case we will delegate the memory ownership to Facade Class
     */
    Facade(Subsystem1 *subsystem1 = nullptr, Subsystem2 *subsystem2 = nullptr) {
        this->subsystem1_ = subsystem1 ?: new Subsystem1;
        this->subsystem2_ = subsystem2 ?: new Subsystem2;
    }
    ~Facade() {
        delete subsystem1_;
        delete subsystem2_;
    }
    /**
     * Методы Фасада удобны для быстрого доступа к сложной функциональности
     * подсистем. Однако клиенты получают только часть возможностей подсистемы.
     */
    std::string Operation() {
        std::string result = "Facade initializes subsystems:\n";
        result += this->subsystem1_->Operation1();
        result += this->subsystem2_->Operation1();
        result += "Facade orders subsystems to perform the action:\n";
        result += this->subsystem1_->OperationN();
        result += this->subsystem2_->OperationZ();
        return result;
    }
};

/**
 * Клиентский код работает со сложными подсистемами через простой интерфейс,
 * предоставляемый Фасадом. Когда фасад управляет жизненным циклом подсистемы,
 * клиент может даже не знать о существовании подсистемы. Такой подход позволяет
 * держать сложность под контролем.
 */
void ClientCode(Facade *facade) {
    // ...
    std::cout << facade->Operation();
    // ...
}
/**
 * В клиентском коде могут быть уже созданы некоторые объекты подсистемы. В этом
 * случае может оказаться целесообразным инициализировать Фасад с этими
 * объектами вместо того, чтобы позволить Фасаду создавать новые экземпляры.
 */

int main() {
    Subsystem1 *subsystem1 = new Subsystem1;
    Subsystem2 *subsystem2 = new Subsystem2;
    Facade *facade = new Facade(subsystem1, subsystem2);
    ClientCode(facade);

    delete facade;

    return 0;
}
```

Вывод программы:

```
Facade initializes subsystems:
Subsystem1: Ready!
Subsystem2: Get ready!
Facade orders subsystems to perform the action:
Subsystem1: Go!
Subsystem2: Fire!
```

<hr>

[Содержание](#содержание)

## Легковес 
`Легковес` — это структурный паттерн проектирования, который позволяет вместить бóльшее количество объектов в отведённую оперативную память. `Легковес` экономит память, разделяя общее состояние объектов между собой, вместо хранения одинаковых данных в каждом объекте.

![04](/CPP_from_LETI/LETI_03/img/04_71.png)

__Проблема__

На досуге вы решили написать небольшую игру, в которой игроки перемещаются по карте и стреляют друг в друга. Фишкой игры должна была стать реалистичная система частиц. Пули, снаряды, осколки от взрывов — всё это должно красиво летать и радовать взгляд.

Игра отлично работала на вашем мощном компьютере. Однако ваш друг сообщил, что игра начинает тормозить и вылетает через несколько минут после запуска. Покопавшись в логах, вы обнаружили, что игра вылетает из-за недостатка оперативной памяти. У вашего друга компьютер значительно менее «прокачанный», поэтому проблема у него и проявляется так быстро.

И действительно, каждая частица представлена собственным объектом, имеющим множество данных. В определённый момент, когда побоище на экране достигает кульминации, новые объекты частиц уже не вмещаются в оперативную память компьютера, и программа вылетает.

![04](/CPP_from_LETI/LETI_03/img/04_72.png)

__Решение__

Если внимательно посмотреть на класс частиц, то можно заметить, что цвет и спрайт занимают больше всего памяти. Более того, они хранятся в каждом объекте, хотя фактически их значения одинаковы для большинства частиц.

![04](/CPP_from_LETI/LETI_03/img/04_73.png)

Остальное состояние объектов — координаты, вектор движения и скорость — отличаются для всех частиц. Таким образом, эти поля можно рассматривать как контекст, в котором частица используется. А цвет и спрайт — это данные, не изменяющиеся во времени.

Неизменяемые данные объекта принято называть «внутренним состоянием». Все остальные данные — это «внешнее состояние».

Паттерн `Легковес` предлагает не хранить в классе внешнее состояние, а передавать его в те или иные методы через параметры. Таким образом, одни и те же объекты можно будет повторно использовать в различных контекстах. Но главное — понадобится гораздо меньше объектов, ведь теперь они будут отличаться только внутренним состоянием, а оно имеет не так много вариаций.

![04](/CPP_from_LETI/LETI_03/img/04_74.png)

В нашем примере с частицами достаточно будет оставить всего три объекта с отличающимися спрайтами и цветом — для пуль, снарядов и осколков. Несложно догадаться, что такие облегчённые объекты называют легковéсами .

__Хранилище внешнего состояния__

Но куда переедет внешнее состояние? Ведь кто-то должен его хранить. Чаще всего, его перемещают в контейнер, который управлял объектами до применения паттерна.

В нашем случае это был главный объект игры. Вы могли бы добавить в его класс поля-массивы для хранения координат, векторов и скоростей частиц. Кроме этого, понадобится ещё один массив для хранения ссылок на объекты-легковесы, соответствующие той или иной частице.

![04](/CPP_from_LETI/LETI_03/img/04_75.png)

Но более элегантным решением было бы создать дополнительный класс-контекст, который бы связывал внешнее состояние с тем или иным легковесом. Это позволит обойтись только одним полем-массивом в классе контейнера.

«Но погодите-ка, нам потребуется столько же этих объектов, сколько было в самом начале!», — скажете вы и будете правы! Но дело в том, что объекты-контексты занимают намного меньше места, чем первоначальные. Ведь самые тяжёлые поля остались в легковесах (простите за каламбур), и сейчас мы будем ссылаться на эти объекты из контекстов, вместо того, чтобы повторно хранить дублирующееся состояние.

__Неизменяемость Легковесов__

Так как объекты легковесов будут использованы в разных контекстах, вы должны быть уверены в том, что их состояние невозможно изменить после создания. Всё внутреннее состояние легковес должен получать через параметры конструктора. Он не должен иметь сеттеров и публичных полей.

__Фабрика Легковесов__

Для удобства работы с легковесами и контекстами можно создать `фабричный метод`, принимающий в параметрах всё внутреннее (а иногда и внешнее) состояние желаемого объекта.

Главная польза от этого метода в том, чтобы искать уже созданные легковесы с таким же внутренним состоянием, что и требуемое. Если легковес находится, его можно повторно использовать. Если нет — просто создаём новый. Обычно этот метод добавляют в контейнер легковесов либо создают отдельный класс-фабрику. Его даже можно сделать статическим и поместить в класс легковесов.

Структура

![04](/CPP_from_LETI/LETI_03/img/04_76.jpg)

__Применимость__

+ Когда не хватает оперативной памяти для поддержки всех нужных объектов.

Эффективность паттерна `Легковес` во многом зависит от того, как и где он используется. Применяйте этот паттерн, когда выполнены все перечисленные условия:
+ в приложении используется большое число объектов;
+ из-за этого высоки расходы оперативной памяти;
+ большую часть состояния объектов можно вынести за пределы их классов;
+ большие группы объектов можно заменить относительно небольшим количеством разделяемых объектов, поскольку внешнее состояние вынесено.

__Шаги реализации__

1. Разделите поля класса, который станет легковесом, на две части:
    + внутреннее состояние: значения этих полей одинаковы для большого числа объектов;
    + внешнее состояние (контекст): значения полей уникальны для каждого объекта.
2. Оставьте поля внутреннего состояния в классе, но убедитесь, что их значения неизменяемы. Эти поля должны инициализироваться только через конструктор.
3. Превратите поля внешнего состояния в параметры методов, где эти поля использовались. Затем удалите поля из класса.
4. Создайте фабрику, которая будет кешировать и повторно отдавать уже созданные объекты. Клиент должен запрашивать из этой фабрики легковеса с определённым внутренним состоянием, а не создавать его напрямую.
5. Клиент должен хранить или вычислять значения внешнего состояния (контекст) и передавать его в методы объекта легковеса.

__Преимущества и недостатки__

![04](/CPP_from_LETI/LETI_03/img/04_77.jpg)

__Отношения с другими паттернами__
+ `Компоновщик` часто совмещают с `Легковесом`, чтобы реализовать общие ветки дерева и сэкономить при этом память.
+ `Легковес` показывает, как создавать много мелких объектов, а `Фасад` показывает, как создать один объект, который отображает целую подсистему.
+ Паттерн `Легковес` может напоминать `Одиночку`, если для конкретной задачи у вас получилось свести количество объектов к одному. Но помните, что между паттернами есть два кардинальных отличия:
    + В отличие от `Одиночки`, вы можете иметь множество объектов-легковесов.
    + Объекты-легковесы должны быть неизменяемыми, тогда как объект-одиночка допускает изменение своего состояния.

<hr>

[Содержание](#содержание)

## Примеры реализации паттерна Легковес (Flyweight)

```c++
#include <iostream>
#include <string>
#include <unordered_map>
#include <vector>


/**
 * Паттерн Легковес
 *
 * Назначение: Позволяет вместить бóльшее количество объектов в отведённую
 * оперативную память. Легковес экономит память, разделяя общее состояние
 * объектов между собой, вместо хранения одинаковых данных в каждом объекте.
 */

struct SharedState {
    std::string brand_;
    std::string model_;
    std::string color_;

    SharedState(const std::string &brand, const std::string &model, const std::string &color)
        : brand_(brand), model_(model), color_(color) {}

    friend std::ostream &operator<<(std::ostream &os, const SharedState &ss) {
        return os << "[ " << ss.brand_ << " , " << ss.model_ << " , " << ss.color_ << " ]";
    }
};

struct UniqueState {
    std::string owner_;
    std::string plates_;

    UniqueState(const std::string &owner, const std::string &plates) : owner_(owner), plates_(plates) {}

    friend std::ostream &operator<<(std::ostream &os, const UniqueState &us) {
        return os << "[ " << us.owner_ << " , " << us.plates_ << " ]";
    }
};

/**
 * Легковес хранит общую часть состояния (также называемую внутренним
 * состоянием), которая принадлежит нескольким реальным бизнес-объектам.
 * Легковес принимает оставшуюся часть состояния (внешнее состояние, уникальное
 * для каждого объекта)  через его параметры метода.
 */
class Flyweight {
   private:
    SharedState *shared_state_;

   public:
    Flyweight(const SharedState *shared_state) : shared_state_(new SharedState(*shared_state)) {}
    Flyweight(const Flyweight &other) : shared_state_(new SharedState(*other.shared_state_)) {}
    ~Flyweight() { delete shared_state_; }
    SharedState *shared_state() const { return shared_state_; }
    void Operation(const UniqueState &unique_state) const {
        std::cout << "Flyweight: Displaying shared (" << *shared_state_ << ") and unique (" << unique_state
                  << ") state.\n";
    }
};
/**
 * Фабрика Легковесов создает объекты-Легковесы и управляет ими. Она
 * обеспечивает правильное разделение легковесов. Когда клиент запрашивает
 * легковес, фабрика либо возвращает существующий экземпляр, либо создает новый,
 * если он ещё не существует.
 */
class FlyweightFactory {
    /**
     * @var Flyweight[]
     */
   private:
    std::unordered_map<std::string, Flyweight> flyweights_;
    /**
     * Возвращает хеш строки Легковеса для данного состояния.
     */
    std::string GetKey(const SharedState &ss) const { return ss.brand_ + "_" + ss.model_ + "_" + ss.color_; }

   public:
    FlyweightFactory(std::initializer_list<SharedState> share_states) {
        for (const SharedState &ss : share_states) {
            this->flyweights_.insert(
                std::make_pair<std::string, Flyweight>(this->GetKey(ss), Flyweight(&ss)));
        }
    }

    /**
     * Возвращает существующий Легковес с заданным состоянием или создает новый.
     */
    Flyweight GetFlyweight(const SharedState &shared_state) {
        std::string key = this->GetKey(shared_state);
        if (this->flyweights_.find(key) == this->flyweights_.end()) {
            std::cout << "FlyweightFactory: Can't find a flyweight, creating new one.\n";
            this->flyweights_.insert(std::make_pair(key, Flyweight(&shared_state)));
        } else {
            std::cout << "FlyweightFactory: Reusing existing flyweight.\n";
        }
        return this->flyweights_.at(key);
    }
    void ListFlyweights() const {
        size_t count = this->flyweights_.size();
        std::cout << "\nFlyweightFactory: I have " << count << " flyweights:\n";
        for (std::pair<std::string, Flyweight> pair : this->flyweights_) {
            std::cout << pair.first << "\n";
        }
    }
};

// ...
void AddCarToPoliceDatabase(FlyweightFactory &ff, const std::string &plates, const std::string &owner,
                            const std::string &brand, const std::string &model, const std::string &color) {
    std::cout << "\nClient: Adding a car to database.\n";
    const Flyweight &flyweight = ff.GetFlyweight({brand, model, color});
    // Клиентский код либо сохраняет, либо вычисляет внешнее состояние и
    // передает его методам легковеса.
    flyweight.Operation({owner, plates});
}

/**
 * Клиентский код обычно создает кучу предварительно заполненных легковесов на
 * этапе инициализации приложения.
 */

int main() {
    FlyweightFactory *factory = new FlyweightFactory({{"Chevrolet", "Camaro2018", "pink"},
                                                      {"Mercedes Benz", "C300", "black"},
                                                      {"Mercedes Benz", "C500", "red"},
                                                      {"BMW", "M5", "red"},
                                                      {"BMW", "X6", "white"}});
    factory->ListFlyweights();

    AddCarToPoliceDatabase(*factory, "CL234IR", "James Doe", "BMW", "M5", "red");

    AddCarToPoliceDatabase(*factory, "CL234IR", "James Doe", "BMW", "X1", "red");
    factory->ListFlyweights();
    delete factory;

    return 0;
}
```

Результат выполнения:

```
FlyweightFactory: I have 5 flyweights:
BMW_X6_white
Mercedes Benz_C500_red
Mercedes Benz_C300_black
BMW_M5_red
Chevrolet_Camaro2018_pink

Client: Adding a car to database.
FlyweightFactory: Reusing existing flyweight.
Flyweight: Displaying shared ([ BMW , M5 , red ]) and unique ([ CL234IR , James Doe ]) state.

Client: Adding a car to database.
FlyweightFactory: Can't find a flyweight, creating new one.
Flyweight: Displaying shared ([ BMW , X1 , red ]) and unique ([ CL234IR , James Doe ]) state.

FlyweightFactory: I have 6 flyweights:
BMW_X1_red
Mercedes Benz_C300_black
BMW_X6_white
Mercedes Benz_C500_red
BMW_M5_red
Chevrolet_Camaro2018_pink
```

<hr>

[Содержание](#содержание)

## Заместитель

__Заместитель__ — это структурный паттерн проектирования, который позволяет подставлять вместо реальных объектов специальные объекты-заменители. Эти объекты перехватывают вызовы к оригинальному объекту, позволяя сделать что-то до или после передачи вызова оригиналу.

![04](/CPP_from_LETI/LETI_03/img/04_78.png)

__Проблема__

Для чего вообще контролировать доступ к объектам? Рассмотрим такой пример: у вас есть внешний ресурсоёмкий объект, который нужен не все время, а изредка.

![04](/CPP_from_LETI/LETI_03/img/04_79.png)

Мы могли бы создавать этот объект не в самом начале программы, а только тогда, когда он кому-то реально понадобится. Каждый клиент объекта получил бы некий код отложенной инициализации. Но, вероятно, это привело бы к множественному дублированию кода.

В идеале, этот код хотелось бы поместить прямо в служебный класс, но это не всегда возможно. Например, код класса может находиться в закрытой сторонней библиотеке.

__Решение__

Паттерн `Заместитель` предлагает создать новый класс-дублёр, имеющий тот же интерфейс, что и оригинальный служебный объект. При получении запроса от клиента объект-заместитель сам бы создавал экземпляр служебного объекта и переадресовывал бы ему всю реальную работу.

![04](/CPP_from_LETI/LETI_03/img/04_80.png)

Но в чём же здесь польза? Вы могли бы поместить в класс заместителя какую-то промежуточную логику, которая выполнялась бы до (или после) вызовов этих же методов в настоящем объекте. А благодаря одинаковому интерфейсу, объект-заместитель можно передать в любой код, ожидающий сервисный объект.

__Аналогия из жизни__

![04](/CPP_from_LETI/LETI_03/img/04_81.png)

Платёжная карточка — это заместитель пачки наличных. И карточка, и наличные имеют общий интерфейс — ими можно оплачивать товары. Для покупателя польза в том, что не надо таскать с собой тонны наличных, а владелец магазина рад, что ему не нужно делать дорогостоящую инкассацию наличности в банк — деньги поступают к нему на счёт напрямую.

__Структура__

![04](/CPP_from_LETI/LETI_03/img/04_82.jpg)

__Применимость__

+ Ленивая инициализация (виртуальный прокси). Когда у вас есть тяжёлый объект, грузящий данные из файловой системы или базы данных.<br>
Вместо того, чтобы грузить данные сразу после старта программы, можно сэкономить ресурсы и создать объект тогда, когда он действительно понадобится.
+ Защита доступа (защищающий прокси). Когда в программе есть разные типы пользователей, и вам хочется защищать объект от неавторизованного доступа. Например, если ваши объекты — это важная часть операционной системы, а пользователи — сторонние программы (хорошие или вредоносные).<br>
Прокси может проверять доступ при каждом вызове и передавать выполнение служебному объекту, если доступ разрешён.
+ Локальный запуск сервиса (удалённый прокси). Когда настоящий сервисный объект находится на удалённом сервере.<br>
В этом случае заместитель транслирует запросы клиента в вызовы по сети в протоколе, понятном удалённому сервису.
+ Логирование запросов (логирующий прокси). Когда требуется хранить историю обращений к сервисному объекту.<br>
`Заместитель` может сохранять историю обращения клиента к сервисному объекту.
+ Кеширование объектов («умная» ссылка). Когда нужно кешировать результаты запросов клиентов и управлять их жизненным циклом.<br>
`Заместитель` может подсчитывать количество ссылок на сервисный объект, которые были отданы клиенту и остаются активными. Когда все ссылки освобождаются, можно будет освободить и сам сервисный объект (например, закрыть подключение к базе данных).<br>
Кроме того, `Заместитель` может отслеживать, не менял ли клиент сервисный объект. Это позволит использовать объекты повторно и здóрово экономить ресурсы, особенно если речь идёт о больших прожорливых сервисах.

__Шаги реализации__
1. Определите интерфейс, который бы сделал заместитель и оригинальный объект взаимозаменяемыми.
2. Создайте класс заместителя. Он должен содержать ссылку на сервисный объект. Чаще всего, сервисный объект создаётся самим заместителем. В редких случаях заместитель получает готовый сервисный объект от клиента через конструктор.
3. Реализуйте методы заместителя в зависимости от его предназначения. В большинстве случаев, проделав какую-то полезную работу, методы заместителя должны передать запрос сервисному объекту.
4. Подумайте о введении фабрики, которая решала бы, какой из объектов создавать — заместитель или реальный сервисный объект. Но, с другой стороны, эта логика может быть помещена в создающий метод самого заместителя.
5. Подумайте, не реализовать ли вам ленивую инициализацию сервисного объекта при первом обращении клиента к методам заместителя.

__Преимущества и недостатки__

![04](/CPP_from_LETI/LETI_03/img/04_83.jpg)

__Отношения с другими паттернами__

+ `Адаптер` предоставляет классу альтернативный интерфейс. `Декоратор` предоставляет расширенный интерфейс. `Заместитель` предоставляет тот же интерфейс.
+ `Фасад` похож на `Заместитель` тем, что замещает сложную подсистему и может сам её инициализировать. Но в отличие от `Фасада`, `Заместитель` имеет тот же интерфейс, что его служебный объект, благодаря чему их можно взаимно заменять.
+ `Декоратор` и `Заместитель` имеют схожие структуры, но разные назначения. Они похожи тем, что оба построены на принципе композиции и делегируют работу другим объектам. Паттерны отличаются тем, что `Заместитель` сам управляет жизнью сервисного объекта, а обёртывание `Декораторов` контролируется клиентом.

<hr>

[Содержание](#содержание)

## Примеры использования паттерна Заместитель (Proxy)

```c++
#include <iostream>
#include <string>
#include <unordered_map>
#include <vector>

/**
 * Интерфейс Субъекта объявляет общие операции как для Реального Субъекта, так и
 * для Заместителя. Пока клиент работает с Реальным Субъектом, используя этот
 * интерфейс, вы сможете передать ему заместителя вместо реального субъекта.
 */
class Subject {
   public:
    virtual void Request() const = 0;
};
/**
 * Реальный Субъект содержит некоторую базовую бизнес-логику. Как правило,
 * Реальные Субъекты способны выполнять некоторую полезную работу, которая к
 * тому же может быть очень медленной или точной – например, коррекция входных
 * данных. Заместитель может решить эти задачи без каких-либо изменений в коде
 * Реального Субъекта.
 */
class RealSubject : public Subject {
   public:
    void Request() const override { std::cout << "RealSubject: Handling request.\n"; }
};
/**
 * Интерфейс Заместителя идентичен интерфейсу Реального Субъекта.
 */
class Proxy : public Subject {
    /**
     * @var RealSubject
     */
   private:
    RealSubject *real_subject_;

    bool CheckAccess() const {
        // Некоторые реальные проверки должны проходить здесь.
        std::cout << "Proxy: Checking access prior to firing a real request.\n";
        return true;
    }
    void LogAccess() const { std::cout << "Proxy: Logging the time of request.\n"; }

    /**
     * Заместитель хранит ссылку на объект класса РеальныйСубъект. Клиент может
     * либо лениво загрузить его, либо передать Заместителю.
     */
   public:
    Proxy(RealSubject *real_subject) : real_subject_(new RealSubject(*real_subject)) {}

    ~Proxy() { delete real_subject_; }
    /**
     * Наиболее распространёнными областями применения паттерна Заместитель
     * являются ленивая загрузка, кэширование, контроль доступа, ведение журнала и
     * т.д. Заместитель может выполнить одну из этих задач, а затем, в зависимости
     * от результата, передать выполнение одноимённому методу в связанном объекте
     * класса Реального Субъект.
     */
    void Request() const override {
        if (this->CheckAccess()) {
            this->real_subject_->Request();
            this->LogAccess();
        }
    }
};
/**
 * Клиентский код должен работать со всеми объектами (как с реальными, так и
 * заместителями) через интерфейс Субъекта, чтобы поддерживать как реальные
 * субъекты, так и заместителей. В реальной жизни, однако, клиенты в основном
 * работают с реальными субъектами напрямую. В этом случае, для более простой
 * реализации паттерна, можно расширить заместителя из класса реального
 * субъекта.
 */
void ClientCode(const Subject &subject) {
    // ...
    subject.Request();
    // ...
}

int main() {
    std::cout << "Client: Executing the client code with a real subject:\n";
    RealSubject *real_subject = new RealSubject;
    ClientCode(*real_subject);
    std::cout << "\n";
    std::cout << "Client: Executing the same client code with a proxy:\n";
    Proxy *proxy = new Proxy(real_subject);
    ClientCode(*proxy);

    delete real_subject;
    delete proxy;
    return 0;
}
```

Результат выполнения:

```
Client: Executing the client code with a real subject:
RealSubject: Handling request.

Client: Executing the same client code with a proxy:
Proxy: Checking access prior to firing a real request.
RealSubject: Handling request.
Proxy: Logging the time of request.
```

<hr>

[Содержание](#содержание)

## Вопросы 3

Сопоставьте значения из двух списков

![04](/CPP_from_LETI/LETI_03/img/04_84.PNG)

Вашему коду приходится работать с большим количеством объектов некой сложной библиотеки или фреймворка. Вы должны самостоятельно инициализировать эти объекты, следить за правильным порядком зависимостей и так далее.

В результате бизнес-логика ваших классов тесно переплетается с деталями реализации сторонних классов. Такой код довольно сложно понимать и поддерживать.

Какой паттерн (паттерны) проектирования вы бы использовали для решения данной проблемы?

+ [ ] Прототип
+ [ ] Посетитель
+ [x] Фасад
+ [ ] Снимок
+ [x] Абстрактная фабрика

<hr>

[Содержание](#содержание)

# 4.4 Поведенческие паттерны проектирования

## Виды поведенческих паттернов проектирования

![04](/CPP_from_LETI/LETI_03/img/04_85.jpg)

__Поведенческие паттерны проектирования__

Паттерны поведения рассматривают вопросы о связях между объектами и распределением обязанностей между ними. Для этого могут использоваться механизмы, основанные как на наследовании, так и на композиции.

<hr>

[Содержание](#содержание)

## Цепочка обязанностей

__Цепочка обязанностей__ — это поведенческий паттерн проектирования, который позволяет передавать запросы последовательно по цепочке обработчиков. Каждый последующий обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи.

![04](/CPP_from_LETI/LETI_03/img/04_86.png)

__Проблема__

Представьте, что вы делаете систему приёма онлайн-заказов. Вы хотите ограничить к ней доступ так, чтобы только авторизованные пользователи могли создавать заказы. Кроме того, определённые пользователи, владеющие правами администратора, должны иметь полный доступ к заказам.

Вы быстро сообразили, что эти проверки нужно выполнять последовательно. Ведь пользователя можно попытаться «залогинить» в систему, если его запрос содержит логин и пароль. Но если такая попытка не удалась, то проверять расширенные права доступа попросту не имеет смысла.

![04](/CPP_from_LETI/LETI_03/img/04_86.png)

На протяжении следующих нескольких месяцев вам пришлось добавить ещё несколько таких последовательных проверок.
+ Кто-то резонно заметил, что неплохо бы проверять данные, передаваемые в запросе перед тем, как вносить их в систему — вдруг запрос содержит данные о покупке несуществующих продуктов.
+ Кто-то предложил блокировать массовые отправки формы с одним и тем же логином, чтобы предотвратить подбор паролей ботами.
+ Кто-то заметил, что форму заказа неплохо бы доставать из кеша, если она уже была однажды показана.

![04](/CPP_from_LETI/LETI_03/img/04_87.png)

С каждой новой «фичей» код проверок, выглядящий как большой клубок условных операторов, всё больше и больше раздувался. При изменении одного правила приходилось трогать код всех проверок. А для того, чтобы применить проверки к другим ресурсам, пришлось продублировать их код в других классах.

Поддерживать такой код стало не только очень хлопотно, но и затратно. И вот в один прекрасный день вы получаете задачу рефакторинга...

__Решение__

Как и многие другие поведенческие паттерны, Цепочка обязанностей базируется на том, чтобы превратить отдельные поведения в объекты. В нашем случае каждая проверка переедет в отдельный класс с единственным методом выполнения. Данные запроса, над которым происходит проверка, будут передаваться в метод как аргументы.

А теперь по-настоящему важный этап. Паттерн предлагает связать объекты обработчиков в одну цепь. Каждый из них будет иметь ссылку на следующий обработчик в цепи. Таким образом, при получении запроса обработчик сможет не только сам что-то с ним сделать, но и передать обработку следующему объекту в цепочке.

Передавая запросы в первый обработчик цепочки, вы можете быть уверены, что все объекты в цепи смогут его обработать. При этом длина цепочки не имеет никакого значения.

И последний штрих. Обработчик не обязательно должен передавать запрос дальше, причём эта особенность может быть использована по-разному.

В примере с фильтрацией доступа обработчики прерывают дальнейшие проверки, если текущая проверка не прошла. Ведь нет смысла тратить попусту ресурсы, если и так понятно, что с запросом что-то не так.

![04](/CPP_from_LETI/LETI_03/img/04_88.png)

Но есть и другой подход, при котором обработчики прерывают цепь только когда они могут обработать запрос. В этом случае запрос движется по цепи, пока не найдётся обработчик, который может его обработать. Очень часто такой подход используется для передачи событий, создаваемых классами графического интерфейса в результате взаимодействия с пользователем.

Например, когда пользователь кликает по кнопке, программа выстраивает цепочку из объекта этой кнопки, всех её родительских элементов и общего окна приложения на конце. Событие клика передаётся по этой цепи до тех пор, пока не найдётся объект, способный его обработать. Этот пример примечателен ещё и тем, что цепочку всегда можно выделить из древовидной структуры объектов, в которую обычно и свёрнуты элементы пользовательского интерфейса.

![04](/CPP_from_LETI/LETI_03/img/04_89.png)

Очень важно, чтобы все объекты цепочки имели общий интерфейс. Обычно каждому конкретному обработчику достаточно знать только то, что следующий объект в цепи имеет метод выполнить. Благодаря этому связи между объектами цепочки будут более гибкими. Кроме того, вы сможете формировать цепочки на лету из разнообразных объектов, не привязываясь к конкретным классам.

__Аналогия из жизни__

![04](/CPP_from_LETI/LETI_03/img/04_90.png)

Вы купили новую видеокарту. Она автоматически определилась и заработала под Windows, но в вашей любимой Ubuntu «завести» её не удалось. Со слабой надеждой вы звоните в службу поддержки.

Первым вы слышите голос автоответчика, предлагающий выбор из десятка стандартных решений. Ни один из вариантов не подходит, и робот соединяет вас с живым оператором.

Увы, но рядовой оператор поддержки умеет общаться только заученными фразами и давать шаблонные ответы. После очередного предложения «выключить и включить компьютер» вы просите связать вас с настоящими инженерами.

Оператор перебрасывает звонок дежурному инженеру, изнывающему от скуки в своей каморке. Уж он-то знает, как вам помочь! Инженер рассказывает вам, где скачать подходящие драйвера и как настроить их под Ubuntu. Запрос удовлетворён. Вы кладёте трубку.

__Структура__

![04](/CPP_from_LETI/LETI_03/img/04_91.jpg)

__Применимость__

+ Когда программа должна обрабатывать разнообразные запросы несколькими способами, но заранее неизвестно, какие конкретно запросы будут приходить и какие обработчики для них понадобятся.
+ С помощью `Цепочки обязанностей` вы можете связать потенциальных обработчиков в одну цепь и при получении запроса поочерёдно спрашивать каждого из них, не хочет ли он обработать запрос.
+ Когда важно, чтобы обработчики выполнялись один за другим в строгом порядке.
+ `Цепочка обязанностей` позволяет запускать обработчиков последовательно один за другим в том порядке, в котором они находятся в цепочке.
+ Когда набор объектов, способных обработать запрос, должен задаваться динамически.
+ В любой момент вы можете вмешаться в существующую цепочку и переназначить связи так, чтобы убрать или добавить новое звено.

__Шаги реализации__

1. Создайте интерфейс обработчика и опишите в нём основной метод обработки.
2. Продумайте, в каком виде клиент должен передавать данные запроса в обработчик. Самый гибкий способ — превратить данные запроса в объект и передавать его целиком через параметры метода обработчика.
3. Имеет смысл создать абстрактный базовый класс обработчиков, чтобы не дублировать реализацию метода получения следующего обработчика во всех конкретных обработчиках.<br>
4. Добавьте в базовый обработчик поле для хранения ссылки на следующий объект цепочки. Устанавливайте начальное значение этого поля через конструктор. Это сделает объекты обработчиков неизменяемыми. Но если программа предполагает динамическую перестройку цепочек, можете добавить и сеттер для поля.<br>
5. Реализуйте базовый метод обработки так, чтобы он перенаправлял запрос следующему объекту, проверив его наличие. Это позволит полностью скрыть поле-ссылку от подклассов, дав им возможность передавать запросы дальше по цепи, обращаясь к родительской реализации метода.
6. Один за другим создайте классы конкретных обработчиков и реализуйте в них методы обработки запросов. При получении запроса каждый обработчик должен решить:
    + Может ли он обработать запрос или нет?
    + Следует ли передать запрос следующему обработчику или нет?
7. Клиент может собирать цепочку обработчиков самостоятельно, опираясь на свою бизнес-логику, либо получать уже готовые цепочки извне. В последнем случае цепочки собираются фабричными объектами, опираясь на конфигурацию приложения или параметры окружения.
8. Клиент может посылать запросы любому обработчику в цепи, а не только первому. Запрос будет передаваться по цепочке до тех пор, пока какой-то обработчик не откажется передавать его дальше, либо когда будет достигнут конец цепи.
9. Клиент должен знать о динамической природе цепочки и быть готов к таким случаям:
+ Цепочка может состоять из единственного объекта.
+ Запросы могут не достигать конца цепи.
+ Запросы могут достигать конца, оставаясь необработанными.

__Преимущества и недостатки__

![04](/CPP_from_LETI/LETI_03/img/04_92.jpg)

__Отношения с другими паттернами__

+ `Цепочка обязанностей`, `Команда`, `Посредник` и `Наблюдатель` показывают различные способы работы отправителей запросов с их получателями:
    + `Цепочка обязанностей` передаёт запрос последовательно через цепочку потенциальных получателей, ожидая, что какой-то из них обработает запрос.
    + `Команда` устанавливает косвенную одностороннюю связь от отправителей к получателям.
    + `Посредник` убирает прямую связь между отправителями и получателями, заставляя их общаться опосредованно, через себя.
    + `Наблюдатель` передаёт запрос одновременно всем заинтересованным получателям, но позволяет им динамически подписываться или отписываться от таких оповещений.
+ `Цепочку обязанностей` часто используют вместе с `Компоновщиком`. В этом случае запрос передаётся от дочерних компонентов к их родителям.
+ Обработчики в `Цепочке обязанностей` могут быть выполнены в виде `Команд`. В этом случае множество разных операций может быть выполнено над одним и тем же контекстом, коим является запрос.<br>
Но есть и другой подход, в котором сам запрос является `Командой`, посланной по цепочке объектов. В этом случае одна и та же операция может быть выполнена над множеством разных контекстов, представленных в виде цепочки.
+ `Цепочка обязанностей` и `Декоратор` имеют очень похожие структуры. Оба паттерна базируются на принципе рекурсивного выполнения операции через серию связанных объектов. Но есть и несколько важных отличий.<br>
Обработчики в `Цепочке обязанностей` могут выполнять произвольные действия, независимые друг от друга, а также в любой момент прерывать дальнейшую передачу по цепочке. С другой стороны `Декораторы` расширяют какое-то определённое действие, не ломая интерфейс базовой операции и не прерывая выполнение остальных декораторов.

<hr>

[Содержание](#содержание)

## Примеры реализации паттерна Цепочка обязанностей 

```c++
#include <iostream>

/**
 * Интерфейс Обработчика объявляет метод построения цепочки обработчиков. Он
 * также объявляет метод для выполнения запроса.
 */
class Handler {
   public:
    virtual Handler *SetNext(Handler *handler) = 0;
    virtual std::string Handle(std::string request) = 0;
};
/**
 * Поведение цепочки по умолчанию может быть реализовано внутри базового класса
 * обработчика.
 */
class AbstractHandler : public Handler {
    /**
     * @var Handler
     */
   private:
    Handler *next_handler_;

   public:
    AbstractHandler() : next_handler_(nullptr) {}
    Handler *SetNext(Handler *handler) override {
        this->next_handler_ = handler;
        // Возврат обработчика отсюда позволит связать обработчики простым способом,
        // вот так:
        // $monkey->setNext($squirrel)->setNext($dog);
        return handler;
    }
    std::string Handle(std::string request) override {
        if (this->next_handler_) {
            return this->next_handler_->Handle(request);
        }

        return {};
    }
};
/**
 * Все Конкретные Обработчики либо обрабатывают запрос, либо передают его
 * следующему обработчику в цепочке.
 */
class MonkeyHandler : public AbstractHandler {
   public:
    std::string Handle(std::string request) override {
        if (request == "Banana") {
            return "Monkey: I'll eat the " + request + ".\n";
        } else {
            return AbstractHandler::Handle(request);
        }
    }
};
class SquirrelHandler : public AbstractHandler {
   public:
    std::string Handle(std::string request) override {
        if (request == "Nut") {
            return "Squirrel: I'll eat the " + request + ".\n";
        } else {
            return AbstractHandler::Handle(request);
        }
    }
};
class DogHandler : public AbstractHandler {
   public:
    std::string Handle(std::string request) override {
        if (request == "MeatBall") {
            return "Dog: I'll eat the " + request + ".\n";
        } else {
            return AbstractHandler::Handle(request);
        }
    }
};
/**
 * Обычно клиентский код приспособлен для работы с единственным обработчиком. В
 * большинстве случаев клиенту даже неизвестно, что этот обработчик является
 * частью цепочки.
 */
void ClientCode(Handler &handler) {
    std::vector<std::string> food = {"Nut", "Banana", "Cup of coffee"};
    for (const std::string &f : food) {
        std::cout << "Client: Who wants a " << f << "?\n";
        const std::string result = handler.Handle(f);
        if (!result.empty()) {
            std::cout << "  " << result;
        } else {
            std::cout << "  " << f << " was left untouched.\n";
        }
    }
}
/**
 * Другая часть клиентского кода создает саму цепочку.
 */
int main() {
    MonkeyHandler *monkey = new MonkeyHandler;
    SquirrelHandler *squirrel = new SquirrelHandler;
    DogHandler *dog = new DogHandler;
    monkey->SetNext(squirrel)->SetNext(dog);

    /**
     * Клиент должен иметь возможность отправлять запрос любому обработчику, а не
     * только первому в цепочке.
     */
    std::cout << "Chain: Monkey > Squirrel > Dog\n\n";
    ClientCode(*monkey);
    std::cout << "\n";
    std::cout << "Subchain: Squirrel > Dog\n\n";
    ClientCode(*squirrel);

    delete monkey;
    delete squirrel;
    delete dog;

    return 0;
}
```

Результат выполнения:

```
Chain: Monkey > Squirrel > Dog

Client: Who wants a Nut?
  Squirrel: I'll eat the Nut.
Client: Who wants a Banana?
  Monkey: I'll eat the Banana.
Client: Who wants a Cup of coffee?
  Cup of coffee was left untouched.

Subchain: Squirrel > Dog

Client: Who wants a Nut?
  Squirrel: I'll eat the Nut.
Client: Who wants a Banana?
  Banana was left untouched.
Client: Who wants a Cup of coffee?
  Cup of coffee was left untouched.
```

<hr>

[Содержание](#содержание)

## Команда

__Команда__ — это поведенческий паттерн проектирования, который превращает запросы в объекты, позволяя передавать их как аргументы при вызове методов, ставить запросы в очередь, логировать их, а также поддерживать отмену операций.

![04](/CPP_from_LETI/LETI_03/img/04_93.png)

__Проблема__

Представьте, что вы работаете над программой текстового редактора. Дело как раз подошло к разработке панели управления. Вы создали класс красивых Кнопок и хотите использовать его для всех кнопок приложения, начиная от панели управления, заканчивая простыми кнопками в диалогах.

![04](/CPP_from_LETI/LETI_03/img/04_94.png)

Все эти кнопки, хоть и выглядят схоже, но делают разные вещи. Поэтому возникает вопрос: куда поместить код обработчиков кликов по этим кнопкам? Самым простым решением было бы создать подклассы для каждой кнопки и переопределить в них метод действия под разные задачи.

![04](/CPP_from_LETI/LETI_03/img/04_95.png)

Но скоро стало понятно, что такой подход никуда не годится. Во-первых, получается очень много подклассов. Во-вторых, код кнопок, относящийся к графическому интерфейсу, начинает зависеть от классов бизнес-логики, которая довольно часто меняется.

![04](/CPP_from_LETI/LETI_03/img/04_96.png)

Но самое обидное ещё впереди. Ведь некоторые операции, например, «сохранить», можно вызывать из нескольких мест: нажав кнопку на панели управления, вызвав контекстное меню или просто нажав клавиши `Ctrl+S`. Когда в программе были только кнопки, код сохранения имелся только в подклассе `SaveButton`. Но теперь его придётся продублировать ещё в два класса.

__Решение__

Хорошие программы обычно структурированы в виде слоёв. Самый распространённый пример — слои пользовательского интерфейса и бизнес-логики. Первый всего лишь рисует красивую картинку для пользователя. Но когда нужно сделать что-то важное, интерфейс «просит» слой бизнес-логики заняться этим.

В реальности это выглядит так: один из объектов интерфейса напрямую вызывает метод одного из объектов бизнес-логики, передавая в него какие-то параметры.

![04](/CPP_from_LETI/LETI_03/img/04_97.png)

Паттерн `Команда` предлагает больше не отправлять такие вызовы напрямую. Вместо этого каждый вызов, отличающийся от других, следует завернуть в собственный класс с единственным методом, который и будет осуществлять вызов. Такие объекты называют командами.

К объекту интерфейса можно будет привязать объект команды, который знает, кому и в каком виде следует отправлять запросы. Когда объект интерфейса будет готов передать запрос, он вызовет метод команды, а та — позаботится обо всём остальном.

![04](/CPP_from_LETI/LETI_03/img/04_98.png)

Классы команд можно объединить под общим интерфейсом c единственным методом запуска. После этого одни и те же отправители смогут работать с различными командами, не привязываясь к их классам. Даже больше: команды можно будет взаимно заменять на лету, изменяя итоговое поведение отправителей.

Параметры, с которыми должен быть вызван метод объекта получателя, можно загодя сохранить в полях объекта-команды. Благодаря этому, объекты, отправляющие запросы, могут не беспокоиться о том, чтобы собрать необходимые для получателя данные. Более того, они теперь вообще не знают, кто будет получателем запроса. Вся эта информация скрыта внутри команды.

![04](/CPP_from_LETI/LETI_03/img/04_99.png)

После применения `Команды` в нашем примере с текстовым редактором вам больше не потребуется создавать уйму подклассов кнопок под разные действия. Будет достаточно единственного класса с полем для хранения объекта команды.

Используя общий интерфейс команд, объекты кнопок будут ссылаться на объекты команд различных типов. При нажатии кнопки будут делегировать работу связанным командам, а команды — перенаправлять вызовы тем или иным объектам бизнес-логики.

Так же можно поступить и с контекстным меню, и с горячими клавишами. Они будут привязаны к тем же объектам команд, что и кнопки, избавляя классы от дублирования.

Таким образом, команды станут гибкой прослойкой между пользовательским интерфейсом и бизнес-логикой. И это лишь малая доля пользы, которую может принести паттерн Команда!

__Аналогия из жизни__

![04](/CPP_from_LETI/LETI_03/img/04_100.png)

Вы заходите в ресторан и садитесь у окна. К вам подходит вежливый официант и принимает заказ, записывая все пожелания в блокнот. Откланявшись, он уходит на кухню, где вырывает лист из блокнота и клеит на стену. Далее лист оказывается в руках повара, который читает содержание заказа и готовит заказанные блюда.

В этом примере вы являетесь отправителем, официант с блокнотом — командой, а повар — получателем. Как и в паттерне, вы не соприкасаетесь напрямую с поваром. Вместо этого вы отправляете заказ с официантом, который самостоятельно «настраивает» повара на работу. С другой стороны, повар не знает, кто конкретно послал ему заказ. Но это ему безразлично, так как вся необходимая информация есть в листе заказа.

__Структура__

![04](/CPP_from_LETI/LETI_03/img/04_101.jpg)

__Применимость__

+ Когда вы хотите параметризовать объекты выполняемым действием.<br>
Команда превращает операции в объекты. А объекты можно передавать, хранить и взаимно заменять внутри других объектов.<br>
Скажем, вы разрабатываете библиотеку графического меню и хотите, чтобы пользователи могли использовать меню в разных приложениях, не меняя каждый раз код ваших классов. Применив паттерн, пользователям не придётся изменять классы меню, вместо этого они будут конфигурировать объекты меню различными командами.
+ Когда вы хотите ставить операции в очередь, выполнять их по расписанию или передавать по сети.<br>
Как и любые другие объекты, команды можно сериализовать, то есть превратить в строку, чтобы потом сохранить в файл или базу данных. Затем в любой удобный момент её можно достать обратно, снова превратить в объект команды и выполнить. Таким же образом команды можно передавать по сети, логировать или выполнять на удалённом сервере.
+ Когда вам нужна операция отмены.<br>
Главная вещь, которая вам нужна, чтобы иметь возможность отмены операций, — это хранение истории. Среди многих способов, которыми можно это сделать, паттерн `Команда` является, пожалуй, самым популярным.<br>
История команд выглядит как стек, в который попадают все выполненные объекты команд. Каждая команда перед выполнением операции сохраняет текущее состояние объекта, с которым она будет работать. После выполнения операции копия команды попадает в стек истории, все ещё неся в себе сохранённое состояние объекта. Если потребуется отмена, программа возьмёт последнюю команду из истории и возобновит сохранённое в ней состояние.<br>
    Этот способ имеет две особенности.
    + Во-первых, точное состояние объектов не так-то просто сохранить, ведь часть его может быть приватным. Но с этим может помочь справиться паттерн `Снимок`.
    + Во-вторых, копии состояния могут занимать довольно много оперативной памяти. Поэтому иногда можно прибегнуть к альтернативной реализации, когда вместо восстановления старого состояния команда выполняет обратное действие. Недостаток этого способа в сложности (а иногда и невозможности) реализации обратного действия.

__Шаги реализации__

1. Создайте общий интерфейс команд и определите в нём метод запуска.
2. Один за другим создайте классы конкретных команд. В каждом классе должно быть поле для хранения ссылки на один или несколько объектов-получателей, которым команда будет перенаправлять основную работу.
3. Кроме этого, команда должна иметь поля для хранения параметров, которые нужны при вызове методов получателя. Значения всех этих полей команда должна получать через конструктор.
4. И, наконец, реализуйте основной метод команды, вызывая в нём те или иные методы получателя.
5. Добавьте в классы отправителей поля для хранения команд. Обычно объекты-отправители принимают готовые объекты команд извне — через конструктор либо через сеттер поля команды.
6. Измените основной код отправителей так, чтобы они делегировали выполнение действия команде.
7. Порядок инициализации объектов должен выглядеть так:
    + Создаём объекты получателей.
    + Создаём объекты команд, связав их с получателями.
    + Создаём объекты отправителей, связав их с командами.

Преимущества и недостатки

![04](/CPP_from_LETI/LETI_03/img/04_102.jpg)

__Отношения с другими паттернами__

+ `Цепочка обязанностей`, `Команда`, `Посредник` и `Наблюдатель` показывают различные способы работы отправителей запросов с их получателями:
    + `Цепочка обязанностей` передаёт запрос последовательно через цепочку потенциальных получателей, ожидая, что какой-то из них обработает запрос.
    + `Команда` устанавливает косвенную одностороннюю связь от отправителей к получателям.
    + `Посредник` убирает прямую связь между отправителями и получателями, заставляя их общаться опосредованно, через себя.
    + `Наблюдатель` передаёт запрос одновременно всем заинтересованным получателям, но позволяет им динамически подписываться или отписываться от таких оповещений.
+ Обработчики в `Цепочке обязанностей` могут быть выполнены в виде `Команд`. В этом случае множество разных операций может быть выполнено над одним и тем же контекстом, коим является запрос.
+ Но есть и другой подход, в котором сам запрос является `Командой`, посланной по цепочке объектов. В этом случае одна и та же операция может быть выполнена над множеством разных контекстов, представленных в виде цепочки.
+ `Команду` и `Снимок` можно использовать сообща для реализации отмены операций. В этом случае объекты команд будут отвечать за выполнение действия над объектом, а снимки будут хранить резервную копию состояния этого объекта, сделанную перед самым запуском команды.
+ `Команда` и `Стратегия` похожи по духу, но отличаются масштабом и применением:
    + `Команду` используют, чтобы превратить любые разнородные действия в объекты. Параметры операции превращаются в поля объекта. Этот объект теперь можно логировать, хранить в истории для отмены, передавать во внешние сервисы и так далее.
    + С другой стороны, `Стратегия` описывает разные способы произвести одно и то же действие, позволяя взаимно заменять эти способы в каком-то объекте контекста.
+ Если `Команду` нужно копировать перед вставкой в историю выполненных команд, вам может помочь `Прототип`.
+ `Посетитель` можно рассматривать как расширенный аналог `Команды`, который способен работать сразу с несколькими видами получателей.

<hr>

[Содержание](#содержание)

## Итератор

__Итератор__ — это поведенческий паттерн проектирования, который даёт возможность последовательно обходить элементы составных объектов, не раскрывая их внутреннего представления.

![04](/CPP_from_LETI/LETI_03/img/04_103.png)

__Проблема__

`Коллекции` — самая распространённая структура данных, которую вы можете встретить в программировании. Это набор объектов, собранный в одну кучу по каким-то критериям.

![04](/CPP_from_LETI/LETI_03/img/04_104.png)

Большинство коллекций выглядят как обычный список элементов. Но есть и экзотические коллекции, построенные на основе деревьев, графов и других сложных структур данных.

Но как бы ни была структурирована коллекция, пользователь должен иметь возможность последовательно обходить её элементы, чтобы проделывать с ними какие-то действия.

Но каким способом следует перемещаться по сложной структуре данных? Например, сегодня может быть достаточным обход дерева в глубину, но завтра потребуется возможность перемещаться по дереву в ширину. А на следующей неделе и того хуже — понадобится обход коллекции в случайном порядке.

![04](/CPP_from_LETI/LETI_03/img/04_105.png)

Добавляя всё новые алгоритмы в код коллекции, вы понемногу размываете её основную задачу, которая заключается в эффективном хранении данных. Некоторые алгоритмы могут быть и вовсе слишком «заточены» под определённое приложение и смотреться дико в общем классе коллекции.

__Решение__

Идея паттерна `Итератор` состоит в том, чтобы вынести поведение обхода коллекции из самой коллекции в отдельный класс.

![04](/CPP_from_LETI/LETI_03/img/04_106.png)

Объект-итератор будет отслеживать состояние обхода, текущую позицию в коллекции и сколько элементов ещё осталось обойти. Одну и ту же коллекцию смогут одновременно обходить различные итераторы, а сама коллекция не будет даже знать об этом.

К тому же, если вам понадобится добавить новый способ обхода, вы сможете создать отдельный класс итератора, не изменяя существующий код коллекции.

__Аналогия из жизни__

![04](/CPP_from_LETI/LETI_03/img/04_107.png)

Вы планируете полететь в Рим и обойти все достопримечательности за пару дней. Но приехав, вы можете долго петлять узкими улочками, пытаясь найти Колизей.

Если у вас ограниченный бюджет — не беда. Вы можете воспользоваться виртуальным гидом, скачанным на телефон, который позволит отфильтровать только интересные вам точки. А можете плюнуть и нанять локального гида, который хоть и обойдётся в копеечку, но знает город как свои пять пальцев, и сможет посвятить вас во все городские легенды.

Таким образом, Рим выступает коллекцией достопримечательностей, а ваш мозг, навигатор или гид — итератором по коллекции. Вы, как клиентский код, можете выбрать один из итераторов, отталкиваясь от решаемой задачи и доступных ресурсов.

__Структура__

![04](/CPP_from_LETI/LETI_03/img/04_108.jpg)

__Применимость__

+ Когда у вас есть сложная структура данных, и вы хотите скрыть от клиента детали её реализации (из-за сложности или вопросов безопасности).<br>
Итератор предоставляет клиенту всего несколько простых методов перебора элементов коллекции. Это не только упрощает доступ к коллекции, но и защищает её данные от неосторожных или злоумышленных действий.
+ Когда вам нужно иметь несколько вариантов обхода одной и той же структуры данных.<br>
Нетривиальные алгоритмы обхода структуры данных могут иметь довольно объёмный код. Этот код будет захламлять всё вокруг — будь то сам класс коллекции или часть бизнес-логики программы. Применив итератор, вы можете выделить код обхода структуры данных в собственный класс, упростив поддержку остального кода.
+ Когда вам хочется иметь единый интерфейс обхода различных структур данных.<br>
Итератор позволяет вынести реализации различных вариантов обхода в подклассы. Это позволит легко взаимно заменять объекты итераторов, в зависимости от того, с какой структурой данных приходится работать.

__Шаги реализации__

1. Создайте общий интерфейс итераторов. Обязательный минимум — это операция получения следующего элемента коллекции. Но для удобства можно предусмотреть и другое. Например, методы для получения предыдущего элемента, текущей позиции, проверки окончания обхода и прочие.
2. Создайте интерфейс коллекции и опишите в нём метод получения итератора. Важно, чтобы сигнатура метода возвращала общий интерфейс итераторов, а не один из конкретных итераторов.
3. Создайте классы конкретных итераторов для тех коллекций, которые нужно обходить с помощью паттерна. Итератор должен быть привязан только к одному объекту коллекции. Обычно эта связь устанавливается через конструктор.
4. Реализуйте методы получения итератора в конкретных классах коллекций. Они должны создавать новый итератор того класса, который способен работать с данным типом коллекции. Коллекция должна передавать ссылку на собственный объект в конструктор итератора.
5. В клиентском коде и в классах коллекций не должно остаться кода обхода элементов. Клиент должен получать новый итератор из объекта коллекции каждый раз, когда ему нужно перебрать её элементы.

__Преимущества и недостатки__

![04](/CPP_from_LETI/LETI_03/img/04_109.jpg)

__Отношения с другими паттернами__

+ Вы можете обходить дерево `Компоновщика`, используя `Итератор`.
+ `Фабричный метод` можно использовать вместе с `Итератором`, чтобы подклассы коллекций могли создавать подходящие им итераторы.
+ `Снимок` можно использовать вместе с `Итератором`, чтобы сохранить текущее состояние обхода структуры данных и вернуться к нему в будущем, если потребуется.
+ `Посетитель` можно использовать совместно с `Итератором`. `Итератор` будет отвечать за обход структуры данных, а `Посетитель` — за выполнение действий над каждым её компонентом.

<hr>

[Содержание](#содержание)

## Пример использования паттерна Итератор (Iterator)

```c++
/**
 * Паттерн Итератор
 *
 * Назначение: Даёт возможность последовательно обходить элементы составных
 * объектов, не раскрывая их внутреннего представления.
 */
#include <iostream>
#include <string>
#include <vector>

/**
 * C++ has its own implementation of iterator that works with a different
 * generics containers defined by the standard library.
 */
template <typename T, typename U>
class Iterator {
   public:
    typedef typename std::vector<T>::iterator iter_type;
    Iterator(U *p_data, bool reverse = false) : m_p_data_(p_data) { m_it_ = m_p_data_->m_data_.begin(); }

    void First() { m_it_ = m_p_data_->m_data_.begin(); }

    void Next() { m_it_++; }

    bool IsDone() { return (m_it_ == m_p_data_->m_data_.end()); }

    iter_type Current() { return m_it_; }

   private:
    U *m_p_data_;
    iter_type m_it_;
};

/**
 * Конкретные Коллекции предоставляют один или несколько методов для получения
 * новых экземпляров итератора, совместимых с классом коллекции.
 */
template <class T>
class Container {
    friend class Iterator<T, Container>;

   public:
    void Add(T a) { m_data_.push_back(a); }

    Iterator<T, Container> *CreateIterator() { return new Iterator<T, Container>(this); }

   private:
    std::vector<T> m_data_;
};

class Data {
   public:
    Data(int a = 0) : m_data_(a) {}

    void set_data(int a) { m_data_ = a; }

    int data() { return m_data_; }

   private:
    int m_data_;
};

/**
 * The client code may or may not know about the Concrete Iterator or Collection
 * classes, for this implementation the container is generic so you can used
 * with an int or with a custom class.
 */
void ClientCode() {
    std::cout << "________________Iterator with int______________________________________" << std::endl;
    Container<int> cont;

    for (int i = 0; i < 10; i++) {
        cont.Add(i);
    }

    Iterator<int, Container<int>> *it = cont.CreateIterator();
    for (it->First(); !it->IsDone(); it->Next()) {
        std::cout << *it->Current() << std::endl;
    }

    Container<Data> cont2;
    Data a(100), b(1000), c(10000);
    cont2.Add(a);
    cont2.Add(b);
    cont2.Add(c);

    std::cout << "________________Iterator with custom Class______________________________" << std::endl;
    Iterator<Data, Container<Data>> *it2 = cont2.CreateIterator();
    for (it2->First(); !it2->IsDone(); it2->Next()) {
        std::cout << it2->Current()->data() << std::endl;
    }
    delete it;
    delete it2;
}

int main() {
    ClientCode();
    return 0;
}
```

Результат выполнения:

```
________________Iterator with int______________________________________
0
1
2
3
4
5
6
7
8
9
________________Iterator with custom Class______________________________
100
1000
10000
```

<hr>

[Содержание](#содержание)

## Посредник

`Посредник` — это поведенческий паттерн проектирования, который позволяет уменьшить связанность множества классов между собой, благодаря перемещению этих связей в один класс-посредник.

![04](/CPP_from_LETI/LETI_03/img/04_110.png)

__Проблема__

Предположим, что у вас есть диалог создания профиля пользователя. Он состоит из всевозможных элементов управления — текстовых полей, чекбоксов, кнопок.

![04](/CPP_from_LETI/LETI_03/img/04_111.png)

Отдельные элементы диалога должны взаимодействовать друг с другом. Так, например, чекбокс «у меня есть собака» открывает скрытое поле для ввода имени домашнего любимца, а клик по кнопке отправки запускает проверку значений всех полей формы.

![04](/CPP_from_LETI/LETI_03/img/04_112.png)

Прописав эту логику прямо в коде элементов управления, вы поставите крест на их повторном использовании в других местах приложения. Они станут слишком тесно связанными с элементами диалога редактирования профиля, которые не нужны в других контекстах. Поэтому вы сможете использовать либо все элементы сразу, либо ни одного.

__Решение__

Паттерн `Посредник` заставляет объекты общаться не напрямую друг с другом, а через отдельный объект-посредник, который знает, кому нужно перенаправить тот или иной запрос. Благодаря этому, компоненты системы будут зависеть только от посредника, а не от десятков других компонентов.

В нашем примере посредником мог бы стать диалог. Скорее всего, класс диалога и так знает, из каких элементов состоит, поэтому никаких новых связей добавлять в него не придётся.

![04](/CPP_from_LETI/LETI_03/img/04_113.png)

Основные изменения произойдут внутри отдельных элементов диалога. Если раньше при получении клика от пользователя объект кнопки сам проверял значения полей диалога, то теперь его единственной обязанностью будет сообщить диалогу о том, что произошёл клик. Получив извещение, диалог выполнит все необходимые проверки полей. Таким образом, вместо нескольких зависимостей от остальных элементов кнопка получит только одну — от самого диалога.

Чтобы сделать код ещё более гибким, можно выделить общий интерфейс для всех посредников, то есть диалогов программы. Наша кнопка станет зависимой не от конкретного диалога создания пользователя, а от абстрактного, что позволит использовать её и в других диалогах.

Таким образом, посредник скрывает в себе все сложные связи и зависимости между классами отдельных компонентов программы. А чем меньше связей имеют классы, тем проще их изменять, расширять и повторно использовать.

Аналогия из жизни

![04](/CPP_from_LETI/LETI_03/img/04_114.png)

Пилоты садящихся или улетающих самолётов не общаются напрямую с другими пилотами. Вместо этого они связываются с диспетчером, который координирует действия нескольких самолётов одновременно. Без диспетчера пилотам приходилось бы все время быть начеку и следить за всеми окружающими самолётами самостоятельно, а это приводило бы к частым катастрофам в небе.

Важно понимать, что диспетчер не нужен во время всего полёта. Он задействован только в зоне аэропорта, когда нужно координировать взаимодействие многих самолётов.

__Структура__

![04](/CPP_from_LETI/LETI_03/img/04_115.jpg)

__Применимость__

+ Когда вам сложно менять некоторые классы из-за того, что они имеют множество хаотичных связей с другими классами.<br>
`Посредник` позволяет поместить все эти связи в один класс, после чего вам будет легче их отрефакторить, сделать более понятными и гибкими.
+ Когда вы не можете повторно использовать класс, поскольку он зависит от уймы других классов.<br>
После применения паттерна компоненты теряют прежние связи с другими компонентами, а всё их общение происходит косвенно, через объект-посредник.
+ Когда вам приходится создавать множество подклассов компонентов, чтобы использовать одни и те же компоненты в разных контекстах.<br>
Если раньше изменение отношений в одном компоненте могли повлечь за собой лавину изменений во всех остальных компонентах, то теперь вам достаточно создать подкласс посредника и поменять в нём связи между компонентами.

__Шаги реализации__

1. Найдите группу тесно переплетённых классов, отвязав которые друг от друга, можно получить некоторую пользу. Например, чтобы повторно использовать их код в другой программе.
2. Создайте общий интерфейс посредников и опишите в нём методы для взаимодействия с компонентами. В простейшем случае достаточно одного метода для получения оповещений от компонентов.
3. Этот интерфейс необходим, если вы хотите повторно использовать классы компонентов для других задач. В этом случае всё, что нужно сделать — это создать новый класс конкретного посредника.
4. Реализуйте этот интерфейс в классе конкретного посредника. Поместите в него поля, которые будут содержать ссылки на все объекты компонентов.
5. Вы можете пойти дальше и переместить код создания компонентов в класс посредника, после чего он может напоминать фабрику или фасад.
6. Компоненты тоже должны иметь ссылку на объект посредника. Связь между ними удобнее всего установить, подавая посредника в параметры конструктора компонентов.
7. Измените код компонентов так, чтобы они вызывали метод оповещения посредника, вместо методов других компонентов. С противоположной стороны, посредник должен вызывать методы нужного компонента, когда получает оповещение от компонента.

__Преимущества и недостатки__

![04](/CPP_from_LETI/LETI_03/img/04_116.jpg)

__Отношения с другими паттернами__
+ `Цепочка обязанностей`, `Команда`, `Посредник` и `Наблюдатель` показывают различные способы работы отправителей запросов с их получателями:
    + `Цепочка обязанностей` передаёт запрос последовательно через цепочку потенциальных получателей, ожидая, что какой-то из них обработает запрос.
    + `Команда` устанавливает косвенную одностороннюю связь от отправителей к получателям.
    + `Посредник` убирает прямую связь между отправителями и получателями, заставляя их общаться опосредованно, через себя.
    + `Наблюдатель` передаёт запрос одновременно всем заинтересованным получателям, но позволяет им динамически подписываться или отписываться от таких оповещений.
+ `Посредник` и `Фасад` похожи тем, что пытаются организовать работу множества существующих классов.
+ `Фасад` создаёт упрощённый интерфейс к подсистеме, не внося в неё никакой добавочной функциональности. Сама подсистема не знает о существовании `Фасада`. Классы подсистемы общаются друг с другом напрямую.
+ `Посредник` централизует общение между компонентами системы. Компоненты системы знают только о существовании `Посредника`, у них нет прямого доступа к другим компонентам.
+ Разница между `Посредником` и `Наблюдателем` не всегда очевидна. Чаще всего они выступают как конкуренты, но иногда могут работать вместе.<br>
Цель `Посредника` — убрать обоюдные зависимости между компонентами системы. Вместо этого они становятся зависимыми от самого посредника. С другой стороны, цель `Наблюдателя` — обеспечить динамическую одностороннюю связь, в которой одни объекты косвенно зависят от других.<br>
Довольно популярна реализация `Посредника` при помощи `Наблюдателя`. При этом объект посредника будет выступать издателем, а все остальные компоненты станут подписчиками и смогут динамически следить за событиями, происходящими в посреднике. В этом случае трудно понять, чем же отличаются оба паттерна.<br>
Но `Посредник` имеет и другие реализации, когда отдельные компоненты жёстко привязаны к объекту посредника. Такой код вряд ли будет напоминать `Наблюдателя`, но всё же останется `Посредником`.<br>
Напротив, в случае реализации посредника с помощью `Наблюдателя` представим такую программу, в которой каждый компонент системы становится издателем. Компоненты могут подписываться друг на друга, в то же время не привязываясь к конкретным классам. Программа будет состоять из целой сети Наблюдателей, не имея центрального объекта-Посредника.

<hr>

[Содержание](#содержание)

## Пример использования паттерна Посредник (Mediator)

```c++
#include <iostream>
#include <string>
/**
 * Интерфейс Посредника предоставляет метод, используемый компонентами для
 * уведомления посредника о различных событиях. Посредник может реагировать на
 * эти события и передавать исполнение другим компонентам.
 */
class BaseComponent;
class Mediator {
   public:
    virtual void Notify(BaseComponent *sender, std::string event) const = 0;
};

/**
 * Базовый Компонент обеспечивает базовую функциональность хранения экземпляра
 * посредника внутри объектов компонентов.
 */
class BaseComponent {
   protected:
    Mediator *mediator_;

   public:
    BaseComponent(Mediator *mediator = nullptr) : mediator_(mediator) {}
    void set_mediator(Mediator *mediator) { this->mediator_ = mediator; }
};

/**
 * Конкретные Компоненты реализуют различную функциональность. Они не зависят от
 * других компонентов. Они также не зависят от каких-либо конкретных классов
 * посредников.
 */
class Component1 : public BaseComponent {
   public:
    void DoA() {
        std::cout << "Component 1 does A.\n";
        this->mediator_->Notify(this, "A");
    }
    void DoB() {
        std::cout << "Component 1 does B.\n";
        this->mediator_->Notify(this, "B");
    }
};

class Component2 : public BaseComponent {
   public:
    void DoC() {
        std::cout << "Component 2 does C.\n";
        this->mediator_->Notify(this, "C");
    }
    void DoD() {
        std::cout << "Component 2 does D.\n";
        this->mediator_->Notify(this, "D");
    }
};

/**
 * Конкретные Посредники реализуют совместное поведение, координируя отдельные
 * компоненты.
 */
class ConcreteMediator : public Mediator {
   private:
    Component1 *component1_;
    Component2 *component2_;

   public:
    ConcreteMediator(Component1 *c1, Component2 *c2) : component1_(c1), component2_(c2) {
        this->component1_->set_mediator(this);
        this->component2_->set_mediator(this);
    }
    void Notify(BaseComponent *sender, std::string event) const override {
        if (event == "A") {
            std::cout << "Mediator reacts on A and triggers following operations:\n";
            this->component2_->DoC();
        }
        if (event == "D") {
            std::cout << "Mediator reacts on D and triggers following operations:\n";
            this->component1_->DoB();
            this->component2_->DoC();
        }
    }
};

/**
 * Клиентский код.
 */

void ClientCode() {
    Component1 *c1 = new Component1;
    Component2 *c2 = new Component2;
    ConcreteMediator *mediator = new ConcreteMediator(c1, c2);
    std::cout << "Client triggers operation A.\n";
    c1->DoA();
    std::cout << "\n";
    std::cout << "Client triggers operation D.\n";
    c2->DoD();

    delete c1;
    delete c2;
    delete mediator;
}

int main() {
    ClientCode();
    return 0;
}
```

Результат выполнения:

```
Client triggers operation A.
Component 1 does A.
Mediator reacts on A and triggers following operations:
Component 2 does C.

Client triggers operation D.
Component 2 does D.
Mediator reacts on D and triggers following operations:
Component 1 does B.
Component 2 does C.
```

<hr>

[Содержание](#содержание)

## Снимок

`Снимок` — это поведенческий паттерн проектирования, который позволяет сохранять и восстанавливать прошлые состояния объектов, не раскрывая подробностей их реализации.

![04](/CPP_from_LETI/LETI_03/img/04_117.png)

__Проблема__

Предположим, что вы пишете программу текстового редактора. Помимо обычного редактирования, ваш редактор позволяет менять форматирование текста, вставлять картинки и прочее.

В какой-то момент вы решили сделать все эти действия отменяемыми. Для этого вам нужно сохранять текущее состояние редактора перед тем, как выполнить любое действие. Если потом пользователь решит отменить своё действие, вы достанете копию состояния из истории и восстановите старое состояние редактора.

![04](/CPP_from_LETI/LETI_03/img/04_118.png)

Чтобы сделать копию состояния объекта, достаточно скопировать значение его полей. Таким образом, если вы сделали класс редактора достаточно открытым, то любой другой класс сможет заглянуть внутрь, чтобы скопировать его состояние.

Казалось бы, что ещё нужно? Ведь теперь любая операция сможет сделать резервную копию редактора перед своим действием. Но такой наивный подход обеспечит вам уйму проблем в будущем. Ведь если вы решите провести рефакторинг — убрать или добавить парочку полей в класс редактора — то придётся менять код всех классов, которые могли копировать состояние редактора.

![04](/CPP_from_LETI/LETI_03/img/04_119.png)

Но это ещё не все. Давайте теперь рассмотрим сами копии состояния редактора. Из чего состоит состояние редактора? Даже самый примитивный редактор должен иметь несколько полей для хранения текущего текста, позиции курсора и прокрутки экрана. Чтобы сделать копию состояния, вам нужно записать значения всех этих полей в некий «контейнер».

Скорее всего, вам понадобится хранить массу таких контейнеров в качестве истории операций, поэтому удобнее всего сделать их объектами одного класса. Этот класс должен иметь много полей, но практически никаких методов. Чтобы другие объекты могли записывать и читать из него данные, вам придётся сделать его поля публичными. Но это приведёт к той же проблеме, что и с открытым классом редактора. Другие классы станут зависимыми от любых изменений в классе контейнера, который подвержен тем же изменениям, что и класс редактора.

Получается, нам придётся либо открыть классы для всех желающих, испытывая массу хлопот с поддержкой кода, либо оставить классы закрытыми, отказавшись от идеи отмены операций. Нет ли какого-то другого пути?

__Решение__

Все проблемы, описанные выше, возникают из-за нарушения инкапсуляции. Это когда одни объекты пытаются сделать работу за других, влезая в их приватную зону, чтобы собрать необходимые для операции данные.

Паттерн `Снимок` поручает создание копии состояния объекта самому объекту, который этим состоянием владеет. Вместо того, чтобы делать снимок «извне», наш редактор сам сделает копию своих полей, ведь ему доступны все поля, даже приватные.

Паттерн предлагает держать копию состояния в специальном объекте-снимке с ограниченным интерфейсом, позволяющим, например, узнать дату изготовления или название снимка. Но, с другой стороны, снимок должен быть открыт для своего создателя, позволяя прочесть и восстановить его внутреннее состояние.

![04](/CPP_from_LETI/LETI_03/img/04_120.png)

Такая схема позволяет создателям производить снимки и отдавать их для хранения другим объектам, называемым опекунами. Опекунам будет доступен только ограниченный интерфейс снимка, поэтому они никак не смогут повлиять на «внутренности» самого снимка. В нужный момент опекун может попросить создателя восстановить своё состояние, передав ему соответствующий снимок.

В примере с редактором вы можете сделать опекуном отдельный класс, который будет хранить список выполненных операций. Ограниченный интерфейс снимков позволит демонстрировать пользователю красивый список с названиями и датами выполненных операций. А когда пользователь решит откатить операцию, класс истории возьмёт последний снимок из стека и отправит его объекту редактор для восстановления.

__Структура__

Классическая реализация паттерна полагается на механизм вложенных классов, который доступен лишь в некоторых языках программирования (C++, C#, Java).

![04](/CPP_from_LETI/LETI_03/img/04_121.jpg)

__Применимость__

+ Когда вам нужно сохранять мгновенные снимки состояния объекта (или его части), чтобы впоследствии объект можно было восстановить в том же состоянии.<br>
Паттерн `Снимок` позволяет создавать любое количество снимков объекта и хранить их, независимо от объекта, с которого делают снимок. Снимки часто используют не только для реализации операции отмены, но и для транзакций, когда состояние объекта нужно «откатить», если операция не удалась.
+ Когда прямое получение состояния объекта раскрывает приватные детали его реализации, нарушая инкапсуляцию.<br>
Паттерн предлагает изготовить снимок самому исходному объекту, поскольку ему доступны все поля, даже приватные.

__Шаги реализации__

1. Определите класс создателя, объекты которого должны создавать снимки своего состояния.
2. Создайте класс снимка и опишите в нём все те же поля, которые имеются в оригинальном классе-создателе.
3. Сделайте объекты снимков неизменяемыми. Они должны получать начальные значения только один раз, через свой конструктор.
4. Если ваш язык программирования это позволяет, сделайте класс снимка вложенным в класс создателя. Если нет, извлеките из класса снимка пустой интерфейс, который будет доступен остальным объектам программы. Впоследствии вы можете добавить в этот интерфейс некоторые вспомогательные методы, дающие доступ к метаданным снимка, однако прямой доступ к данным создателя должен быть исключён.
5. Добавьте в класс создателя метод получения снимков. Создатель должен создавать новые объекты снимков, передавая значения своих полей через конструктор.
6. Сигнатура метода должна возвращать снимки через ограниченный интерфейс, если он у вас есть. Сам класс должен работать с конкретным классом снимка.
7. Добавьте в класс создателя метод восстановления из снимка. Что касается привязки к типам, руководствуйтесь той же логикой, что и в пункте 4.
8. Опекуны, будь то история операций, объекты команд или нечто иное, должны знать о том, когда запрашивать снимки у создателя, где их хранить и когда восстанавливать.
9. Связь опекунов с создателями можно перенести внутрь снимков. В этом случае каждый снимок будет привязан к своему создателю и должен будет сам восстанавливать его состояние. Но это будет работать либо если классы снимков вложены в классы создателей, либо если создатели имеют соответствующие сеттеры для установки значений своих полей.

__Преимущества и недостатки__

![04](/CPP_from_LETI/LETI_03/img/04_122.jpg)

__Отношения с другими паттернами__

+ `Команду` и `Снимок` можно использовать сообща для реализации отмены операций. В этом случае объекты команд будут отвечать за выполнение действия над объектом, а снимки будут хранить резервную копию состояния этого объекта, сделанную перед самым запуском команды.
+ `Снимок` можно использовать вместе с `Итератором`, чтобы сохранить текущее состояние обхода структуры данных и вернуться к нему в будущем, если потребуется.
+ `Снимок` иногда можно заменить `Прототипом`, если объект, состояние которого требуется сохранять в истории, довольно простой, не имеет активных ссылок на внешние ресурсы либо их можно легко восстановить.

<hr>

[Содержание](#содержание)

## Пример использования паттерна Снимок (Memento)

```c++
#include <ctime>
#include <iostream>

/**
 * Интерфейс Снимка предоставляет способ извлечения метаданных снимка, таких как
 * дата создания или название. Однако он не раскрывает состояние Создателя.
 */
class Memento {
   public:
    virtual std::string GetName() const = 0;
    virtual std::string date() const = 0;
    virtual std::string state() const = 0;
};

/**
 * Конкретный снимок содержит инфраструктуру для хранения состояния Создателя.
 */
class ConcreteMemento : public Memento {
   private:
    std::string state_;
    std::string date_;

   public:
    ConcreteMemento(std::string state) : state_(state) {
        this->state_ = state;
        std::time_t now = std::time(0);
        this->date_ = std::ctime(&now);
    }
    /**
     * Создатель использует этот метод, когда восстанавливает своё состояние.
     */
    std::string state() const override { return this->state_; }
    /**
     * Остальные методы используются Опекуном для отображения метаданных.
     */
    std::string GetName() const override { return this->date_ + " / (" + this->state_.substr(0, 9) + "...)"; }
    std::string date() const override { return this->date_; }
};

/**
 * Создатель содержит некоторое важное состояние, которое может со временем
 * меняться. Он также объявляет метод сохранения состояния внутри снимка и метод
 * восстановления состояния из него.
 */
class Originator {
    /**
     * @var string Для удобства состояние создателя хранится внутри одной
     * переменной.
     */
   private:
    std::string state_;

    std::string GenerateRandomString(int length = 10) {
        const char alphanum[] =
            "0123456789"
            "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
            "abcdefghijklmnopqrstuvwxyz";
        int stringLength = sizeof(alphanum) - 1;

        std::string random_string;
        for (int i = 0; i < length; i++) {
            random_string += alphanum[std::rand() % stringLength];
        }
        return random_string;
    }

   public:
    Originator(std::string state) : state_(state) {
        std::cout << "Originator: My initial state is: " << this->state_ << "\n";
    }
    /**
     * Бизнес-логика Создателя может повлиять на его внутреннее состояние. Поэтому
     * клиент должен выполнить резервное копирование состояния с помощью метода
     * save перед запуском методов бизнес-логики.
     */
    void DoSomething() {
        std::cout << "Originator: I'm doing something important.\n";
        this->state_ = this->GenerateRandomString(30);
        std::cout << "Originator: and my state has changed to: " << this->state_ << "\n";
    }

    /**
     * Сохраняет текущее состояние внутри снимка.
     */
    Memento *Save() { return new ConcreteMemento(this->state_); }
    /**
     * Восстанавливает состояние Создателя из объекта снимка.
     */
    void Restore(Memento *memento) {
        this->state_ = memento->state();
        std::cout << "Originator: My state has changed to: " << this->state_ << "\n";
    }
};

/**
 * Опекун не зависит от класса Конкретного Снимка. Таким образом, он не имеет
 * доступа к состоянию создателя, хранящемуся внутри снимка. Он работает со
 * всеми снимками через базовый интерфейс Снимка.
 */
class Caretaker {
    /**
     * @var Memento[]
     */
   private:
    std::vector<Memento *> mementos_;

    /**
     * @var Originator
     */
    Originator *originator_;

   public:
    Caretaker(Originator *originator) : originator_(originator) { this->originator_ = originator; }

    void Backup() {
        std::cout << "\nCaretaker: Saving Originator's state...\n";
        this->mementos_.push_back(this->originator_->Save());
    }
    void Undo() {
        if (!this->mementos_.size()) {
            return;
        }
        Memento *memento = this->mementos_.back();
        this->mementos_.pop_back();
        std::cout << "Caretaker: Restoring state to: " << memento->GetName() << "\n";
        try {
            this->originator_->Restore(memento);
        } catch (...) {
            this->Undo();
        }
    }
    void ShowHistory() const {
        std::cout << "Caretaker: Here's the list of mementos:\n";
        for (Memento *memento : this->mementos_) {
            std::cout << memento->GetName() << "\n";
        }
    }
};
/**
 * Клиентский код.
 */

void ClientCode() {
    Originator *originator = new Originator("Super-duper-super-puper-super.");
    Caretaker *caretaker = new Caretaker(originator);
    caretaker->Backup();
    originator->DoSomething();
    caretaker->Backup();
    originator->DoSomething();
    caretaker->Backup();
    originator->DoSomething();
    std::cout << "\n";
    caretaker->ShowHistory();
    std::cout << "\nClient: Now, let's rollback!\n\n";
    caretaker->Undo();
    std::cout << "\nClient: Once more!\n\n";
    caretaker->Undo();

    delete originator;
    delete caretaker;
}

int main() {
    std::srand(static_cast<unsigned int>(std::time(NULL)));
    ClientCode();
    return 0;
}
```

Результат выполнения:

```bash
Originator: My initial state is: Super-duper-super-puper-super.

Caretaker: Saving Originator's state...
Originator: I'm doing something important.
Originator: and my state has changed to: uOInE8wmckHYPwZS7PtUTwuwZfCIbz

Caretaker: Saving Originator's state...
Originator: I'm doing something important.
Originator: and my state has changed to: te6RGmykRpbqaWo5MEwjji1fpM1t5D

Caretaker: Saving Originator's state...
Originator: I'm doing something important.
Originator: and my state has changed to: hX5xWDVljcQ9ydD7StUfbBt5Z7pcSN

Caretaker: Here's the list of mementos:
Sat Oct 19 18:09:37 2019
 / (Super-dup...)
Sat Oct 19 18:09:37 2019
 / (uOInE8wmc...)
Sat Oct 19 18:09:37 2019
 / (te6RGmykR...)

Client: Now, let's rollback!

Caretaker: Restoring state to: Sat Oct 19 18:09:37 2019
 / (te6RGmykR...)
Originator: My state has changed to: te6RGmykRpbqaWo5MEwjji1fpM1t5D

Client: Once more!

Caretaker: Restoring state to: Sat Oct 19 18:09:37 2019
 / (uOInE8wmc...)
Originator: My state has changed to: uOInE8wmckHYPwZS7PtUTwuwZfCIbz
```

<hr>

[Содержание](#содержание)

## Наблюдатель

__Наблюдатель__ — это поведенческий паттерн проектирования, который создаёт механизм подписки, позволяющий одним объектам следить и реагировать на события, происходящие в других объектах.

![04](/CPP_from_LETI/LETI_03/img/04_123.png)

__Проблема__

Представьте, что вы имеете два объекта: `Покупатель` и `Магазин`. В магазин вот-вот должны завезти новый товар, который интересен покупателю.

Покупатель может каждый день ходить в магазин, чтобы проверить наличие товара. Но при этом он будет злиться, без толку тратя своё драгоценное время.

![04](/CPP_from_LETI/LETI_03/img/04_124.png)

С другой стороны, магазин может разослать спам каждому своему покупателю. Многих это расстроит, так как товар специфический, и не всем он нужен.

Получается конфликт: либо покупатель тратит время на периодические проверки, либо магазин тратит ресурсы на бесполезные оповещения.

__Решение__

Давайте называть `Издателями` те объекты, которые содержат важное или интересное для других состояние. Остальные объекты, которые хотят отслеживать изменения этого состояния, назовём `Подписчиками`.

Паттерн `Наблюдатель` предлагает хранить внутри объекта издателя список ссылок на объекты подписчиков, причём издатель не должен вести список подписки самостоятельно. Он предоставит методы, с помощью которых подписчики могли бы добавлять или убирать себя из списка.

![04](/CPP_from_LETI/LETI_03/img/04_125.png)

Теперь самое интересное. Когда в издателе будет происходить важное событие, он будет проходиться по списку подписчиков и оповещать их об этом, вызывая определённый метод объектов-подписчиков.

Издателю безразлично, какой класс будет иметь тот или иной подписчик, так как все они должны следовать общему интерфейсу и иметь единый метод оповещения.

![04](/CPP_from_LETI/LETI_03/img/04_126.png)

Увидев, как складно всё работает, вы можете выделить общий интерфейс, описывающий методы подписки и отписки, и для всех издателей. После этого подписчики смогут работать с разными типами издателей, а также получать оповещения от них через один и тот же метод.

__Аналогия из жизни__

![04](/CPP_from_LETI/LETI_03/img/04_127.png)

После того как вы оформили подписку на газету или журнал, вам больше не нужно ездить в супермаркет и проверять, не вышел ли очередной номер. Вместо этого издательство будет присылать новые номера по почте прямо к вам домой сразу после их выхода.

Издательство ведёт список подписчиков и знает, кому какой журнал высылать. Вы можете в любой момент отказаться от подписки, и журнал перестанет вам приходить.

__Структура__

![04](/CPP_from_LETI/LETI_03/img/04_128.jpg)

__Применимость__

+ Когда после изменения состояния одного объекта требуется что-то сделать в других, но вы не знаете наперёд, какие именно объекты должны отреагировать.<br>
Описанная проблема может возникнуть при разработке библиотек пользовательского интерфейса, когда вам надо дать возможность сторонним классам реагировать на клики по кнопкам.<br>
Паттерн `Наблюдатель` позволяет любому объекту с интерфейсом подписчика зарегистрироваться на получение оповещений о событиях, происходящих в объектах-издателях.
+ Когда одни объекты должны наблюдать за другими, но только в определённых случаях.<br>
Издатели ведут динамические списки. Все наблюдатели могут подписываться или отписываться от получения оповещений прямо во время выполнения программы.

__Шаги реализации__
1. Разбейте вашу функциональность на две части: независимое ядро и опциональные зависимые части. Независимое ядро станет издателем. Зависимые части станут подписчиками.
2. Создайте интерфейс подписчиков. Обычно в нём достаточно определить единственный метод оповещения.
3. Создайте интерфейс издателей и опишите в нём операции управления подпиской. Помните, что издатель должен работать только с общим интерфейсом подписчиков.
4. Вам нужно решить, куда поместить код ведения подписки, ведь он обычно бывает одинаков для всех типов издателей. Самый очевидный способ — вынести этот код в промежуточный абстрактный класс, от которого будут наследоваться все издатели.<br>
Но если вы интегрируете паттерн в существующие классы, то создать новый базовый класс может быть затруднительно. В этом случае вы можете поместить логику подписки во вспомогательный объект и делегировать ему работу из издателей.
5. Создайте классы конкретных издателей. Реализуйте их так, чтобы после каждого изменения состояния они отправляли оповещения всем своим подписчикам.
6. Реализуйте метод оповещения в конкретных подписчиках. Не забудьте предусмотреть параметры, через которые издатель мог бы отправлять какие-то данные, связанные с происшедшим событием.<br>
Возможен и другой вариант, когда подписчик, получив оповещение, сам возьмёт из объекта издателя нужные данные. Но в этом случае вы будете вынуждены привязать класс подписчика к конкретному классу издателя.
7. Клиент должен создавать необходимое количество объектов подписчиков и подписывать их у издателей.

__Преимущества и недостатки__

![04](/CPP_from_LETI/LETI_03/img/04_129.jpg)

__Отношения с другими паттернами__

+ `Цепочка обязанностей`, `Команда`, `Посредник` и `Наблюдатель` показывают различные способы работы отправителей запросов с их получателями:
    + `Цепочка обязанностей` передаёт запрос последовательно через цепочку потенциальных получателей, ожидая, что какой-то из них обработает запрос.
    + `Команда` устанавливает косвенную одностороннюю связь от отправителей к получателям.
    + `Посредник` убирает прямую связь между отправителями и получателями, заставляя их общаться опосредованно, через себя.
    + `Наблюдатель` передаёт запрос одновременно всем заинтересованным получателям, но позволяет им динамически подписываться или отписываться от таких оповещений.
+ Разница между `Посредником` и `Наблюдателем` не всегда очевидна. Чаще всего они выступают как конкуренты, но иногда могут работать вместе.<br>
Цель `Посредника` — убрать обоюдные зависимости между компонентами системы. Вместо этого они становятся зависимыми от самого посредника. С другой стороны, цель Наблюдателя — обеспечить динамическую одностороннюю связь, в которой одни объекты косвенно зависят от других.<br>
Довольно популярна реализация `Посредника` при помощи `Наблюдателя`. При этом объект посредника будет выступать издателем, а все остальные компоненты станут подписчиками и смогут динамически следить за событиями, происходящими в посреднике. В этом случае трудно понять, чем же отличаются оба паттерна.<br>
Но `Посредник` имеет и другие реализации, когда отдельные компоненты жёстко привязаны к объекту посредника. Такой код вряд ли будет напоминать `Наблюдателя`, но всё же останется `Посредником`.<br>
Напротив, в случае реализации посредника с помощью Наблюдателя представим такую программу, в которой каждый компонент системы становится издателем. Компоненты могут подписываться друг на друга, в то же время не привязываясь к конкретным классам. Программа будет состоять из целой сети `Наблюдателей`, не имея центрального объекта-`Посредника`.

<hr>

[Содержание](#содержание)

## Примеры реализации паттерна Наблюдатель

```c++
#include <iostream>
#include <list>
#include <string>

class IObserver {
   public:
    virtual ~IObserver(){};
    virtual void Update(const std::string &message_from_subject) = 0;
};

class ISubject {
   public:
    virtual ~ISubject(){};
    virtual void Attach(IObserver *observer) = 0;
    virtual void Detach(IObserver *observer) = 0;
    virtual void Notify() = 0;
};

/**
 * Издатель владеет некоторым важным состоянием и оповещает наблюдателей о его
 * изменениях.
 */

class Subject : public ISubject {
   public:
    virtual ~Subject() { std::cout << "Goodbye, I was the Subject.\n"; }

    /**
     * Методы управления подпиской.
     */
    void Attach(IObserver *observer) override { list_observer_.push_back(observer); }
    void Detach(IObserver *observer) override { list_observer_.remove(observer); }
    void Notify() override {
        std::list<IObserver *>::iterator iterator = list_observer_.begin();
        HowManyObserver();
        while (iterator != list_observer_.end()) {
            (*iterator)->Update(message_);
            ++iterator;
        }
    }

    void CreateMessage(std::string message = "Empty") {
        this->message_ = message;
        Notify();
    }
    void HowManyObserver() {
        std::cout << "There are " << list_observer_.size() << " observers in the list.\n";
    }

    /**
     * Обычно логика подписки – только часть того, что делает Издатель. Издатели
     * часто содержат некоторую важную бизнес-логику, которая запускает метод
     * уведомления всякий раз, когда должно произойти что-то важное (или после
     * этого).
     */
    void SomeBusinessLogic() {
        this->message_ = "change message message";
        Notify();
        std::cout << "I'm about to do some thing important\n";
    }

   private:
    std::list<IObserver *> list_observer_;
    std::string message_;
};

class Observer : public IObserver {
   public:
    Observer(Subject &subject) : subject_(subject) {
        this->subject_.Attach(this);
        std::cout << "Hi, I'm the Observer \"" << ++Observer::static_number_ << "\".\n";
        this->number_ = Observer::static_number_;
    }
    virtual ~Observer() { std::cout << "Goodbye, I was the Observer \"" << this->number_ << "\".\n"; }

    void Update(const std::string &message_from_subject) override {
        message_from_subject_ = message_from_subject;
        PrintInfo();
    }
    void RemoveMeFromTheList() {
        subject_.Detach(this);
        std::cout << "Observer \"" << number_ << "\" removed from the list.\n";
    }
    void PrintInfo() {
        std::cout << "Observer \"" << this->number_ << "\": a new message is available --> "
                  << this->message_from_subject_ << "\n";
    }

   private:
    std::string message_from_subject_;
    Subject &subject_;
    static int static_number_;
    int number_;
};

int Observer::static_number_ = 0;

void ClientCode() {
    Subject *subject = new Subject;
    Observer *observer1 = new Observer(*subject);
    Observer *observer2 = new Observer(*subject);
    Observer *observer3 = new Observer(*subject);
    Observer *observer4;
    Observer *observer5;

    subject->CreateMessage("Hello World! :D");
    observer3->RemoveMeFromTheList();

    subject->CreateMessage("The weather is hot today! :p");
    observer4 = new Observer(*subject);

    observer2->RemoveMeFromTheList();
    observer5 = new Observer(*subject);

    subject->CreateMessage("My new car is great! ;)");
    observer5->RemoveMeFromTheList();

    observer4->RemoveMeFromTheList();
    observer1->RemoveMeFromTheList();

    delete observer5;
    delete observer4;
    delete observer3;
    delete observer2;
    delete observer1;
    delete subject;
}

int main() {
    ClientCode();
    return 0;
}
```

Результат выполнения:

```
Hi, I'm the Observer "1".
Hi, I'm the Observer "2".
Hi, I'm the Observer "3".
There are 3 observers in the list.
Observer "1": a new message is available --> Hello World! :D
Observer "2": a new message is available --> Hello World! :D
Observer "3": a new message is available --> Hello World! :D
Observer "3" removed from the list.
There are 2 observers in the list.
Observer "1": a new message is available --> The weather is hot today! :p
Observer "2": a new message is available --> The weather is hot today! :p
Hi, I'm the Observer "4".
Observer "2" removed from the list.
Hi, I'm the Observer "5".
There are 3 observers in the list.
Observer "1": a new message is available --> My new car is great! ;)
Observer "4": a new message is available --> My new car is great! ;)
Observer "5": a new message is available --> My new car is great! ;)
Observer "5" removed from the list.
Observer "4" removed from the list.
Observer "1" removed from the list.
Goodbye, I was the Observer "5".
Goodbye, I was the Observer "4".
Goodbye, I was the Observer "3".
Goodbye, I was the Observer "2".
Goodbye, I was the Observer "1".
Goodbye, I was the Subject.
```

<hr>

[Содержание](#содержание)

## Состояние

__Состояние__ — это поведенческий паттерн проектирования, который позволяет объектам менять поведение в зависимости от своего состояния. Извне создаётся впечатление, что изменился класс объекта.

![04](/CPP_from_LETI/LETI_03/img/04_130.png)

__Проблема__

Паттерн `Состояние` невозможно рассматривать в отрыве от концепции машины состояний, также известной как стейт-машина или конечный автомат.

![04](/CPP_from_LETI/LETI_03/img/04_131.png)

Основная идея в том, что программа может находиться в одном из нескольких состояний, которые всё время сменяют друг друга. Набор этих состояний, а также переходов между ними, предопределён и конечен. Находясь в разных состояниях, программа может по-разному реагировать на одни и те же события, которые происходят с ней.

Такой подход можно применить и к отдельным объектам. Например, объект `Документ` может принимать три состояния: `Черновик`, `Модерация` или `Опубликован`. В каждом из этих состоянии метод опубликовать будет работать по-разному:
+ Из черновика он отправит документ на модерацию.
+ Из модерации — в публикацию, но при условии, что это сделал администратор.
+ В опубликованном состоянии метод не будет делать ничего.

![04](/CPP_from_LETI/LETI_03/img/04_132.png)

Машину состояний чаще всего реализуют с помощью множества условных операторов, `if` либо `switch`, которые проверяют текущее состояние объекта и выполняют соответствующее поведение. Наверняка вы уже реализовали хотя бы одну машину состояний в своей жизни, даже не зная об этом. Как насчёт вот такого кода, выглядит знакомо?

```c++
class Document is
    field state: string
    // ...
    method publish() is
        switch (state)
            "draft":
                state = "moderation"
                break
            "moderation":
                if (currentUser.role == 'admin')
                    state = "published"
                break
            "published":
                // Do nothing.
                break
    // ...
```
Основная проблема такой машины состояний проявится в том случае, если в `Документ` добавить ещё десяток состояний. Каждый метод будет состоять из увесистого условного оператора, перебирающего доступные состояния. Такой код крайне сложно поддерживать. Малейшее изменение логики переходов заставит вас перепроверять работу всех методов, которые содержат условные операторы машины состояний.

Путаница и нагромождение условий особенно сильно проявляется в старых проектах. Набор возможных состояний бывает трудно предопределить заранее, поэтому они всё время добавляются в процессе эволюции программы. Из-за этого решение, которое выглядело простым и эффективным в самом начале разработки, может впоследствии стать проекцией большого макаронного монстра.

__Решение__

Паттерн `Состояние` предлагает создать отдельные классы для каждого состояния, в котором может пребывать объект, а затем вынести туда поведения, соответствующие этим состояниям.

Вместо того, чтобы хранить код всех состояний, первоначальный объект, называемый контекстом, будет содержать ссылку на один из объектов-состояний и делегировать ему работу, зависящую от состояния.

![04](/CPP_from_LETI/LETI_03/img/04_133.png)

Благодаря тому, что объекты состояний будут иметь общий интерфейс, контекст сможет делегировать работу состоянию, не привязываясь к его классу. Поведение контекста можно будет изменить в любой момент, подключив к нему другой объект-состояние.

Очень важным нюансом, отличающим этот паттерн от `Стратегии`, является то, что и контекст, и сами конкретные состояния могут знать друг о друге и инициировать переходы от одного состояния к другому.

Аналогия из жизни
Ваш смартфон ведёт себя по-разному, в зависимости от текущего состояния:
+ Когда телефон разблокирован, нажатие кнопок телефона приводит к каким-то действиям.
+ Когда телефон заблокирован, нажатие кнопок приводит к экрану разблокировки.
+ Когда телефон разряжен, нажатие кнопок приводит к экрану зарядки.

__Структура__

![04](/CPP_from_LETI/LETI_03/img/04_134.jpg)

__Применимость__

+ Когда у вас есть объект, поведение которого кардинально меняется в зависимости от внутреннего состояния, причём типов состояний много, и их код часто меняется.<br>
Паттерн предлагает выделить в собственные классы все поля и методы, связанные с определёнными состояниями. Первоначальный объект будет постоянно ссылаться на один из объектов-состояний, делегируя ему часть своей работы. Для изменения состояния в контекст достаточно будет подставить другой объект-состояние.
+ Когда код класса содержит множество больших, похожих друг на друга, условных операторов, которые выбирают поведения в зависимости от текущих значений полей класса.<br>
Паттерн предлагает переместить каждую ветку такого условного оператора в собственный класс. Тут же можно поселить и все поля, связанные с данным состоянием.
+ Когда вы сознательно используете табличную машину состояний, построенную на условных операторах, но вынуждены мириться с дублированием кода для похожих состояний и переходов.<br>
Паттерн `Состояние` позволяет реализовать иерархическую машину состояний, базирующуюся на наследовании. Вы можете отнаследовать похожие состояния от одного родительского класса и вынести туда весь дублирующий код.

__Шаги реализации__

1. Определитесь с классом, который будет играть роль контекста. Это может быть как существующий класс, в котором уже есть зависимость от состояния, так и новый класс, если код состояний размазан по нескольким классам.
2. Создайте общий интерфейс состояний. Он должен описывать методы, общие для всех состояний, обнаруженных в контексте. Заметьте, что не всё поведение контекста нужно переносить в состояние, а только то, которое зависит от состояний.
3. Для каждого фактического состояния создайте класс, реализующий интерфейс состояния. Переместите код, связанный с конкретными состояниями в нужные классы. В конце концов, все методы интерфейса состояния должны быть реализованы во всех классах состояний.
4. При переносе поведения из контекста вы можете столкнуться с тем, что это поведение зависит от приватных полей или методов контекста, к которым нет доступа из объекта состояния. Существует парочка способов обойти эту проблему.
5. Самый простой — оставить поведение внутри контекста, вызывая его из объекта состояния. С другой стороны, вы можете сделать классы состояний вложенными в класс контекста, и тогда они получат доступ ко всем приватным частям контекста. Но последний способ доступен только в некоторых языках программирования (например, Java, C#).
6. Создайте в контексте поле для хранения объектов-состояний, а также публичный метод для изменения значения этого поля.
7. Старые методы контекста, в которых находился зависимый от состояния код, замените на вызовы соответствующих методов объекта-состояния.
8. В зависимости от бизнес-логики, разместите код, который переключает состояние контекста либо внутри контекста, либо внутри классов конкретных состояний.

__Преимущества и недостатки__

![04](/CPP_from_LETI/LETI_03/img/04_135.jpg)

__Отношения с другими паттернами__

+ `Мост`, `Стратегия` и `Состояние` (а также слегка и `Адаптер`) имеют схожие структуры классов — все они построены на принципе «композиции», то есть делегирования работы другим объектам. Тем не менее, они отличаются тем, что решают разные проблемы. Помните, что паттерны — это не только рецепт построения кода определённым образом, но и описание проблем, которые привели к данному решению.

Состояние можно рассматривать как надстройку над `Стратегией`. Оба паттерна используют композицию, чтобы менять поведение основного объекта, делегируя работу вложенным объектам-помощникам. Однако в `Стратегии` эти объекты не знают друг о друге и никак не связаны. В `Состоянии` сами конкретные состояния могут переключать контекст.

<hr>

[Содержание](#содержание)

## Примеры использования паттерна Состояние (State)

```c++
 * Контекст определяет интерфейс, представляющий интерес для клиентов. Он также
 * хранит ссылку на экземпляр подкласса Состояния, который отображает текущее
 * состояние Контекста.
 */
class Context {
    /**
     * @var State Ссылка на текущее состояние Контекста.
     */
   private:
    State *state_;

   public:
    Context(State *state) : state_(nullptr) { this->TransitionTo(state); }
    ~Context() { delete state_; }
    /**
     * Контекст позволяет изменять объект Состояния во время выполнения.
     */
    void TransitionTo(State *state) {
        std::cout << "Context: Transition to " << typeid(*state).name() << ".\n";
        if (this->state_ != nullptr) delete this->state_;
        this->state_ = state;
        this->state_->set_context(this);
    }
    /**
     * Контекст делегирует часть своего поведения текущему объекту Состояния.
     */
    void Request1() { this->state_->Handle1(); }
    void Request2() { this->state_->Handle2(); }
};

/**
 * Конкретные Состояния реализуют различные модели поведения, связанные с
 * состоянием Контекста.
 */

class ConcreteStateA : public State {
   public:
    void Handle1() override;

    void Handle2() override { std::cout << "ConcreteStateA handles request2.\n"; }
};

class ConcreteStateB : public State {
   public:
    void Handle1() override { std::cout << "ConcreteStateB handles request1.\n"; }
    void Handle2() override {
        std::cout << "ConcreteStateB handles request2.\n";
        std::cout << "ConcreteStateB wants to change the state of the context.\n";
        this->context_->TransitionTo(new ConcreteStateA);
    }
};

void ConcreteStateA::Handle1() {
    {
        std::cout << "ConcreteStateA handles request1.\n";
        std::cout << "ConcreteStateA wants to change the state of the context.\n";

        this->context_->TransitionTo(new ConcreteStateB);
    }
}

/**
 * Клиентский код.
 */
void ClientCode() {
    Context *context = new Context(new ConcreteStateA);
    context->Request1();
    context->Request2();
    delete context;
}

int main() {
    ClientCode();
    return 0;
}
```

Результат выполнения:

```
Context: Transition to 14ConcreteStateA.
ConcreteStateA handles request1.
ConcreteStateA wants to change the state of the context.
Context: Transition to 14ConcreteStateB.
ConcreteStateB handles request2.
ConcreteStateB wants to change the state of the context.
Context: Transition to 14ConcreteStateA.
```

<hr>

[Содержание](#содержание)

## Стратегия

__Стратегия__ — это поведенческий паттерн проектирования, который определяет семейство схожих алгоритмов и помещает каждый из них в собственный класс, после чего алгоритмы можно взаимозаменять прямо во время исполнения программы.

![04](/CPP_from_LETI/LETI_03/img/04_136.png)

__Проблема__

Вы решили написать приложение-навигатор для путешественников. Оно должно показывать красивую и удобную карту, позволяющую с лёгкостью ориентироваться в незнакомом городе.

Одной из самых востребованных функций являлся поиск и прокладывание маршрутов. Пребывая в неизвестном ему городе, пользователь должен иметь возможность указать начальную точку и пункт назначения, а навигатор — проложит оптимальный путь.

Первая версия вашего навигатора могла прокладывать маршрут лишь по дорогам, поэтому отлично подходила для путешествий на автомобиле. Но, очевидно, не все ездят в отпуск на машине. Поэтому следующим шагом вы добавили в навигатор прокладывание пеших маршрутов.

Через некоторое время выяснилось, что некоторые люди предпочитают ездить по городу на общественном транспорте. Поэтому вы добавили и такую опцию прокладывания пути.

Но и это ещё не всё. В ближайшей перспективе вы хотели бы добавить прокладывание маршрутов по велодорожкам. А в отдалённом будущем — интересные маршруты посещения достопримечательностей.

![04](/CPP_from_LETI/LETI_03/img/04_137.png)

Если с популярностью навигатора не было никаких проблем, то техническая часть вызывала вопросы и периодическую головную боль. С каждым новым алгоритмом код основного класса навигатора увеличивался вдвое. В таком большом классе стало довольно трудно ориентироваться.

Любое изменение алгоритмов поиска, будь то исправление багов или добавление нового алгоритма, затрагивало основной класс. Это повышало риск сделать ошибку, случайно задев остальной работающий код.

Кроме того, осложнялась командная работа с другими программистами, которых вы наняли после успешного релиза навигатора. Ваши изменения нередко затрагивали один и тот же код, создавая конфликты, которые требовали дополнительного времени на их разрешение.

__Решение__

Паттерн `Стратегия` предлагает определить семейство схожих алгоритмов, которые часто изменяются или расширяются, и вынести их в собственные классы, называемые стратегиями.

Вместо того, чтобы изначальный класс сам выполнял тот или иной алгоритм, он будет играть роль контекста, ссылаясь на одну из стратегий и делегируя ей выполнение работы. Чтобы сменить алгоритм, вам будет достаточно подставить в контекст другой объект-стратегию.

Важно, чтобы все стратегии имели общий интерфейс. Используя этот интерфейс, контекст будет независимым от конкретных классов стратегий. С другой стороны, вы сможете изменять и добавлять новые виды алгоритмов, не трогая код контекста.

![04](/CPP_from_LETI/LETI_03/img/04_138.png)

В нашем примере каждый алгоритм поиска пути переедет в свой собственный класс. В этих классах будет определён лишь один метод, принимающий в параметрах координаты начала и конца пути, а возвращающий массив точек маршрута.

Хотя каждый класс будет прокладывать маршрут по-своему, для навигатора это не будет иметь никакого значения, так как его работа заключается только в отрисовке маршрута. Навигатору достаточно подать в стратегию данные о начале и конце маршрута, чтобы получить массив точек маршрута в оговорённом формате.

Класс навигатора будет иметь метод для установки стратегии, позволяя изменять стратегию поиска пути на лету. Такой метод пригодится клиентскому коду навигатора, например, переключателям типов маршрутов в пользовательском интерфейсе.

__Аналогия из жизни__

![04](/CPP_from_LETI/LETI_03/img/04_139.png)

Вам нужно добраться до аэропорта. Можно доехать на автобусе, такси или велосипеде. Здесь вид транспорта является стратегией. Вы выбираете конкретную стратегию в зависимости от контекста — наличия денег или времени до отлёта.

__Структура__

![04](/CPP_from_LETI/LETI_03/img/04_140.jpg)

__Применимость__

+ Когда вам нужно использовать разные вариации какого-то алгоритма внутри одного объекта.<br>
`Стратегия` позволяет варьировать поведение объекта во время выполнения программы, подставляя в него различные объекты-поведения (например, отличающиеся балансом скорости и потребления ресурсов).
+ Когда у вас есть множество похожих классов, отличающихся только некоторым поведением.<br>
`Стратегия` позволяет вынести отличающееся поведение в отдельную иерархию классов, а затем свести первоначальные классы к одному, сделав поведение этого класса настраиваемым.
+ Когда вы не хотите обнажать детали реализации алгоритмов для других классов.<br>
`Стратегия` позволяет изолировать код, данные и зависимости алгоритмов от других объектов, скрыв эти детали внутри классов-стратегий.
+ Когда различные вариации алгоритмов реализованы в виде развесистого условного оператора. Каждая ветка такого оператора представляет собой вариацию алгоритма.<br>
`Стратегия` помещает каждую лапу такого оператора в отдельный класс-стратегию. Затем контекст получает определённый объект-стратегию от клиента и делегирует ему работу. Если вдруг понадобится сменить алгоритм, в контекст можно подать другую стратегию.

__Шаги реализации__

1. Определите алгоритм, который подвержен частым изменениям. Также подойдёт алгоритм, имеющий несколько вариаций, которые выбираются во время выполнения программы.
2. Создайте интерфейс стратегий, описывающий этот алгоритм. Он должен быть общим для всех вариантов алгоритма.
3. Поместите вариации алгоритма в собственные классы, которые реализуют этот интерфейс.
4. В классе контекста создайте поле для хранения ссылки на текущий объект-стратегию, а также метод для её изменения. Убедитесь в том, что контекст работает с этим объектом только через общий интерфейс стратегий.
5. Клиенты контекста должны подавать в него соответствующий объект-стратегию, когда хотят, чтобы контекст вёл себя определённым образом.

__Преимущества и недостатки__

![04](/CPP_from_LETI/LETI_03/img/04_141.jpg)

__Отношения с другими паттернами__

+ `Мост`, `Стратегия` и `Состояние` (а также слегка и `Адаптер`) имеют схожие структуры классов — все они построены на принципе «композиции», то есть делегирования работы другим объектам. Тем не менее, они отличаются тем, что решают разные проблемы. Помните, что паттерны — это не только рецепт построения кода определённым образом, но и описание проблем, которые привели к данному решению.
+ `Команда` и `Стратегия` похожи по духу, но отличаются масштабом и применением:
    + `Команду` используют, чтобы превратить любые разнородные действия в объекты. Параметры операции превращаются в поля объекта. Этот объект теперь можно логировать, хранить в истории для отмены, передавать во внешние сервисы и так далее.
    + С другой стороны, `Стратегия` описывает разные способы произвести одно и то же действие, позволяя взаимозаменять эти способы в каком-то объекте контекста.
+ `Стратегия` меняет поведение объекта «изнутри», а `Декоратор` изменяет его «снаружи».
+ `Шаблонный метод` использует наследование, чтобы расширять части алгоритма. `Стратегия` использует делегирование, чтобы изменять выполняемые алгоритмы на лету. `Шаблонный метод` работает на уровне классов. `Стратегия` позволяет менять логику отдельных объектов.
+ `Состояние` можно рассматривать как надстройку над `Стратегией`. Оба паттерна используют композицию, чтобы менять поведение основного объекта, делегируя работу вложенным объектам-помощникам. Однако в `Стратегии` эти объекты не знают друг о друге и никак не связаны. В `Состоянии` сами конкретные состояния могут переключать контекст.

<hr>

[Содержание](#содержание)

## Пример использования паттерна Стратегия (Strategy)

```c++

#include <iostream>
#include <algorithm>


/**
 * Интерфейс Стратегии объявляет операции, общие для всех поддерживаемых версий
 * некоторого алгоритма.
 *
 * Контекст использует этот интерфейс для вызова алгоритма, определённого
 * Конкретными Стратегиями.
 */
class Strategy {
   public:
    virtual ~Strategy() {}
    virtual std::string DoAlgorithm(const std::vector<std::string> &data) const = 0;
};

/**
 * Контекст определяет интерфейс, представляющий интерес для клиентов.
 */

class Context {
    /**
     * @var Strategy Контекст хранит ссылку на один из объектов Стратегии.
     * Контекст не знает конкретного класса стратегии. Он должен работать со
     * всеми стратегиями через интерфейс Стратегии.
     */
   private:
    Strategy *strategy_;
    /**
     * Обычно Контекст принимает стратегию через конструктор, а также
     * предоставляет сеттер для её изменения во время выполнения.
     */
   public:
    Context(Strategy *strategy = nullptr) : strategy_(strategy) {}
    ~Context() { delete this->strategy_; }
    /**
     * Обычно Контекст позволяет заменить объект Стратегии во время выполнения.
     */
    void set_strategy(Strategy *strategy) {
        delete this->strategy_;
        this->strategy_ = strategy;
    }
    /**
     * Вместо того, чтобы самостоятельно реализовывать множественные версии
     * алгоритма, Контекст делегирует некоторую работу объекту Стратегии.
     */
    void DoSomeBusinessLogic() const {
        // ...
        std::cout << "Context: Sorting data using the strategy (not sure how it'll do it)\n";
        std::string result = this->strategy_->DoAlgorithm(std::vector<std::string>{"a", "e", "c", "b", "d"});
        std::cout << result << "\n";
        // ...
    }
};

/**
 * Конкретные Стратегии реализуют алгоритм, следуя базовому интерфейсу
 * Стратегии. Этот интерфейс делает их взаимозаменяемыми в Контексте.
 */
class ConcreteStrategyA : public Strategy {
   public:
    std::string DoAlgorithm(const std::vector<std::string> &data) const override {
        std::string result;
        std::for_each(std::begin(data), std::end(data),
                      [&result](const std::string &letter) { result += letter; });
        std::sort(std::begin(result), std::end(result));

        return result;
    }
};
class ConcreteStrategyB : public Strategy {
    std::string DoAlgorithm(const std::vector<std::string> &data) const override {
        std::string result;
        std::for_each(std::begin(data), std::end(data),
                      [&result](const std::string &letter) { result += letter; });
        std::sort(std::begin(result), std::end(result));
        for (int i = 0; i < result.size() / 2; i++) {
            std::swap(result[i], result[result.size() - i - 1]);
        }

        return result;
    }
};
/**
 * Клиентский код выбирает конкретную стратегию и передаёт её в контекст. Клиент
 * должен знать о различиях между стратегиями, чтобы сделать правильный выбор.
 */

void ClientCode() {
    Context *context = new Context(new ConcreteStrategyA);
    std::cout << "Client: Strategy is set to normal sorting.\n";
    context->DoSomeBusinessLogic();
    std::cout << "\n";
    std::cout << "Client: Strategy is set to reverse sorting.\n";
    context->set_strategy(new ConcreteStrategyB);
    context->DoSomeBusinessLogic();
    delete context;
}

int main() {
    ClientCode();
    return 0;
}
```

Результат выполнения:

```
Client: Strategy is set to normal sorting.
Context: Sorting data using the strategy (not sure how it'll do it)
abcde

Client: Strategy is set to reverse sorting.
Context: Sorting data using the strategy (not sure how it'll do it)
edcba
```

<hr>

[Содержание](#содержание)

## Шаблонный метод

__Шаблонный метод__ — это поведенческий паттерн проектирования, который определяет скелет алгоритма, перекладывая ответственность за некоторые его шаги на подклассы. Паттерн позволяет подклассам переопределять шаги алгоритма, не меняя его общей структуры.

![04](/CPP_from_LETI/LETI_03/img/04_142.png)

__Проблема__

Вы пишете программу для дата-майнинга в офисных документах. Пользователи будут загружать в неё документы в разных форматах (PDF, DOC, CSV), а программа должна извлекать из них полезную информацию.

В первой версии вы ограничились только обработкой DOC-файлов. В следующей версии добавили поддержку CSV. А через месяц прикрутили работу с PDF-документами.

![04](/CPP_from_LETI/LETI_03/img/04_143.png)

В какой-то момент вы заметили, что код всех трёх классов обработки документов хоть и отличается в части работы с файлами, но содержат довольно много общего в части самого извлечения данных. Было бы здорово избавится от повторной реализации алгоритма извлечения данных в каждом из классов.

К тому же остальной код, работающий с объектами этих классов, наполнен условиями, проверяющими тип обработчика перед началом работы. Весь этот код можно упростить, если слить все три класса воедино либо свести их к общему интерфейсу.

__Решение__

Паттерн `Шаблонный метод` предлагает разбить алгоритм на последовательность шагов, описать эти шаги в отдельных методах и вызывать их в одном шаблонном методе друг за другом.

Это позволит подклассам переопределять некоторые шаги алгоритма, оставляя без изменений его структуру и остальные шаги, которые для этого подкласса не так важны.

В нашем примере с дата-майнингом мы можем создать общий базовый класс для всех трёх алгоритмов. Этот класс будет состоять из шаблонного метода, который последовательно вызывает шаги разбора документов.

![04](/CPP_from_LETI/LETI_03/img/04_144.png)

Для начала шаги шаблонного метода можно сделать абстрактными. Из-за этого все подклассы должны будут реализовать каждый из шагов по-своему. В нашем случае все подклассы и так содержат реализацию каждого из шагов, поэтому ничего дополнительно делать не нужно.

По-настоящему важным является следующий этап. Теперь мы можем определить общее для всех классов поведение и вынести его в суперкласс. В нашем примере шаги открытия, считывания и закрытия могут отличаться для разных типов документов, поэтому останутся абстрактными. А вот одинаковый для всех типов документов код обработки данных переедет в базовый класс.

Как видите, у нас получилось два вида шагов: абстрактные, которые каждый подкласс обязательно должен реализовать, а также шаги с реализацией по умолчанию, которые можно переопределять в подклассах, но не обязательно.

Но есть и третий тип шагов — хуки: их не обязательно переопределять, но они не содержат никакого кода, выглядя как обычные методы. `Шаблонный метод` останется рабочим, даже если ни один подкласс не переопределит такой хук. Однако, хук даёт подклассам дополнительные точки «вклинивания» в шаблонный метод.

__Аналогия из жизни__

![04](/CPP_from_LETI/LETI_03/img/04_145.png)

Строители используют подход, похожий на шаблонный метод при строительстве типовых домов. У них есть основной архитектурный проект, в котором расписаны шаги строительства:
+ заливка фундамента,
+ постройка стен,
+ перекрытие крыши,
+ установка окон и так далее.

Но, несмотря на стандартизацию каждого этапа, строители могут вносить небольшие изменения на любом из этапов, чтобы сделать дом чуточку непохожим на другие.

__Псевдокод__

В этом примере `Шаблонный метод` используется как заготовка для стандартного искусственного интеллекта в простой игре-стратегии. Для введения в игру новой расы достаточно создать подкласс и реализовать в нём недостающие методы.

![04](/CPP_from_LETI/LETI_03/img/04_146.png)

Все расы игры будут содержать примерно такие же типы юнитов и строений, поэтому структура ИИ будет одинаковой. Но разные расы могут по-разному реализовать эти шаги. Так, например, орки будут агрессивней в атаке, люди — более активны в защите, а дикие монстры вообще не будут заниматься строительством.

```c++
class GameAI is
    // Шаблонный метод должен быть задан в базовом классе. Он
    // состоит из вызовов методов в определённом порядке. Чаще
    // всего эти методы являются шагами некоего алгоритма.
    method turn() is
        collectResources()
        buildStructures()
        buildUnits()
        attack()

    // Некоторые из этих методов могут быть реализованы прямо в
    // базовом классе.
    method collectResources() is
        foreach (s in this.builtStructures) do
            s.collect()

    // А некоторые могут быть полностью абстрактными.
    abstract method buildStructures()
    abstract method buildUnits()

    // Кстати, шаблонных методов в классе может быть несколько.
    method attack() is
        enemy = closestEnemy()
        if (enemy == null)
            sendScouts(map.center)
        else
            sendWarriors(enemy.position)

    abstract method sendScouts(position)
    abstract method sendWarriors(position)

// Подклассы могут предоставлять свою реализацию шагов
// алгоритма, не изменяя сам шаблонный метод.
class OrcsAI extends GameAI is
    method buildStructures() is
        if (there are some resources) then
            // Строить фермы, затем бараки, а потом цитадель.

    method buildUnits() is
        if (there are plenty of resources) then
            if (there are no scouts)
                // Построить раба и добавить в группу
                // разведчиков.
            else
                // Построить пехотинца и добавить в группу
                // воинов.

    // ...

    method sendScouts(position) is
        if (scouts.length > 0) then
            // Отправить разведчиков на позицию.

    method sendWarriors(position) is
        if (warriors.length > 5) then
            // Отправить воинов на позицию.

// Подклассы могут не только реализовывать абстрактные шаги, но
// и переопределять шаги, уже реализованные в базовом классе.
class MonstersAI extends GameAI is
    method collectResources() is
        // Ничего не делать.

    method buildStructures() is
        // Ничего не делать.

    method buildUnits() is
        // Ничего не делать.
```

__Применимость__

+ Когда подклассы должны расширять базовый алгоритм, не меняя его структуры.<br>
`Шаблонный метод` позволяет подклассам расширять определённые шаги алгоритма через наследование, не меняя при этом структуру алгоритмов, объявленную в базовом классе.
+ Когда у вас есть несколько классов, делающих одно и то же с незначительными отличиями. Если вы редактируете один класс, то приходится вносить такие же правки и в остальные классы.<br>
Паттерн шаблонный метод предлагает создать для похожих классов общий суперкласс и оформить в нём главный алгоритм в виде шагов. Отличающиеся шаги можно переопределить в подклассах.
+ Это позволит убрать дублирование кода в нескольких классах с похожим поведением, но отличающихся в деталях.

__Шаги реализации__

1. Изучите алгоритм и подумайте, можно ли его разбить на шаги. Прикиньте, какие шаги будут стандартными для всех вариаций алгоритма, а какие — изменяющимися.
2. Создайте абстрактный базовый класс. Определите в нём шаблонный метод. Этот метод должен состоять из вызовов шагов алгоритма. Имеет смысл сделать шаблонный метод финальным, чтобы подклассы не могли переопределить его (если ваш язык программирования это позволяет).
3. Добавьте в абстрактный класс методы для каждого из шагов алгоритма. Вы можете сделать эти методы абстрактными или добавить какую-то реализацию по умолчанию. В первом случае все подклассы должны будут реализовать эти методы, а во втором — только если реализация шага в подклассе отличается от стандартной версии.
4. Подумайте о введении в алгоритм хуков. Чаще всего, хуки располагают между основными шагами алгоритма, а также до и после всех шагов.
5. Создайте конкретные классы, унаследовав их от абстрактного класса. Реализуйте в них все недостающие шаги и хуки.

__Преимущества и недостатки__

![04](/CPP_from_LETI/LETI_03/img/04_147.jpg)

__Отношения с другими паттернами__

+ `Фабричный метод` можно рассматривать как частный случай `Шаблонного метода`. Кроме того, `Фабричный метод` нередко бывает частью большого класса с `Шаблонными методами`.
+ `Шаблонный метод` использует наследование, чтобы расширять части алгоритма. Стратегия использует делегирование, чтобы изменять выполняемые алгоритмы на лету. `Шаблонный метод` работает на уровне классов. Стратегия позволяет менять логику отдельных объектов.

<hr>

[Содержание](#содержание)

## Примеры реализации паттерна Шаблонный метод (TemplateMethod)

```c++

/**
 * Абстрактный Класс определяет шаблонный метод, содержащий скелет некоторого
 * алгоритма, состоящего из вызовов (обычно) абстрактных примитивных операций.
 *
 * Конкретные подклассы должны реализовать эти операции, но оставить сам
 * шаблонный метод без изменений.
 */
class AbstractClass {
    /**
     * Шаблонный метод определяет скелет алгоритма.
     */
   public:
    void TemplateMethod() const {
        this->BaseOperation1();
        this->RequiredOperations1();
        this->BaseOperation2();
        this->Hook1();
        this->RequiredOperation2();
        this->BaseOperation3();
        this->Hook2();
    }
    /**
     * Эти операции уже имеют реализации.
     */
   protected:
    void BaseOperation1() const { std::cout << "AbstractClass says: I am doing the bulk of the work\n"; }
    void BaseOperation2() const {
        std::cout << "AbstractClass says: But I let subclasses override some operations\n";
    }
    void BaseOperation3() const {
        std::cout << "AbstractClass says: But I am doing the bulk of the work anyway\n";
    }
    /**
     * А эти операции должны быть реализованы в подклассах.
     */
    virtual void RequiredOperations1() const = 0;
    virtual void RequiredOperation2() const = 0;
    /**
     * Это «хуки». Подклассы могут переопределять их, но это не обязательно,
     * поскольку у хуков уже есть стандартная (но пустая) реализация. Хуки
     * предоставляют дополнительные точки расширения в некоторых критических
     * местах алгоритма.
     */
    virtual void Hook1() const {}
    virtual void Hook2() const {}
};
/**
 * Конкретные классы должны реализовать все абстрактные операции базового
 * класса. Они также могут переопределить некоторые операции с реализацией по
 * умолчанию.
 */
class ConcreteClass1 : public AbstractClass {
   protected:
    void RequiredOperations1() const override {
        std::cout << "ConcreteClass1 says: Implemented Operation1\n";
    }
    void RequiredOperation2() const override { std::cout << "ConcreteClass1 says: Implemented Operation2\n"; }
};
/**
 * Обычно конкретные классы переопределяют только часть операций базового
 * класса.
 */
class ConcreteClass2 : public AbstractClass {
   protected:
    void RequiredOperations1() const override {
        std::cout << "ConcreteClass2 says: Implemented Operation1\n";
    }
    void RequiredOperation2() const override { std::cout << "ConcreteClass2 says: Implemented Operation2\n"; }
    void Hook1() const override { std::cout << "ConcreteClass2 says: Overridden Hook1\n"; }
};
/**
 * Клиентский код вызывает шаблонный метод для выполнения алгоритма. Клиентский
 * код не должен знать конкретный класс объекта, с которым работает, при
 * условии, что он работает с объектами через интерфейс их базового класса.
 */
void ClientCode(AbstractClass *class_) {
    // ...
    class_->TemplateMethod();
    // ...
}

int main() {
    std::cout << "Same client code can work with different subclasses:\n";
    ConcreteClass1 *concreteClass1 = new ConcreteClass1;
    ClientCode(concreteClass1);
    std::cout << "\n";
    std::cout << "Same client code can work with different subclasses:\n";
    ConcreteClass2 *concreteClass2 = new ConcreteClass2;
    ClientCode(concreteClass2);
    delete concreteClass1;
    delete concreteClass2;
    return 0;
}
```

Результат выполнения:

```
Same client code can work with different subclasses:
AbstractClass says: I am doing the bulk of the work
ConcreteClass1 says: Implemented Operation1
AbstractClass says: But I let subclasses override some operations
ConcreteClass1 says: Implemented Operation2
AbstractClass says: But I am doing the bulk of the work anyway

Same client code can work with different subclasses:
AbstractClass says: I am doing the bulk of the work
ConcreteClass2 says: Implemented Operation1
AbstractClass says: But I let subclasses override some operations
ConcreteClass2 says: Overridden Hook1
ConcreteClass2 says: Implemented Operation2
AbstractClass says: But I am doing the bulk of the work anyway
```

<hr>

[Содержание](#содержание)

## Посетитель

__Посетитель__ — это поведенческий паттерн проектирования, который позволяет добавлять в программу новые операции, не изменяя классы объектов, над которыми эти операции могут выполняться.

![04](/CPP_from_LETI/LETI_03/img/04_148.png)

__Проблема__

Ваша команда разрабатывает приложение, работающее с геоданными в виде графа. Узлами графа являются городские локации: памятники, театры, рестораны, важные предприятия и прочее. Каждый узел имеет ссылки на другие, ближайшие к нему узлы. Каждому типу узлов соответствует свой класс, а каждый узел представлен отдельным объектом.

![04](/CPP_from_LETI/LETI_03/img/04_149.png)

Ваша задача — сделать экспорт этого графа в XML. Дело было бы плёвым, если бы вы могли редактировать классы узлов. Достаточно было бы добавить метод экспорта в каждый тип узла, а затем, перебирая узлы графа, вызывать этот метод для каждого узла. Благодаря полиморфизму, решение получилось бы изящным, так как вам не пришлось бы привязываться к конкретным классам узлов.

Но, к сожалению, классы узлов вам изменить не удалось. Системный архитектор сослался на то, что код классов узлов сейчас очень стабилен, и от него многое зависит, поэтому он не хочет рисковать и позволять кому-либо его трогать.

![04](/CPP_from_LETI/LETI_03/img/04_150.png)

К тому же он сомневался в том, что экспорт в XML вообще уместен в рамках этих классов. Их основная задача была связана с геоданными, а экспорт выглядит в рамках этих классов чужеродно.

Была и ещё одна причина запрета. Если на следующей неделе вам бы понадобился экспорт в какой-то другой формат данных, то эти классы снова пришлось бы менять.

__Решение__

Паттерн `Посетитель` предлагает разместить новое поведение в отдельном классе, вместо того чтобы множить его сразу в нескольких классах. Объекты, с которыми должно было быть связано поведение, не будут выполнять его самостоятельно. Вместо этого вы будете передавать эти объекты в методы посетителя.

Код поведения, скорее всего, должен отличаться для объектов разных классов, поэтому и методов у посетителя должно быть несколько. Названия и принцип действия этих методов будет схож, но основное отличие будет в типе принимаемого в параметрах объекта, например:

```c++
class ExportVisitor implements Visitor is
    method doForCity(City c) { ... }
    method doForIndustry(Industry f) { ... }
    method doForSightSeeing(SightSeeing ss) { ... }
    // ...
```

Здесь возникает вопрос: как подавать узлы в объект-посетитель? Так как все методы имеют отличающуюся сигнатуру, использовать полиморфизм при переборе узлов не получится. Придётся проверять тип узлов для того, чтобы выбрать соответствующий метод посетителя.

```c++
foreach (Node node in graph)
    if (node instanceof City)
        exportVisitor.doForCity((City) node)
    if (node instanceof Industry)
        exportVisitor.doForIndustry((Industry) node)
    // ...
```

Тут не поможет даже механизм перегрузки методов (доступный в Java и C#). Если назвать все методы одинаково, то неопределённость реального типа узла всё равно не даст вызвать правильный метод. Механизм перегрузки всё время будет вызывать метод посетителя, соответствующий типу `Node`, а не реального класса поданного узла.

Но паттерн `Посетитель` решает и эту проблему, используя механизм двойной диспетчеризации. Вместо того, чтобы самим искать нужный метод, мы можем поручить это объектам, которые передаём в параметрах посетителю. А они уже вызовут правильный метод посетителя.

```c++
// Client code
foreach (Node node in graph)
    node.accept(exportVisitor)

// City
class City is
    method accept(Visitor v) is
        v.doForCity(this)
    // ...

// Industry
class Industry is
    method accept(Visitor v) is
        v.doForIndustry(this)
    // ...
```

Как видите, изменить классы узлов всё-таки придётся. Но это простое изменение позволит применять к объектам узлов и другие поведения, ведь классы узлов будут привязаны не к конкретному классу посетителей, а к их общему интерфейсу. Поэтому если придётся добавить в программу новое поведение, вы создадите новый класс посетителей и будете передавать его в методы узлов.

__Аналогия из жизни__

![04](/CPP_from_LETI/LETI_03/img/04_151.png)

Представьте начинающего страхового агента, жаждущего получить новых клиентов. Он беспорядочно посещает все дома в округе, предлагая свои услуги. Но для каждого из посещаемых типов домов у него имеется особое предложение.
+ Придя в дом к обычной семье, он предлагает оформить медицинскую страховку.
+ Придя в банк, он предлагает страховку от грабежа.
+ Придя на фабрику, он предлагает страховку предприятия от пожара и наводнения.

__Структура__

![04](/CPP_from_LETI/LETI_03/img/04_152.jpg)

__Применимость__

+ Когда вам нужно выполнить какую-то операцию над всеми элементами сложной структуры объектов, например, деревом.<br>
Посетитель позволяет применять одну и ту же операцию к объектам различных классов.
+ Когда над объектами сложной структуры объектов надо выполнять некоторые не связанные между собой операции, но вы не хотите «засорять» классы такими операциями.<br>
Посетитель позволяет извлечь родственные операции из классов, составляющих структуру объектов, поместив их в один класс-посетитель. Если структура объектов является общей для нескольких приложений, то паттерн позволит в каждое приложение включить только нужные операции.
+ Когда новое поведение имеет смысл только для некоторых классов из существующей иерархии.<br>
Посетитель позволяет определить поведение только для этих классов, оставив его пустым для всех остальных.

__Шаги реализации__

1. Создайте интерфейс посетителя и объявите в нём методы «посещения» для каждого класса элемента, который существует в программе.
2. Опишите интерфейс элементов. Если вы работаете с уже существующими классами, то объявите абстрактный метод принятия посетителей в базовом классе иерархии элементов.
3. Реализуйте методы принятия во всех конкретных элементах. Они должны переадресовывать вызовы тому методу посетителя, в котором тип параметра совпадает с текущим классом элемента.
4. Иерархия элементов должна знать только о базовом интерфейсе посетителей. С другой стороны, посетители будут знать обо всех классах элементов.
5. Для каждого нового поведения создайте конкретный класс посетителя. Приспособьте это поведение для работы со всеми типами элементов, реализовав все методы интерфейса посетителей.<br>
Вы можете столкнуться с ситуацией, когда посетителю нужен будет доступ к приватным полям элементов. В этом случае вы можете либо раскрыть доступ к этим полям, нарушив инкапсуляцию элементов, либо сделать класс посетителя вложенным в класс элемента, если вам повезло писать на языке, который поддерживает вложенность классов.
6. Клиент будет создавать объекты посетителей, а затем передавать их элементам, используя метод принятия.

__Преимущества и недостатки__

![04](/CPP_from_LETI/LETI_03/img/04_153.jpg)

__Отношения с другими паттернами__

+ `Посетитель` можно рассматривать как расширенный аналог `Команды`, который способен работать сразу с несколькими видами получателей.
+ Вы можете выполнить какое-то действие над всем деревом `Компоновщика` при помощи `Посетителя`.
+ `Посетитель` можно использовать совместно с `Итератором`. `Итератор` будет отвечать за обход структуры данных, а `Посетитель` — за выполнение действий над каждым её компонентом.

<hr>

[Содержание](#содержание)

## Примеры реализации паттерна Посетитель (Visitor)

```c++
/**
 * Интерфейс Посетителя объявляет набор методов посещения, соответствующих
 * классам компонентов. Сигнатура метода посещения позволяет посетителю
 * определить конкретный класс компонента, с которым он имеет дело.
 */
class ConcreteComponentA;
class ConcreteComponentB;

class Visitor {
   public:
    virtual void VisitConcreteComponentA(const ConcreteComponentA *element) const = 0;
    virtual void VisitConcreteComponentB(const ConcreteComponentB *element) const = 0;
};

/**
 * Интерфейс Компонента объявляет метод accept, который в качестве аргумента
 * может получать любой объект, реализующий интерфейс посетителя.
 */

class Component {
   public:
    virtual ~Component() {}
    virtual void Accept(Visitor *visitor) const = 0;
};

/**
 * Каждый Конкретный Компонент должен реализовать метод accept таким образом,
 * чтобы он вызывал метод посетителя, соответствующий классу компонента.
 */
class ConcreteComponentA : public Component {
    /**
     * Обратите внимание, мы вызываем visitConcreteComponentA, что соответствует
     * названию текущего класса. Таким образом мы позволяем посетителю узнать, с
     * каким классом компонента он работает.
     */
   public:
    void Accept(Visitor *visitor) const override { visitor->VisitConcreteComponentA(this); }
    /**
     * Конкретные Компоненты могут иметь особые методы, не объявленные в их
     * базовом классе или интерфейсе. Посетитель всё же может использовать эти
     * методы, поскольку он знает о конкретном классе компонента.
     */
    std::string ExclusiveMethodOfConcreteComponentA() const { return "A"; }
};

class ConcreteComponentB : public Component {
    /**
     * То же самое здесь: visitConcreteComponentB => ConcreteComponentB
     */
   public:
    void Accept(Visitor *visitor) const override { visitor->VisitConcreteComponentB(this); }
    std::string SpecialMethodOfConcreteComponentB() const { return "B"; }
};

/**
 * Конкретные Посетители реализуют несколько версий одного и того же алгоритма,
 * которые могут работать со всеми классами конкретных компонентов.
 *
 * Максимальную выгоду от паттерна Посетитель вы почувствуете, используя его со
 * сложной структурой объектов, такой как дерево Компоновщика. В этом случае
 * было бы полезно хранить некоторое промежуточное состояние алгоритма при
 * выполнении методов посетителя над различными объектами структуры.
 */
class ConcreteVisitor1 : public Visitor {
   public:
    void VisitConcreteComponentA(const ConcreteComponentA *element) const override {
        std::cout << element->ExclusiveMethodOfConcreteComponentA() << " + ConcreteVisitor1\n";
    }

    void VisitConcreteComponentB(const ConcreteComponentB *element) const override {
        std::cout << element->SpecialMethodOfConcreteComponentB() << " + ConcreteVisitor1\n";
    }
};

class ConcreteVisitor2 : public Visitor {
   public:
    void VisitConcreteComponentA(const ConcreteComponentA *element) const override {
        std::cout << element->ExclusiveMethodOfConcreteComponentA() << " + ConcreteVisitor2\n";
    }
    void VisitConcreteComponentB(const ConcreteComponentB *element) const override {
        std::cout << element->SpecialMethodOfConcreteComponentB() << " + ConcreteVisitor2\n";
    }
};
/**
 * Клиентский код может выполнять операции посетителя над любым набором
 * элементов, не выясняя их конкретных классов. Операция принятия направляет
 * вызов к соответствующей операции в объекте посетителя.
 */
void ClientCode(std::array<const Component *, 2> components, Visitor *visitor) {
    // ...
    for (const Component *comp : components) {
        comp->Accept(visitor);
    }
    // ...
}

int main() {
    std::array<const Component *, 2> components = {new ConcreteComponentA, new ConcreteComponentB};
    std::cout << "The client code works with all visitors via the base Visitor interface:\n";
    ConcreteVisitor1 *visitor1 = new ConcreteVisitor1;
    ClientCode(components, visitor1);
    std::cout << "\n";
    std::cout << "It allows the same client code to work with different types of visitors:\n";
    ConcreteVisitor2 *visitor2 = new ConcreteVisitor2;
    ClientCode(components, visitor2);

    for (const Component *comp : components) {
        delete comp;
    }
    delete visitor1;
    delete visitor2;

    return 0;
}
```

Результат выполнения:

```
The client code works with all visitors via the base Visitor interface:
A + ConcreteVisitor1
B + ConcreteVisitor1

It allows the same client code to work with different types of visitors:
A + ConcreteVisitor2
B + ConcreteVisitor2
```

<hr>

[Содержание](#содержание)

## Вопросы 4

Сопоставьте значения из двух списков

![04](/CPP_from_LETI/LETI_03/img/04_154.PNG)

Представьте, что вы делаете систему приёма онлайн-заказов. Вы хотите ограничить к ней доступ так, чтобы только авторизованные пользователи могли создавать заказы. Кроме того, определённые пользователи, владеющие правами администратора, должны иметь полный доступ к заказам.

Вы быстро сообразили, что эти проверки нужно выполнять последовательно. Ведь пользователя можно попытаться «залогинить» в систему, если его запрос содержит логин и пароль. Но если такая попытка не удалась, то проверять расширенные права доступа попросту не имеет смысла.

![04](/CPP_from_LETI/LETI_03/img/04_155.png)

Какой паттерн (паттерны) проектирования вы бы использовали для решения данной проблемы?

+ [ ] Легковес
+ [ ] Мост
+ [ ] Снимок
+ [ ] Адаптер
+ [x] Команда

<hr>

[Содержание](#содержание)

# 4.5 Задания на разработку

## Введение в ООП: создание классов, конструкторов классов, методов классов; наследование 

__Обязательное задание__

Разработать и реализовать набор классов:

+ Класс игрового поля
+ Набор классов юнитов

Игровое поле является контейнером для объектов представляющим прямоугольную сетку. Основные требования к классу игрового поля:

+ Создание поля произвольного размера
+ Контроль максимального количества объектов на поле
+ Возможность добавления и удаления объектов на поле
+ Возможность копирования поля (включая объекты на нем)

Юнит является объектов, размещаемым на поля боя. Один юнит представляет собой отряд. Основные требования к классам юнитов:

+ Все юниты должны иметь как минимум один общий интерфейс
+ Реализованы 3 типа юнитов (например, пехота, лучники, конница)
+ Реализованы 2 вида юнитов для каждого типа (например, для пехоты могут быть созданы мечники и копейщики)
+ Юниты имеют характеристики, отражающие их основные атрибуты, такие как здоровье, броня, атака.
+ Юнит имеет возможность перемещаться по карте

Пример игрового поля:

![04](/CPP_from_LETI/LETI_03/img/04_156.jpg)

https://stepik.org/lesson/569062/step/1?unit=563474

<hr>

[Содержание](#содержание)

## Интерфейсы классов, взаимодействие классов, перегрузка операций 

__Обязательное задание__

Разработать и реализовать набор классов:
+ Класс базы
+ Набор классов ландшафта карты
+ Набор классов нейтральных объектов поля

Класс базы должен отвечать за создание юнитов, а также учитывать юнитов, относящихся к текущей базе. Основные требования к классу база:
+ База должна размещаться на поле
+ Методы для создания юнитов
+ Учет юнитов, и реакция на их уничтожение и создание
+ База должна обладать характеристиками такими, как здоровье, максимальное количество юнитов, которые могут быть одновременно созданы на базе, и.т.д.

Набор классов ландшафта определяют вид поля. Основные требования к классам ландшафта:

Должно быть создано минимум 3 типа ландшафта
+ Все классы ландшафта должны иметь как минимум один интерфейс
+ Ландшафт должен влиять на юнитов (например, возможно пройти по клетке с определенным ландшафтом или запрет для атаки определенного типа юнитов)
+ На каждой клетке поля должен быть определенный тип ландшафта

Набор классов нейтральных объектов представляют объекты, располагаемые на поле и с которыми могут взаимодействие юнитов. Основные требования к классам нейтральных объектов поля:
+ Создано не менее 4 типов нейтральных объектов
+ Взаимодействие юнитов с нейтральными объектами, должно быть реализовано в виде перегрузки операций
+ Классы нейтральных объектов должны иметь как минимум один общий интерфейс

Пример карты:

![04](/CPP_from_LETI/LETI_03/img/04_157.jpg)

https://stepik.org/lesson/569062/step/2?unit=563474

<hr>

[Содержание](#содержание)

## Логическое разделение классов 
__Обязательное задание__

Разработать и реализовать набора классов для взаимодействия пользователя с юнитами и базой. Основные требования:
+ Должен быть реализован функционал управления юнитами
+ Должен быть реализован функционал управления базой

Пример управления базой:

![04](/CPP_from_LETI/LETI_03/img/04_158.png)

Пример управлением юнитом:

![04](/CPP_from_LETI/LETI_03/img/04_159.png)

Пример состояния базы:

![04](/CPP_from_LETI/LETI_03/img/04_160.jpg)

https://stepik.org/lesson/569062/step/3?unit=563474

<hr>

[Содержание](#содержание)

## Полиморфизм
Реализовать набор классов, для ведения логирования действий и состояний программы. Основные требования:
+ Логирование действий пользователя
+ Логирование действий юнитов и базы

Пример простого логирования (более сложный вариант - вынос состояний): 

![04](/CPP_from_LETI/LETI_03/img/04_161.png)

*Переключение между разным логированием (логирование в файл, в терминал, без логирования) реализуется при помощи паттерна “Прокси”*

Пример использования паттерна Адаптер: 

![04](/CPP_from_LETI/LETI_03/img/04_162.png)

https://stepik.org/lesson/569062/step/4?unit=563474

<hr>

[Содержание](#содержание)

## Сериализация состояния программы 
Реализация сохранения и загрузки состояния программы. Основные требования:
+ Возможность записать состояние программы в файл
+ Возможность считать состояние программы из файла

Пример сериализации состояния программы (лучше вынести на горячие клавиши):

![04](/CPP_from_LETI/LETI_03/img/04_163.png)

Условный пример записи в файл:

![04](/CPP_from_LETI/LETI_03/img/04_164.png)

https://stepik.org/lesson/569062/step/5?unit=563474

<hr>

[Содержание](#содержание)

## Шаблонные классы

Разработка и реализация набора классов правил игры. Основные требования:
+ Правила игры должны определять начальное состояние игры
+ Правила игры должны определять условия выигрыша игроков
+ Правила игры должны определять очередность ходов игрока
+ Должна быть возможность начать новую игру

https://stepik.org/lesson/569062/step/6?unit=563474

<hr>

[Содержание](#содержание)

# 4.6 Курсовой проект

Необходимо объединить отчеты по всем выполненным практическим заданиям. 

Добавьте сюда ссылку на `git` с проектом и отчётом.

Также к коду должна быть сгенерирована документация - описание функций, классов, диаграммы. Это можно сделать вручную или же сгенерировать автоматически, например с использованием `DoxyStyle`:

![04](/CPP_from_LETI/LETI_03/img/04_165.png)

<hr>

[Содержание](#содержание)
