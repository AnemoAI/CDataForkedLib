#  Начало работы

# 2.1 Командная строка

## Зачем нужно уметь работать в консольном режиме
Несмотря на то, что современные персональные компьютеры становятся все более мощными и предоставляют все больше возможностей, они не способны решить действительно сложные задачи, такие, например, как имитационное моделирование инженерных систем, обработку и анализ больших данных, обучение нейронных сетей. Для этих задач необходимы суперкомпьютеры и вычислительные кластеры. Такие высокопроизводительные системы, предоставляют колоссальные возможности для вычислений и хранению данных и обычно размещаются в центрах коллективного пользования. На них же устанавливаются различные прикладные пакеты для решения упомянутых выше практических задач: инженерного моделирования, статистического анализа, машинного обучения и множества других, требующих большого объема вычислений или больших объемов памяти. Установить такой пакет на персональный компьютер возможно, но расчет на нем займет месяцы и годы, тогда как на суперкомпьютере эта задача может быть решена за дни или часы.

Основным интерфейсом работы с суперкомпьютером является консоль под ОС UNIX. Конечно, на специализированный суперкомпьютер для решения одной задачи (или нескольких типовых задач) на базе одного программного пакета, например, финансового анализа или инженерного расчета, может быть сделан графический интерфейс для удобства использования сотрудниками - не программистами организации-владельца суперкомпьютера. Однако, если речь идет о суперкомпьютерном центре коллективного пользования или суперкомпьютерной инфраструктуре (XSEDE, PRACE), то удаленный доступ к суперкомпьютеру выполняется по протоколу SSH - шифруемой удаленной консоли. Графический интерфейс может запускаться пользователем, например, на этапах подготовки данных, и визуализации результатов расчетов. Сами же расчеты десятков и сотен вариантов запускаются на выполнение в пакетном режиме или скриптом в консоли.

Таким образом, современному пользователю суперкомпьютерного центра коллективного пользования или центра обработки данных необходимы знания и умения работы с консолью под ОС UNIX.

В консольном режиме можно работать под операционной системой MасOS, а также WINDOWS. В последней существует имитация MSDOS (программа cmd) а, в последних версиях, встроена консоль OS UBUNTU (разновидность LINUX).

Писать программу в специальной среде разработки со визуальными средствами организации проекта, выбором функций из подсказок, встроенными средствами отладки, конечно, удобно. Но, программы, запущенные из среды разработки, работают иначе, чем запущенные непосредственно из под операционной системы. Например, среда разработки может специально очищать память перед запуском программы, что приведет к изменению результата.

Программы c графическим интерфейсом предполагают интерактивное взаимодействие через пункты меню и кнопки. Это требует непосредственного участия пользователя на каждом этапе работы с данными, и при большом количестве данных создаст трудности.

Консольный режим позволяет использовать так называемый ПАКЕТНЫЙ режим запуска, когда часто выполняемые или сложные действия (запуски различных приложений для работы с разными файлами) записываются в один скрипт. Такие скрипты очень удобны, когда нужно последовательно или параллельно обработать большие объемы данных различными программами, передавая результат от одной к другой.

Когда мы говорим о UNIX, подразумеваются все многопользовательские многозадачные UNIX-подобные операционные системы, происхождение которых восходит к AT&T UNIX, разработанной в 70-е годы прошлого века. Это и разновидности LINUX, BSD-системы, MacOS, Solaris, HP-UX и ... Android. Но и в не имеющей к ним отношения Windows развивается консоль, повторяющая функциональность консоли UBUNTU-Linux.

Зачем сейчас учиться работать в консоли
В этом курсе не будет сложных вычислительных задач, но придется проверять написанные программы и исправлять в них ошибки (тестировать и отлаживать программы). Умея работать в консоли, можно заново запустить программу вычисления суммы матриц 100х100 нажатием пар клавиш. Это быстрее, чем вводить матрицы руками, ошибаясь при вводе данных.

Приведенные ниже в нашем курсе команды и примеры работы с консолью относятся к UBUNTU-Linux и могут иметь незначительные отличия от консоли Вашей операционной системы.

## Как начать работать в Unix-консоли
Вы получили `login` и вошли в систему. Теперь вы пользователь (`user`) `Unix`.

Все программы, тексты, картинки, музыка и др. хранятся в файлах. А сами файлы располагаются в каталогах, называемых также папками или директориями. Впрочем, каталог - это тоже файл. Только в нем записан список всех других файлов и каталогов, которые находятся в нем.

Каждый пользователь имеет свой домашний каталог. Это каталог, в который пользователь попадает при входе в систему. Тот каталог, в котором пользователь работает, является рабочим или текущим. Используя команды консоли пользователь может перейти из каталога в каталог (сменить рабочий каталог).

Каждый файл или каталог может быть создан, изменен или удален с помощью специальных программ: команд операционной системы или других приложений.

Несколько основных команд

Команда | Назначение | Пример
-|-|-
pwd | указывает полное название текущего каталога (в которой работаем ) | >pwd<br>/home/user1
ls | показывает список файлов в текущем каталоге | >ls <br>student workspace

Внимание! Знак `>` перед командой `pwd` набирать не нужно. Это приглашение на ввод (`command prompt`) в консоли. Оно разное в разных консолях, и его можно изменить. В Вашей консоли может быть другое приглашение на ввод. Далее в примерах, для команд применяемых в консоли, будет использоваться приглашение на ввод >. Со следующей строки - то, что напечатала команда или программа.

Будет видео и картинку вставим

Задание: Запустите консоль в той операционной системе (ОС), где вы работаете и выполните команду pwd. Что она напечатала?

## Файлы и каталоги
С точки зрения Unix все данные помещаются в файлы. Каталоги также являются файлами. В них - список файлов и других каталогов, которые размещены в этом каталоге. Кстати, один и тот же файл может одновременно находиться в разных каталогах и иметь разные имена. Unix рассматривает различные физические устройства: диски, флеш-карты, сетевые подключения и т.д. как файлы.

Кроме пользовательских файлов, существуют системные служебные файлы. Как правило, обычный пользователь не имеет к ним доступа (это определяется настройками ОС). Все каталоги размещены в одном корневом каталоге, который обозначается /. В названиях файлов Unix различает строчные и прописные буквы на любом языке.

Как правило, пользовательские "домашние" каталоги находятся в каталоге home, который, в свою очередь, расположен в корневом каталоге. Имя каталога может быть ПОЛНЫМ (абсолютным) и ОТНОСИТЕЛЬНЫМ. Если мы работаем в корневом каталоге, то home -- относительное имя (относительно текущего каталога, то есть сейчас относительно корневого каталога), а /home -- полное имя.

Имя файла (каталога) еще называют путь. Путь может быть абсолютным или относительным. Абсолютный путь начинается с /.

Допустим есть пользователь с именем student, который создал себе рабочий каталог workspace и поместил в него файл `myprog.c`

IMAGE структура каталогов

Файл или каталог | Что это значит
-|-
myprog.c | относительное имя, если пользователь в каталоге workspace
workspace/myprog | имя, относительно каталога student
/home/student/workspace/myprog | полное имя файла
./ | обозначение ТЕКУЩЕГО каталога
./myprog.c | явное обозначение файла в текущем каталоге
../ | обозначение каталога выше

## Некоторые команды для работы с файлами и папками (размещение, перенос, переименование)

При работе с файлами и каталогами их необходимо: создавать, перемещать, копировать в другое место, удалять и т.д.

Для исполнения команды, ее нужно набрать на консоли и нажать ENTER.

`ls`

`ls` каталог

Просмотр указанного каталога. Если каталог в качестве аргумента команды не указан, то подразумевается текущий каталог.

Пусть в каталоге `/home` находится только каталог `student`. В нем находится папка `work` и файл `my.c`.

Текущий каталог `/home`. Выполним следующие действия

Просмотр содержимого текущего каталога (это `/home`)

```bash
> ls
student
```

просмотр содержимого каталога `student`

```bash
> ls student
work my.c
```

`mkdir` каталог

Создать папку каталог .

+ просмотр текущего (пустого) каталога;
+ создание каталога (папки) myWorkFolder
+ просмотр текущего каталога (в нем оказывается только что созданный каталог myWorkFolder)

> ls

> mkdir myWorkFolder

> ls

    myWorkFolder
    cd
    cd каталог

Перейти в каталог . Если каталог в качестве аргумента не указан, перейти в домашний.
+ просмотр текущего каталога
+ переход в каталог myWorkFolder
+ просмотр нового текущего каталога (myWorkFolder)
+ переход на каталог выше (обратно)

Просмотр каталога

Переход в каталог /home

Переход в домашний каталог

> ls

    myWorkFolder

>cd myWorkFolder

>ls

    myprog.c


> cd ..

> ls

    myWorkFolder

> cd /home

>cd ~

    cp откуда куда

Копировать файл откуда в куда

+ Копирование файла myprog.c в файл yourprog.c и просмотр (есть оба файла).

>cp myprog.c yourprog.c

>ls
    
    myprog.c yourprog.c

+ Копирование файла из myWorkFolder в текущий каталог. В текущем каталоге появится файл с таким же именем.

>cp myWorkFolder/myprog.c .

+ Копирование файла 'otherfile' в каталог myWorkFolder. В каталоге myWorkFolder появится файл с таким же именем

>cp otherfile myWorkFolder/

    mv откуда куда

+ Переместить файл откуда в куда . Файл (каталог) откуда будет удален. Используется для переименования и перемещения файлов (каталогов).

+ Переименование файла myprog.c в файл yourprog.c и просмотр (файла с именем myprog.c не стало)

>ls

    myprog.c

>mv myprog.c yourprog.c

>ls

    yourprog.c

+Перемещение файла из myWorkFolder в текущий каталог. В текущем каталоге появится файл с таким же именем, в каталоге myWorkFolder будет удален.

>mv myWorkFolder/myprog.c .

+ Перемещение файла otherfile в каталог myWorkFolder. В каталоге myWorkFolder появится файл с таким же именем, в текущем будет удален.

>mv otherfile myWorkFolder/

## Создание и изменение файлов.
Все файлы создаются специальными программами. Мы будем работать с текстовыми файлами (это - написанные программы и данные) и запускаемыми файлами.

Запускаемые файлы мы будем получать из текстовых файлов-программ. А сами программы и другие тексты пишутся в текстовых редакторах, которых великое множество.

Текстовые редакторы разделяются на интерактивные и неинтерактивные.

## Неинтерактивные редакторы

cat
cat - простейший неинтерактивный текстовый редактор.

> cat myprog.c

```c
#include <stdio.h>
int main() {
    int a;
    /* это комментарий */

    printf("Hello");
}
```

Просмотр содержимого файла 'myprog.c'. Вывод происходит на экран.

Если 'cat' не указать файл для вывода, он будет ожидать ввод с клавиатуры и сразу все печатать на экран. Символ ''>' (перенаправление вывода) позволяет перенаправить вывод с экрана в файл. При этом либо создается новый файл, либо полностью перезаписывается содержимое уже существующего файла.

Создание нового файла 'newfile.txt'.

В файл будет записан весь текст, который набирается на клавиатуре. Чтобы закончить ввод и закрыть файл, нужно ввести новую строку (ENTER) и нажать CTRL+D

Символы '>>' позволяют добавить вывод в конец уже существующего файла без удаления записанной ранее информации.

```bash
>cat>newfile.txt
1234567
>ls
myprog.c newfile.txt
>cat>>newfile.txt
abcdef
>cat newfile.txt
1234567
abcdef
sed - String EDitor (строковый редактор)
```

Позволяет искать в строках текста комбинации символов (шаблоны) и заменять их на другие комбинации, а также выполнять некоторые операции над строками, которые ищутся по номеру строки в тексте или по наличию в ней шаблона.

Пусть файл zz содержит следующие данные:

```
12341212
qwerty
1234
```

Просматриваем содержимое файла zz.

```bash
> cat zz
12341212
qwerty
1234
```

Заменить подстроку 1 раз s/образец/замена/

В файле zz в каждой строке меняем комбинацию 12 на двенадцать один раз (первое нахождение). Результат выводится на экран. Файл zz при этом не изменился (можем просмотреть содержимое файла командой cat).

s - search (искать)

>sed -e "s/12/двенадцать/" zz
двенадцать341212
qwerty
двенадцать34
Заменить все подстроки s/образец/замена/g
Чтобы заменить все вхождения, добавим ключ g (global) в конце выражения. Результат запишем в файл tmp (перенаправим вывод с экрана в файл).

При перенаправлении в тот же файл, он становится пустым так как > сначала создает новый или очищает существующий файл прежде выполнения других действий.

> sed -e "s/12/двенадцать/g" zz > tmp ; mv tmp zz
> cat zz
двенадцать34двенадцатьдвенадцать
qwerty
двенадцать34
Удалить все строки с образцом /образец/d
d - delete (удалить).

Удаляем все строки с комбинацией 34. Результат выводим на экран.

> sed -e "/34/d" zz
qwerty
Более подробно с шаблонами познакомимся при работе со строками.

## Заключение
UNIX и Windows имеют разную структуру файловой системы. В UNIX нет логических дисков C, D и так далее, все файлы объединены в директории. Директория самого верхнего уровня / (корень).

Пути бывают абсолютными и относительными. Абсолютный путь начинается с /. Текущая директория . (точка), директория уровнем выше .. (две точки).

Для работы в командной строке UNIX используются команды:

Команда | Что делает | Пример использования
-|-|-
pwd | Pring Working Directory<br>Печать полного пути к текущей (рабочей) директории | `pwd` <br>/home/user/student
ls | LiSt <br>Вывести содержимое текущей директории | `ls` <br>work data.txt hello.c
ls директория | Вывести содержимое указанной директории | `ls work`<br>1int 2func 3for
cd | Change Directory<br>Сменить директорию (вернуться в домашнюю диреторию) | `cd`
cd директория | Перейти в указанную директорию. | `cd work` <br>`ls` <br>1int 2func 3for
cp откуда куда | CoPy <br>Копирует файл откуда в куда | `cp my.c your.c` <br> `ls` <br> my.c your.c
mv откуда куда | MoVe <br>Перемещает файл откуда в куда | `mv my.c your.c` <br>`ls` <br>my.c
mkdir директория | MaKe DIRectory <br>Сделать директорию директория | `mkdir lesson1`
cat файл | Вывести содержимое файла | `cat my.c`
sed -e "команда" файл | String EDitor <br>Для каждой строки файла выполнить команду <br> В файле 1 раз в каждой строке заменить подстроку one на two <br> В файле заменить все подстроки one на two <br> В файле удалить все строки, где есть подстрока one | `sed -e "s/one/two/" my.c` <br>`sed -e "s/one/two/g" my.c`<br>`sed -e "/one/d my.c`

# 2.2 Тест: командная строка

В начале работы с операционной системой была набрана команда и получен ответ:

    >pwd
    /home/student

Команда `pwd` показала:

+ [ ] полный путь всех каталогов в каталоге /home
+ [ ] все каталоги доступные пользователю
+ [x] полный путь рабочего (текущего) каталога пользователя
+ [ ] относительный путь рабочего (текущего) каталога пользователя
+ [ ] каталоги всех пользователей системы

В начале работы с операционной системой были набраны команды и получены ответы:

    >pwd
    /home/student
    >ls
    MyWork Pictures

Команда `ls` показала:


+ [ ] каталоги и файлы всех пользователей системы
+ [ ] абсолютные имена (пути) каталогов и файлов в текущем (рабочем) каталоге
+ [ ] все каталоги доступные пользователю
+ [ ] полный путь всех каталогов и файлов в каталоге /home
+ [x] относительные имена каталогов и файлов в текущем (рабочем) каталоге

В начале работы с операционной системой были набраны команды и получены ответы:

    >pwd
    /home/student
    >ls
    MyWork Pictures

Чтобы посмотреть содержимое каталога Pictures нужно набрать команду:

+ [x] ls /home/student/Pictures
+ [ ] mkdir Pictures
+ [ ] cd Pictures
+ [ ] ls
+ [ ] cd /home/student/Pictures

В начале работы с операционной системой были набраны команды и получены ответы:

    >pwd
    /home/student
    >ls
    MyWork Pictures

Чтобы создать каталог Video в каталоге Pictures нужно набрать команду:

+ [ ] ls Video
+ [ ] mkdir Video
+ [ ] cd Pictures/Video
+ [x] mkdir Pictures/Video
+ [ ] ls /home/student/Pictures

В начале работы с операционной системой были набраны команды и получены ответы:

    >pwd
    /home/student
    >ls
    MyWork Pictures
    >ls MyWork
    SRC program.c test.dat

Чтобы перейти в каталог SRC (сделать его текущим), нужно набрать команду:

+ [ ] ls /home/student/Pictures/MyWork/SRC
+ [ ] mkdir Pictures/SRC
+ [ ] cd SRC
+ [ ] ls SRC
+ [x] cd MyWork/SRC

В начале работы с операционной системой были набраны команды и получены ответы:

    >pwd
    /home/student
    >ls
    MyWork Pictures
    >cd MyWork/SRC

Чтобы посмотреть содержимое каталога Pictures, нужно набрать команду:

+ [ ] ls /home/student/Pictures/MyWork/SRC
+ [ ] mkdir Pictures
+ [x] ls ../../Pictures
+ [ ] ls Pictures
+ [ ] cd Pictures

В начале работы с операционной системой были набраны команды и получены ответы:

    >pwd
    /home/student
    >ls
    MyWork Pictures task1.cpp
    >ls MyWork
    SRC task1.c 
    >cat task1.c
    my C-prog
    >

Чтобы создать файл `test.dat`, необходимо:

+ [ ] выполнить команды<br> `cat MyWork/test.dat`<br> затем набрать текст и закончить ввод CTRL+D
+ [ ] обратиться к администратору для установки программы редактирования
+ [ ] выполнить команды <br>`cd >MyWork/test.dat`<br>затем набрать тест и закончить ввод CTRL+D
+ [x] выполнить команды<br>`cat >MyWork/test.dat`<br>затем набрать текст и закончить ввод CTRL+D
+ [ ] выполнить команды <br>`cat < MyWork/test.dat`<br>затем набрать текст и закончить ввод CTRL+D

В начале работы с операционной системой были набраны команды и получены ответы:

    >pwd
    /home/student
    >ls
    MyWork Pictures
    >ls MyWork
    SRC task1.c test.dat

Чтобы скопировать файл `test.dat` в файл `test001.dat`, нужно выполнить команды:

+ [x] `cp MyWork/test.dat test001.dat`
+ [ ] `cp test.dat MyWork/test001.dat`
+ [ ] `mv test.dat test001.dat`
+ [ ] `cp test.dat test001.dat`
+ [ ] `ls test.dat test001.dat`

В начале работы с операционной системой были набраны команды и получены ответы:

    >pwd
    /home/student
    >ls
    MyWork Pictures
    >ls MyWork
    SRC task1.c test.dat

Чтобы перенести файл test.dat в каталог tests и переименовать его в файл test001.dat, нужно выполнить команды:

+ [ ]
    >mkdir tests<br>
    >mv tests/test001.dat test.dat 

+ [x]
    >mkdir tests<br>
    >mv MyWork/test.dat tests/test001.dat  

+ [ ]
    >cat >tests/test001.dat<br>
    затем набрать текст и закончить ввод CTRL+D
+ [ ]
    >cp MyWork/test.dat tests/test001.dat
+ [ ]
    >mkdir tests<br>
    >cd tests<br>
    >mv MyWork/test.dat tests/test001.dat

В начале работы с операционной системой были набраны команды и получены ответы:

    >pwd
    /home/student
    >ls
    MyWork Pictures
    >ls MyWork
    SRC task1.c test.dat
    >cat MyWork/test.dat
    What are little boys made of?
    What are little boys made of?
    Snips and snails
    And puppy-dogs tails
    That is what little boys are made of

    What are little girls made of?
    What are little girls made of?
    Sugar and spice
    And everything nice
    That is what little girls are made of

Далее, с помощью sed были произведены изменения в файле:

    cat MyWork/test.dat
    What are little boys made of?
    What are little boys made of?
    Snips and pebbles
    And puppy-dogs tails
    That is what little boys are made of

    What are little girls made of?
    What are little girls made of?
    Sugar and spice
    And everything nice
    That is what little girls are made of

Чтобы получить такие изменения были выполнены команды:


>sed -e "s/snails/pebbles/" test.dat

>sed -e "/snails/pebbles/" test.dat

>sed -e "s/snails/pebbles/" test.dat >test.dat


>sed -e "s/pebbles/snails/" test.dat >testZZ.dat
>mv testZZ.dat test.dat

+ [x]
>sed -e "s/snails/pebbles/" test.dat >testZZ.dat
>mv testZZ.dat test.dat

В начале работы с операционной системой были набраны команды и получены ответы:

    >pwd
    /home/student
    >ls
    MyWork Pictures
    >ls MyWork
    SRC task1.c test.dat
    >cat test.dat
    What are 
    boys made of?
    What are 
    boys made of?
    Snips and pebbles
    And puppy-dogs tails
    That is what 
    boys are made of

    What are 
    girls made of?
    What are 
    girls made of?
    Sugar and spice
    And everything nice
    That is what 
    girls are made of

Далее, с помощью sed были произведены изменения в файле:

    cat test.dat
    What are 
    girls made of?
    What are 
    girls made of?
    Snips and snails
    And puppy-dogs tails
    That is what 
    girls are made of

    What are 
    boys made of?
    What are 
    boys made of?
    Sugar and spice
    And everything nice
    That is what 
    boys are made of
Чтобы получить такие изменения были выполнены команды:

+ [x]
>sed -e "s/boys/ZZ/" test.dat>t1
>sed -e "s/girls/boys/" t1>t2
>sed -e "s/ZZ/girls/" t2>test.dat

>sed -e "s/boys/girls/" test.dat>t2
>mv t2 test.dat

>sed -e "/boys/d" test.dat >testZZ.dat
>sed -e "/girls/d" testZZ.dat >test.dat
>sed -e "s/\d/girls/" test.dat>t2
>sed -e "s/\d/boys/" t2>test.dat

>sed -e "s/little boys/little girls/" test.dat>t2
>mv t2 test.dat

>sed -e "/boys/d" test.dat >testZZ.dat
>sed -e "/girls/d" testZZ.dat >test.dat
>sed -e "s/little\d/girls/" test.dat>t2
>sed -e "s/little\d/boys/" t2>test.dat

# 2.3 Начало работы с vim

## Справочная информация
Для редактирования текстов существует консольный редактор vim.

vim может находится в:
+ нормальном режиме,
+ режиме ввода команд,
+ режиме ввода текста,
+ визуальном режиме.

Запуск vim:

    vim mytext

`vim` выполняет команды клавиатуры: сочетание различных клавиш и командных строк, набранных на клавиатуре. Сразу после запуска пользователь оказывается в нормальном режиме: в котором можно ставить метки, копировать, удалять, вставлять текст их буферов и т.д

Для ввода текста необходимо перейти в режим ввода текста. Самый простой способ - клавиша `i`.

Вернуться в нормальный режим -- клавиша `ESC`

Здесь точно нужно видео

vim: основные команды в нормальном режиме (просмотр)

Для перехода в нормальный режим нажмите клавишу `ESC`.

Клавиши или их сочетания | Что делает
-|-
hjkl | перемещение в разные стороны или стрелки (Когда vi был написан (в 70-х годах прошлого века), стрелки не всегда были доступны . Поэтому h, j, k, и l были выбраны как команды для перемещения влево,вниз,вверх и вправо соотвественно.)
i | режим вставки (insert)
I | добавление в начало строки
a | режим добавления (append)
A | добавление в конец строки
o | вставить строку за текущей (out)
O | вставить строку перед текущей
R | писать поверх (replace)
u | отмена предыдущего действия (undo)
CTR-R | отмена отмены предыдущего действия (redo)
dd | удалить строку и сохранить в буфер (delete)
yy | копировать строку в буфер (copY)
p | вставить из буфера обмена (paste)
{n}d | удалить n+1 строку
{n}y | скопировать n+1 строку
ESC | перейти в режим просмотра
DEL | удалить следующий символ
:{n} | перейти на строку n
:e myfile | открыть для редактирования файл (edit)
:w myfile | записать изменения (write)
:wa | сохранить изменения во всех открытых файлах (write all)
:q | выйти из редактора (quit)
:q! | выйти из редактора без сохранения
:cd [path] | перейти в другой каталог
:!команда | выполнить команду - man, gcc, и так далее
CTR+u, CTR+d | Page Up / Page Down
CTR+y, CTR+e | Перемотка вверх/вниз без движения курсора

## vim: Маркеры
Для быстрого перехода по нужным вам позициям в файле используют маркеры. Работать с маркерами можно в нормальном режиме.

Клавиши или их сочетания | Что делает
-|-
ma | установить локальный маркер a (имя маркера любая буква) на позицию, в которой стоит курсор
mB | установить глобальный маркер B
`c | перейти к локальному маркеру c (при использовании маркеров для выделения текста при копировании, удалении и т.д выделяется весь текст от текущего положения курсора до маркера)
`c | переход к строке, на которой установлен маркер (перед именем маркера клавиша SHIFT+~, обратная кавычка)
:marks | просмотр маркеров
## vim: Поиск и замена

Специальные символы для поиска | Что означает
-|-
/n | перенос строки
/t | табуляция
/s | пробел
/< | слово должно начинаться с набора символов, который стоит за этими знаками
/> | слово должно заканчиваться набором символов который стоит перед этими знаками
\* | символ, после которого стоит * может встречаться сколько угодно раз (от 0)
. | точка означает "любой символ"
/ | последовательность символов перед этим должна встречаться не менее n раз
[набор символов] | в строке должен встречаться какой-нибудь из перечисленных в скобках символов.

Командная строка или клавиша | Что делает
-|-
/текст | поиск строки текста в файле сверху вниз
?текст | поиск строки текста в файле снизу вверх
n | следующее совпадение
N | предыдущее совпадение
:%s/текст1/текст2/g | замена строки текст1 на текст2 во всем файле

## vim: Работа в мультиоконном режиме

Командная строка или клавиша | Что делает
-|-
:vsplit | открыть еще одно окно для редактирования рядом по вертикали
:split | открыть еще одно окно для редактирования рядом по горизонтали
CTRL+ww | переход между окнами
:q | закрыть окно (если открыто одно окно, то выход из редактора)
:q! | закрыть окно без сохранения
:Explore | открыть новое окно со списком всех файлов в текущем каталоге (если подвести курсор к файлу и нажать ENTER, в этом окне откроется содержимое файла)
:e . | открыть список всех файлов в текущем каталоге ("e латинское, пробел, точка" (точка обозначает текущий каталог))

## Первая программа на С
Чтобы написать и запустить программу на С воспользуемся текстовым редактором `vim`. Из командной строки запустим `vim` с указанием названия файла с текстом программы:

    >vim first.c
    ~ 
    ~ 
    ~ 
    ~ 
    ~
    "first.c" [New File]

Перейдем в режим ввода текста (клавиша i) и наберем следующий текст:

```c
#include <stdio.h>

int main() {
        printf("Начали!\n");
}
~
~
~
-- INSERT --
```

Теперь нужно сохранить текст программы в этом файле и выйти из редактора.

1. Переходим в нормальный режим (клавиша `ESC`).
2. Вводим команду записи файла:

```c
#include <stdio.h>

int main() {
        printf("Начали!\n");
}
~ 
~ 
~ 
:w
```

и получаем ответ:

```c
#include <stdio.h>
int main() {
    printf("Начали!\n");
}
~          
"first.c" [New] 6L, 62C written 
```

3. Вводим команду выхода из редактора, `а`, затем команду `ls`, чтобы посмотреть содержимое рабочего каталога:

```c
#include<stdio.h>

int main() {
        printf("Начали!\n");
}
~ 
~ 
~ 
:q
>ls
first.c
```

Теперь нужно сделать из текста программы файл, который будет запускаться (исполняемый файл). Для этого нужна программа-компилятор. Воспользуемся компилятором gcc:

>gcc first.c -o first.exec

`first.c` - это файл с текстом программы, написанный нами в текстовом редакторе.

`first.exec` - это файл с готовой программой, которую из нашего текста сделал компилятор `gcc`. Этот файл можно запустить. В LINUX необязательно указывать ''расширение'' после имени файла. Имя может быть любым. Главное, чтобы имя исполняемого файла отличалось от имени файла с текстом программы. Иначе после попытки компиляции текст будет УТЕРЯН.
`-o` -- специальный ключ, который указывает компилятору как назвать исполняемый файл

Запускаем исполняемый файл:

>./first.exec

Начали!
>

`./` указывает, что файл запускался из текущего (рабочего ) каталога.

## Самый простой makefile
Чтобы не писать каждый раз длинную строку компиляции, для написания каждой программы полезно иметь `makefile`. В этом файле записывается (в простейшем случае) строка для создания запускаемого файла из текста программы.

Откроем `vim` и запишем следующую информацию. ВАЖНО: вторая строка начинается с `tab`, а не с пробелов. Сохраним этот текст в файл `makefile`.

```c
all:
    gcc first.c -o first
~
~
:w makefile
```

Проверим содержимое каталога

>ls<br>
first.c makefile<br>

Теперь для создания исполняемого файла достаточно выполнить команду `make`:

>make<br>
>ls<br>
first.c first makefile<br>
>./first<br>
Начали!

## Сообщения компилятора об ошибках и их исправление в текстовом редакторе
Если компилятор смог получить исполняемый файл из текста программы, он не выдает никаких сообщений.

Однако в тексте программы могут быть ошибки из-за которых исполняемый код не может быть получен. В этом случае компилятор печатает сообщения об обнаруженных ошибках, не позволяющих скомпилировать программу. Например:

    >gcc first.c -o first
    first.c: In function ‘main’:
    first.c:6:1: error: expected ‘;’ before ‘}’ token
    }
    ^
    >

Компилятор сообщает имя файла, в котором обнаружена ошибка, номер строки в файле и номер колонки(символа) в строке с ошибкой. В данном случае в файле `first.c` на 6 строке первым символом в строке, перед `}` обнаружено отсутствие `;`.

Эту ошибку нужно исправить и снова попытаться скомпилировать программу.

Можно запомнить номер строки, запустить текстовый редактор и исправить ошибку. Но, если ошибок много, то все номера строк запомнить трудно.

Попытаемся скомпилировать и исправить программу прямо из `vim`.

Вспомним, что мы написали файл `makefile`. Если в каталоге лежит этот файл, то компилировать программу можно просто исполняя команду `make` (пример выше). Также можно исполнить `make` как команду `vim`. А чтобы посмотреть ошибки не выходя из редактора можно добавить команду `:copen`.

```c
#include<stdio.h>

int main() {
        printf("Начали!\n")
}
~                                                                  
~                                                                  
~                                                                  
:make|:copen
```

После выполнения попадаем в обычную консоль. `vim` при этом не выключается, он работает в фоновом режиме.

```c
gcc first.c -o first
first.c: In function ‘main’:
first.c:6:1: error: expected ‘;’ before ‘}’ token
 }
 ^
makefile:2: recipe for target 'all' failed
make: *** [all] Error 1

Press ENTER or type command to continue
```

Возвращаемся в редактор нажимая два раза `ENTER`.

Получаем два рабочих окна в редакторе: первое с текстом программы, второе со списком ошибок.

```c
#include<stdio.h>

int main() {
        printf("Начали!\n")
}                                                                  
~                                                                  
~

first.c                                                       6,1            All
|| gcc first.c -o first
|| first.c: In function ‘main’:
first.c|6 col 1| error: expected ‘;’ before ‘}’ token                           
||  }
||  ^
makefile|2| recipe for target 'all' failed
|| make: *** [all] Error 1
~                                                                               
~                                                                               
~                                                                               
[Quickfix List]                                               3,1            All
(3 of 7): error: expected ‘;’ before ‘}’ token
```

Курсор находится в окне `[Quickfix List]` на строке с описанием первой ошибки. По списку ошибок можно перемещаться как по обычному текстовому файлу.

Если подвести курсор к строке с описанием ошибки и нажать на `ENTER`, курсор переместится в окно с текстом программы на строку с ошибкой.

Исправив ошибки проверим появился ли исполняемый файл в каталоге. Для этого можно открыть новое вертикальное окно (`:vsplit`) и выполнить команду просмотра каталога из `vim` (`:e`.)

Получим результат:

```
" ======================================|#include<stdio.h>
" Netrw Directory Listing               |
"   /home/student/problem               |int main()
"   Sorted by      name                 |{
"   Sort sequence: [\/]$,\<core\%(\.\d\+|        printf("Начали!\n")
"   Quick Help: <F1>:help  -:go up dir  |}
" ======================================|~                                      
../                                     |~                                      
./                                      |~                                      
first.c                                 |~                                      
first*                                  |~                                      
makefile                                |~                                      
.first.c.swp                            |~                                      
~                                       |~                                      
/home/student/problem [RO] 13,1           All first.c              1,1            All
/home/student/problem" [Not edited][readonly] 13 lines --61%--
:!./first
```

Если нужно запустить из `vim` что-то, не являющееся командой `vim`, необходимо использовать "!"

Получим результат:

```
Начали!

Press ENTER or type command to continue
```
Текстовый редактор `vim` и `makefile` обладают множеством возможностей в использовании, что делает разработку удобной, понятной и переносимой на любое другое устройство.

## Заключение
Текст программы на языке С, которая печатает Hello, world!

```c
#include<stdio.h>

int main() {
        printf("Начали!\n")
}
```

Если эта программа находится в файле `hello.c`, то создаем исполняемый файл hello.exe командой

    gcc -o hello.exe hello.c

Выполнить получившийся исполняемый файл:

    ./hello.exe

Имя файла с текстом программы `hello.c` и имя исполняемого файла `hello.exe` должны быть РАЗНЫМИ.

Если не писать имя исполняемого файла с ключом `-o`, то будет создан по умолчанию исполняемый файл с именем a.out

Чтобы было найдено как можно больше ошибок, рекомендуем добавлять ключи `-Wall -Wextra`

# 2.4 Лабораторная работа: создание программ