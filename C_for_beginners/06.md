# 6. Условные операторы

# 6.1 Выбор

## Простые высказывания в языке С и логические операции над ними.

До этого момента мы совершали различные арифметические операции над переменными (`+`, `-`, `*`, `/`, `%`). Кроме этих операций существуют еще операции сравнения (также арифметические), которые порождают простые __выражения__, принимающие значение __истина__ и __ложь__.

Логические конструкции в языках программирования, такие как `if`, `switch` и т.д. рассматривают такие __выражения__ как выражения __алгебры логики__: совокупность __логических переменных__ и __логических связок__.

__Логические переменные__ всегда принимают значения __истина__ и __ложь__

__Логические связки__ - это логические операции, которые по заданным значениям аргументов однозначно определяют результат.

Для работы с логическими переменными в языке С используются специальные коды.

Значение | Код
-|-
ложь | 0
истина | все числа, кроме 0, включая отрицательные и дробные

В тексте будем обозначать истину как `1`.

Таким образом, все числа, все функции, возвращающие значения, могут считаться логическими переменными, принимающими логические значения, и, соответственно, обработаны.

## Операции над высказываниями

Будем обозначать простые высказывания как $x_1, x_2, … ,x_n$
​
### Отрицание (не)

$x$ | $\overline{x}$
-|- 
1 | 0
0 | 1

### Логическое умножение (и)

$x_1$ | $x_2$ | $x_1 ∧ x_2$
-|-|- 
1 | 1 | 1
0 | 1 | 0
1 | 0 | 0
0 | 0 | 0

### Логическое сложение (или)

$x_1$ | $x_2$ | $x_1 ∨ x_2$
-|-|- 
​1 | 1 | 1
0 | 1 | 1
1 | 0 | 1
0 | 0 | 0

### Сложение по модулю 2 (исключающее или )
Если $x_1$ и $x_2$ действительно принимают только значения `0`, `1`, то можно использовать еще операцию "сложение по модулю 2" или "исключающее или" .

$x_1$ | $x_2$ | $x_1 ⊕ x_2$
-|-|- 
1 | 1 | 0
0 | 1 | 1
1 | 0 | 1
0 | 0 | 0

В языке С этот оператор обозначается как "^". Его можно применять, только если значения $x_1$ и $x_2$ действительно могут быть $0$ или $1$.

## Некоторые соотношения в логических формулах

$xx=x$

$x∨x=x$

$x=x$

$\overline{\overline{x}}=x$

$x∧1=x$

$x∧0=0$

$x∨0=x$

$x∨1=1$

Правило де Моргана

$\overline{x_1 ∧ x_2} = x_1 ∨ x_2$

$\overline{x_1 ∨ x_2} = x_1 ∧ x_2$<br>


Это решение гораздо короче, но длинные логические выражения иногда приводят к путанице. Поэтому иногда стоит упрощать длинные формулы.

$x_1 (x_2 x_3)=x_1 x_2 x_3$<br>
$x_1 ∨ (x_2 ∨ x_3) = x_1 ∨ x_2 ∨ x_3$<br>
​$x_1 x_2 = x_2 x_1$<br>
​$x_1 ∨ x_2 = x_2 ∨ x_1$<br>
​$x_1 (x_2 ∨ x_3) = x_1 x_2 ∨ x_1 x_3$<br>
​$x_1 ∨ (x_2 x_3) = (x_1 ∨ x_2) (x_1 ∨ x_3)$<br>

## Логические операции в языке С

Целочисленные переменные языка С можно использовать как переменные, принимающие логические значения (истина и ложь).

В языке С целочисленное значение $0$ - это ложь (как логическое значение), все остальные значения переменных, включая отрицательные и дробные воспринимаются как истина.

Над переменными, принимающими логические значения можно совершать логические операции.

Рассмотрим задачу.

Пароход приходит к острову между 10-ым и 15-ым числами месяца, если это не зима. Зима - это 12, 1 и 2 месяцы.

Сегодня YYYY-MM-DD -дата

Необходимо выяснить можно ли сегодня ждать парохода.

Рассмотрим решение.

Необходимо провести проверку на числа месяца, и проверку на время года.

Для сравнения чисел используются арифметические операторы:

```c
a == b; // равно (только для целых чисел) 
a != b; // не равно (только для целых чисел)
a > b;  // больше
a >= b; // больше или равно
a < b; // меньше
a <= b;  // меньше или равно
```

Все эти операторы производят действия над числами, но результатом их выполенения будет логическое значение (ложь или истина)

Кроме того можно интерпретировать как ложь или истину результат выполнения вычитания, сложения, деления, взятие остатка от деления и т. д. Также функции могут возвращать логические значения.

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int yy; // год
    int mm; // месяц
    int dd; // день
}Date;


int main() {
    Date dat;
    scanf("%d-%d-%d", &dat.yy, &dat.mm,&dat.dd);
// Переменные для логических значений
    char ddOk = 0; // правильный день
    char zima = 0; // зима
    char ddL = 0; // правильный день сначала
    char ddR = 0; // правильный день с конца
// Проверка дня
    ddL = dat.dd >= 10; // больше или равен 10
    ddR = dat.dd <= 15; // меньше или равен 15

// Проверка попадает ли день в диапазон
// && логический оператор "И"
    ddOk = ddL && ddR;

// Проверка времени года
// || - логический оператор ИЛИ
    zima = dat.mm == 12 || dat.mm < 3;
// отладочная печать для зимы
    printf("zima: %d\n", zima);

// логическая переменная для ожидания парохода
    char wait = 0;
// ! - логический оператор отрицания
  wait = ddOk && !zima;
    printf("%d\n", wait);
    return 0;
}
```

## Решение с другими проверками

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int yy; // год
    int mm; // месяц
    int dd; // день
}Date;


int main() {
    Date dat;
    scanf("%d-%d-%d", &dat.yy, &dat.mm,&dat.dd);
    char ddOk = 0, 
    char neZima = 0;
    char ddL = 0;
    char ddR = 0;
// Проверка на неправильную дату
    ddL = dat.dd < 10;
    ddR = dat.dd > 15;
//  Проверка на ПРАВИЛЬНУЮ дату
// правило де Моргана
    ddOk = !ddL || !ddR;

// Проверка на время года
    neZima = dat.mm < 12 && dat.mm > 2 ;
    printf("neZima: %d\n", neZima);

    char wait = 0;
  wait = ddOk && neZima;
    printf("%d\n", wait);
    return 0;
}
```

### Конструкция IF

Для задачи, описанной выше вывод не очень наглядный.

Для выбора действий в зависимости от значения логических переменных

Конструкция `if` позволяет выполнять такие действия

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int yy; // год
    int mm; // месяц
    int dd; // день
}Date;


int main() {
    Date dat;
    scanf("%d-%d-%d", &dat.yy, &dat.mm,&dat.dd);
    char ddOk = 0;// правильный день 
    char neZima = 0; // не зима
    char ddL = 0;
    char ddR = 0;

// прверка дня месяца
    ddL = dat.dd < 10;
    ddR = dat.dd > 15;

// правило де Моргана
    ddOk = !ddL || !ddR;

// проверка времени года
// не 12 месяц и месяц больше 2
    neZima = dat.mm < 12 && dat.mm > 2 ;
    printf("neZima: %d\n", neZima);

    char wait = 0;
// проверка можно ли ждать парохода
// правильная дата и не зима
  wait = ddOk && neZima;
    printf("%d\n", wait);

// Конструкциия if
// if выполняет инструкцию, записанную сразу за ним
// если выражение в скобках истинно

    if (wait)
        printf("Можно ждать пароход\n");
    return 0;
}
```

## Альтернативное действие (IF...ELSE)

Напечатаем, является ли число четным

Конструкция `if` позволяет выполнять и альтернативные действия

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int N; 
    scanf("%d", &N);
// if выполняет , записанные сразу за ним
// если выражение в скобках истинно
// арифметический оператор % возвращает 0 (ложь)
// когда число четное
// Превратим его в истину
    if ( !(N % 2) ) {
        printf("Четное\n");
    }
// После else выполняются альтернативные действия   
    else {
        printf("Не четное\n");
    }

    return 0;
}
```

```
>./ifp
8 
Четное
>
7
Не четное
>
```

## Задача о корректности времени

Можно вычислять логические значения в самом операторе `if`

Время вводится как часы h и минуты min

Требуется установить правильность ввода, если речь идет о часах с 24-х часовым циферблатом.

Решение 1

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int h; // часы
    int min; //  минуты
    scanf("%d:%d", &h, &min);
// часы должны быть не менее 0 и не более 23
// а минуты - от 0 до 59

// проверяем часы 
// используем логическое и (&&)
    if ( 0 <= h && h < 24) {
// если с все верно, можно проверить минуты
        if ( 0 <= min && min < 60) {
// Если и минуты правильные, так и пишем
            printf("YES\n");
        }
        else {
            printf("NO\n");
        }
    }
// После else выполняются альтернативные действия   
    else {
        printf("NO\n");
    }

    return 0;
}
```

```
>./ifh
07:05
YES
>./ifh
35:5
NO
>./ifh
12:60
NO
```

Решение получилось правильное, но очень громоздкое.

Решение 2

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int h; // часы
    int min; //  минуты
    scanf("%d:%d", &h, &min);
// часы должны быть не менее 0 и не более 23
// а минуты - от 0 до 59

// проверяем часы и минуты сразу
// используем логическое и (&&)
    if ( 0 <= h && h < 24 && 0 <= min && min < 60) {
        printf("YES\n");
    }
// После else выполняются альтернативные действия   
    else {
        printf("NO\n");
    }

    return 0;
}
```

А можно записать и по-другому

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int h; // часы
    int min; //  минуты
    scanf("%d:%d", &h, &min);
// часы должны быть не менее 0 и не более 23
// а минуты - от 0 до 59

// проверяем часы на недопустимость
// используем переменные для сохранения значений
// логических выражений
    int hNo = 0 > h || h >= 24; // неправильный ввод

//  проверяем минуты на недопустимость минуты сразу
    int minNo = 0 > min || min >= 60; // неправильный ввод

// что-то пошло не так:
    if ( hNo || minNo ) {
        printf("NO\n");
    }
// После else выполняются альтернативные действия   
    else {
        printf("YES\n");
    }

    return 0;
}
```

## Функции- датчики

Иногда ответ типа «да» или «нет» требует выполнения множества действий. Для решения таких проблем удобно использовать функции-датчики. Это функции, которые возвращают целое число - код проверки условия (часто это `0` или `1`).

Задачу со временем попробуем переписать с использованием функции

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int h; // часы
    int min; // минуты
}Timer;

// эта функция ничего не печатает!!!
int isTimeCorrect(Timer a) {
    // часы должны быть не менее 0 и не более 23
    // а минуты - от 0 до 59

    // возвращаем 1 если все верно
    if ( 0 <= a.h && a.h < 24 && 0 <= a.min && a.min < 60)
        return 1;
    // возвращаем код неправильного времени
    return 0;
};

int main() {
    Timer tm;
    scanf("%d:%d", &tm.h, &tm.min);
    // часы должны быть не менее 0 и не более 23
    // а минуты - от 0 до 59

    // проверяем часы 
    // используем функцию-датчик
    if ( isTimeCorrect(tm)) {
        printf("YES\n");        
    } else {
        printf("NO\n");
    }

    return 0;
}
```

А теперь предположим, что необходимо знать, что введено неправильно, часы, минуты или и часы и минуты одновременно.

## Решение 2 (с кодировкой)

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int h; // часы
    int min; // минуты
}Timer;

// эта функция ничего не печатает!!!
int isTimeCorrect(Timer a) {
   // часы должны быть не менее 0 и не более 23
   // а минуты - от 0 до 59

    // notH - содержит результат логической операции (0 или 1)
    int notH = 0 <= a.h && a.h < 24;
    // notMin - содержит результат логической операции (0 или 1)
    int notMin = a.min && a.min < 60;
    // code содержит код проблемы: 0, 1, 2 или 3
    // если notH == 1 и notMin == 1, то все в порядке (3)
    // если notH == 1 и notMin == 0, то минуты не верны (1)
    // если notH == 0 и notMin == 1, то минуты не верны (2)
    // если notH == 0 и notMin == 0, то все не верно (0)
    int code = notH + 2 * notMin;
    // возвращаем code 
    return code;
};

int main() {
    Timer tm;
    scanf("%d:%d", &tm.h, &tm.min);
// часы должны быть не менее 0 и не более 23
// а минуты - от 0 до 59

// проверяем часы 
// == - оператор сравнения на равенство

    if ( isTimeCorrect(tm) == 3) {
            printf("YES\n");        
    }
// != - оператор сравнения на неравенство
    if ( isTimeCorrect(tm) != 3) {
        printf("NO\n");
    }
    if ( isTimeCorrect(tm) == 1 ) {
        printf("NO (мин)\n");
    }
    if ( isTimeCorrect(tm) == 2 ) {
        printf("NO (часы)\n");
    }
    return 0;
}
```

Вот теперь по коду можно определить что случилось с временем. Но эта запись слишком громозка, да и значение `0` было упущено.

## Оператор switch

Рассмотрим выбор из нескольких допустимых значений

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int h;    // часы
    int min;  // минуты
} Timer;

// эта функция ничего не печатает!!!
int isTimeCorrect(Timer a) {
    // часы должны быть не менее 0 и не более 23
    // а минуты - от 0 до 59

    // notH - содержит результат логической операции (0 или 1)
    int notH = 0 <= a.h && a.h < 24;
    // notMin - содержит результат логической операции (0 или 1)
    int notMin = a.min && a.min < 60;
    // code содержит код проблемы: 0, 1, 2 или 3
    // если notH == 1 и notMin == 1, то все в порядке (3)
    // если notH == 1 и notMin == 0, то минуты не верны (1)
    // если notH == 0 и notMin == 1, то минуты не верны (2)
    // если notH == 0 и notMin == 0, то все не верно (0)
    int code = notH + 2 * notMin;
    // возвращаем code
    return code;
};

int main() {
    Timer tm;
    scanf("%d:%d", &tm.h, &tm.min);
    // часы должны быть не менее 0 и не более 23
    // а минуты - от 0 до 59

    int code = isTimeCorrect(tm);
    // code - для проверки какое условие выбирать
    switch (code) {
            // если code ==  0
        case 0:
            printf("NO\n");
            // break прерывает выполнение switch
            break;
            // если code ==  1
        case 1:
            printf("NO\n");
            printf("минуты не верно\n");
            break;
            // если code ==  2
        case 2:
            printf("NO\n");
            printf("часы не верно\n");
            break;
            // если code ==  3
        case 3:
            printf("YES\n");
    }

    return 0;
}
```

`break` прерывает исполнение инструкций в `switch`. Но если его не написать в какой-либо из ветвей, то будут выполняться все следующие инструкции до конца или ближайшего `break`

## Решение с логическими переменными

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int h;    // часы
    int min;  // минуты
} Timer;

// эта функция ничего не печатает!!!
int isTimeCorrect(Timer a) {
    // часы должны быть не менее 0 и не более 23
    // а минуты - от 0 до 59

    // notH - содержит результат логической операции (0 или 1)
    int notH = 0 <= a.h && a.h < 24;
    // notMin - содержит результат логической операции (0 или 1)
    int notMin = a.min && a.min < 60;
    // code содержит код проблемы: 0, 1, 2 или 3
    // если notH == 1 и notMin == 1, то все в порядке (3)
    // если notH == 1 и notMin == 0, то минуты не верны (1)
    // если notH == 0 и notMin == 1, то минуты не верны (2)
    // если notH == 0 и notMin == 0, то все не верно (0)
    int code = notH + 2 * notMin;
    // возвращаем code
    return code;
};

int main() {
    Timer tm;
    scanf("%d:%d", &tm.h, &tm.min);
    // часы должны быть не менее 0 и не более 23
    // а минуты - от 0 до 59

    int code = isTimeCorrect(tm);
    // code - для проверки какое условие выбирать
    switch (code) {
            // если code ==  0
        case 0:
            printf("NO\n");
            // break прерывает выполнение switch
            // но здесь не написан, значит будут выполнены
            // все остальные инструкции до break или конца
            // если code ==  1
        case 1:
            printf("минуты не верно\n");
            // если code ==  2
        case 2:
            printf("часы не верно\n");
            break;
            // если code ==  3
        case 3:
            printf("YES\n");
    }

    return 0;
}
```
```
>./sw
67:90
NO
минуты не верно
часы не верно
>./sw
5:70
минуты не верно
часы не верно
>./sw
25:6
часы не верно
```

## И еще одна запись switch

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int h;    // часы
    int min;  // минуты
} Timer;

// эта функция ничего не печатает!!!
int isTimeCorrect(Timer a) {
    // часы должны быть не менее 0 и не более 23
    // а минуты - от 0 до 59

    // notH - содержит результат логической операции (0 или 1)
    int notH = 0 <= a.h && a.h < 24;
    // notMin - содержит результат логической операции (0 или 1)
    int notMin = a.min && a.min < 60;
    int negMin = a.min < 0;
    int negH = a.h < 0;
    // code содержит код проблемы: 0, 1, 2 или 3
    // если notH == 1 и notMin == 1, то все в порядке (3)
    // если notH == 1 и notMin == 0, то минуты не верны (1)
    // если notH == 0 и notMin == 1, то минуты не верны (2)
    // если notH == 0 и notMin == 0, то все не верно (0)
    int code = notH + 2 * notMin + 10 * negMin + 20 * negH;
    // возвращаем code
    return code;
};

int main() {
    Timer tm;
    scanf("%d:%d", &tm.h, &tm.min);
    // часы должны быть не менее 0 и не более 23
    // а минуты - от 0 до 59

    int code = isTimeCorrect(tm);
    // code - для проверки какое условие выбирать
    switch (code) {
            // если code ==  0
        case 0:
            printf("NO\n");
            // break прерывает выполнение switch
            // но здесь не написан, значит будут выполнены
            // все остальные инструкции до break или конца
            // если code ==  1
        case 1:
            printf("минуты не верно\n");
            // если code ==  2
        case 2:
            printf("часы не верно\n");
            break;
            // если code ==  3
        case 3:
            printf("YES\n");
            break;
            // default будет выполняться для всех отальных значений,
            // не упомянутых в case
        default:
            printf("Все отрицательное\n");
    }

    return 0;
}
```

# 6.2 Вопросы по логическим операциям

Ночь наступает в `22:00` и заканчивается в `6:00`. Дано показание часов h часов и min минут. Правильной записью, для определения является ли это время ночным является


+ [ ] 22 * 60 <= h  * 60 + min  && h * 60 + min <= 24 * 60 && h > 24 * 60 && h < 6 * 60
+ [ ] 22*60 <= h && h <= 6 * 60
+ [ ] h >= 22 && h < 6
+ [ ] h >= 22 || h < 6 && min == 0
+ [x] 22*60 <= h * 60 + min && h * 60 + min < 24 * 60  ||  h > 0 && h * 60 + min  < 6 * 60

$x_1$ и $x_2$ - простые логические переменные.

Они связаны формулой:

​$x_1 x_2 ∨ \overline{x_2 ∨ x_1}$
​
Значение этой формулы __тождественно истинно__

При исполнении С-программы все условия проверяются слева направо.

При этом поверка условия заканчивается в тот момент, когда значение вычисляемого выражения уже не зависит от дальнейших вычислений. Например для выражения $(x_1 ∣∣ x_2)$ достаточно установить истинность $x_1$
​
Для чисел a и b проверяются следующие условия: $a>24,b≤a/b,b>0$

Записью, которая позволит избежать ошибки при исполнении программы будет

```c
if ( b > 0  && b <= a / b && a > 24)
```

$x,yz$ - простые логические переменные.

Их отношение записано формулой: $x∨xy∨yz∨ \overline{x}z$

Самой короткой упрощенной записью этой формулы будет $x∨z$

# 6.3 Задачи

[Контест с задачами](http://judge2.vdi.mipt.ru/cgi-bin/new-client?contest_id=900304)

Задачи разделены на блоки:

+ Для начинающих (первый язык программирования или очень слабый уровень, остальные могут их не решать)
    + if_1 - минимум из двух чисел
    + if_5 - является ли число четным (попробуйте написать и отладить эту программу, не заглядывая в лекции; сравните потом ваше решение с лекционным)
    + if_3 - принадлежит ли точка множеству [-25, 37)
    + if_4 - принадлежит ли точка множеству  (-∞; 37) U [146; ∞)
    + if_m_log5 - сколько километров бежит участник соревнований?
    + if_rect - принадлежит ли точка области (прямоугольник)
+ Обязательные задачи (для всех: и для начинающих, и для тех, кто хорошо программирует)
    + if_A - принадлежит ли точка области (треугольник)
    + if_7 - бьют ли ладьи друг друга?
    + Zif_chinaTime - переведите время в старый восточный формат
    + if_m_log_35 - делится на 3 или 5, но не 15
    + funcp_sort3 - отсортируйте 3 числа (очень полезная функция для следующих задач)
    + if_91 - существует ли треугольник с такими сторонами
    + struct_51 - найти наибольший прямоугольник из двух
    + struct_4 - пересекаются два прямоугольника или нет
    + Zif_11palochek - 11 палочек (нужно чуть-чуть подумать)
    + if_interval1 - add
    + if_interval3 - cross
    + if_interval2 - minus
+ Задачи на "подумать". Не обязательные. Для интереса и удовольствия. Технически их легко могут решить начинающие, но нужно подумать...
    + if_boat - смогут ли эти 3 человека переправиться через реку на лодке?
    + if_bus - на каком автобусе ехать?
    + Aif_romashka - математически угорелая девушка гадает на ромашках о любви.
+ Задачи на сравнение дробных чисел. (Мы пока не написали к ним теорию, но она скоро будет! Тогда эти задачи будут для всех обязательны.)
    + if_10eps
    + if_11eps
    + if_13eps

# 6.4 Рекурсия

## Понятие рекурсивной функции

__Рекурсия -- это определение очередного значения функции через ранее вычисленные значения этой же функции.__

Рассмотрим функцию факториала.

$n!=1⋅2⋅3⋅4⋅⋯⋅n$

Рекурсия определяется через понятие суперпозиции (подстановки) функций в функции

"Обычные формулы", полученные суперпозицией (подстановкой) других более простых (элементарных) формул содержат фиксированное значение операций для любых значений переменных.

Рекурсивные функции отличаются тем, что количество операций для вычисления искомого значения растет в зависимости от $n$

В качестве примера возьмем факториал.

В его определении лежит рекуррентная формула (рекурсивное определение)

$0!=1;(n+1)!=n!(n+1)$

__Функции, которые можно построить из целых чисел и арифметических операций с помощью суперпозиций и рекурсивных определений, называются рекурсивными__

## Простой пример. Вычисление факториала.

Рассмотрим реализацию функции вычисления факториала на языке С

```c
#include <stdio.h>
#include <stdlib.h>

int fact(int n) {
    int res = 1;
    int k = 0;

    printf("вызов с %d\n", n);
    if (n == 0) {
        printf("\nвозврат:\nn:0 - res: 1\n");
        return 1;
    }
    k = fact(n - 1);
    res = n * k;
    printf("для %d:  %d * %d = %d\n",n,  n, k, res);
    return res;
};

int main() {
    int n;
    int res;
    scanf("%d", &n);
    res = fact(n);
    printf("res: %d\n", res);
}
```

Запуск программы с рекурсивной функцией.

```
>./fc
6
вызов с 6
вызов с 5
вызов с 4
вызов с 3
вызов с 2
вызов с 1
вызов с 0 
возврат:
n:0 - res: 1
для 1:  1 * 1 = 1
для 2:  2 * 1 = 2
для 3:  3 * 2 = 6
для 4:  4 * 6 = 24
для 5:  5 * 24 = 120
для 6:  6 * 120 = 720
res: 720
```

Как видно из запуска, функция вызывается до тех пор пока не будет вычислено изначально определенное значение $f(0)=1$. Затем вычисленное значение будет возвращено в вызывающую функцию и использовано в выражении $res=n∗k$. На 6 рекурсивных вызовов приходится `6` возвратов с вычисленным значением.

## Пример бесконечно-рекурсивной функции

Можно написать рекурсивную функцию по-другому.

```c
#include <stdio.h>
#include <stdlib.h>

void aboutGoat() {
    char answer[200];

    printf("Рассказать тебе сказку о сереньком козлике?\n");
    scanf("%s", answer);
    printf("Все говорят, %s.\n");
// Вызов рекурсивной функции
    aboutGoat();
};

int main() {
    aboutGoat();
    return 0;
}
```

Если запустить такую программу, можно легко убедится, что отвечать на вопросы придется без конца.

Это пример рекурсивной функции, в которой наблюдается __недостижимость конца функции__, а значит, и программы.

Вся информация о вызовах функций размещается в специальной области памяти - __стеке__.

__Стек__ - это специальная область памяти, в которой помещается информация о вызванных функциях до момента их завершения.

![06](/C_for_beginners/img/06_01.png)

Пока функция не завершила свою работу, информация о ней остается в стеке. Вновь вызванная функция займет новую память в стеке. Если таких незавершенных вызовов много, то память заканчивается и мы получаем сообщение `Segmentation fault` (`core dumped`) или `Stack overflow`

## Неявная рекурсия

Рассмотрим еще одно написание программы с бесконечным рекурсивным вызовом.

```c
#include <stdio.h>
#include <stdlib.h>

// Если в функциях есть вызов других
// функций, еще не реализованных,
// то вначале делаются ОБЪЯВЛЕНИЯ
// этих функций
// Иначе компилятор не сможет найти вызываемую функцию

void aboutGoat();  // основная функция про козлика
void askYou();     // функция, задающая вопрос
void listenYou();  // функция, получающая ответ

// Каждая из функций явно вызывает не саму себя,
// а ДРУГУЮ функцию.
// Однако, каждая из функций вызывает себя
// косвенно через вызов в другой функции

// Таким образом также получается рекурсивный вызов

void askYou() {
    printf("Рассказать тебе сказку о сереньком козлике?\n");
    // В listenYou() есть вызов askYou()
    listenYou();
};

void listenYou() {
    char answer[200];
    scanf("%s", answer);
    printf("Все говорят, %s.\n", answer);
    // в askYou() есть вызов listenYou()
    askYou();
};
void aboutGoat() { askYou(); };

int main() {
    aboutGoat();
    return 0;
}
```
![06](/C_for_beginners/img/06_02.png)

# 6.5 Отладка с помощью gdb

## Алгоритм Евклида.

В самом простом случае алгоритм Евклида применяется к паре положительных целых чисел и формирует новую пару, которая состоит из меньшего числа и разницы между большим и меньшим числом. Процесс повторяется, пока числа не станут равными. Найденное число и есть наибольший общий делитель исходной пары.

```c
#include <stdio.h>
#include <stdlib.h>
int nod(int a, int b) {
    int res;
    if (a < b) {
        // обмен значениями  a  и b
        // для указателей не применять!! (проверьте почему)
        a = a - b;
        b = b + a;
        a = b - a;
    }
    printf("a: %d b: %d\n", a, b);
    // Условие на выход из функции по получению
    // элементарного результата
    if (a == b) {
        printf("%d == %d\n return\n", a, b);
        return b;
    }
    // Действия перед вызовом
    // Изменение параметров функции
    a = a - b;

    // Вызов рекурсивной функции
    res = nod(a, b);
    // Действия после вызова - присваивание результата к res
    printf("res: %d return \n", res);
    return res;
}

int main() {
    int a, b, res;
    scanf("%d%d", &a, &b);
    res = nod(a, b);
    printf("%d\n", res);
    return 0;
}
```
Запуск с отладочной печатью

```
>./nod 
144 54
a: 144 b: 54
a: 90 b: 54
a: 54 b: 36
a: 36 b: 18
a: 18 b: 18
18 == 18
 return
res: 18 return 
res: 18 return 
res: 18 return 
res: 18 return 
18
>
```

## Короткий вариант без отладочной печати

```c
#include <stdio.h>
#include <stdlib.h>
int nod(int a, int b) {
    int res;
    if (a == b) {
        return b;
    }
    res = (a > b) ? nod(a - b, b) : nod(b, b - a);
    return res;
}

int main() {
    int a, b, res;
    scanf("%d%d", &a, &b);
    res = nod(a, b);
    printf("%d\n", res);
    return 0;
}
```

## Отладка с помощью консольного отладчика GDB

Отладчик - специальная программа, которая позволяет просматривать состояние программы (переменных, функций и т.д.) во время выполнения программы, управлять ее исполнением (выполнять пошагово или до определенных меток или условий). Отладчики имеют множество полезных функций, мы будем знакомиться с ними постепенно.

## Подготовка программы к работе с отладчиком.
Программа должна быть скомпилирована со специальном ключом -g

```bash
>gcc -g nod.c -o nod
```

Теперь отладчик будет "видеть" инструкции программы при запуске.

Запуск с отладчиком

```bash
>gdb nod
GNU gdb (Ubuntu 8.1-0ubuntu3) 8.1.0.20180409-git
Copyright (C) 2018 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
<http://www.gnu.org/software/gdb/documentation/>.
For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from nd...done.
(gdb) 
```

Программа запущена.

Если просто запустить программу (run, r), то она исполнится до конца, и просмотреть моменты исполнения не получится.

Прежде нужно поставить "точки останова" на тех инструкциях или строках, в которых нужно пронаблюдать за исполнением внимательнее.

## Минимальный набор команд gdb

Команда | Пример | Пояснение
-|-|-
`r` | `r` | запуск программы
`r` | `r < t.dat` | запуск с перенаправлением ввода из файла
`с` | `c` | продолжение исполнения с данного места до следующей точки останова
`break (b)` | `b main` | точка останова (`breakpoint`) на функцию `main()`
`break (b)` | `b 12` | точка останова на `12` строку программы
`break ... if` | `b 11 if a == 10` | точка останова на `11` строке, если `a==10`
`break info` | `break info` | информация о точках останова
`delete <n>` | `delete 1` | удаление точки останова
`print (p)` | `p a * a` | печать значения переменной или выражения
`display` | `display a` | просмотр значения или выражения на каждом шаге выполнения
`step (s)` | `s` | выполнение инструкций на одной строке с "заходом" в функцию
`next (n)` | `n` | выполнение инструкций на одной строке (функция выполняется как одна инструкция полностью)
`backtrace (bt)` | `bt` | печать информации о всех незавершеннных функциях (фреймах)
`backtrace (bt) n` | `bt n` | печать информации о функции (фрейме) `n`
`kill` | `kill` | прервать исполнение программы

Пример просмотра выполнения программы с помощью gdb после запуска отладчика:

## Установка breakpoint на функции main и nod

```bash
(gdb) b main
Breakpoint 1 at 0x777: file nod1.c, line 35.
(gdb) b nod
Breakpoint 2 at 0x728: file nod1.c, line 7.
(gdb) 
```
