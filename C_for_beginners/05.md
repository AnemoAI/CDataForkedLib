# 5. Структуры

## 5.1 Структуры

## Объявление новых типов данных.

Типы данных `int`, `long long`, `float`, `double`, `char` и т.д. -- это встроенные типы данных. То есть эти типы уже существуют в языке С.

Иногда удобно определить новое название -- синоним некоторого типа. Это может помочь сделать код более понятным и короче.

Например, указатель на переменную можно назвать другим именем (явно указав в имени, что это указатель: `intPtr` - указатель на `int`):

```c
#include <stdio.h>
#include <stdlib.h>

//typedef служит для объявления нового названия
// уже существующим или объявленным типам данных

// обявление нового имени на указатель для целых чисел
typedef int* intPtr;

//использование
int main(){
    int a;
    // название объявили через typedef  
    intPtr pa; // указатель на int
    // присвоим указателю адрес а  
    pa = &a;
    //прочитаем значение для а через указатель  
    scanf("%d", pa);
    // напечатаем значение а
    printf("a=%d\n", a);
}
```

`typedef` позволяет давать новые имена всем типам данных, известным программе.

## Структуры (записи)

Чтобы понять что такое структуры и зачем они нужны, рассмотрим задачу.

### Задача S1. Механический календарь.

В механическом календаре всего `360` дней в году. Все дни поделены на месяцы (с 1 по 12), в каждом месяце - 30 дней (с 1 по 30).

Сначала на календаре была дата: `year` - год $(0≤y_0≤9999)$, month - месяц $(1≤m0≤12)$, day - день $(1≤m0≤30)$. Если меняется последний день последнего месяца последнего года, то новый год становится нулевым.

Прошло days дней $(0≤y0≤10^6)$.

Требуется определить какая дата должна быть на календаре.

Рассмотрим пути решения задачи.

При решении задачи будет необходимо объявить переменные для описания: 
+ начального времени (`startDay`),
+ количества прошедших дней (`days`) и
+ искомую дату (`newDay`).

При использовании переменных обычным способом понадобится объявить и использовать в программе, как минимум, 7 различных переменных.

Программа получится несколько громоздкой и недостаточно понятной.

Попробуем сгруппировать год, месяц м день в одну переменную, чтобы при программировании можно было пользоваться "начальной датой" (`startDay`) и искомой датой (`newDay`).

Для такого представления данных в языке С есть понятие структура.

__Структура__ - это тип переменных, который программист создает самостоятельно. Для каждой структуры определяются поля или атрибуты: их имена и уже известный программе тип данных.

Фактически несколько переменных (со своими именами и типами) объединены под одним общим именем.

## Описание структуры Date

Опишем тип данных `Date` для описания даты на механическом календаре.

```c
// Date - это имя структуры (новый тип данных)
// Этикет требует чтобы все названия новых типов данных
// начинались с заглавных букв, а переменные - со строчных
// Тогда в тексте программы будет труднее перепутать
// имена переменных и типов данных

struct Date
//  здесь описываются атрибуты (поля) структуры
{
    int year;   // год  даты
    char month; // месяц даты
    char day;   // день даты
};
// описание структуры всегда должно заканчиваться ;
```

При размещении переменной такого типа в памяти, выделяется место в памяти на все атрибуты (иногда чуть больше), и атрибуты располагаются непрерывно в этом выделенном месте.

## Использование структуры в программе

```c
// Начало мантры
#include <stdio.h>
#include <stdlib.h>
// Конец мантры

struct Date
//  здесь описываются атрибуты (поля) структуры
{
    int year;   // год  даты
    char month; // месяц даты
    char day;   // день даты
};
// описанная выше структура - это только тип переменной
//  но не сама переменная
// а struct Date - это имя ТИПА

//использование
int main(){ 
    //объявляем переменную типа struct Date
    struct Date startDay;
    // У переменной startDay есть ПОЛЯ: year, month, day
    int a;
    char b,c;
    // заполним поля переменной startDay значениями
    scanf("%d%hhd%hhd",&a,&b,&c);

    //========= Обращение к атрибутам переменной startDay ===========
    /*
    при обращении называется имя переменной (startDay) и, 
    через точку, имя атрибута (поля)

    */

    // обращение (присваивание значения) к полю year
    startDay.year = a;
    // обращение (присваивание значения) к полю mount
    startDay.month = b;
    // обращение (присваивание значения) к полю day
    startDay.day = c;
    // печать значений атрибутов переменной startDay (для проверки)
    printf("%04d.%02hhd.%02hhd\n",startDay.year, startDay.month, startDay.day);
    return 0;
}
```

Для решения задачи нужны еще переменные. Добавим еще объявление переменной `newDay` и `days` (`s_date.c`):

```c
// Начало мантры
#include <stdio.h>
#include <stdlib.h>
// Конец мантры

struct Date
//  здесь описываются атрибуты (поля) структуры
{
    int year;   // год  даты
    char month; // месяц даты
    char day;   // день даты
};
// описанная выше структура - это только тип переменной
//  но не сама переменная
// а struct Date - это имя ТИПА

//использование
int main(){ 
    //объявляем переменную типа struct Date
    struct Date startDay;
    // У переменной startDay есть ПОЛЯ: year, month, day

    //объявляем еще одну переменную типа struct Date
    struct Date newDay;
    // У переменной newDay есть так же ПОЛЯ: year, month, day
    // Но у каждой переменной типа Date свои поля: значения полей с
    // одинаковыми названиями у разных переменных хранятся в разных 
    // областях памяти

    int days; // прошедшие дни
    int y;
    char m,d;
    // заполним поля переменной startDay значениями
    scanf("%d%hhd%hhd",&y, &m, &d);

    //========= Обращение к атрибутам переменной startDay ===========
    /*
    при обращении называется имя переменной (startDay) и, 
    через точку, имя атрибута (поля)

    */

// Чтобы упростить вычисления, пусть первый день месяца будет - 0
// и первый месяц года, тоже будет 0

    // обращение (присваивание значения) к полю year
    startDay.year = y;
    // обращение (присваивание значения) к полю mount
    startDay.month = m - 1;
    // обращение (присваивание значения) к полю day
    startDay.day = d - 1;

    // При присваивании структурных перемен все атрибуты переменной startDay
    // присваиваются соответствующим (по именам) атрибутам newDay
    newDay = startDay;

    // печать значений атрибутов переменной newDay (для проверки)
 // при выводе нужно указать правильный номер месяца и года 
    printf("newDay: %04d.%02hhd.%02hhd\n", newDay.year, newDay.month + 1, newDay.day + 1 );


    scanf("%d", &days);

    // Вычисление новой даты для механического календаря

        m = startDay.month + (newDay.day + days) / 30;
    newDay.day += days;
    newDay.day %= 30;    
    newDay.month = m % 12;
    newDay.year += m / 12 ;


    // печать новой даты
    printf("newDay: %04d.%02hhd.%02hhd\n",newDay.year, newDay.month - 1, newDay.day - 1);
    return 0;
}
```

Проограмма `s_date.c` без комментариев и картинок

```c
#include <stdio.h>
#include <stdlib.h>

struct Date {
    int year;   // год  даты
    char month; // месяц даты
    char day;   // день даты
};

int main(){ 

    struct Date startDay; // начальная дата
    struct Date newDay;   // искомая дата
    int days;             // прошедшие дни
    int y;
    char m,d;

    scanf("%d%hhd%hhd", &y, &m, &d);

    startDay.year = y;
// Чтобы упростить вычисления, пусть первый день месяца будет - 0
// и первый месяц года, тоже будет 0
    startDay.month = m - 1;
    startDay.day = d - 1;

    newDay = startDay;

// при выводе нужно указать правильный номер месяца и года 
    printf("newDay: %04d.%02hhd.%02hhd\n", newDay.year, newDay.month + 1, newDay.day + 1 );

    scanf("%d", &days);

        m = startDay.month + (newDay.day + days) / 30;
    newDay.day += days;
    newDay.day %= 30;    
    newDay.month = m % 12;
    newDay.year += m / 12 ;

    // печать новой даты
    printf("newDay: %04d.%02hhd.%02hhd\n",newDay.year, newDay.month + 1, newDay.day + 1);
    return 0;
}
```

Запуск.

```
>./s_date
1 12 29
startDay: 0001.12.29
20
newDay: 0002.01.19
>./s_date
1 12 29
startDay: 0001.12.29
1
newDay: 0001.12.30
```

## Указатели на структуры.

Переменная структуры, как и все остальные переменные, располагается в памяти. Поэтому для структур также как и для встроенных переменных можно иметь переменные-указатели на структуры.

```c
// Начало мантры
#include <stdio.h>
#include <stdlib.h>
// Конец мантры

struct Date
//  здесь описываются атрибуты (поля) структуры
{
    int year;   // год  даты
    char month; // месяц даты
    char day;   // день даты
};
// описанная выше структура - это только тип переменной
// но не сама переменная
// а struct Date - это имя ТИПА

//использование
int main(){ 
    //объявляем переменную типа struct Date
    struct Date oneDay;

    // Объявляем переменную-указатель на структуры типа Date
    // Эта переменная занимает место только для хранения адреса!!
    struct Date *ptrDate;

    // Переменной можно сразу задать начальное значение (инициализация)
    int days = 0;

    // получим значения для атрибутов переменной oneDay
    scanf("%d%hhd%hhd",&(oneDay.year), &(oneDay.month), &(oneDay.day));

    // Присвоим адрес переменной oneDay указателю
    ptrDate = &oneDay; 

    //========= Обращение к атрибутам структуры через указатель ===========
    /*
    Если мы используем имя переменной-структуы, то обращение к полям происходит
    через ".": oneDay.year

    Если указатель имеет значение реального адреса переменной-структуры, 
    то обращение к атрибутам этой структуры  происходит через "->"
    */

    // обращение к атрибуту year
    days += ptrDate->year * 12 * 30;
    // обращение к атрибуту month
    days += ptrDate->month * 30;
    // обращение к атрибуту day
    days += ptrDate->day;
    // печать значений атрибутов переменной oneDay (для проверки)
    printf("oneDay: %04d.%02hhd.%02hhd\n",ptrDate->year, ptrDate->month, ptrDate->day);

    printf("дней с начала отсчета: %d\n",days);
    return 0;
}
```
Запускаем работу программы

```
>./ptr_st
2 9 10
oneDay: 0002.09.10
дней с начала отсчета: 1000
>
```

## Сложные структуры

Структурные переменные еще называют объектами. При этом каждый такой объект может иметь в качестве атрибутов (полей) другие объекты - структурные переменные.

Указатели на атрибуты (поля) объектов (структурных переменных)
Каждый атрибут объекта - это тоже переменная, которая занимает место в памяти и имеет адрес. Значит можно получить адрес каждого атрибута и работать с ним также как и с указателями обычных переменных.

```c
#include <stdio.h>
#include <stdlib.h>

// Допустим описана подобная структура
typedef struct Coord
{
    int x; // координата по x 
    int y; // координата по y
} Point;

// Примеры работы с указателями на атрибуты
int main(){
    // Инициализация (присвоение начальных значений) 
    // первое число - первому атрибуту (x)
    // второе число - второму атрибуту (y)

    Point coord = {7, 5}; // объект coord
    Point *directPoint;  // уаказатель на объект типа Point
    int *px, *py;       // указатели на int

    directPoint = &coord; // адрес coord присваивается directPoint

    // Присваивание адресов атрибутов coord:
    // Сначала получаем доступ к атрибуту,
    // а затем вычисляем его адрес
    px = &(coord.x);
    py = &(coord.y);

    // Отладочная наглядная печать
    printf("Object! px: %p coord.x: %d\n", px, coord.x);
    printf("Object! py: %p coord.y: %d\n", py, coord.y);

    // Присваивание адресов атрибутов через указатель directPoint:
    // Сначала получаем доступ к атрибуту,
    // а затем вычисляем его адрес
    px = &(directPoint->x);
    py = &(directPoint->y);

    // Отладочная наглядная печать
    printf("Direct! px: %p coord.x: %d\n", px, coord.x);
    printf("Direct! py: %p coord.y: %d\n", py, coord.y);

    // Получение значений атрибутов через scanf 
    scanf("%d%d", &(coord.x), &(coord.y));

    // Отладочная наглядная печать
    printf("scanf! coord.x: %d\n", coord.x);
    printf("scanf! coord.y: %d\n", coord.y);

    return 0;
}
```

Запуск программы:

```
./direct
Object! px: 0x7ffe2c520d10 coord.x: 7
Object! py: 0x7ffe2c520d14 coord.y: 5
Direct! px: 0x7ffe2c520d10 coord.x: 7
Direct! py: 0x7ffe2c520d14 coord.y: 5
12 56
scanf! coord.x: 12
scanf! coord.y: 56
```

## Задача S2. Длина отрезка на плоскости

Отрезок на плоскости задается координатами точек своих концов. Все координаты - целые числа, не превышающие $10^4$.

Требуется вычислить длину этого отрезка с точностью до второго знака после запятой.

### Решение задачи S2.

Заметим, что решать задачи, скажем по геометрии, гораздо удобнее, если оперировать геометрическими понятиями, а не набором переменных.

Поэтому будем использовать структуры, описывающие геометрические объекты: точки и отрезки.

```c
// Начало мантры
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

// Конец мантры

// Дадим структуре struct Coord  синоним Point - новое имя типа 

typedef struct Coord
//  точка на плоскости
{
    short int x;   // координата точки x
    short int y;   // координата точки y
} Point;
// теперь вместо struct Coord a; 
// можно написать просто Point a;


typedef struct LineSegment
{
    // описание вершин отрезка
    // Point - это структура struct Coord
    Point a;        // вершина a
    Point b;        // вершина b
    float distance; // расстояние между вершинами (длина отрезка)
} Line; // новое имя типа Line


int main(){ 
    //объявляем переменную типа Line
    Line lin;

    // Присвоим значения координатам вершин отрезка lin
    lin.a.x = 0; // вершина a, координата x
    lin.a.y = 0; // вершина a, координата y
    lin.b.x = 3; // вершина b, координата x
    lin.b.y = 4; // вершина b, координата y

    // вычислим длину отрезка lin и присвоим это значение атрибуту distance

    lin.distance = sqrtf((lin.a.x - lin.b.x) * (lin.a.x - lin.b.x) + (lin.a.y - lin.b.y) * (lin.a.y - lin.b.y));

    // печать
    printf("lin: a(%d, %d) b(%d, %d), %0.2f\n", lin.a.x, lin.a.y, lin.b.x, lin.b.y, lin.distance);
    return 0;
}
```

```
>./line
lin: a(0, 0) b(3, 4), 5.00
>
```

## Указатель как атрибут структуры (объекта)

Пусть имеется двое часов, которые показывают дату, час и минуты. Показания часов и минут могут различаться, а дата на часах не зависит от часов и минут и должна быть одинаковой.

Для описания подобной ситуации разумно использовать указатель на переменную с датой.

```c
// Начало мантры
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

// Конец мантры

typedef struct ClockFace
{
    char min;         // минуты
    char h;           // часы
    // этот атрибут будет иметь смысл только если ему
    // передать адрес существующей переменной для даты 
    int *dayOfmonth; // адрес переменной день месяца
} Ctime;

int main(){ 
    //объявляем переменные типа Ctime
    Ctime timer1, timer2;
    // объявляем переменную для даты
    int date = 21;

    // Присвоим значения атрибутам timer1
    timer1.h = 11;
    timer1.min = 10;
    // присваиваем адрес переменной date
    // до этого реального адреса в dayOfmonth не было
    timer1.dayOfmonth = &date;

    // Присвоим значения атрибутам timer1
    timer2.h = 3;
    timer2.min = 45;
    // присваиваем адрес переменной date
    // до этого реального адреса в dayOfmonth не было
    timer2.dayOfmonth = &date;

    // изменим значение даты и напечатаем результат
    date++;

    // печать
    // *(timer1.dayOfmonth) - значение по адресу timer1.dayOfmonth
    printf("timer1: %02d %02hhd:%02hhd\n", *(timer1.dayOfmonth), timer1.h, timer1.min);
    printf("timer2: %02d %02hhd:%02hhd\n", *(timer2.dayOfmonth), timer2.h, timer2.min);
    return 0;
}
```

```
>./ptimer
timer1: 22 11:10
timer2: 22 03:45
>
```

Структура может иметь указатель на переменные любого типа, в том числе и на структурные переменные (объекты)

# 5.2 Структуры и функции

## Зачем нужны структуры

Использование структур в простых программах не делают процесс программирования более удобным. Программа, в некоторых случаях, становится более понятна, но все же достаточно громоздка.

Структуры больше всего нужны при работе с функциями. Структурные переменные (объекты) и указатели на них используются как атрибуты функций и как возвращаемые значения функций.

## Простая передача функции атрибута-объекта (структуры)

### FS3. Функция печати даты.

Дата представлена как структура:

```c
typedef struct Dt
{
    unsigned char day;
    unsigned char month;
    unsigned int year;
} Date;
```

Написать функцию `void printDate(Date day);`, которая печатает время в привычном нам формате `yyyy-mm-hh`.

### Решение FS3.

```c
#include <stdio.h>
#include <stdlib.h>

// Допустим описана подобная структура
typedef struct Termin
{
    unsigned char day;   // день месяца
    unsigned char month; // месяц года
    unsigned int year;   // год
} Date;

// Функция печати даты
// функция принимает объект struct Termin
// вместо struct Termin можно использовать
// синоним Date
void printDate(struct Termin a){
    // при вызове функции с параметром, значения всех 
    // полей копируется в соответствующие поля объекта a
    printf("%04u-%02hhu-%02hhu\n", a.year, a.month, a.day);
};

int main(){
    Date dt; // объект дата

    // получение значений атрибутов с консоли
    scanf("%u%hhu%hhu", &(dt.year), &(dt.month), &(dt.day));

    // вызов функции printDate(), параметр функции dt
    printDate(dt);

    return 0;
}
```

## Передача указателя на объект (структуру)

### FS3. Функция получения даты с консоли.
Дата представлена как структура:

```c
typedef struct Dt
{
    unsigned char day;
    unsigned char month;
    unsigned int year;
} Date;
```
Написать функцию `void getDate(Date * day);`, которая считывает время в привычном нам формате `yyyy-mm-hh`.

Решение.

```c
#include <stdio.h>
#include <stdlib.h>

// Допустим описана подобная структура
typedef struct Termin
{
    unsigned char day;   // день месяца
    unsigned char month; // месяц года
    unsigned int year;   // год
} Date;

// Функция печати даты
// функция принимает объект struct Termin
// вместо struct Termin можно использовать
// синоним Date
void printDate(struct Termin day){
    // при вызове функции с параметром, значения всех 
    // полей копируется в соответствующие поля объекта a
    printf("%04u-%02hhu-%02hhu\n", day.year, day.month, day.day);
};

// Функция получения даты
// функция принимает указатель на объект типа Date
// Это позволит изменять значения переменной по адресу
void getDate(Date* a){
    // при вызове функции с параметром указателем
    // в переменную-указатель копируется адрес объекта
    // Таким образом scanf работает с адресом
    // a->year - получение ЗНАЧЕНИЯ атрибута ПО АДРЕСУ объекта
    // &(a->year) - получение адреса атрибута, 
    // можно писать &a->year, приоритет оператора -> выше, чем у &
    scanf("%u%hhu%hhu", &(a->year), &(a->month), &(a->day));
};

int main(){
    Date dt; // объект дата

    // получение значений атрибутов с консоли
    // парметр - адрес dt
    // значение dt в main() меняется функцией getDate()
    getDate(&dt);

    // вызов функции printDate(), параметр функции - dt
    // значение dt копируется в локальную переменную функции
    // значение dt в main() не меняется 
    printDate(dt);

    return 0;
}
```

Программа без объяснений

```c
#include <stdio.h>
#include <stdlib.h>

// Допустим описана подобная структура
typedef struct Termin
{
    unsigned char day;   // день месяца
    unsigned char month;// месяц года
    unsigned int year;   // год
} Date;

// Функция печати даты

void printDate(struct Termin day){
    printf("%04u-%02hhu-%02hhu\n", day.year, day.month, day.day);
};

// Функция получения даты
void getDate(Date* a){
    scanf("%u%hhu%hhu", &a->year, &a->month, &a->day);
};

int main(){
    Date dt; // объект дата

    // получение значений атрибутов с консоли
    getDate(&dt);

    // печать
    printDate(dt);

    return 0;
}
```

## Функция возвращает структуру

### FS4. Функция вычисления суммы времен.

Часы имеют 12-ти часовой циферблат. Человек вышел из дома когда часы показывали `hour` часов, `min` минут, `sec` секунд. Он вернулся через `dhour` часов $(0≤dhour≤12)$, `dmin` минут, `dsec`.

Требуется вычислить показания часов когда человек вернулся.

### Решение (1)FS4

```c
#include <stdio.h>
#include <stdlib.h>

// Допустим описана подобная структура
typedef struct Time
{
    unsigned char hour;   // часы
    unsigned char min;    // минуты
    unsigned char sec;    // секунды
} Timer;

// функция принимает объект struct Time
// вместо struct Time можно использовать
// синоним Timer
// Передаем указатель на объект типа Timer
// для передачи значений
void timePlus(Timer a, struct Time b, Timer * tmp){
    // Чтобы функция могла вернуть какой-либо объект,
    // он должен быть в ее распоряжении

    int sec, min, h;
    sec = a.sec + b.sec;
    min = sec / 60 + a.min + b.min;
    h = min / 60 + a.hour + b.hour;

    // заполнение атрибутов переданного объекта
    tmp->sec = sec % 60;
    tmp->min = min % 60;
    tmp->hour = h % 12;

};

// функция печати времени в формате hh:mm:ss
void printTime(Timer a)
{
    printf("%02hhu:%02hhu:%02hhu\n", a.hour, a.min, a.sec);
};

int main(){
    Timer t1, t2; // объект дата
    Timer res;

    // получение значений атрибутов с консоли
    // ввод в формате hh:mm:ss
    scanf("%hhu:%hhu:%hhu", &(t1.hour), &(t1.min), &(t1.sec));
    scanf("%hhu:%hhu:%hhu", &(t2.hour), &(t2.min), &(t2.sec));

    // вызов функции timePlus(), c передачей 
    // указателя на res
    timePlus(t1, t2, &res);

    // вызов функции печати
    printTime(res);
    return 0;
}
```

`struct` `Time` и `Timer` используется в примере одновременно в аргументах функции. Чтобы показать, что они равноправны с точки зрения компилятора. Но не делайте так в настоящем коде! Только `Timer`.

### Решение (2)FS4

```c
#include <stdio.h>
#include <stdlib.h>

// Допустим описана подобная структура
typedef struct Time
{
    unsigned char hour; // часы
    unsigned char min;  // минуты
    unsigned char sec;  // секунды
} Timer;

// функция печати времени в формате hh:mm:ss
void printTime(Timer a)
{
    printf("%02hhu:%02hhu:%02hhu\n", a.hour, a.min, a.sec);
};

// функция принимает объект struct Termin
// вместо struct Termin можно использовать
// синоним Date

Timer timePlus(Timer a, struct Time b){
    // Чтобы функция могла вернуть какой-либо объект,
    // он должен быть в ее распоряжении

    // Создадим временный объект tmp типа Timer,
    // в который запишем результаты вычислений
    // после окончания работы функции все локальные
    // переменные, в том числе и tmp прекратят свое
    // существование
    Timer tmp;

    int sec, min, h;
    sec = a.sec + b.sec;
    min = sec / 60 + a.min + b.min;
    h = min / 60 + a.hour + b.hour;

    tmp.sec = sec % 60;
    tmp.min = min % 60;
    tmp.hour = h % 12;

    // возврат объекта типа  Timer
    return tmp;
};


int main(){
    Timer t1, t2; // объект дата
    Timer res;

    // получение значений атрибутов с консоли
    // ввод в формате hh:mm:ss
    scanf("%hhu:%hhu:%hhu", &(t1.hour), &(t1.min), &(t1.sec));
    scanf("%hhu:%hhu:%hhu", &(t2.hour), &(t2.min), &(t2.sec));

    // вызов функции timePlus() и получение копии 
    // возвращаемого значения
    res = timePlus(t1, t2);

    // вызов функции печати
    printTime(res);
    return 0;
}
```

Запуск и проверка

```
>./timePlus
10:40:50
2:20:10
01:01:00
>
```

## SF5 Разность показания часов.

Часы имеют 24-часовой циферблат. Два события произошли в течение одних суток (не ранее 0 часов и не позднее 24) и зафиксированы показания часов: первого события и второго.

Требуется вычислить сколько времени прошло между событиями с точностью до секунд.

### Решение SF5

```c
#include <stdio.h>
#include <stdlib.h>

// Допустим описана подобная структура
typedef struct Time
{
    unsigned char hour; // часы
    unsigned char min;  // минуты
    unsigned char sec;  // секунды
} Timer;

// функция печати времени в формате hh:mm:ss
void printTime(Timer a)
{
    printf("%02hhu:%02hhu:%02hhu\n", a.hour, a.min, a.sec);
};

// функция вычисления разницы между показаниями 
// предполагаем, что первый параметр - более позднее событие,
// а второй параметр - более раннее
Timer timeMinus(Timer a, struct Time b){
    // Чтобы функция могла вернуть какой-либо объект,
    // он должен быть в ее распоряжении

    // Создадим временный объект tmp типа Timer,
    // в который запишем результаты вычислений
    // после окончания работы функции все локальные
    // переменные, в том числе и tmp прекратят свое
    // существование
    Timer tmp;
    unsigned char sec, min, h;

    h =  a.hour - b.hour - 1;
    min = 60 + a.min - b.min - 1;
    sec = 60 + a.sec - b.sec;

    tmp.hour = h + (( min + sec / 60)) / 60 ;
	tmp.min = (min  + sec / 60 ) % 60;
	tmp.sec = sec % 60;

    // возврат объекта типа  Timer
    return tmp;
};


int main(){
    Timer t1, t2; // объект дата
    Timer res;

    // получение значений атрибутов с консоли
    // ввод в формате hh:mm:ss
    scanf("%hhu:%hhu:%hhu", &(t1.hour), &(t1.min), &(t1.sec));
    scanf("%hhu:%hhu:%hhu", &(t2.hour), &(t2.min), &(t2.sec));

    // вызов функции timePlus() и получение копии 
    // возвращаемого значения
    res = timeMinus(t1, t2);

    // вызов функции печати
    printTime(res);
    return 0;
}
```

Запуск и проверка

```
>./timeMin
10:5:40
8:45:55
01:19:45
>
```

## Математическое отступление (дополнительный код)

При решении задачи необходимо было обязательно учитывать какое из показаний больше.

Чтобы избежать этого можно использовать так называемый "дополнительный код" для представления отрицательного числа.

Допустим наши числа могут принимать некоторое максимальное (по модулю) значение `max`, то есть, в нашем представлении, $max+1=0$. Обозначим $z=0$, если число `number` у нас положительное и $z=1$ , если - отрицательное. Тогда: $kode=max−number$ и $z=1$ - число $number<0$, представленное в дополнительном коде.

Например, если $max=1000$, то дополнительный код для $−17:kode=1000−17=9983,z=1$ Имеется два числа a и b и неизвестно какое из них больше. Разность чисел a и b можено представить так:

$diff=a−b=a+(max−b)−max$ 

или

$diff=(a+kode)−max,z=1$

Рассмотрим сумму $trans=a+kode.-trans>max$, тогда $res=trans−max$ - получаем положительное число, в нормальном виде и $z=0$. $-trans<max$,  тогда $res=trans−max=−(max−trans)$ - это отрицательное число в дополнительном коде и $z=1$. Здесь число необходимо представить в нормальном виде

Необходимо научиться представлять число в дополнительном коде и производить с ним действия.

Рассмотрим простые пример для десятичных чисел, не превышающих $10000$.

Пример 1 
$a=287,b=170$ $a−b=a+(−b) −b$ представляем в дополнительном коде. 

$10000−170=9830$ 

Замечаем, что эту операцию удобно выполнять поразрядно. Но, младшие нули остаются нулями, а первый ненулевой разряд дополнительного кода - это дополнение до $10: 10−7$, а все остальные после первого ненулевого разряда - дополнение до $9: 9−1$, $9−0$ и т.д.

Таким образом для решения задачи необходимо написать функцию преобразования числа в дополнительный код.

Представим десятичное число $(−10000<number<10000)$ поразрядно и отдельно представим знак числа.

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct Num
{
    char a0; // младший разряд числа
    char a1; // второй разряд
    char a2; // третий разряд
    char a3; // четвертый разряд
    char sign;
} Number;

// Функция представления десятичного числа в обратном коде
Number addCode(Number d){
    Number tmp; // переменная для возврата значения

/*====== Преобразование разрядов ==========================
 для вычисления значения дополнительного разряда учитываем что
 первый ненулевой младший разряд дополнительного числа вычисляется
 как 10 - a0, 
 а все остальные после первого ненулевого вычисляются как
 9 - a0 
 p "отвечает" за 10 - a0
 z "отвечает" за 9 - a0 
=========================================================== */
  char z = 0; // самый младший разряд вычисляется как 
  char p = 1; // 10 - a0

    //обратный код для младшего разряда
    tmp.a0 = (10 - d.a0) % 10;;

    // Если tmp.a0 > 0, то для всех последующих операций
    // нужно сделать p=0
    // !!tmp.a0 будет 1 если tmp.a0 > 0 и будет 0, если tmp.a0 = 0
    // если !!tmp.a0 = 1, то (p + !!tmp.a0) % 2 будет 0
    // если tmp.a0 = 0, то (p + !!tmp.a0) % 2 будет 1
    // То есть значение всего выражения зависит от (p + !!tmp.a0) % 2
    p = p * ( (p + !!tmp.a0) % 2);

    // z становится 1 как только p будет 0
    z = !p;
    printf("a0: %hhd p: %hhd z: %hhd\n", tmp.a0, p, z);
    tmp.a1  = z * ( 9 - d.a1) + (p * ( 10 - d.a1)) % 10;

    // После того как один раз p стало 0, значение выражения p * ( (p + !!tmp.a1) % 2)
    // больше не зависит от (p + !!tmp.a1) % 2, оно будет 0
    p = p * ( (p + !!tmp.a1) % 2);

    // с этой поры z всегда 1
    z = !p;
    printf("a1: %hhd p: %hhd z: %hhd\n", tmp.a1, p, z);

    tmp.a2  = z * ( 9 - d.a2) + (p * ( 10 - d.a2)) % 10; 
    p = p * ( (p + !!tmp.a2) % 2);
    z = !p;
    printf("a2: %hhd p: %hhd z: %hhd\n", tmp.a2, p, z);

    tmp.a3  = z * ( 9 - d.a3) + (p * ( 10 - d.a3)) % 10; 
    p = p * ( (p + !!tmp.a2) % 2);
    z = !p;
    printf("a3: %hhd p: %hhd z: %hhd\n", tmp.a3, p, z);

    tmp.sign = d.sign;
    return tmp;
};

void prNum(Number tmp) {
    printf("%hhd %hhd %hhd %hhd %hhd \n", tmp.a3, tmp.a2, tmp.a1, tmp.a0, tmp.sign);
};

int main() {
    Number nb={0,0,5,1,1}, nz;
    nz=addCode(nb);
    prNum(nz);
}
```

Запуск и проверка

```
>./ac
1 0 0 5 1
a0: 9 p: 0 z: 1
a1: 4 p: 0 z: 1
a2: 9 p: 0 z: 1
a3: 9 p: 0 z: 1
9 9 4 9 1
>./ac
1 5 1 0 0
a0: 0 p: 1 z: 0
a1: 0 p: 1 z: 0
a2: 9 p: 0 z: 1
a3: 4 p: 0 z: 1
4 9 0 0 1
>./ac
1 0 5 1 0
a0: 0 p: 1 z: 0
a1: 9 p: 0 z: 1
a2: 4 p: 0 z: 1
a3: 9 p: 0 z: 1
9 4 9 0 1
>
```

Конечно, для работы с простыми числами проще было бы воспользоваться обычными средствами. Но часто приходится выполнять "обычные" математические функции для сложных величин, которые записаны в неоднородных системах счисления. Например, даты.

## Примечание о работе с числами в неоднородных системах счисления

Гораздо проще формулы для сложения или вычитания часов, минут и секунд получаются, если написать функции преобразования времени в виде `Timer` в количество секунд с `0:00` (назовем это `usec`) и обратно. Но они будут неверно срабатывать, если `from > to`. Подумайте, как можно изменить код, чтобы он работал для задачи "Электричка выехала во время `from` и приехала во время `to`, сколько времени была в пути электричка?" 

Электричка может выехать в `23:40:00` и приехать в `0:15:00`, в пути `0:35:00`.

```c
int time2usec(Timer t) {
    int res = t.hour * 24 + t.min;  // minutes since 0:00
    res = res * 60 + t.sec;
    return res;
}
Timer usec2time(int sec) {
    Timer t;
    t.sec = sec % 60;   
    sec = sec / 60;     // осталось минут
    t.min = sec % 60;   
    sec = sec / 60;     // осталось часов
    t.hour = sec % 24;
    return t;
}
Timer timeMinus(Timer from, Timer to){
    Timer tmp;
    int sec_from = time2usec(from);
    int sec_to = time2usec(to);
    tmp = usec2time(sec_to - sec_from);

    // возврат объекта типа  Timer
    return tmp;
};
```

# 5.3 Контрольные вопросы

Дана структура и фрагмент кода:

```c
struct Vector {
    float x;
    float y;
};

int main() {
    struct Vector vec;
    int x, y;
    //..... 
    vec.x = y;
    vec.y = y;
}
```
При таком написании

+ [ ] компилятор выдаст ошибку так как есть переменные с одинаковыми названиями
+ [ ] компилятор выдаст ошибку, так как не соответствуют имена
+ [ ] компилятор выдаст ошибку так как нарушен порядок присваивания
+ [x] синтаксической ошибки нет
+ [ ] компилятор выдаст ошибку, так как не соответствуют типы

Дана структура и код программы:

```c
typedef struct Vec {
    float x;
    float y;
} Vector;

int main() {
    Vector vec;
    Vector * pvec;
    int x, y;
    pvec = &vec;
    pvec.x = x;
    vec.y = y;
}
```

При таком написании

+ [ ] компилятор выдаст ошибку, так как для доступа к атрибуту через pvec нужно использовать .
+ [ ] компилятор выдаст ошибку так как есть переменные с одинаковыми названиями
+ [x] компилятор выдаст ошибку, так как для доступа к атрибуту через pvec нужно использовать ->
+ [ ] компилятор выдаст ошибку, так как для доступа к атрибуту через vec нужно использовать ->
+ [ ] синтаксической ошибки нет

Дана структура и код программы:

```c
typedef struct Vec {
    float x;
    float y;
} Vector;

int main() {
    Vector vec;
    Vector * pvec;
    int x, y;
    pvec->x = x;
    vec.y = y;
    printf("x: %f y: %f\n", pvec->x, vec.y);
}
```

При таком написании

+ [ ] компилятор выдаст ошибку, так как для доступа к атрибуту через vec нужно использовать ->
+ [x] результат работы программы не определён, так как pvec не получает адреса переменной-структуры
+ [ ] программа запустится и напечатает ожидаемый результат
+ [ ] компилятор выдаст ошибку, так как для доступа к атрибуту через pvec нужно использовать .
+ [ ] компилятор выдаст ошибку, так как не соответствуют типы атрибутов при печати

Дана структура и код программы:

```c
typedef struct Vec {
    int x;
    int y;
} Vector;

int main() {
    Vector vec;
    Vector * pvec;
    int x, y;
    int *px;
    pvec = &vec;
    // необходимо получить адрес атрибута x
    // ...
}
```

Адрес атрибута x можно получить:

```c
px = &(pvec->x);
```

Дана структура и код программы:

```c
typedef struct Vec {
    int x;
    int y;
} Vector;

// реализация функции
int funct(Vector *a, Vector b) {
 // здесь должен быть код
};
```

При копировании из `b` в `a` правильным написанием будет 

```c
a->x = b.x;
```

# 5.4 Задачи

[Задачи](http://judge2.vdi.mipt.ru/cgi-bin/new-client?contest_id=900303) в проверяющем контесте.