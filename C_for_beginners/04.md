# 4. Функции и указатели

# 4.1 Адреса и указатели

## Адреса и указатели

Все значения переменных хранятся в памяти компьютера. Вся память разбита на ячейки -- байты. Все байты памяти имеют номера.

На сегодняшний момент в каждом байте по 8 бит. Бит может принимать значений либо 0, либо 1.

Байт -- это минимальная адресуемая часть памяти. Нельзя просто так обратиться к биту.

Из нулей и единиц можно составлять числа в двоичной системе счисления.

Все байты в памяти имеют свой номер - адрес.

![04](/C_for_beginners/img/04_01.png)

![04](/C_for_beginners/img/04_02.png)

## Переменные в памяти

Переменные разных типов занимают разное количество байт. Например, целые числа, типа `int` для нашего компилятора `gcc` занимают `4` байта, а символы типа `char` занимают только один байт.

В различных системах размер для переменных конкретных типов может быть разным.

С некоторыми типами переменных мы уже знакомы. Теперь можно определить сколько байт в памяти занимают переменные того или иного типа.

Для этого напишем простую программу, которая определит сколько байт занимают переменные в зависимости от типа в данной системе.

```c
// Начало мантры
#include <stdio.h>
#include <stdlib.h>
// Конец мантры

// Запуск программы начинается с main
int main(){
    int a;        // целые числа
    float fa;     // дробные числа
    char z;       // символы
    long long al; // длинные целые числа
    double df;    // длинные дробные числа
    int lin;      // для размера числа

    // Для определения размера воспользуемся sizeof():
    lin = sizeof(a);
    printf("размер int: %d\n", lin);
    lin = sizeof(long long);
    printf("размер long long: %d\n", lin);
}
```

Результат работы программы:

```
>./check_lin
 >размер int: 4
 >размер long long:8
```

Видим, что целые числа типа `int` занимают `4` байта, а `long long` -- `8`. Хотя в других системах может быть по-другому.

Адрес переменной считается с первого байта, в который будет записываться и храниться значение этой переменной.

Адрес также можно поместить в специальную переменную, чтобы можно было его вычислять, хранить, изменять и т.д.

## Указатели

Для указания адреса, то есть номера байта, с которого записаны значения, служат переменные -- указатели адреса или просто указатели.

Для каждого типа переменных -- свой тип указателя.

Описываются они так:

```c
int a;     // целое число
// для хранения адреса целого числа
int *pa;   // указатель на целое число

float fa;  // дробное число (с плавающей точкой)
// для хранения адреса числа c плавающей точкой
float *dfa; // указатель на дробное число.

char z;    // для короткого числи или символа
// для хранения адреса символа
char *uz;  // указатель на короткое число или символ
```

Можно передать адрес переменной указателю:

```c
// знак "амперсент" - оператор вычисления адреса
pa = &a; // адрес a присвоен переменной pa

// печать адреса
// %p - печать адреса (номера первого байта переменной) в
// шестнадцатеричном виде  
printf("адрес: %p\n",pa);
```

Можно получить значения переменной, адрес которой находится в переменной:

```c
// знак "звездочка" - оператор вычисления значения переменной по этому адресу
a = *pa; // значение (число) по адресу в pa присваивается переменной a
// печать адреса
printf("адрес: %p значение: %d\n", pa, a);
```

## Программа с указателями
Напишем небольшую программу с указателями (адресами переменных).

```c
#include <stdio.h>
#include <stdlib.h>

int main(){

    // Эта переменная может хранить адрес числа (указатель),
    // которое занимает 1 байт памяти
    // Самой переменной типа char в этой программе нет
    char *pc;
    // если увеличить pс на 1, то она будет указывать на
    // СЛЕДУЮЩУЮ ПЕРЕМЕННУЮ после char
    // Значит, адрес увеличится на 1.

    // создадим переменную для беззнакового целого.
    // как мы уже видели, для целой переменной int нужны 4 байта
    unsigned int a;

    // это указатель для целой переменной
    int *pa;
    // если увеличить pa на 1, то она будет указывать на
    // СЛЕДУЮЩУЮ ПЕРЕМЕННУЮ после int
    // Значит, адрес увеличится на 4.


    // В каждом байте переменной типа unsigned int
    // можно записать число от 0 до 255
    // Eсли у нас 4 байта, то получается  4 таких числа

    // Число, которое может так записываться в unsigned int
    // представляeтся так:

    // 7.2.5.3
    a = 3 + 256 * ( 5 + 256 * ( 2 + 256 * 7 ) );

    // Получилось целое число без знака по основанию 256.

    // передадим адрес переменной а в переменнную pa
    // Передается номер первого байта из четырех, в
    // которых записано число
    pa =&a;

    //========================================================
    //  Тип указателя можно менять
    //========================================================
    // преобразуем указатель на int (4 байта)
    // в указатель на char (1 байт).
    pc = (char*)pa;
    // pa также указывает на int,
    // а pc имеет тот же адрес (номер байта),
    // но является указателем на char

    // напечатаем значение a
    // %u - десятичное число без знака
    printf("a = %u\n",a);

    // напечатаем значение первого, второго, третьего
    // и четвертого байта переменной a;
    // результат выведем в восьмеричном виде

    // Первый байт имеет адрес pa и pc. Но, если увеличить pa (pa + 1), то
    // pa увеличится сразу на 4 байта (int), поэтому  будем пользоваться
    // pc (char, то есть 1 байт).
    // pc + 1 увеличит адрес на 1 байт, pc + 2 - на 2 байта, pc + 3 увеличит на 3 байта.
    // a0 - первый байт, а1 - второй, a2 - третий, a3 - четвертый
    printf("\t a0 = %u \n\t a1 = %u \n\t a2 = %u \n\t a3 = %u \n",*pc, *(pc + 1), *(pc + 2), *(pc + 3));
    return 0;
}
```

![04](/C_for_beginners/img/04_03.png)

```
a = 117572867
    a0 = 3
    a1 = 5
    a2 = 2
    a3 = 7
```

Вывод | Пояснения
-|-
a0 = 3 | значение в первом байте (адрес не менялся)
a1 = 5 | значение во втором байте (адрес увеличился на 1)
a2 = 3 | значение в третьем байте (адрес увеличился на 2)
a3 = 3 | значение во четвертом байте (адрес увеличился на 3)

Здесь получилось, что число записано в "обратном".

Вообще порядок записи в память компьютера может быть разным и зависит от типа процессора.

"Обратную" запись числа удобно использовать при решении задач с "длинными" числами.

# 4.2 Вопросы по указателям

Для проверки размера переменной типа float была написана программа:

```c
// Начало мантры
#include <stdio.h>
#include <stdlib.h>
// Конец мантры

// Запуск программы начинается с main
int main(){ 
    float fa;
    // Для определения размера воспользуемся sizeof():
    printf("размер float: %d\n", sizeof(fa));
}
```
Результат работы программы:
```
>./size
8
```
Программа напечатала

+ [ ] номер байта - адрес переменной fa
+ [x] количество памяти, занимаемой fa в байтах
+ [ ] номер бита - адрес переменной fa
+ [ ] значение переменной fa, преобразованное к целому числу
+ [ ] количество памяти, занимаемой fa в битах

В программе необходимо описать переменную a типа long long и указатель на эту переменную pa:

Правильной записью является:

```c
long long a;
long long *pa;
```

Дан текст программы

```c
// Начало мантры
#include <stdio.h>
#include <stdlib.h>
// Конец мантры

// Запуск программы начинается с main
int main(){
    int a = 5; 
    int *pa;
    // Необходимо присвоить переменной pa адрес a

    return 0;
}
```

Чтобы присвоить переменной pa адрес a необходимо написать

```
pa = &a;
```

Дан текст программы

```c
// Начало мантры
#include <stdio.h>
#include <stdlib.h>
// Конец мантры

// Запуск программы начинается с main
int main(){
    int a = 5; 
    int *pa;
    int *pb;
    pa = &a;
    pb = pa;

    pa++;
    a = *pb;

    return 0;
}
```

В результате этого действия

+ [ ] значением a будет компьютерный мусор
+ [ ] значением a будет адрес, увеличенный на 1
+ [x] значением a будет 5
+ [ ] значением a будет 6
+ [ ] будет ошибка программы

Дан текст программы

```c
// Начало мантры
#include <stdio.h>
#include <stdlib.h>
// Конец мантры

// Запуск программы начинается с main
int main(){
    int a = 5; 
    int *pa;

    printf("a: %d\n", *pa);
    return 0;
}
```

В результате работы

+ [ ] программа напечатает адрес переменной a
+ [ ] программа напечатает 0
+ [ ] программа напечатает адрес переменной a в десятичном виде
+ [ ] программа напечатает 5
+ [x] программа напечатает "компьютерный мусор" или упадет

Пять переменных типа `int` записаны в памяти подряд.

Указатель `point` содержит адрес первой переменной, а указатель `pointNext` - должен содержать адрес четвертой переменной.

Чтобы получить адрес четвертой переменной нужно выполнить операцию:

```c
pointNext = point + 3
```

# 4.3 Функции и их параметры

## Функции
Часть программы можно описать отдельно, дать этой части собственное имя и исполнять как отдельную инструкцию.

Таким образом мы получим функцию.

Каждая функция имеет:
+ собственное имя,
+ набор переменных, которые функции необходимо знать для вычислений,
+ значение, которое вычисляет функция в процессе своей работы,
+ набор инструкций, которые выполняет функция

## Самая простая функция

```c
// Начало мантры
#include <stdio.h>
#include <stdlib.h>
// Конец мантры

//===================================================
// Объявление и описание функции hello
//===================================================

// имя функции - hello, 
// переменных нет, 
// никаких значений эта функция не вычисляет

// Функция не возвращает никаких значений,
// значит нужно указать void
 void hello() // интерфейс функции
// в {} - тело функции
{
// здесь описание функции - инструкции для выполнения
    printf("Hello\n");
};
// Объявление или описание каждой функции должно заканчиваться ;

 // Запуск программы начинается с main()
int main(){ 

// ВЫЗОВ функции
//  с этого места начнут выполняться инструкции функции hello()

  hello();

// с этого места будут выполняться иструкции main,
// которые записаны после вызова hello()

  return 0;
}
```

Короткий вариант:

```c
#include <stdio.h>
#include <stdlib.h>

void hello()    // реализация функции (definition)
{
    printf("Hello\n");
}

// Запуск программы начинается с main()
int main(){ 

    hello();    // вызов функции (call)
    hello();    // вызов функции (call)

    return 0;
}
```

Реализуем только один раз.
Вызываем (используем) сколько хотим раз (много).

## Печать двенадцатеричной цифры

Рассмотрим функцию с одним параметром (аргументом). Эта функция получает целое положительное число, не превышаюшее `12` и печатает его в `12`-ричном виде.

```c
#include <stdio.h>

// unsigned char в скобках функции - тип переменной, 
// которую ожидает функция
void dozenPrint(unsigned char dig){
// Здесь (внутри тела функции) объявляются переменные функции dozenPrint
// Это внутренние или ЛОКАЛЬНЫЕ переменные
// Только функция dozenPrint может с ними работать
// Все остальные функции эти переменные "не видят"

// dig - тоже локальная переменная функции dozenPrint
// просто ее объявили при описании интерфейса функции
    char doz;

    doz = !!(dig / 10) * ('A' + dig % 10) + ! (dig / 10) * (dig + '0');
    printf("%c\n", doz);
};

// main() - тоже функция.
// Эта функция вызывается системой при запуске прогаммы.
int main(){
    unsigned char digit; // число от 0 до 12

//==== Все значения вводим в main() ============

// ввод беззнакового char
// h - означает, что число короткое,
// hh - самое короткое целое число - char
// u - целое без знака (положительное или 0)
    scanf("%hhu", &digit);

// Вызов функции dozenPrint()
// функции передается ЗНАЧЕНИЕ переменной digit
// В самой функции dozenPrint() это значение получает 
// внутренняя (локальная) переменная dig

    dozenPrint(digit);

    return 0;
}
```

Программа `fdozen` без комметариев

```c
#include <stdio.h>

void dozenPrint(unsigned char dig){
    char doz;

    doz = !!(dig / 10) * ('A' + dig % 10) + ! (dig / 10) * (dig + '0');
    printf("%c\n", doz);
};

int main(){
    unsigned char digit; // число от 0 до 12

    scanf("%hhu", &digit);
    dozenPrint(digit);

    return 0;
}
```
Запуск программы:
```
>./fdozen
7
7
```
```
>./fdozen
10
A
>
```

## Округление числа (математическое)

Рассмотрим функцию, которая вычисляет значение и возвращает его. Эта функция должна округлять десятичную дробь до целого по правилам математики. То есть, $3.2 → 3$, а $4.6 → 5$

```c
// Начало мантры
#include <stdio.h>
#include <stdlib.h>
// Конец мантры

/* 
Имя функции - truncate. 
Она получает дробную переменную a (аргумент).
Результатом работы функции должно быть округленное по
математическим правилам целое число.

Число, которое ВОЗВРАЩАЕТ функция может быть присвоено 
другой переменной в main(), или напечатано, или его можно
использовать в вычислениях.
*/

// В описании интерфейса функции 
// указывается int - тип возвращаемого значения

int truncate( float fract) // интерфейс функции
{
// переменная float fract уже описана как аргумент и является 
// внутренней (локальной) переменной.
// имя a - это локальное имя, видимое только внутри функции
// все переменные с таким же именем, описанные в другом месте
// функция truncate не видит
// переменная number примет ЗНАЧЕНИЕ той переменной, которая будет передаваться 
// функции при вызове.

    int rez; // локальная переменная rez

// инструкции
// вычисление значения переменной rez
    rez = fract + 0.5;

// return завершает работу функции и
// возвращает указанное ему значение 
// (здесь rez)  
    return rez;
};

// Запуск программы начинается с main
// main() - тоже функция :)
int main(){ 
    float z; // дробное число
    int result; // целое число для результата

    scanf("%f",&z);  
// ======= Вызов функции truncate() ============================
// Функции передается ЗНАЧЕНИЕ переменной z, которое
// будет присвоено локальной переменной fract
// Программист не должен знать как называются локальные
// переменные в функции.

    result = truncate(z);

// После выполнения инструкций функции trancate() выполняются инструкции main()
// и первая инструкция - это присваивание полученного от truncate()
// значения переменной result, 
// Затем инструкция печати:
    printf("result=%d\n",result);
    return 0;
}
```

Truncate без комментариев

```c
#include <stdio.h>
#include <stdlib.h>

int truncate( float fract) {
    int rez; 
    // вычисление значения переменной rez
    rez = fract + 0.5;
    return rez;
};

int main(){ 
    float z;        // дробное число
    int result;     // целое число для результата    
    scanf("%f",&z);  
    result = truncate(z);
    printf("result=%d\n",result);
    return 0;
}
```
Результат запуска программы с проверкой правильности вывода для различных значений z

```
>./trunc
0
0
>./trunc
10
10
>./trunc
3.14
3
>./trunc
3.54
4
>./trunc
3.5
4
```

При написании и проверке программ необходимо тестировать (проверять) работу программы с различными входными значениями. При этом нужно использовать значения, отвечающие за различные ситуации, в которые может попасть программа

Входное значение | Ожидаемый ответ | Результат | Что проверяли
-|-|-|-
0 | 0 | 0 | ноль - специальное значение в математике, проверка на ноль часто бывает полезна
10 | 10 | 10 | проверка работы с целым числом
3.14 | 3 | 3 | проверка работы с дробным остатком меньше 0.5
3.54 | 4 | 4 | проверка работы с дробным остатком больше 0.5
3.5 | 4 | 4 | проверка работы с дробным остатком равным 0.5

## Передача в функцию множества параметров (аргументов)
В функцию можно передать больше одного параметра (аргумента).

Сложение двух чисел.

```c
// Начало мантры
#include <stdio.h>
#include <stdlib.h>
// Конец мантры

/* 
имя функции - add. Она получает два аргумента - целых числа,
а результатом работы функции должна быть сумма чисел
*/

// Аргументы функции записываются так: тип передаваемого значения, 
// имя локальной (для функции) переменной.
// Далее через запятую так указываются все передаваемые аргументы.

// Запомним, что при передаче не важны имена переменных, значения которых передаются.
// ВАЖЕН ПОРЯДОК.
// Значение первой указанной в вызове переменной будет передано first, а второй - second

int add( int first, float second) // интерфейс функции
{
// переменные first и second - локальные.
// В эти переменные передаются значения при вызове функции

    int rez; // локальная переменная rez

// ===== Инструкции ========================================
// округлим second и преобразуем результат к целому значению.
    rez = first + (int)(second + 0.5);

// вернем результат   
    return rez;
};

 // Запуск программы начинается с main
int main(){ 
    int x,   // целое число
    float y; // дробное число
    int result; // целое число для результата

    scanf("%d%f",&x, &y);  
//====== Вызов функции =================================
// вычисленное значение (возвращаемое) присвоим result
// значения переменных x и y будет присвоено локальным  
// переменным first и second соответственно внутри функции 
// first - первая указанная в описании переменная получит значение первой переменной в вызове, то есть x (ожидается int), 
// second - вторая переменная в описании (ожидается float) получит значение второй переменнной в вызове (y).
    result = add(x, y);
    printf("result = %d\n", result);
}
```

При необходимости функции можно передавать и большее количество параметров. При этом правила передаче значения будут таким же: типы и значение передаваемых в функцию переменных должны соответствовать порядку этих переменных в описании функции.

## Передача в функцию указателя (адреса) переменной

Если мы передаем в функцию значения переменных, то эти значения передаются локальным переменным функциии. В этом случае, в процессе работы функция изменяет значения только своих локальных переменных, а значения переменных, которые использовались в вызове функции не меняются

Тем не менее иногда требуется написать функции, которые должны именно менять значение переданных переменных.

Попробуем написать функцию, которая меняет переменные местами.

```c
// Начало мантры
#include <stdio.h>
#include <stdlib.h>
// Конец мантры

// попробуем поменять значения переменных местами
// функция никаких значений не вычисляет
void swap0( int a, int b) // интерфейс функции
{
// переменные a и b - локальные.
// Передаются значения этих переменных

    int c; // локальная переменная c
    c = a;
    a = b;
    b = c;

//===== Это "отладочная печать" ======================
// она нужна, чтобы понять какие значения 
// принимают переменные в процессе работыв функции 

    printf("в swap0: a = %d b = %d\n", a,b);

// если функция работает правильно, после тестирования 
// эту инструкцию следует удалить или 
// закомментировать
};

 // Запуск программы начинается с main
int main(){ 
    int x, y; // дробное число

    scanf("%d%d",&x,&y);  
    swap0(x,y);
    printf("в main: x = %d x = %d\n", x,y);
    return 0;
}
```

Результат работы программы:

```
7 9
в swap0: a = 9 b = 7
в main: x = 7 x = 9
```

Как видно из вывода программы, в функции `swap0` переменные поменялись значениями, а в `main()` - нет.

Чтобы решить задачу, передадим в функцию указатели (адреса) переменных из `main()`.

![04](/C_for_beginners/img/04_04.png)

Локальные переменные из функции примут в качестве значения адреса передаваемых параметров. Тогда, значения будут записываться непосредственно по указанному адресу, а не по локальному имени переменной.

```c
#include <stdio.h>
#include <stdlib.h>
// Конец мантры

// попробуем поменять значения переменных местами
// функция никаких значений не возвращает
// первый аргумент - указатель (адрес) целого числа
// второй аргумент - указатель (адрес) целого числа
void swap1( int *pointA, int *pointB) // интерфейс функции
{
// переменные a и b - локальные, но содержат АДРЕСА.

    int c;  // локальная переменная c - целое число
//============ Это отладочная печать ==================================================
// Посмотрим переданные адреса и значения по этим адресам
    printf("\n swap1:\n");
    printf("адрес первого параметра: %p, значение по этому адресу: %d\n", pointA, *pointA);
    printf("адрес второго параметра: %p, значение по этому адресу: %d\n", pointB, *pointB);
//====================================================================================== 
    c = *pointA; // присваиваем c значение по АДРЕСУ pointA
    *pointA = *pointB;// значение по АДРЕСУ pointB записывается по АДРЕСУ pointA
    *pointB = c; // значение переменной с записывается по АДРЕСУ pointB

//============ Это тоже отладочная печать ==============================================
// эта функция ничего не должна печатать  
    printf("\n в swap1: *pointA = %d *pointB = %d\n", *pointA, *pointB);
};
 // Запуск программы начинается с main
int main(){ 
    int x, y; // целые числа, которые будем менять
    x = 7;
    y = 9;
//============ Это отладочная печать ==================================================
// Посмотрим переданные адреса и значения по этим адресам
    printf("main:\n");
    printf("адрес x: %p, значение по этому адресу: %d\n", &x, x);
    printf("адрес y: %p, значение по этому адресу: %d\n", &y, y);
//====================================================================================== 

// scanf() - тоже функция и тоже изменяет значения x и y, поэтому
// в scanf() тоже передаются адреса   
//  scanf("%d%d",&x, &y);

//======== передаем АДРЕСА =========================
// & - операция вычисления адреса переменной  
    swap1( &x, &y);
//===== Печать результата:  
    printf("\n в main: x = %d y = %d\n", x, y);
    return 0;
}
```
Результат работы программы:

```
main:
адрес x: 0x7ffcc00f8890, значение по этому адресу: 7
адрес y: 0x7ffcc00f8894, значение по этому адресу: 9

 swap1:
адрес первого параметра: 0x7ffcc00f8890, значение по этому адресу: 7
адрес второго параметра: 0x7ffcc00f8894, значение по этому адресу: 9

 в swap1: *pointA = 9 *pointB = 7

 в main: x = 9 y = 7
```

Как видно из печати адреса переменных и в функции `main()`, и в функции `swap1()` были одинаковые, поэтому значения записывались именно в те места, которые соответсвовали адресам.

Обратим еще внимание на то, что `printf()` и `scanf()` - тоже функции. При этом функция `scanf()` меняет значения передаваемых ей переменных. Значит, она тоже требует адреса переменных.

### Функция swap1() - короткая запись без отладочной печати с вводом значений переменных через консоль

```c
#include <stdio.h>
#include <stdlib.h>
// Конец мантры

void swap1( int *pointA, int *pointB) // интерфейс функции
{
    int c;  // локальная переменная c - целое число

    c = *pointA; // присваиваем c значение по АДРЕСУ pointA
    *pointA = *pointB;// значение по АДРЕСУ pointB записывается по АДРЕСУ pointA
    *pointB = c; // значение переменной с записывается по АДРЕСУ pointB
};


int main(){ 
    int x, y; // целые числа, которые будем менять

    // scanf() - тоже функция и тоже изменяет значения x и y, поэтому
    // в scanf() тоже передаются адреса 
    scanf("%d%d",&x, &y);

    //======== передаем АДРЕСА =========================
    // & - операция вычисления адреса переменной  
    swap1( &x, &y);

    //===== Печать результата:  
    printf("\n в main: x = %d y = %d\n", x, y);
    return 0;
}
```

## Меняем значения переменных с помощью функций

Рассмотрим задачу.

Площадь была измеряна в квадратных сантиметрах $cm^2$ . Эту площадь необходимо представить в метрах квадратных $(m^2)$ с точностью до целых.

### Первое решение

```c
#include <stdio.h>
#include <stdlib.h>
// Конец мантры

// передача указателя на переменную и 
// изменение значения по адресу

void toM2(int *pointcm2)
{
// /= оператор, эквивалентный a = a / <делитель>
    *pointcm2 /= 10000;

};

 // Запуск программы начинается с main
int main(){ 
    int s; // целые числа, которые будем менять

// scanf() - тоже функция и тоже изменяет значения x и y, поэтому
// в scanf() тоже передаются адреса   
    scanf("%d",&s);

//======== передаем АДРЕС =========================
// & - операция вычисления адреса переменной  
    toM2( &s);
//===== Печать результата:  
    printf("\n площадь: %d\n", s);

    return 0;
}
```
```
./arr
256740

площадь: 25
```

### Второе решение

```c
#include <stdio.h>
#include <stdlib.h>
// Конец мантры

// передается значение переменной
// функция возвращает вычисленное значение
// и оно присваевается той же переменной

int toM2R(int s)
{
    // можно сразу вернуть вычисленное значение
    // без присваивание его переменной
    return s / 10000;
};

// Запуск программы начинается с main
int main(){ 
    int s; // целые числа, которые будем менять

    // scanf() - тоже функция и тоже изменяет значения x и y, поэтому
    // в scanf() тоже передаются адреса   
    scanf("%d",&s);

    s = toM2R(s);

    //===== Печать результата:  
    printf("\n площадь: %d\n", s);

    return 0;
}
```

```
./arr
256740

площадь: 25
```

## Некоторые математические функции языка С

В языке С существует множество уже реализованных функций. В том числе и математических.

Рассмотрим пример вычисления квадратного корня из числа

```c
#include <stdio.h>
#include <stdlib.h>
// подключили математику
#include <math.h>
// Конец мантры

 // Запуск программы начинается с main
int main(){ 
    float vol; // из этого числа извлекается корень
    float res; // корень
    scanf("%f",&vol);

    // sqrtf() - функция вычисления корня квадратного
    res = sqrtf(vol);
    //===== Печать результата:  
    printf("%0.4f\n", res);

    return 0;
}
```

Компиляция и запуск программы с математическими функциями
```
> gcc sq.c -o sq -lm
>./sq
250000
500.0000
```


Функция | Назначение
-|-
`float sqrtf(float x);` | вычисление квадратного корня
`float logf(float x);` | вычисление натурального логарифма
`int abs(int j);` | вычисление модуля целого числа
`float fabsf(float x);` | вычисление модуля числа типа float

Для всех этих функций есть аналогичные для других типов переменных. Интерфейс функций можно посмотреть в справочной системе man
```
>man fabs
FABS(3)                    Linux Programmer's Manual                   FABS(3)

NAME
       fabs, fabsf, fabsl - absolute value of floating-point number

SYNOPSIS
       #include <math.h>

       double fabs(double x);
       float fabsf(float x);
       long double fabsl(long double x);

       Link with -lm.

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       fabsf(), fabsl():
           _ISOC99_SOURCE || _POSIX_C_SOURCE >= 200112L
               || /* Since glibc 2.19: */ _DEFAULT_SOURCE
               || /* Glibc versions <= 2.19: */ _BSD_SOURCE || _SVID_SOURCE

DESCRIPTION
       These  functions return the absolute value of the floating-point number
       x.
```

Команды сравочной системы аналогичны командам `vim`, но исключают изменение текста

При возведении числа в квадрат или третью степень стоит пользоваться умножением

# 4.4 Задачи урока

[Контест задач](http://judge2.vdi.mipt.ru/cgi-bin/new-register?contest_id=000302) со свободной регистрацией в МФТИ.
Зарегистрируйтесь и пользуйтесь этим логином во всех контестах данного курса.

Если у вас возникли проблемы с регистрацией, пишите в комментариях.