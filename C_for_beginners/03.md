# 3. Переменные, встроенные типы данных. Операции

# 3.1 Переменные. Типы данных

## Переменные. Типы данных.

Вся информация в вычислительных устройствах является цифровой. Что это значит?

В привычном нам представлении цифрами записываются числа. Как целые, так и дробные. Существуют математические правила для записи иррациональных, комплексных и других чисел. Эти правила определяют набор используемых для записи чисел символов - цифры, и порядок их расположения. Набор правил для записи чисел называется системой счисления. Эти системы либо исторически сложились, либо были выбраны как наиболее удобные для совершения определенных математических операций.

Числам, записанным цифрами, по определенным правилам могут быть поставлены в соответствие различные объекты и их свойства. Например, символы кодируются целыми числами, а цвета, отображаемые на экране компьютера кодируются сочетанием трех целых чисел.

Информацию, которую живые существа воспринимают и обрабатывают естественным образом, необходимо представлять в числовом виде для обработки с помощью компьютера и хранения в памяти компьютера.

Для записи и последующей передачи информации, подлежащей логическому анализу, люди используют различные физические объекты: бумагу, ткань, камни, скалы, собственное тело (татуировки), тело животных, бересту, глину, веревки, магнитные устройства, лазерные диски и т.д.

Любой реальный объект имеет бесконечное количество свойств и состояний. Даже математические абстракции оперируют понятием "бесконечность": линия бесконечной длины, бесконечно тонкая нить, бесконечная дробная часть у иррациональных чисел и т.д. Например, для числа pi можно вычислить любой десятичный знак, но этих знаков бесконечно.

Бесконечное количество информации невозможно записать и логически проанализировать за конечное время используя вычислительные устройства с дискретной конечной памятью.

Но для решения вполне определенного класса задач с некоторой точностью достаточно бывает ограниченного количества информации.

По способу представления обрабатываемой информации вычислительные машины можно разделить на аналоговые, в которых информация представлена в виде непрерывно изменяющихся переменных, выраженных физическими величинами (силой тока, напряжение), и цифровые, в которых информация представлена в виде набора дискретных значений (чисел) физической величины. Современные вычислительные машины являются цифровыми, то есть они используют дискретные сигналы для представления и обработки информации. Используемая при этом система счисления определяется числом устойчивых состояний дискретных элементов, на которых сделан компьютер. Сравнительная простота реализации быстродействующих дискретных элементов, использующих два состояния, определила использование в современных компьютерах двоичной системы счисления.

Более подробно свойства двоичной системы мы рассмотрим позже.

Программа, запущенная на компьютере использует память для вычислений. Вся память, используемая для записи, разделена на ячейки (байты). Для записи одного числа используется определенное количество байтов.

Язык программирования определяет имя переменной (символьное название места в памяти, где записано число) и тип переменной (количество байт и способ представления числа, записанного в эту область памяти).

## Простая задача

Попробуем решить простую задачу.

### Задача P1

Лекция длилась 2 часа 37 минут.

Требуется написать программу на языке С, чтобы подсчитать длительность лекции в минутах и еще в секундах.

Решение:
+ Программа состоит из инструкций компьютеру.
+ Инструкции могут складываться в выражения. Одна инструкция - это тоже выражение.
+ Каждое выражение заканчивается символом ;
+ Все инструкции выполняются последовательно с первой по последнюю. "Непоследовательное" выполнение будет рассматриваться позже. Арифметические выражения выполняются слева направо.
+ Выполнение начинается с `main()`. Если `main()` нет в тексте программы на С, программа выполняться не сможет. Все инструкции, которые будет выполнять `main()`, помещаются в {}

```c
// Это комментарий. Он не выполняется
// здесь объяснения на одну строку
/*
Это тоже комментарий. Здесь будут объяснения на несколько строк.
*/

// Это начало "мантры". 
// Эти строки нужны для того, чтобы заработала программа.
// Но их смысл которых будет объяснен в позже, в других уроках
#include <stdio.h>
#include <stdlib.h>
// Это конец "мантры".
//===========================================================

// Это main() - начало выполнения программы
//-----------------------------------------------------------
int main() {
//------------------------------------------------------------
// Объявление переменных.
//------------------------------------------------------------
/*
 Для решения задачи нужны целые числа. В языке С нужно объявить
 число целым. Выберем для этого тип int. Далее указывается ИМЯ
 переменной.
 Для решения наших задач предполагаем, что переменная типа
 находится в пределах от -2147483648 до  +2147483647
 Если переменная объявлена, но в нее ничего не записано,
 то будем считать, что ее содержимое (ЗНАЧЕНИЕ) не определено
*/

    int min; // переменная для минут
    int sec; // переменная для секунд
//------------------------------------------------------------
/*
 Объявления переменных, вычисления и т.д. - это инструкции для
 выполнения. Каждая инструкция заканчивается или выражение, сосотящее из инструкций заканчивается ;
 Если написаны несколько ;; подряд, то это ПУСТЫЕ инструкции.
 Они не приводят ни к каким действиям.
 Если ; нет после окончания выражения, это ошибка. Такая программа работать нне будет
*/

// Производим вычисления:
// * - умножение, + - сложение
// = - присваивание записывает число в переменную min

    min = 2 * 60 + 37;

// Значение min определено. Это 157.
// Можно использовать переменную min в следующих вычислениях
    sec = min * 60;

//-----------------------------------------------------------
// Печать на экран значений переменных min и sec
//-----------------------------------------------------------
/*
  printf - для печати
    печатает текст, заключенный в кавычки
  шаблон %d указывает, что вместо него нужно подставить
  значение переменной, которая записана после текста
  после запятой. %d - означает, что будет напечатано целое
  число
  \n означает перенос строки
*/
    printf("минуты: %d\n", min);
    printf("секунды: %d\n", sec);
    return 0;
}
```

Сохраним программу под именем `time1.c` Проверим как работает эта программа.

Программисты обычно пишут только те комментарии, которые поясняют, что они пишут и зачем. Посмотрим как выглядит наша программа без дополнительных объяснений. Каждый логический блок обычно отделяется от другого пустой строкой:

```c
#include <stdio.h>

int main() {
    int min; // переменная для минут
    int sec; // переменная для секунд

    min = 2 * 60 + 37;
    sec = min * 60;

    printf("минуты: %d\n", min);
    printf("секунды: %d\n", sec);

    return 0;
}
```

### Компиляция и запуск
```bash
>gcc time1.c -o time1
>ls
time1.c time1
>./time1
минуты: 157
секунды: 9420
>
```

### На самом деле
Для решения наших задач предполагаем, что переменная типа `int` находится в пределах от `-2147483648` до `+2147483647`.

Если переменная объявлена, но в нее ничего не записано, то будем считать, что ее содержимое (ЗНАЧЕНИЕ) не определено, то есть может оказаться любое число.

## Усложняем задачу (1)

В предыдущей задачи использовались константные значения.

Поставим задачу в более общем виде.

### Задача P2

Лекция длилась `h` часа `min` минут.

Требуется подсчитать длительность лекции в минутах и еще в секундах.

Решение Для решения задачи необходимо сообщить программе значения переменных `h` и `min`.

Добавим строки.

```c
int h;              // переменная для часов

scanf("%d", &h);    //запись значения в h
scanf("%d", &min);  //запись значения в min
```

Для получения значений с консоли используем `scanf`.
+ `%d` означает получение целого числа
+ значение записывается в переменную, записанную после текста
+ знак & перед именем переменной нужно писать обязательно

Итого получили программу:

```c
#include <stdio.h>

//===========================================================
// Это main() - начало выполнения программы
//-----------------------------------------------------------
int main() {
    //------------------------------------------------------------
    // Объявление переменных.
    //------------------------------------------------------------
    /*
     Для решения задачи нужны целые числа. В языке С нужно объявить
     число целым. Выберем для этого тип int. Далее указывается ИМЯ
     переменной.
     Для решения наших задач предполагаем, что переменная типа
     находится в пределах от -2147483648 до  +2147483647
     Если переменная объявлена, но в нее ничего не записано, то
     будем считать, что ее содержимое (ЗНАЧЕНИЕ) не определено
    */
    int h;   // переменная для часов
    int min; // переменная для минут
    int sec; // переменная для секунд
    //------------------------------------------------------------

    //------------------------------------------------------------
    /*
      для получения значений с консоли используем scanf
      %d означает получение целого числа
        значение записывается в переменную, записанную после текста
      знак & перед именем переменной нужно писать обязательно
    */
   scanf("%d", &h);     //запись значения в h
   scanf("%d", &min);  //запись значения в min
    //------------------------------------------------------------

    // Производим вычисления:
    /*
      сначала вычисляется значение выражения
      h * 60 + min,
      затем это значение записывается в переменную min
      вместо старого
    */

    min = h * 60 + min;

    // Значение min определено.
    // Можно использовать переменную min в следующих вычислениях
    sec = min * 60;

    //-----------------------------------------------------------
    // Печать на экран значений переменных min и sec
    //-----------------------------------------------------------
    /*
      printf - для печати
        печатает текст, заключенный в кавычки
      шаблон %d указывает, что вместо него нужно подставить
      значение переменной, которая записана после текста
      после запятой. %d - означает, что будет напечатано целое
      число
      \n означает перенос строки
    */
    printf("минуты: %d\n", min);
    printf("секунды: %d\n", sec);
    return 0;
}
```

Сохраним программу в файл `time2.c`.

## Короткий вариант программы:

```c
#include <stdio.h>

int main() {
    int h;   // часы
    int min; // минуты
    int sec; // секунды

    // читаем часы и минуты
    scanf("%d", &h);
    scanf("%d", &min);

    min = h * 60 + min;
    sec = min * 60;

    // выводим минуты и секунды
    printf("минуты: %d\n", min);
    printf("секунды: %d\n", sec);

    return 0;
}
```

Запишем еще `makefile` (`<TAB>` - означает клавишу табуляции)

```bash
all:
<TAB>gcc time2.c -o time2
```

Проверим, содержимое текущего каталога:

```bash
>ls
time1.c time2.c makefile
```

Создадим запускаемый файл time1 и проверим содержимое каталога:

```c
>make
>ls
time1.c time1 time2.c makefile
```

Запустим программу `time1`

```bash
>./time1
```

Программа требует ввода значений. Напечатаем число часов и минут. После этого получим результат работы программы.

```
10 45
минуты: 645
секунды: 38700
>
```

## Обратная задача.

### Задача P3
Лекция длилась `sec` секунд.

Требуется подсчитать длительность лекции в часах, минутах и секундах.

Решение

```c
#include <stdio.h>

//===========================================================
// Это main() - начало выполнения программы
//-----------------------------------------------------------
int main() {
//------------------------------------------------------------
// Объявление переменных.
//------------------------------------------------------------

    int h;   // переменная для часов
    int min; // переменная для минут
    int sec; // переменная для секунд
//------------------------------------------------------------

//------------------------------------------------------------
/*
  Получаем значение sec
*/
   scanf("%d", &sec);     //запись значения в sec

//------------------------------------------------------------

// Производим вычисления:
/*
  Замечаем, что в минутах 60 секунд, а в часе 3600. Чтобы вычислить количество минут,
  нужно поделить НАЦЕЛО sec на 60.
  Оператор / - деление. При делении целых чисел происходит деление НАЦЕЛО,
  то есть дробная часть отбрасывается.
  Оператор % - вычисление остатка от деления. Применяется только к целым числам!!
*/
/*
---------------------------------------------------------------------------------
  Если sec = 7323, то целых часов будет 7323/3600 = 2,
  секунд, не вошедших в часы: 7323 - 2 * 3600 = 123 или 7323 % 3600 = 123.
  Минут будет 123/60 = 2.
  Секунд 123 - 60*2 = 3 или 123 % 60 = 3
---------------------------------------------------------------------------------
*/

// Вычисляем количество часов.

    h = sec / 3600;

// Вычисляем оставшееся количество секунд.
    sec = sec % 3600;

// Вычисляем количество минут
    min = sec / 60;

// Вычисляем оставшееся количество секунд:
    sec = sec % 60;

//-----------------------------------------------------------
// Печать на экран значений переменных h, min и sec
//-----------------------------------------------------------
/*
  printf - для печати
  шаблон %d указывает, что вместо него нужно подставить
  значение переменной, которая записана после текста.
  Значение первой переменной после текста (после кавычек и запятой)
  будет вставлено вместо перового шаблона %d, значение второй -
  после второго шаблона, значение третьей - полсе третьего и т.д.
  Печатаем время в формате h:min:sec
  \n означает перенос строки
*/
    printf("%d:%d:%d\n", h, min, sec);
    return 0;
}
```

Сохраним файл с программой как `time2.c`. Скомпилируем и запустим программу. Получим ответ:

```
>./time2
7323
2:2:3
```

## Короткий вариант программы (стоит всегда описывать используемую математическую или физическую модель):

```c
#include <stdio.h>

int main() {
    int h;   // часы
    int min; // минуты
    int sec; // секунды

    // считываем общее количество секунд
    scanf("%d", &sec);     


    h = sec / 3600;         // количество часов
    sec = sec % 3600;       // оставшееся количество секунд

    min = sec / 60;         // количество минут
    sec = sec % 60;         // оставшееся количество секунд


    // Печатаем время в формате hh:mm:ss
    printf("%d:%d:%d\n", h, min, sec);

    return 0;
}
```

## В погоне за красотой

Ответ, который мы получили вполне правильный. Но, мы привыкли к тому, чтобы часы, минуты и секунды печатались двумя знаками, например `02:02:03` или `12:05:44`.

Попробуем заставить нашу программу печатать также:

```c
#include <stdio.h>

//===========================================================
// Это main() - начало выполнения программы
//-----------------------------------------------------------
int main() {
//------------------------------------------------------------
// Объявление переменных.
//------------------------------------------------------------

    int h;   // переменная для часов
    int min; // переменная для минут
    int sec; // переменная для секунд
//------------------------------------------------------------

//------------------------------------------------------------
/*
  Получаем значение sec
*/
   scanf("%d", &sec);     //запись значения в sec

//------------------------------------------------------------

// Вычисляем количество часов.

    h = sec / 3600;

// Вычисляем оставшееся количество секунд.
    sec = sec % 3600;

// Вычисляем количество минут
    min = sec / 60;

// Вычисляем оставшееся количество секунд:
    sec = sec % 60;

//-----------------------------------------------------------
// Печать на экран значений переменных h, min и sec
//-----------------------------------------------------------
/*
  printf - для печати
  шаблон %d указывает, что вместо него нужно подставить
  значение переменной, которая записана после текста.
  Рассмотрим шаблон %d. Если после % указать 02, то это означает,
  что всякое число при печати должно занимать не менее двух знаков.
  Если же число однозначное, то первый знак запоняется 0

  Печатаем время в формате hh:mm:ss
  \n означает перенос строки
*/
    printf("%02d:%02d:%02d\n", h, min, sec);
    return 0;
}
```

Запустим нашу программу:

```bash
>./time3
72403
20:06:43
```

## Программа без дополнительных объяснений:

```c
#include <stdio.h>

int main() {
    int h;   // часы
    int min; // минуты
    int sec; // секунды

    // считываем общее количество секунд
    scanf("%d", &sec);     


    h = sec / 3600;         // количество часов
    sec = sec % 3600;       // оставшееся количество секунд

    min = sec / 60;         // количество минут
    sec = sec % 60;         // оставшееся количество секунд


    // Печатаем время в формате hh:mm:ss
    printf("%02d:%02d:%02d\n", h, min, sec);

    return 0;
}
```

# 3.2 Порядок операций и вычислений

## Задача P4 (Про деда и бабу (I))

Дед и баба изготавливают деревянные ложки. Дед делает `dedl` ложек за `dedDays`, а бабка `babl` ложек за `babDays`.

Требуется подсчитать сколько ложек они изготовят за N дней.

### Решение 1 (школьное)

Вычислим сколько ложек изготавливает дед за один день и бабка за один день. Затем сложим эти ложки и помножим на `N`.

```c
#include <stdio.h>

//===========================================================
// Это main() - начало выполнения программы
//-----------------------------------------------------------
int main() {
//------------------------------------------------------------
// Объявление переменных.
//------------------------------------------------------------

    int N;   // общие дни
    int dedl, dedDays; // ложки и дни деда
    int babl, babDays; // ложки и дни бабки
    int dedOne; // ложки за день деда 
    int babOne; // ложки за день бабки
    int result; // результат
//------------------------------------------------------------
/*
 В одной записи scanf можно указать несколько переменных.
 Шаблон %d%d означает, что первое число будет записано в первую 
 переменную (dedl), а второе - во вторую переменную (dedDays)
 scanf сам различает разделители между числами 
 scanf сам пропустит перед очередным числом пробельные символы 
       (пробел, табуляция \t, новая строка \n и т.д.)
*/
//------------------------------------------------------------
/*
  Получаем значение для ложек и дней деда
*/
   scanf("%d%d", &dedl, &dedDays);  

/*
  Получаем значение для ложек и дней бабки
*/
   scanf("%d%d", &babl, &babDays);    

/*
  Получаем значение для общего числа дней 
*/
   scanf("%d", &N);   
//------------------------------------------------------------

// Вычисляем сколько ложек сделает дед за день. 

    dedOne = dedl / dedDays;
// Печать для проверки (потом можно убрать)
// \t - табуляция для "красоты"
   printf("дед за день:\t%d\n", dedOne);

// Вычисляем сколько ложек сделает бабка за день. 

    babOne = babl / babDays;
// Печать для проверки (потом можно убрать)
// \t - табуляция для "красоты"
   printf("бабка за день:\t%d\n", babOne);

// Вычисляем сколько всего ложек будет за N дней
    result = (dedOne + babOne) * N;


//-----------------------------------------------------------
// Печать результата:
//-----------------------------------------------------------

    printf("всего:\t%d\n", result);
    return 0;
}
```

Сохраним программу как `loeffel.c` Проверим как работает эта программа:

```bash
>./loeffel
15 5
10 5
7
дед за день:    3
бабка за день:  2
всего:  35
>./loeffel
40 15
20 10
25
дед за день:    2
бабка за день:  2
всего:  100
```


номер | dedl | dedDays | babl | babDays | N | ожидаемый <br>результат | получилось <br> (result) | верно? <br>да/нет
-|-|-|-|-|-|-|-|-
1 | 15 | 5 | 10 | 5 | 7 | 35 | 35 | да
2 | 40 | 15 | 20 | 10 | 30 | 120 | 140 | нет

Видно, что наша программа явно выдает неверный результат. Причину такого результата можно установить, обратив внимание на "проверочный вывод": сколько ложек за день делает дед и бабка каждый в отдельности. 

Из условия понятно, что бабка, действительно, за `30` дней сделает `60` ложек. Но, дед за `30` дней сделает `80`!! ложек. А если бы дед делал всего `10` ложек за `40` дней, то его вклад в общее дело вообще бы не учитывался ( `10` / `40` = 0). А на самом деле в этом случае за `30` дней они с бабкой сделали бы `67` ложек.

Произошла утеря точности в результате деления нацело при подсчете ложек за один день.

Значит ЭТО НЕПОЛНОЕ РЕШЕНИЕ . То есть оно дает правильный результат, только если количество ложек кратно количеству дней.

## Это же решение с краткими комментариями:

```c
#include <stdio.h>

int main() {

    int N;              // общие дни
    int dedl, dedDays;  // ложки и дни деда
    int babl, babDays;  // ложки и дни бабки
    int dedOne;         // ложки за 1 день деда 
    int babOne;         // ложки за 1 день бабки
    int result;         // результат

    // чтение входных данных:
    scanf("%d%d", &dedl, &dedDays);     // ложек и дней деда
    scanf("%d%d", &babl, &babDays);     // ложек и дней бабки
    scanf("%d", &N);                    // общее количество дней

    dedOne = dedl / dedDays;            // сделает дед за 1 день
    printf("дед за день:\t%d\n", dedOne);

    babOne = babl / babDays;            // сделает бабка за 1 день
    printf("бабка за день:\t%d\n", babOne);

    result = (dedOne + babOne) * N;     // всего ложек за N дней
    printf("всего:\t%d\n", result);

    return 0;
}
```

Попробуем решить задачу иначе.

## Решение 2 (старинное)

Старинное решение (основано на принципе сложения простых дробей).

$\Bigg(\dfrac{dedl}{dedDays} + \dfrac{babl}{babDays}\Bigg) \cdot N$

Приведем формулу к общему знаменателю:

$\dfrac{(dedl \cdot babDays + babl \cdot dedDays) \cdot N }{dedDays \cdot babDays}$

Для этого выражения сначала вычисляется числитель, затем знаменатель, и, последним действием происходит деление. 

При таком порядке мы добиваемся максимальной разрядности в числителе. И тогда при делении нацело потеря точности уменьшается.

Для проверки будем считать промежуточные результаты:

$dedF=dedl⋅babDays$

$babF=babl⋅dedDays$

$divident=(dedl⋅babDays+babl⋅dedDays)⋅N$

Переписываем программу и проверяем.

```c
#include <stdio.h>

//===========================================================
// Это main() - начало выполнения программы
//-----------------------------------------------------------
int main() {
//------------------------------------------------------------
// Объявление переменных.
//------------------------------------------------------------

    int N;              // общие дни
    int dedl, dedDays;  // ложки и дни деда
    int babl, babDays;  // ложки и дни бабки
    int dedF;           // ложки деда за dedl*babDays дней
    int babF;           // ложки бабки за babl*dedDays дней
    int divident;       // числитель
    int result;         // результат
//------------------------------------------------------------
/*
 В одной записи scanf можно указать несколько переменных.
 Шаблон %d%d означает, что первое число будет записано в первую 
 переменную (dedl), а второе - во вторую переменную (dedDays)
 scanf сам различает разделители между числами 
*/
//------------------------------------------------------------
/*
  Получаем значение для ложек и дней деда
*/
   scanf("%d%d", &dedl, &dedDays);  

/*
  Получаем значение для ложек и дней бабки
*/
   scanf("%d%d", &babl, &babDays);    

/*
  Получаем значение для общего числа дней 
*/
   scanf("%d", &N);   
//------------------------------------------------------------

// Вычисляем сколько ложек сделает дед за dedl * babDays день. 

    dedF = dedl * babDays;
// Печать для проверки (потом можно убрать)
// \t - табуляция для "красоты"
   printf("дед за %d*%d день:\t%d\n", dedl, babDays, dedF);

// Вычисляем сколько ложек сделает бабка за babl*dedDays день. 

    babF = babl * dedDays;
// Печать для проверки (потом можно убрать)
// \t - табуляция для "красоты"
   printf("бабка за  %d*%d день:\t%d\n", babl, dedDays, babF);

    divident = (dedF + babF) * N;
// Печать для проверки (потом можно убрать)
// \t - табуляция для "красоты"
   printf("числитель (%d+%d)*%d=%d\t знаменатель: %d\n", dedF, babF, N, divident, dedDays*babDays);

// Вычисляем сколько всего ложек будет за N дней
/*
 В математических выражениях действия производятся слева направо. При этом 
 приоритет операций *, /, % выше чем у +, -. Но приоритет между *, /, % не
 очевиден. Поэтому используются скобки, чтобы ЗАВЕДОМО определить нужный
 порядок вычислений. 
 Операции, заключенные в скобки, выполняются до операций за скобками.
*/
    result = (dedl * babDays + babl * dedDays) * N / (dedDays * babDays);


//-----------------------------------------------------------
// Печать результата:
//-----------------------------------------------------------

    printf("всего:\t%d\n", result);
    return 0;
}
```

## Запускаем с разными данными и заполняем таблицу

```
>./loeffel
15 5
10 5
7
дед за 15*5 день:       75
бабка за  10*5 день:    50
числитель (75+50)*7=875  знаменатель: 25
всего:  35
```

```
>./loeffel
40 15
20 10
25
дед за 40*10 день:      400
бабка за  20*15 день:   300
числитель (400+300)*25=17500     знаменатель: 150
всего:  116
```

```
>./loeffel
1000
800
900
1100
2000
дед за 1000*1100 день:  1100000
бабка за  900*800 день: 720000
числитель (1100000+720000)*2000=-654967296       знаменатель: 880000
всего:  -744
```

номер | dedl | dedDays | babl | babDays | N | ожидаемый <br>результат | получилось <br> (result) | верно? <br>да/нет
-|-|-|-|-|-|-|-|-
1 | 15 | 5 | 10 | 5 | 7 | 35 | 35 | да
2 | 40 | 15 | 20 | 10 | 30 | 140 | 140 | да (ура!!)
3 | 1000 | 800 | 900 | 1100 | 2000 | 4136 | -744 | нет (какой кошмар!!)

Последний (третий) результат получен из-за того, что число, помещаемое в `divident` превышает допустимое значения для типа `int`. Это явление называется ПЕРЕПОЛНЕНИЕ. 

Механизм переполнения мы рассмотрим позднее, а пока нужно уметь делать оценки применимости данной программы.

## Это же решение с краткими комментариями:

```c
#include <stdio.h>

int main() {
    // Рассчитываем количество ложек за N дней по формуле для повышения точности вычислений:
    // (dedl * babDays + babl * dedDays) * N / (dedDays * babdays), где

    int N;              // общие дни
    int dedl, dedDays;  // ложки и дни деда
    int babl, babDays;  // ложки и дни бабки
    int result;         // результат
                        // переменные для промежуточных вычислений:
    int dedF;           // dedl * babDays
    int babF;           // babl * dedDays
    int divident;       // числитель формулы 
    int znamenatel;     // знаменатель формулы

    // чтение входных данных:
    scanf("%d%d", &dedl, &dedDays);     // ложек и дней деда
    scanf("%d%d", &babl, &babDays);     // ложек и дней бабки
    scanf("%d", &N);                    // общее количество дней

    dedF = dedl * babDays;
    printf("дед за %d*%d день:\t%d\n", dedl, babDays, dedF);

    babF = babl * dedDays;
    printf("бабка за  %d*%d день:\t%d\n", babl, dedDays, babF);

    divident = (dedF + babF) * N;
    printf("числитель (%d+%d)*%d=%d\t знаменатель: %d\n", 
            dedF, babF, N, divident, dedDays*babDays);

    // так мы теперь не пишем:
    // result = (dedl * babDays + babl * dedDays) * N / (dedDays * babDays);
    // если есть вычисленные промежуточные значения, используем их
    result = divident / (dedDays * babDays);
    printf("всего:\t%d\n", result);

    return 0;
}
```

## Другие целые типы переменных. Преобразование типов.

Решение для задачи `P4` можно изменить с тем, чтобы расширить диапазон допустимых значений.

Самый простой способ - это использовать другой тип переменной (для хранения больших чисел).

В языке С существуют еще несколько типов переменных для целых чисел которые могут быть как положительными, так и отрицательными (со знаком).

Все переменные размещаются в памяти. Память компьютера разделена на ячейки (БАЙТЫ). Каждый байт имеет свой номер в памяти.

Переменные разных типов занимают разное количество байтов.

В стандарте языка С не определено количество байт для каждого типа. В нашем курсе мы предположим, что на переменные выделена память согласно этим таблицам:

тип | занимаемая память (байты) | допустимые значения | шаблон для вывода/вывода
-|-|-|-
int | 4 | [−2 147 483 648, +2 147 483 647] | %d или %i
long | 4 | [−2 147 483 648, +2 147 483 647] | %ld или %li
short | 2 | [−32767, +32767] | %hi
char | 1 | [−127, +127] | %c для символов или %d для чисел
long long | 8 | [−9 223 372 036 854 775 808, +9 223 372 036 854 775 807] | %lld или %Ld

Беззнаковые типы переменных для целых чисел (только положительные):

тип | занимаемая память (байты) | допустимые значения | шаблон для вывода/вывода
-|-|-|-
unsigned int | 4 | [0, +4 294 967 295] | %u
unsigned long | 4 | [0, +4 294 967 295] | %lu
unsigned short | 2 | [0, +65535] | %hu
unsigned char | 1 | [0, +255] | %c для символов или %hhu для чисел
unsigned long long | 8 | [0, 18 446 744 073 709 551 615] | %llu или %Lu

Ложки не могут иметь отрицательные значения, значит для решения можно использовать беззнаковый тип unsigned ....

## Перепишем программу:

```c
#include <stdio.h>

//===========================================================
// Это main() - начало выполнения программы
//-----------------------------------------------------------
int main() {
//------------------------------------------------------------
// Объявление переменных.
//------------------------------------------------------------

    unsigned int N;                 // общие дни
    unsigned int dedl, dedDays;     // ложки и дни деда
    unsigned int babl, babDays;     // ложки и дни бабки
    // unsigned long long для произведений и числителя
    unsigned long long dedF;        // ложки деда за dedl*babDays дней
    unsigned long long babF;        // ложки бабки за babl*dedDays дней
    unsigned long long divident;    // числитель
    unsigned long long result;      // результат
//------------------------------------------------------------
/*
 В одной записи scanf можно указать несколько переменных.
 Шаблон %u%u означает, что первое число будет записано в первую 
 переменную (dedl), а второе - во вторую переменную (dedDays)
 scanf сам различает разделители между числами 
*/
//------------------------------------------------------------
/*
  Получаем значение для ложек и дней деда
*/
   scanf("%u%u", &dedl, &dedDays);  

/*
  Получаем значение для ложек и дней бабки
*/
   scanf("%u%u", &babl, &babDays);    

/*
  Получаем значение для общего числа дней 
*/
   scanf("%u", &N);   
//------------------------------------------------------------

// Вычисляем сколько ложек сделает дед за dedDays*babdays день. 
/*
------------------------------------------------------------------
------------------------------------------------------------------
  ВНИМАНИЕ!
  Переменные, которым применяются операторы, называются операнды.

  Если в операции участвуют операнды одного типа, то и результат 
  получается этого же типа (со всеми возможностями к переполнению)

  Если в операции участвуют операнды разных типов, то результат
  получается того типа, чей диапазон значений больше

  При присвоении значений переменной с меньшим диапазоном к 
  переменной с большим диапазоном  операция выполняется корректно

  Наоборот, при присвоении переменной с большим диапазоном к переменной с
  меньшим диапазоном возможно ПЕРЕПОЛНЕНИЕ.

  ПРИ ВЫЧИСЛЕНИЯХ СНАЧАЛА ПОЛУЧАЕТСЯ ЧИСЛО СООТВЕТСТВУЮЩЕГО ТИПА,
  А ЗАТЕМ ОНО ПРИСВАИВАЕТСЯ К РЕЗУЛЬТИРУЮЩЕЙ ПЕРЕМЕННОЙ.
------------------------------------------------------------------
------------------------------------------------------------------ 
*/

/*
 dedl и babDays - переменные типа int. Результат умножения тоже 
 будет типа int.
 Чтобы получить результат типа unsigned long long преобразуем один из 
 операндов (dedl) в unsigned long long:
*/
    dedF = (unsigned long long) dedl * babDays;
// Печать для проверки (потом можно убрать)
// \t - табуляция для "красоты"
   printf("дед за %u*%u день:\t%llu\n", dedDays, babDays, dedF);

// Вычисляем сколько ложек сделает бабка за dedDays*babdays день. 

    babF = (unsigned long long) babl * dedDays;
// Печать для проверки (потом можно убрать)
// \t - табуляция для "красоты"
   printf("бабка за  %u*%u день:\t%llu\n", dedDays, babDays, babF);

    divident = (unsigned long long)(dedF + babF) * N;
// Печать для проверки (потом можно убрать)
// \t - табуляция для "красоты"
   printf("бабка и дед за  %u*%u*%u день:\t%llu\n", dedDays, babDays, N, divident);

// Вычисляем сколько всего ложек будет за N дней

    result = (dedl * babDays + babl * dedDays) * N / (dedDays * babDays);


//-----------------------------------------------------------
// Печать результата:
//-----------------------------------------------------------

    printf("всего:\t%llu\n", result);
    return 0;
}
```

Сохраняем программу как `loeffel1.c`.

## Запускаем программу и заполняем таблицу.

```
>./loeffel1
1000
800
900
1100
2000
дед за 800*1100 день:   1100000
бабка за  800*1100 день:    720000
бабка и дед за  800*1100*2000 день: 3640000000
всего:  4136
```

номер | dedl | dedDays | babl | babDays | N | ожидаемый <br>результат | получилось <br> (result) | верно? <br>да/нет
-|-|-|-|-|-|-|-|-
1 | 15 | 5 | 10 | 5 | 7 | 35 | 35 | да
2 | 40 | 15 | 20 | 10 | 25 | 116 | 116 | да
3 | 1000 | 800 | 900 | 1100 | 2000 | 4136 | 4136 | да

Мы получили правильный результат, но задача НЕ РЕШЕНА!!

Может быть деда и бабу одолеет неземная производительность труда или их рабочие дни приобретут космические размеры. 

Пределов числа нет. 

Значит мы не можем бесконечно переписывать программу как только обнаружим ее несостоятельность для нового диапазона значений.

Можно сказать о том, что задача на программирование решена, когда она удовлетворяет поставленному условию и ОГРАНИЧЕНИЯМ, указанным в условии.

Если в условии ограничения не указаны, то, автор программы обязан сам объявить в каком диапазоне данных его программа работает корректно.

В самом условии не было объявлено никаких ограничений. Поэтому, написав программу, мы вправе объявить, что общее количество ложкодней не может превышать максимальное значение $2^{32}-1$ Таким образом, можно было бы ограничиться первым вариантом программы, внеся в него незначительные изменения.

## Это же решение с краткими комментариями:

```c
#include <stdio.h>

int main() {

    unsigned int N;                 // общие дни
    unsigned int dedl, dedDays;     // ложки и дни деда
    unsigned int babl, babDays;     // ложки и дни бабки
    // long long для произведений и числителя
    unsigned long long dedF;        // ложки деда за dedl*babDays дней
    unsigned long long babF;        // ложки бабки за babl*dedDays дней
    unsigned long long divident;    // числитель
    unsigned long long result;      // результат

    // чтение входных данных:
    scanf("%u%u", &dedl, &dedDays);     // ложек и дней деда
    scanf("%u%u", &babl, &babDays);     // ложек и дней бабки
    scanf("%u", &N);                    // общее количество дней

    dedF = (unsigned long long) dedl * babDays;
    printf("дед за %u*%u день:\t%llu\n", dedl, babDays, dedF);

    babF = (unsigned long long) babl * dedDays;
    printf("бабка за  %u*%u день:\t%llu\n", babl, dedDays, babF);

    divident = (dedF + babF) * N;
    printf("числитель (%llu+%llu)*%u=%llu\t знаменатель: %llu\n", 
            dedF, babF, N, divident, dedDays*babDays);

    result = divident / (dedDays * babDays);
    printf("всего:\t%llu\n", result);

    return 0;
}
```

## Унарные операторы

До сих пор мы рассматривали программы с бинарными операторами: `+`, `-`, `*`, `/`, `%`, `=`. 

Для выполнения этих операторов необходимы две переменные справа и слева или результат вычислений справа и переменная слева. Именно поэтому оператор называется бинарным: необходимы две переменные.

Но существуют еще операторы, которые работатют только с одной переменной. Такие операторы называются унарными.

Рассмотрим примеры таких операторов.

## Унарный оператор математического отрицания -.

Положительные числа преобразует в отрицательные и наоборот. Ноль не изменяется.

Пример

```c
#include <stdio.h>
int main() {
// унарный минус имеет смысл только если числа со знаком
    char z;  
  scanf("%hhd", &z);
// печатаем отрицание z
    printf("%hhd\n", -z);
}
```

```
>./minus
8
-8
>
```

## Унарный оператор инкремента ++ (правый и левый).

Увеличивает значение числа на единицу. Если оператор стоит справа от числа, то значение переменной увеличивается после вычисления математического выражения, в котором участвует эта переменная с оператором. Если оператор стоит слева, то значение переменной увеличивается на единицу до вычисления выражения.

Пример.

```c
#include <stdio.h>

int main(){
 char z;
 char res1, res2;
 scanf("%hhu", &z);
// сначала вычислим 2 * z, а затем увеличим z 
 res1 = 2 * ( z++ ); 
 printf("res1 (после): %hhd, z: %hhd\n", res1, z);
// сначала увеличим z, а затем вычислим 2 * z 
 res2 = 2 * ( ++z ); 
 printf("res1 (до): %hhd, z: %hhd\n", res2, z);
 return 0;
}
```

```
>./plusplus
7
res1 (после): 14, z: 8
res1 (до): 18, z: 9
>
```

## Унарный оператор декремента -- (правый и левый).
Уменьшает значение числа на единицу. Если оператор стоит справа от числа, то значение переменной уменьшается после вычисления математического выражения, в котором участвует эта переменная с оператором. Если оператор стоит слева, то значение переменной уменьшается на единицу до вычисления выражения.

Пример.

```c
#include <stdio.h>

int main(){
 char z;
 char res1, res2;
 scanf("%hhu", &z);
// сначала вычислим 2 * z, а затем уменьшим z 
 res1 = 2 * ( z-- ); 
 printf("res1 (после): %hhd, z: %hhd\n", res1, z);
// сначала уменьшим z, а затем вычислим 2 * z 
 res2 = 2 * ( --z ); 
 printf("res1 (до): %hhd, z: %hhd\n", res2, z);
 return 0;
}
```

```
>./minusminus
7
res1 (после): 14, z: 6
res1 (до): 10, z: 5
```


## Унарный оператор логического отрицания !

`!` записывается слева от переменной или выражения. Целое число 0 преобразует в 1, а любое другое число преобразует в 0.

```c
#include <stdio.h>

int main(){
 float zf; // дробное число
 char z;  // целое число
 char res;
 scanf("%f", &zf);
 scanf("%hhd", &z);
 printf("Целое\n");
// преобразуем целое в 0
 res = !z; 
 printf("res !<число>: %hhd\n", res);
 res = !res; 
 printf("res !<0>: %hhd\n", res);
 res = !res; 
 printf("res !<1>: %hhd\n", res);
 printf("Любое\n");
// преобразуем дробное в 0
// !!! дробное 0.0 не является тождественным 0 !!!
 res = !zf; 
 printf("res !<число>: %hhd\n", res);
 res = !res; 
 printf("res !<0>: %hhd\n", res);
 res = !res; 
 printf("res !<1>: %hhd\n", res);
 return 0;
}
```

```
>./negativ
-20 3.14
Целое
res !<число>: 0
res !<0>: 1
res !<1>: 0
Любое
res !<число>: 0
res !<0>: 1
res !<1>: 0
```

## Порядок исполнения операторов в выражениях. Приоритет.

Как правило, арифметические выражения вычисляются слева направо с учетом приоритетов арифметических операций.

Приоритет операций - это порядок выполнения операций, если в выражении не расставлены скобки.

Приоритет операций определяется разработчиками компиляторов в соответствии с математическими приоритетами и в соответствии с договоренностями о стандартах языка.

Приведем фрагмент таблицы приоритетов для тех, операций, которые уже были использованы в нашем курсе.


приоритет | операции
-|-
2 | `()` скобки: (выражение)<br>`--` постфиксный декремент: `a--`<br>`++` постфиксный инкремент: `a++`
3 | `+` унарный плюс: `+a`<br>`-` унарный минус: `-a`<br>`++` префиксный инкремент: `++a`<br>`--` префиксный декремент: `--a`<br>`!` логическое НЕ: `!a`
5 | `*` умножение: `a * b`<br>`/` деление: `a / b`<br>`%` остаток: `a % b`
6 | `+` сложение: `a + b`<br>`-` вычитание: `a - b`
15 | `=` присваивание: `a = b`<br> `*=` умножение c присваиванием: `a *= b`<br> `/=` деление c присваиванием: `a /= b`<br> `%=` остаток c присваиванием: `a %= b`<br> `+=` сложение c присваиванием: `a += b`<br> `-=` вычитание c присваиванием: `a -= b`

Чем меньше число приоритета, тем раньше будет выполняться операция.

```
c = 9 + a * (b + 1);
```

В этом выражении меньшее число приоритета соответствует `() (2)`. Значит раньше всего будет выполнено выражение в скобках, далее будет выполнено умножение (приоритет `5`) и последней операцией окажется операция сложения (приоритет `6`).

## Операции с побочным эффектом.

Используя унарные операторы мы как раз хотим изменить значение переменных, к которым эти операторы применяются.

Однако мы можем применить унарные операторы к переменным, которые участвуют в выражениях.

Например.

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int a, b, c = 0;
    a = 3;
    b = 7;
    c = --b * a * b++ * a++;
    printf("c: %d a: %d b: %d\n", c, a, b);
  a = 3;
    b = 7;
    c = b-- * a++ * b++ * a;
    printf("c: %d a: %d b: %d\n", c, a, b);
}
```

Получен вывод:

```
>./uno
c: 324 a: 4 b: 7
c: 504 a: 4 b: 7
>
```

В первом случае все, как мы и ожидали: сначала уменьшилось значение b, затем было вычислено выражение , а затем, увеличилось значение переменных a и b.

Во втором случае все оказалось не так. Ожидалось, что сначала будет вычислено все выражение, а затем произойдут изменения в a и b (оператор постфиксный). Однако в результате мы получили значение вот такого выражения:

$b−−(7)×a++(3)×b++(8)×a(3)=504$

Операторы инкремента и декремента в языке С - это операторы с так называемым с «побочным эффектом» . Это означает, что в процессе выполнения выражения значение переменной изменится.

В каком порядке будут изменяться переменные во время выполнения выражения часто зависит от реализации компилятора.

При вычислении выражения в С существуют контрольные точки или точки следования. В нашем случае контрольные точки - это конец выражения, обозначенный знаком ;.

В дальнейшем будет рассказано о других контрольных точках.

Но порядок исполнения операций инкремента (если в выражении к одной переменной он применен более одного раза) не объявлен. Но к моменту достижения контрольной точки или точки следования все побочные эффекты значения точно должны быть исполнены.

Поэтому к моменту печати (там у нас нет побочных эффектов) с переменной b ничего не произошло, а а увеличилась на 1.

В этом примере мы экспериментально убедились, что у инкремента приоритет выше чем у декремента, но изменения значения переменной b произошло не после выполнения всего выражения, а еще в процессе его выполнения.

Подобные примеры призывают не перегружать выражения операциями с побочным эффектом и по-другому организовывать вычисления.

## Задачи 3.2

Студент писал программу для подсчета количества понедельников в месяце. В месяце может быть 28, 30 или 31 день. Понедельник считается первым днем в неделе, вторник - 2, ..., воскресенье - 7. Он использовал переменные: days - количество дней в месяце, nday - дата первого понедельника и count - количество понедельников.

Какой тип переменных следует выбрать для корректной работы программы и максимальной экономии памяти (все переменные вместе должны занимать как можно меньшее количество байт)?

+ [ ] unsigned int
+ [x] unsigned char
+ [ ] int
+ [ ] unsigned short int
+ [ ] short int

Студент писал программу для подсчета количества понедельников в месяце. В месяце может быть 28, 30 или 31 день. Понедельник считается первым днем в неделе, вторник - 2, ..., воскресенье - 7.

```c
#include <stdio.h>

int main(){
    unsigned char nday; // число месяца первого понедельника
    unsigned char days; // количество дней в месяце
    unsigned char count; // количество дней недели в месяце

    // получение данных с консоли (клавиатура)
    scanf("%hhd%hhd",&days, &nday);

    // подсчет количества дней
    count = 1 + days - nday /7;

    // вывод
    printf("%u\n", nday);
    return 0;
}
```

При тестировании он получил такую таблицу:


номер | days | nday | ожидаемый <br>результат | получилось <br>(result) | верно?<br>да/нет
-|-|-|-|-|-
1 | 28 | 4 | 4 | 4 | да
2 | 31 | 1 | 5 | 1 | нет
3 | 30 | 7 | 4 | 7 | нет

+ [ ] count = 1 + (days - nday) /7;<br>printf("%u\n", nday);
+ [x] count = 1 + (days - nday) /7;<br>printf("%u\n", count);
+ [ ] count = 1 + (days - nday) % 7;<br>printf("%u\n", count);
+ [ ] count = (1 + days - nday) /7;<br>printf("%u\n", count);
+ [ ] count = (1 + days - nday) /7;<br>printf("%u\n", nday);

Студент писал программу для выяснения какой день недели является последним днем месяца. В месяце может быть 28, 30 или 31 день. Понедельник считается первым днем в неделе, вторник - 2, ..., воскресенье - 7.

Программа получилась такой:

```c
#include <stdio.h>

int main(){
    unsigned char nday;
    unsigned char days;
    unsigned char count;
    unsigned char weekd;

    scanf("%hhd%hhd",&days, &nday);
    // количество понедельников
    count = (days - nday )/7;

    // какой день недели в последний день месяца
    weekd = (days - nday - count * 7) % 7 + 1;

    printf("%u\n", weekd);
    return 0;
}
```
При тестировании были введены следующие данные:

номер теста | days | nday
-|-|-
1 | 30 | 1
2 | 28 | 4
3 | 31 | 6

Результаты работы программы были получены следующие:

+ []
    ```
    номер теста | weekday
        1       |   1
        2       |   3
        3       |   4
    ```
+ [x]
    ```
    номер теста | weekday
        1       |   2
        2       |   4
        3       |   5
    ```

+ [ ]
    ```
    номер теста | weekday
        1       |   1
        2       |   7
        3       |   6
    ```
+ []
    ```
    номер теста | weekday
        1       |   6
        2       |   7
        3       |   1
    ```

+ []
    ```
    номер теста | weekday
        1       |   0
        2       |   2
        3       |   3
    ```

Для медицинского центра была написана программа, обслуживающая диагностическую установку со встроенным компьютером. Диагностика делалась при каждом посещении центра пациентом, и программа записывала эти данные в память встроенного компьютера. 

Каждой записи в программе был определен `id` - уникальный идентификационный номер записи. 

Программисты выбрали для этой переменной тип `short int` (`2` байта на этих установках). Центр работает `8` часов каждый день. На одного пациента тратится `30` минут. Во время работы центра пациенты посещают его без перерыва.

Как будет вести себя программа если в центре будут работать две подобные установки, не имеющие общей памяти (они никак не связаны между собой)?


+ [ ] через 10 лет года сотрудники будут вынужденны стирать записи о пациентах с первой установки (закончатся номера)
+ [ ] программа будет работать корректно в течении 20 лет на обеих установках
+ [x] через 5 лет сотрудники будут вынужденны стирать записи о пациентах с двух установок (закончатся номера)
+ [ ] через 10 лет сотрудники будут вынужденны стирать записи о пациентах с двух установок (закончатся номера)
+ [ ] через 2,5 года сотрудники будут вынужденны стирать записи о пациентах с двух установок (закончатся номера)

Дед должен сделать `K` ложек. За каждую ложку он получит `M` монет. Если дед сделает больше чем `K` ложек, он один раз получит премию в размере `B` монет. Студент начал писать программу для подсчета денег (`pay`), которые дед получит за фактически сделанные ложки `fact` с учетом премии.

```c
#include <stdio.h>

int main() {
    unsigned int K;
    unsigned int M;
    unsigned int B;
    unsigned int fact;
    unsigned int pay;
    scanf("%u", &K);
    scanf("%u", &M);
    scanf("%u", &B);
    scanf("%u", &fact);
// Правильный код
    pay = !!(fact / (K + 1)) * B + fact * M;
    printf("%u\n", pay);
}
```
Какой код следует дописать для решения задачи?

# 3.3 Работа с символами

## Числа и коды

Текст, который Вы видите на экране монитора, состоит из различных символов: буквы, цифры и др. Специальные программы "умеют" отображать их на экране и считывать при вводе как символы. Кстати, не все символы отображаются на экране. Например, табуляция, перенос строки и другие. Чтобы можно было работать с символами, каждому из них сопоставлено некоторое число - код. При этом, конечно, может быть множество способов сопоставления символов и чисел. Таким образом появились различные кодировки.

Исторически сложилось, что общепользовательские компьютеры используют, в качестве основы, ASCII-кодировку ( American standard code for information interchange) для кодирования цифр, латинских прописных и строчных буквы, знаков препинания, арифметических знаков, а также управляющих символов. Для этого кода использовались числа от 0 до 127. В расширенной версии добавляются еще числа от 128 до 255. Это расширение используется для национальных алфавитов. В зависимости от операционной системы и национального языка используются различные кодировки: latin-1, KOI8-R, win1251 и др.

Понятно, что для кодирования символов таким образом нам достаточно использовать переменные типа unsigned char или char.

`scanf()` и `printf()` умеют работать с кодами и символами.

Посмотрим как преобразовать символы в числа и наоборот.

```c
#include <stdio.h>

//===========================================================
// Это main() - начало выполнения программы
//-----------------------------------------------------------
int main() {
    //------------------------------------------------------------
    // Объявление переменных.
    //------------------------------------------------------------
    /* 
     Переменная digit - для цифр.
     Переменная number - для числа
     Обе переменные имеют тип char
     В зависимости от формата шаблона scanf() и printf()
     воспринимают переменные либо как символ, либо
     как число 
    */
    char digit;
    char number;
    //------------------------------------------------------------

    //------------------------------------------------------------

    //  Получим с консоли цифру (цифра - это символ)

   scanf("%c", &digit);     //%с - для сиволов

    //------------------------------------------------------------

    // Распечатаем сивольное значение digit
    // \n - тоже символ (перенос строки)
    printf("symbol digit: %c\n", digit);

    // Распечатаем численное значение digit
    printf("number digit: %d\n", digit);

    // Получим из символа digit число, соответствующее данной цифре
    /*
      Одиночные кавычки обозначают символ. '0' - символ, 0 - число
      Коды цифр в таблице кодов установлены последовательно: '0', '1', '2',...'9'
      В ASCII код '0' - 48, '1' - 49, ...
      Язык С преобразует символы в числа в выражениях.
    */
    number = digit - '0';
    // Напечатаем численное значение number
    printf("number: %d\n", number);

    return 0;
}
```

Сохраним файл с программой как `chars1.c` Проверим работу программы для нескольких символов:

```c
./chars1
0
symbol digit: 0
number digit: 48
number: 0
```
```
>./chars1
6
symbol digit: 6
number digit: 54
number: 6
```
```
./chars1
4
symbol digit: 4
number digit: 52
number: 4
```

Коды латинских букв также идут последовательно в соответствии с алфавитом.

## Задача P5 (Шифр Цезаря)

Шифр Цезаря заключается в том, что каждая буква в тексте заменяется на другую букву в соответствии со сдвигом. Сдвиг - это число, на которое нужно заменить порядковый номер буквы при замене ее в тексте. Например, пусть для заглавных букв латинского алфавита сдвиг (delt = 3), тогда буквы будут заменяться так:


A | B | C | D | E | F | G | H | I | K | L | M | N | O | P | Q | R | S | T | V | X | Y | Z
-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-
X | Y | Z | A | B | C | D | E | F | G | H | I | K | L | M | N | O | P | Q | R | S | T | V

Дано слово из четырех букв и сдвиг для шифра Цезаря.

Требуется получить зашифрованное слово.

Решение

```c
#include <stdio.h>

//===========================================================
// Это main() - начало выполнения программы
//-----------------------------------------------------------
int main() {
//------------------------------------------------------------
// Объявление переменных.
//------------------------------------------------------------

    char s1,s2,s3,s4; // переменные для букв в слове
    char delt; // сдвиг
//------------------------------------------------------------

//------------------------------------------------------------

//  Получим с консоли слово из четырех символов

   scanf("%c%c%c%c", &s1, &s2, &s3, &s4);     //%с - для сиволов
// Получим численное значение delt
   scanf("%hhd", &delt);

//------------------------------------------------------------

// Вычислим новые значения кодов для букв 
// То есть получим новые буквы:
/*
  s1 - 'A' получаем номер буквы в алфавите (нуменация начинается с нуля)
  'Z' - 'A' + 1 - вычисляем количество букв в алфавите
  Когда мы используем сдвиг (delt), то получаем новый номер, а значит, другую букву.
  Для последних букв алфавита номер нового кода будет больше чем букв в 
  алфавите, тогда эти буквы нужно взять из начла алфавита. Для этого берем остаток от деления на количество букв и получаем
номера от начала алфавита
  + 'A' - получаем код реальной буквы в соответствии с стандартной кодировкой 
*/

   s1 = (s1 - 'A' + delt) % ('Z' - 'A' + 1) + 'A';
   s2 = (s2 - 'A' + delt) % ('Z' - 'A' + 1) + 'A';
   s3 = (s3 - 'A' + delt) % ('Z' - 'A' + 1) + 'A';
   s4 = (s4 - 'A' + delt) % ('Z' - 'A' + 1) + 'A';


// Напечатаем новое слово (символами!!!)
    printf("%c%c%c%c\n", s1, s2, s3, s4);

    return 0;
}
```

Проверяем работу программы на буквах в разных разделах алфавита:

```
>./ch2
AXYZ
3
DABC
```
```
>./ch2
CDEF
4
GHIJ
```

```
>./ch2
LOVE
5
QTAJ
```

```
>./ch2
ZXYA
20
TRSU
```

Шифр Цезаря может быть модифицирован, и, тогда можно получить разные более сложные шифры.

## Задачи 3.3

В программе сделано следующее объявление переменной:

```c
char letter;
```

Инструкция

```c
  scanf("%c", &letter);
```

запишет в `letter`

+ [ ] только букву или цифру
+ [x] число - код первого символа
+ [ ] только цифру
+ [ ] первый введенный символ
+ [ ] только букву


В программе сделано следующее объявление переменной:

```c
char letter;
```

Инструкция

```c
  scanf("%hhd", &letter);
```

запишет в `letter`

+ [x] все введенное число
+ [ ] только первую букву или цифру
+ [ ] только цифру
+ [ ] первый введенный символ
+ [ ] только букву

В программе сделано следующее объявление переменной:

```c
char letter;
int z;
```

Код

```c
letter = '4';
z = letter + '7';
```

+ [ ] некорректно, так как '7' и '4' - это символы
+ [ ] будет выполнено, и результатом будет 11 преобразованное к типу int
+ [x] будет выполнено, и результатом будет сумма кодов символов '4' и '7' преобразованная к типу int
+ [ ] будет выполнено, и результатом будет два символа
+ [ ] некорректно, так как int - это не символ

Ящики расположены в ряд. Для их обозначения использовались 5 букв латинского алфавита: A, B, C, D, E. На каждый ящик, начиная с самого левого наклеивалась одна буква в соответствии с алфавитном порядком. После наклеивания буквы Е, буквы начинали наклеивать сначала. Например.

```
A B C D E A B C.
```

Межу ящиками с буквами В и D один ящик, а между D и B - 2 ящика. Между ящиками A и B нет ящиков. Всего ящиков не более 10.

Студент написал программу для вычисления сколько ящиков между двумя другими (берется минимально возможное количество ящиков: между D и B два ящика). Первым параметром вводится буква левого ящика, а вторым - правого.

```c
#include <stdio.h>
#include <stdlib.h>

    int main(){
    char a, b, res;
    scanf("%c %c", &a, &b);
    int factor = !((5 + b - a) / 5);
    char delt = b - a;
    res = delt * !factor +  (5 - delt) * factor  - 1;
    printf("%d\n", res);
    return 0;
}
```

Для проверки были выбраны пары букв:

Для проверки были выбраны пары букв:

номер | ввод | верный<br>ответ | ответ<br> программы
-|-|-|-
1 | A B | 0 |  
2 | B E | 2 |  
3 | D C | 3 |  
4 | A A | 4 |  
5 | E A | 0 |  

Верным утверждением будет:

+ [ ] программа даст неправильный ответ только на третий тест
+ [x] программа даст неправильный ответ и на четвертый тест и на третий тест
+ [ ] программа даст неправильный ответ и на второй и на третий тест
+ [ ] все ответы программы соответствуют ожидаемому ответу
+ [ ] программа даст неправильный ответ на первый тест

Ящики расположены в ряд. Для их обозначения использовались 5 букв латинского алфавита: A, B, C, D, E. На каждый ящик, начиная с самого левого наклеивалась одна буква в соответствии с алфавитном порядком. После наклеивания буквы Е, буквы начинали наклеивать сначала. Например.

```
A B C D E A B C.
```

Межу ящиками с буквами В и D один ящик, а между D и B - 2 ящика. Между ящиками A и B нет ящиков. Всего ящиков не более 10.

Студент написал программу для вычисления сколько ящиков между двумя другими (берется минимально возможное количество ящиков: между D и B два ящика). Первым параметром вводится буква левого ящика, а вторым - правого.

Для проверки были выбраны пары букв:

номер | ввод | верный<br>ответ | ответ<br>программы
-|-|-|-
1 | A B | 0 | 
2 | B E | 2 | 
3 | D C | 3 | 
4 | A A | 4 | 

Какой из приведенных кодов будет выдавать правильный ответ на все тесты:

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    char a, b, res;
    scanf("%c %c", &a, &b);
    int factor = !!(a / b);
    res = b - a - 1 * !factor + 4 * factor;
    printf("%d\n", res);

}
```

# 3.4 Дробные числа. Типы данных с плавающей точкой

## Дробные числа

При решении различных задач, конечно, нужны еще и дробные числа. Дробные числа в математике бывают рациональные и иррациональные. 

То есть __рациональные__ числа - это такие числа, которые могут быть представлены как отношение целых чисел: числителя и знаменателя. В любой системе счисления они имеют ПЕРИОДИЧЕСКУЮ дробную часть. 

__Иррациональные__ числа не могут быть представлены таким образом. Дробная часть этих чисел непериодическая, хотя и вычисляемая с любой точностью.

В современных вычислительных системах для записи любых чисел выделяется определенное ограниченное количество памяти. 

Значит, все числа, записанные в память компьютера могут быть только рациональными. То есть все дробные числа записываются с определенной точностью.

Как записываются и интерпретируются числа в память компьютеров мы рассмотрим позже.

## Задача P6 (Единицы скорости)

Скорость ветра указывается в метрах в секунду.

Требуется вычислить какова будет эта скорость в километрах в час.

Решение

```c
#include <stdio.h>

int main(){
/*
  Для объявления дробных чисел используется тип float
  Если операция производится с числами типа float, то и 
  результат будет float
*/

    float msec; // скорость ветра в м/сек
    float kmh; // скорость ветра в км/час

// Получаем значение для скорости ветра в км/час
/*
  %f означает, что scanf ожидает ввода дробного
  числа.
  Дробная часть отделяется от целой точкой: 3.14, 0.5,.125
*/
    scanf("%f",&kmh);

// Преобразование. Происходит деление дробных чисел

    msec = kmh / 3.6;

// Печать результата:

// простой
    printf("%f\n", msec);

// с точностью до трех знаков (остальные отрезаются)

    printf("%0.3f\n", msec);

    return 0;
}
```

Назовем программу `wind.c`. Запуск программы:

```
./wind
25.
6.944445
6.944
```

Рекомендуем самостоятельно составить и заполнить таблицу для проверки данных: `0.0` м/сек, `10.6` м/сек и `72` м/сек.

## Короткий вариант задачи P6:

```c
#include <stdio.h>

int main(){
    float msec; // скорость ветра в м/сек
    float kmh; // скорость ветра в км/час

    scanf("%f",&msec);

    kmh = msec / 3.6;       // 1 км/ч = 1000 м/ 3600 сек

    printf("%f\n", kmh);    
    printf("%0.3f\n", kmh); // печать с 3 знаками после .

    return 0;
}
```

## Задача P7 ("Математическое" округление)
Скорость автомобиля указывается в киломметрах в час (не более 10000).

Требуется вычислить какова будет эта скорость метрах в секунду. Ответ округлить с точностью до целых.

Решение

```c
#include <stdio.h>

int main(){
/*
  Для объявления дробных чисел используется тип float
  Если операция производится с числами типа float, nо и 
  результат будет float

  При преобразовании float к целому числу, дробная часть 
  "обрезается".
  То есть округление не "математическое"
*/

    int res; // результат должен быть целым
    float dest; // знаменатель

// Получаем значение для скорости ветра в м/сек
/*
  %f означает, что scanf ожидает ввода дробного
  числа.
  Дробная часть отделяется от целой точкой: 3.14, 0.5,.125
*/
    scanf("%f",&dest);
// напечатаем результат без округления
    printf("%0.4f\n", dest / 3.6);
//========================================================
// Преобразование и округление.
//========================================================
/* 
  Если дробная часть < 0.5, то целая часть числа не изменится,
  если дробная часть >= 0.5, то целая часть числа увеличится на 1

  Такие преобразования мы делаем ТОЛЬКО ДЛЯ ПРЕДСТАВЛЕНИЯ РЕЗУЛЬТАТА
  Для дальнейших вычислений число не должно округляться
*/

    res = dest / 3.6 + 0.5 ; 

// Печать результата:
    printf("res (int): %d\n", res);

//=============================================================
// А если округлить до второго знака после запятой?
//=============================================================
    res = (dest / 3.6 ) * 100 + 0.5;

// (float)res "превратит" res в float на время операции
    printf("%0.2f\n", (float)res / 100 );

    return 0;
}
```

Проверочная таблица

dest | результат без округления | до целых | до второго знака
-|-|-|-
25 | 6.9444 | 7 | 6.94
4 | 1.1111 | 1 | 1.11
6.18 | 1.7167 | 2 | 1.72

## Короткий вариант P7:

```c
#include <stdio.h>

int main() {
    int res;    // результат должен быть целым
    float dest; // знаменатель


    scanf("%f", &dest); // Получаем значение для скорости ветра в м/сек

    printf("%0.4f\n", dest / 3.6);      // результат без округления

    res = dest / 3.6 + 0.5 ;            // округление математическое
    printf("res (int): %d\n", res);

    res = (dest / 3.6 ) * 100 + 0.5;    // округление до 2 знака после .
    printf("%0.2f\n", (float)res / 100 );

    return 0;
}
```

## Задача P8 (Про деда, бабу и квас (старинная))

У деда и бабки было `total` литров кваса. В одной кружке `0,25` литров кваса. Дед привык выпивать `dedcup` кружек кваса за `dedDays`, а бабка привыкла выпивать `babcup` кваса за `babDays`.

Требуется на сколько дней им хватит кваса выпивать "как привыкли". Сколько кружек кваса останется на следующий за последним полноценным днем?

Решение

Заметим, что половина ложки - это не ложка, а уже обломки от нее. А вот квас остается квасом как целая кружка, так и любая часть от нее. Значит можно использовать в решении задачи дробные числа.

Но дни - целые. И это нужно учитывать в нашем решении.

```c
#include <stdio.h>

//===========================================================
// Это main() - начало выполнения программы
//-----------------------------------------------------------
int main() {
//------------------------------------------------------------
// Объявление переменных.
//------------------------------------------------------------

    float total;   // весь квас
    int dedcup, dedDays; // кружки и дни деда
    int babcup, babDays; // кружки и дни бабки
    float dedOne; // кружки за день деда 
    float babOne, one; // кружки за день бабки
    int N; // дни
    int cupslast; // оставшиеся кружки
//------------------------------------------------------------

/*
  Получаем значение для кружек и дней деда
*/
   scanf("%d%d", &dedcup, &dedDays);  

/*
  Получаем значение для кружек и дней бабки
*/
   scanf("%d%d", &babcup, &babDays);    

/*
  Получаем значение для всего кваса
*/
   scanf("%f", &total);   
//------------------------------------------------------------

// Вычисляем сколько кружек выпьет дед за день. 

/*
  dedcup и dedDays - переменные целого типа, значит 
  результат операции деления будет целым, то есть отбросится 
  дробная часть.
  Чтобы получить полноценный дробный результат преобразуем к 
  дробному типу (на время операции) один из операндов, например 
  dedcup. Для этого перед ним в скобках указываем нужный тип.

  Теперь результат деления будет дробный. 
*/

    dedOne = (float)dedcup / dedDays;
// Печать для проверки (потом можно убрать)
    printf("дед за день: %f\n", dedOne);

// Вычисляем сколько кружек выпьет бабка за день. 

    babOne = (float)babcup / babDays;
// Печать для проверки (потом можно убрать)

    printf("бабка за день:\t%f\n", babOne);

// Вычисляем сколько всего дней они будут пить totalCups кружек
    N = total  / ((dedOne + babOne) * 0.25);

/*
  Вычисляем сколько "неполноценных кружек останется на следующий день.

  Очень заманчиво было бы использовать операцию %
  НО % к дробным числам НЕ ПРИМЕНИМА!!!
*/ 
 cupslast = (total  - (N * (dedOne + babOne) * 0.25)) / 0.25;

//-----------------------------------------------------------
// Печать результата:
//-----------------------------------------------------------

    printf("всего дней: %d\n", N);
    printf("останется кружек: %d\n", cupslast);
    return 0;
}
```

Сохраним программу как `kvas.c`. Проверим как работает эта программа и составим проверочную таблицу:

№ | dedcup | dedDays | babcup | babDays | total | ожидаемо | N (cuplast) | да/нет
-|-|-|-|-|-|-|-|-
1 | 10 | 3 | 7 | 5 | 10 | 8(2) | 8(2) | да
2 | 5 | 7 | 7 | 5 | 1 | 1(1) | 1(1) | да
3 | 4 | 1 | 3 | 1 | 0.5 | 0(2) | 0(2) | да

## Короткий вариант P8.

Избегаем "магического числа" `0.25`, сохраняем его в отдельную переменную. Если в задаче изменят размер `1` кружки, мы легко поменяем все решение в одном месте.

```c
#include <stdio.h>

int main() {
    float cup = 0.25;       // литров в 1 кружке
    float total;            // весь квас
    int dedcup, dedDays;    // дед выпивает dedcup кружек за dedDays
    int babcup, babDays;    // бабка выпивает babcup кружек за babDays
    float dedOne;           // кружки за 1 день деда 
    float babOne;           // кружки за 1 день бабки
    int n;                  // дни
    int cupslast;           // оставшиеся кружки

    scanf("%d%d", &dedcup, &dedDays);  
    scanf("%d%d", &babcup, &babDays);    
    scanf("%f", &total);   

    // за 1 день
    dedOne = (float)dedcup / dedDays;
    printf("дед за день: %f\n", dedOne);        // отладочная печать

    babOne = (float)babcup / babDays;
    printf("бабка за день:\t%f\n", babOne);     // отладочная печать

    // Вычисляем сколько всего дней они будут пить totalCups кружек
    N = total  / ((dedOne + babOne) * cup);

    cupslast = (total  - (N * (dedOne + babOne) * cup)) / cup;

    printf("всего дней: %d\n", N);
    printf("останется кружек: %d\n", cupslast);
    return 0;
}
```

## Задачи 3.4

Число π задано так:

```c
//....
 pi = 3.14;
// печать числа pi c точностью до четвертого знака
 printf("pi: %0.4f\n", pi);

//....
```

В результате будет напечатано:

+ [x] 3.1400
+ [ ] 3.1415
+ [ ] 3.14
+ [ ] 3.140
+ [ ] 3.1416

Была написана, скомпилирована и запущена программа:

```c
#include <stdio.h>

int main(){
 float a; 
 float b; 
  scanf("%d",&a);
  b = a / 2;
  printf("%0.4f\n", b);
  return 0;
}
```
```
./prog
12.
0.0000
```

+ [ ] при делении на целое число, результат будет целым
+ [ ] при вводе было записано дробное число вместо целого
+ [ ] результат выведен с недостаточной точностью
+ [x] scanf() ожидал ввода целого числа
+ [ ] в операции деления участвовали целые числа

При вычислении `cos(30o)` использовалась переменная `cos30`

Какой тип переменной наиболее подходит для этой переменной

+ [ ] char
+ [ ] short int
+ [ ] long long
+ [ ] int
+ [x] float

# 3.6 Задачи урока

[Контест задач](http://judge2.vdi.mipt.ru/cgi-bin/new-register?contest_id=000301) со свободной регистрацией в МФТИ.
Зарегистрируйтесь и пользуйтесь этим логином во всех контестах данного курса.

Если у вас возникли проблемы с регистрацией, пишите в комментариях.