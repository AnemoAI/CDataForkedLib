# 2. Переопределение операций. Дружественные классы и функции

## Содержание

+ [2.1 Переопределение операции сложения](#21-переопределение-операции-сложения)
+ [2.2 Дружественные классы и функции](#22-дружественные-классы-и-функции)
    + [Дружественные функции](#дружественные-функции)
    + [Дружественные классы](#дружественные-классы)
+ [2.3 Переопределение операции присваивания](#23-переопределение-операции-присваивания)
+ [2.4 Переопределение операции преобразования типа и [ ]. Вложенные классы](#24-переопределение-операции-преобразования-типа-и---вложенные-классы)
+ [2.5 Переопределение расширенных операций присваивания](#25-переопределение-расширенных-операций-присваивания)
+ [2.6 Переопределение операций инкремента и декремента](#26-переопределение-операций-инкремента-и-декремента)
+ [2.7 Переопределение операции (). Функторы](#27-переопределение-операции--функторы)
+ [2.8 Понятия lvalue и rvalue выражений, rvalue-ссылки](#28-понятия-lvalue-и-rvalue-выражений-rvalue-ссылки)
    + [Понятия lvalue и rvalue выражений](#понятия-lvalue-и-rvalue-выражений)
    + [Выражения rvalue](#выражения-rvalue)
    + [Ссылки на lvalue и rvalue выражения](#ссылки-на-lvalue-и-rvalue-выражения)
    + [Функция std::move](#функция-stdmove)
+ [2.9 Конструктор перемещения. Оператор присваивания перемещением](#29-конструктор-перемещения-оператор-присваивания-перемещением)
    + [Оператор присваивания перемещением](#оператор-присваивания-перемещением)
    + [Конструктор перемещения](#конструктор-перемещения)
    + [Правило пяти](#правило-пяти)

[Оглавдение](/OOP_C_C++/README.md)

# 2.1 Переопределение операции сложения

[Смотреть материал на видео](https://www.youtube.com/watch?v=1HW0z02tEJM&list=PLA0M1Bcd0w8ye84Jmv9yaI5eRTCBTcePE)

Начиная с этого занятия, мы с вами рассмотрим возможность переопределения стандартных операций для объектов классов. И начнем с операции сложения.

О чем здесь речь? Давайте предположим, что у нас есть класс для представления времени:

```c++
class TimeDay {
    unsigned long time {0};
 
public:
    TimeDay() : time(0)
        { }
    TimeDay(unsigned char hs, unsigned char ms, unsigned char ss, unsigned int ds = 0)
        : time(ss + ms * 60 + hs * 3600 + ds * 86400)
        { }
 
    void get_time(unsigned int& days, unsigned char& hours, unsigned char& mins, unsigned char& secs) const {
        secs = time % 60;
        mins = time/60 % 60;
        hours = time/3600 % 24;
        days = time/86400;
    } 
};
```

Время здесь раскладывается по дням, часам, минутам и секундам. В самом классе `TimeDay` хранится одно число `time` – время в секундах. Далее, в функции `main` мы можем использовать этот класс, например, так:

```c++
int main() {
    TimeDay t1(10, 45, 13), t2(4, 11, 50);
 
    unsigned d;
    unsigned char h, m ,s;
    
    t1.get_time(d, h, m, s);
    printf("%u: %02u:%02u:%02u", d, h, m, s);
 
    return 0;
}
```

Предположим теперь, что нам хотелось бы иметь возможность складывать объекты этого класса:

```c++
    TimeDay res = t1 + t2;
```

Но операция сложения для них не определена и компилятор выдаст ошибку. Однако мы можем добавить эту возможности и задать порядок выполнения операции сложения для наших объектов. Для этого в любом классе можно объявить специального вида метод, имя которого состоит из ключевого слова operator с символом переопределяемой операции:

```c++
class TimeDay {
    unsigned long time {0};
 
public:
...
    const TimeDay& operator + (const TimeDay& right) const
    {}
};
```

Я его записал с одним возвращаемым значением в виде константной ссылки на объект класса `TimeDay`, и одним параметром `right` тоже в виде константной ссылки. За что отвечает этот параметр и почему возвращается константная ссылка? Смотрите, когда выполняется сложение:

```c++
    TimeDay res = t1 + t2;
```

то компилятор автоматически подставит вместо сложения вызов нашего метода. При этом текущий объект, из которого был сделан вызов – это объект `t1`, в параметр `right` подставляется объект `t2`, а возвращаемое значение копируется в переменную res.

На самом деле это же сложение можно записать и с явным вызовом метода-оператора:

```c++
TimeDay res = t1.operator+(t2);
```

То есть, `operator+` - это тоже метод, но который используется компилятором при вычислении операции сложения. Там, где она встречается для объектов класса `TimeDay`, будет использоваться метод `operator+`.

Теперь, почему в качестве параметра и возвращаемого типа используется константная ссылка? Конечно, можно было бы записать этот оператор и без ссылок. Результат от этого не изменился бы. Но тогда дополнительно выполнялась бы операция копирования объекта класса `TimeDay` в параметр `right`, и также происходило копирование при возврате значения. Это лишние операции, поэтому часто при переопределении операций используют ссылки. То же относится и к ключевому слову `const`, которое не обязано быть прописанным. Опять же – это правило хорошего тона при вызове метода, который гарантирует неизменность передаваемого объекта, не более того.

Давайте пропишем реализацию метода операции сложения:

```c++
class TimeDay {
    unsigned long time {0};
 
public:
...
    TimeDay(unsigned long tm)
        : time(tm)
        { }
 
...
    TimeDay operator + (const TimeDay& right) {
        return TimeDay(this->time + right.time);
    }
};
```

Для удобства я добавил еще один конструктор в класс с одним обязательным параметром. Напомню, что такой конструктор называется конструктором преобразования. В частности, он тип `long` переводит в объект `TimeDay`. Кроме того, сделал возврат копии объекта `TimeDay` вместо ссылки, так как созданный в методе временный объект перестает существовать при завершении этого метода. И, если бы была ссылка, то она вела бы на не существующий объект. Это тоже следует учитывать, когда мы используем ссылки в параметрах или возвращаемых значениях. Нужно быть уверенным в том, что объекты существуют необходимое нам время.

Благодаря добавлению конструктора преобразования, мы можем им воспользоваться следующим образом:

```c++
TimeDay res = t1 + 10;
```

Здесь `10` в операции сложения воспринимается компилятором, как целочисленный литерал типа `int`. Затем, с помощью конструктора преобразования число `10` (время в секундах) трансформируется в объект класса `TimeDay` и вызывается метод `operator+`. Результат копируется в переменную `res`. 

Напомню, что копирование встроено для объектов классов и структур и для этого вызывается конструктор копирования по умолчанию, который побайтно копирует данные из одного объекта в другой. В данном случае, нас это устраивает.

Так же, учитывая наличие конструктора преобразования, метод `operator+` теперь может возвращать обычное число типа `long`:

```c++
    unsigned long operator + (const TimeDay& right) const {
        return this->time + right.time;
    }
```

Тогда в момент инициализации объекта `res`, это число сначала будет преобразовано во временный объект `TimeDay`, а затем, с ним будет вызван конструктор копирования.

Однако, обратите внимание, если операцию сложения наоборот:

```c++
TimeDay res = 10 + t1;
```

то возникнет ошибка на этапе компиляции. Так как метод `operator+` должен вызываться через объект `int`:

```c++
TimeDay res = 10.operator+(t1);
```

А такого метода у объекта `int` просто не существует. Но мы все же можем выйти из этой ситуации, если определим операцию сложения в виде функции, а не метода. Да, так тоже можно делать. В нашем случае ее можно было бы записать так:

```c++
unsigned long operator + (const TimeDay& left, const TimeDay& right) {
    return left.get_time() + right.get_time();
}
```

И добавить метод `get_time` в класс `TimeDay`:

```c++
unsigned long get_time() const { return time; }
```

Компилятор автоматически выберет подходящий метод для операции сложения и подставит его вызов при выполнении этой операции. Однако может возникнуть конфликт таких операторов, если объявлен метод и в классе и в виде отдельной функции. Если мы поменяем операнды в операции сложения:

```c++
TimeDay res = t1 + 10;
```

то возникает неопределенность: какой из двух подходов использовать? Поэтому операции следует переопределять либо методами, либо функциями.

Конечно, здесь может возникнуть вопрос, зачем вообще разрешили делать переопределение на уровне функций, или, наоборот, на уровне методов? Были бы только методы и такой неопределенности не возникало бы? Причина такого разнообразия в том, что иногда требуется определить операции для объектов уже существующих классов, которые мы не можем редактировать напрямую. И функции здесь единственная возможность для переопределения стандартных операций.

<hr>

[Содержание](#содержание)

# 2.2 Дружественные классы и функции

[Смотреть материал на видео](https://www.youtube.com/watch?v=mbCKKEP1XnI&list=PLA0M1Bcd0w8ye84Jmv9yaI5eRTCBTcePE)

## Дружественные функции

На прошлом занятии мы с вами получили класс для представления времени:

```c++
class TimeDay {
    unsigned long time {0};
 
public:
    TimeDay() : time(0)
        { }
    TimeDay(unsigned char hs, unsigned char ms, unsigned char ss, unsigned int ds = 0)
        : time(ss + ms * 60 + hs * 3600 + ds * 86400)
        { }
    TimeDay(unsigned long tm)
        : time(tm)
        { }
 
    void get_time(unsigned int& days, unsigned char& hours, unsigned char& mins, unsigned char& secs) const
    {
        secs = time % 60;
        mins = time/60 % 60;
        hours = time/3600 % 24;
        days = time/86400;
    }
 
    unsigned long get_time() const { return time; }
};
```

И определили операцию сложения для его объектов с помощью функции:

```c++
unsigned long operator + (const TimeDay& left, const TimeDay& right) {
    return left.get_time() + right.get_time();
}
```

Как видим, эта функция обращается к методу `get_time` переданных объектов – операндов для сложения, чтобы получить доступ к приватному значению поля `time`. И было бы логично расширить на нее область видимости класса `TimeDay`, чтобы в теле этой функции можно было бы напрямую обращаться к приватным данным объектов этого класса. Язык C++ предоставляет такой легальный механизм обхода ограничения для доступа к приватным атрибутам вне класса. Делается это путем объявления функции `operator+` дружественной по отношению к классу `TimeDay`:

```c++
class TimeDay {
    unsigned long time {0};
 
public:
...
    friend unsigned long operator + (const TimeDay& left, const TimeDay& right);
};
```

То есть, пишется ключевое слово `friend`, за которым следует прототип дружественной функции. После этого в теле этой функции становится возможным прямое обращение к полю `time` объектов `left` и `right`:

```c++
unsigned long operator + (const TimeDay& left, const TimeDay& right) {
    return left.time + right.time;
}
```

Надо сказать, что концепция дружественных функций весьма спорная в языке C++. Одни считают ее приемлемой, т.к. редко, но существует необходимость распространить область видимости класса на внешние функции. Другие полагают, что это вносит больше путаницы в текст программы и, как следствие, к появлению неочевидных проблем, т.к. дружественные функции могут менять состояние объектов, напрямую через приватные переменные, а не через публичные методы, как это предусматривает разработчик класса. Тем не менее, этот инструмент существует в языке C++, который, как минимум, нужно знать. Однако применять на практике следует с очень большой осторожностью и несколько раз подумать, а можно ли сделать то же самое иначе без неоправданного расширения области видимости класса.

<hr>

[Содержание](#содержание)

## Дружественные классы

Помимо дружественных функций можно объявлять и дружественные классы. Делается это по аналогии. Я приведу учебный, несколько искусственный пример такого дружественного класса. В действительности, необходимость объявлять целый класс другом другого класса – крайне редкая ситуация. И возникает она, как правило, в нетривиальных проектах. Поэтому здесь будет лишь простая демонстрация этой возможности.

В классе `TimeDay` объявим дружественным класс `Clock` (часы):

```c++
class TimeDay {
    unsigned long time {0};
    friend class Clock;
 
public:
...
};
```

Обратите внимание, что дружественность можно прописывать в любых секциях (`private`, `public`), разницы никакой нет.

После класса `TimeDay` объявим класс `Clock`, например, так:

```c++
class Clock {
public:
    void show_time(const TimeDay& t) {
        unsigned char secs = t.time % 60;
        unsigned char mins = t.time/60 % 60;
        unsigned char hours = t.time/3600 % 24;
 
        printf("%02u:%02u:%02u", hours, mins, secs);
    }
};
```

И, затем воспользуемся им в функции `main`:

```c++
int main() {
    TimeDay t1(10, 45, 13), t2(4, 11, 50);
    TimeDay res = t1 + 10;
 
    Clock cl;
    cl.show_time(res);
 
    return 0;
}
```

Благодаря дружественности с классом `TimeDay` в методе `show_time` класса `Clock` мы имеем возможность напрямую обращаться к приватной переменной `time` объекта `t`.

Конечно, тот же самый функционал легко можно было бы сделать без всякой дружественности и это было бы правильнее. Это исключительно показательный, учебный пример, не более того. Вообще, на практике, если вы задумались об использовании дружественной функции или, тем более, класса, то подумайте еще раз, возможно, несколько стоит изменить структуру программы, отредактировать взаимосвязи между классами и сами классы. И если только после этого видите, что использование дружбы оправданно, пишите ключевое слово `friend`, не раньше!

<hr>

[Содержание](#содержание)


# 2.3 Переопределение операции присваивания

[Смотреть материал на видео](https://www.youtube.com/watch?v=FgDjvk3SSss&list=PLA0M1Bcd0w8ye84Jmv9yaI5eRTCBTcePE)

Продолжаем изучение переопределение операций для объектов классов языка C++. На этом занятии увидим, как и для чего выполняется переопределение встроенной операции присваивания.

Операция присваивания по умолчанию уже работает на уровне объектов любого класса и выполняет побайтное копирование содержимого одного объекта в другой. Но это не всегда желаемое поведение. Как пример, рассмотрим реализацию известной структуры данных – `динамического массива`. Мы с вами ее уже реализовывали в курсе по языку Си. Здесь повторим ее, но сделаем уже на уровне класса языка C++.

Я напомню, что в основе динамического массива лежит обычный массив языка Си. Его состояние можно определить двумя целочисленными переменными:
+ capacity – физическая длина массива;
+ length – количество записанных в массив данных.

Как только длина `length` достигает размера `capacity`, то в памяти создается новый массив, часто удвоенной длины, в который копируются данные из прежнего массива. В итоге происходит автоматическое увеличение физической длины массива и новые данные заносятся уже в него. Вот в двух словах идея работы динамического массива.

Мы объявим класс `DArray` для работы с такой структурой данных в отдельном заголовочном `darray.h` следующим образом:

```c++
class DArray {
    enum {
        start_length_array = 8, // начальная длина массива
        resize_factor = 2,      // множитель для увеличения длины массива
        max_length_array = 30,  // максимальная длина массива
        value_error = 2123456789, // специальное значение для обозначения ошибки данных
    };
 
    int* data {nullptr};
    int length {0};   // число записанных в массив значений
    int capacity {0}; // физический размер массива
 
    void _resize_array(int size_new); // увеличение размера массива data но не более max_length_array элементов
public:
    DArray() : length(0), capacity(start_length_array)
    {
        data = new int[start_length_array];
        capacity = start_length_array;
    }
 
    DArray(const DArray& other) : length(other.length), capacity(other.capacity)
    {
        data = new int[capacity];
        for(int i = 0; i < length;++i)
            data[i] = other.data[i];
    }
 
    ~DArray() { delete[] data; }
 
    int size() const { return length; }
    int capacity_ar() const { return capacity; }
    const int* get_data() const { return data; }
 
    const DArray& operator=(const DArray& other);
 
    void push_back(int value);
    int pop_back();
};
```

Так как каждый объект класса `DArray` формирует свой массив `data`, то необходимо переопределить:
+ конструктор копирования;
+ деструктор;
+ операцию присваивания.

Вообще, в языке C++ 11-го стандарта существует так называемое __правило трех__. 

Оно гласит, если в классе переопределяется хотя бы один из приведенных трех методов, то следует явно переопределить и оставшиеся два. 

Как правило, они все работают в связке. И наш класс `DArray` – не исключение. Здесь действительно необходимо переопределить все эти три элемента. Для полноты картины отмечу, что начиная со стандарта C++14 правило трех превратилось в __правило пяти__, добавилось еще два метода:
+ конструктор перемещения;
+ конструктор копирования перемещением.

Давайте пропишем реализацию операции присваивания (и другие реализации методов) в файле `darray.cpp` следующим образом:

```c++
#include "darray.h"
 
void DArray::_resize_array(int size_new) {
    if(size_new <= capacity)
        return;
 
    while(capacity < size_new) {
        capacity *= resize_factor;
        if(capacity >= max_length_array) {
            capacity = max_length_array;
            break;
        }
    }
 
    int* p = new int[capacity];
 
    for(int i = 0;i < length; ++i)
        p[i] = data[i];
 
    delete[] data;
    data = p;
}
 
const DArray& DArray::operator=(const DArray& other) {
    if(this == &other) // присваивание объекта самому себе
        return other;
 
    length = other.length;
    capacity = other.capacity;
 
    delete[] data;
    data = new int[capacity];
    for(int i = 0;i < length; ++i)
        data[i] = other.data[i];
 
    return *this;
}
 
void DArray::push_back(int value) {
    if(length >= capacity) {
        _resize_array(capacity * resize_factor);
    }
 
    if(length < capacity)
        data[length++] = value;
}
 
int DArray::pop_back() {
    if(length > 0)
        return data[--length];
    return value_error;
}
```

Как видите, операция присваивания работает вполне очевидным образом. Мы копируем все поля из присваиваемого объекта и дополнительно создаем свой массив `data` с копированием в него всех значений так же из присваиваемого объекта. Обратите внимание, на проверку в самом начале. Формально операцию присваивания можно записать с тем же самым объектом. А присваивать что-либо самому себе нет никакого смысла, да и программа работала бы некорректно. Поэтому было добавлено это условие. И, последнее замечание, операцию присваивания нельзя переопределять вне класса отдельной функцией, как это мы делали для операции сложения, только на уровне метода.

В результате, полученный класс можно использовать следующим образом:

```c++
#include <iostream>
#include "darray.h"
 
int main() {
    DArray ar1, ar2;
 
    for(int i = 0;i < 10; ++i)
        ar1.push_back(i+1);
 
    ar2 = ar1;
 
    std::cout << ar2.size() << " " << ar2.capacity_ar() << std::endl;
    
    for(int i = 0;i < ar2.size(); ++i)
        std::cout << ar2.get_data()[i] << " ";
 
    return 0;
}
```

Однако у нас здесь не хватает очевидной операции для работы с объектами динамического массива – доступ к элементам по индексам. Например:

```c++
    ar1[5] = 7;
    int v = ar1[3];
```

Но этот функционал мы добавим на следующем занятии.

<hr>

[Содержание](#содержание)


# 2.4 Переопределение операции преобразования типа и [ ]. Вложенные классы

[Смотреть материал на видео](https://www.youtube.com/watch?v=K6YntA4Ms0s&list=PLA0M1Bcd0w8ye84Jmv9yaI5eRTCBTcePE)

На предыдущем занятии мы с вами начали создавать класс `DArray` для реализации идеи динамического массива. И остановились на необходимости переопределения операции индексирования. Первое, что приходит в голову, это объявить в классе соответствующий метод:

```c++
operator[](int index) { }
```

Но здесь сразу возникает вопрос, что должен возвращать этот метод? Если просто возвратить целочисленное значение:

```c++
    int operator[](int index) {
        return data[index];
    }
```

то получим, при использовании объекта этого класса:

```c++
ar1[5] = 7;   // ошибка
int v = ar1[3]; // ok
```

У нас выражение `ar1[5]` не является леводопустимым (`l-value`), то есть, не связано с ячейкой памяти, в которую можно заносить какое-либо значение. Правда, если при определении оператора указать ссылку:

```c++
    int& operator[](int index) {
        return data[index];
    }
```

то компилятор не выдаст никаких ошибок. Но, я думаю, большинство из вас понимают, что такая реализация операции индексирования нас не может устроить. Здесь есть очевидные проблемы. Во-первых, если индекс будет указан за пределами массива `data`, то запись или чтение будет происходить с неопределенными ячейками памяти, что недопустимо. Но это, конечно, поправить не сложно, прописав условие для переменной `index`:

```c++
    int& operator[](int index) {
        if(index >=0 && index < capacity)
            return data[index];
        return ???;
    }
```

Правда, нужно еще подумать, что возвращать, если индекс выходит за пределы массива.

Вторая проблема посерьезнее. Если выполняется операция присваивания по определенному индексу:

```c++
ar1[15] = 7;
```

и этот индекс превышает физический размер массива `data`, то по идее динамического массива, его следует увеличить до нужного размера и занести в нужный элемент соответствующее значение. А если выполняется чтение:

```c++
int v = ar1[15];
```

то никакого изменения массива `data` выполнять не нужно, даже если индекс превышает физический размер.

Спрашивается, как нам в программе различать эти два варианта использования операции индексирования? К сожалению, простого решения здесь нет. Поэтому нам придется сделать «хитрый» прием.

В классе `DArray` объявим еще один вспомогательный вложенный класс `Item`. Объект класса `Item` будет возвращаться операцией индексирования. А в самом классе мы переопределим две операции:
+ операцию присваивания;
+ операцию преобразования класса к типу `int`.

Операция присваивания будет срабатывать в момент присвоения массиву значения, а операция преобразования типа – в момент чтения значения. Так мы сможем различить эти две ситуации.

Давайте реализуем эту логику. Первым делом в классе `DArray` объявим вложенный класс `Item`:

```c++
class DArray {
    enum {
        start_length_array = 8, // начальная длина массива
        resize_factor = 2,      // множитель для увеличения длины массива
        max_length_array = 30,  // максимальная длина массива
        value_error = 2123456789, // специальное значение для обозначения ошибки данных
    };
 
    class Item {
        DArray* current {nullptr};
        int index {-1};
 
    public:
        Item(DArray* obj, int idx) : current(obj), index(idx)
            { }
 
        operator int() const;
        int operator=(int right) const;
    };
 
    int* data = nullptr;
    int length {0};   // число записанных в массив значений
    int capacity {0}; // физический размер массива
 
    void _resize_array(int size_new); // увеличение размера массива data но не более max_length_array элементов
public:
...
};
```

В классе `Item` объявлен указатель `current` на объект класса `DArray` – динамического массива, с которым выполняется работа, и целочисленная переменная `index` – индекс элемента, к которому идет обращение через операцию индексирования. Эти переменные инициализируются в конструкторе с двумя параметрами, то есть, создать объект класса `Item` без аргументов не получится, нужно обязательно передать текущий объект класса `DArray` и индекс элемента. Далее, идут объявления двух методов, о которых мы только что говорили. Обратите внимание, что у операции преобразования типа возвращаемый тип прописывается после ключевого слова `operator`.

В самом классе `DArray` операция индексирования примет вид:
```c++
    Item operator[](int index)
    {
        return Item(this, index);
    }
```

Мы здесь возвращаем копию объекта, что нас вполне устраивает. Осталось записать реализации методов вложенного приватного класса `Item` в файле `darray.cpp`. Они будут следующими:

```c++
DArray::Item::operator int() const {
    if(index >= current->length || index < 0)
        return value_error;
 
    return current->data[index];
}
 
int DArray::Item::operator=(int right) {
    if(index >= max_length_array || index < 0)
        return right; // размер массива data не может превышать max_length_array элементов
 
    if(index >= current->capacity) {
        current->_resize_array(index+1);
    }
 
    for(int i = current->length; i < index; ++i)
        current->data[i] = 0;   // зануляем все новые добавленные значения
 
    if(index >= current->length)
        current->length = index + 1; // новый размер записанных данных
 
    current->data[index] = right;
    return right;
}
```

В методе операции преобразования типа мы вначале проверяем корректность индекса. Если он выходит за пределы данных, занесенных в массив, то возвращается специальная предопределенная константа `value_error`. Это сделано для удобства в учебном проекте, чтобы не усложнять программу.

В методе операции присвоения так же вначале идет проверка на допустимое значение индекса. Если оно выходит за установленные пределы, то ничего не присваивается, а просто возвращается присваиваемое значение. Далее, проверяется, если индекс превышает физический размер массива `data`, то вызываем метод класса `DArray` для увеличения массива до нужных размеров. Обратите внимание, что в методах вложенного класса `Item` можно совершенно спокойно обращаться к приватным элементам внешнего класса `DArray`. После увеличения массива (если это было необходимо), зануляются все промежуточные элементы, а в элемент с индексом `index` заносится присваиваемое значение `right`. В конце так же возвращается эта величина.

Давайте посмотрим, как будет работать операция индексирования:

```c++
int main() {
    DArray ar1, ar2;
 
    for(int i = 0; i < 10; ++i)
        ar1.push_back(i + 1);
 
    ar1[14] = 7;
    int v = ar1[14];
    
    ar2 = ar1;
 
    std::cout << v << std::endl;
    std::cout << ar2.size() << " " << ar2.capacity_ar() << std::endl;
    
    for(int i = 0;i < ar2.size(); ++i)
        std::cout << ar2.get_data()[i] << " ";
 
    return 0;
}
```

После запуска программы в консоли увидим:

```
7
15 16
1 2 3 4 5 6 7 8 9 10 0 0 0 0 7
```

Как видите, все отработало успешно. Причем, операция приведения типа, которую мы записали, как `int`, будет так же срабатывать и при присвоении значения переменной любого другого числового типа. Например:

```c++
double v = ar1[14];
```

Компилятор автоматически выберет подходящее преобразование объекта класса и применит его. Если автоматическое скрытое преобразование типа объекта не допустимо, то мы можем воспользоваться знакомым ключевым словом `explicit` следующим образом:

```c++
explicit operator int() const;
```

Тогда в коде программы придется прописывать конструкцию вида:

```c++
double v = static_cast<int>(ar1[14]);
```

О преобразовании типов классов (функции `static_cast` и некоторых других) мы еще будем говорить.

Из этого занятия вы должны хорошо себе представлять, как переопределяется операция индексирования и какие особенности ее работы существуют. Как записывается операция преобразования типа класса. А также, как объявляются и работают вложенные классы.

<hr>

[Содержание](#содержание)


# 2.5 Переопределение расширенных операций присваивания

[Смотреть материал на видео](https://www.youtube.com/watch?v=EdHgDl52aNU&list=PLA0M1Bcd0w8ye84Jmv9yaI5eRTCBTcePE)

Продолжаем совершенствовать класс DArray и переопределим для него операции присваивания:

`+=`, `-=`, `*=`, `/=`, `%=` и т.п.

Очевидно, их можно было бы использовать в следующей логике работы объектов класса DArray:

```c++
#include <iostream>
#include "darray.h"
 
int main() {
    DArray ar1, ar2;
 
    ar1[10] = 100;
    ar1[0] += 2;
    ar1[2] = 7; ar1[2] *= 3;
    ar1[3] = 11; ar1[3] %= 4;
    double v = ar1[14];
 
    std::cout << v << std::endl;
    
    for(int i = 0;i < ar1.size(); ++i)
        std::cout << ar1.get_data()[i] << " ";
 
    return 0;
}
```

Давайте пропишем эти операции. Так как они применяются при индексировании к отдельным элементам динамического массива, то их следует располагать в классе `Item`:

```c++
    class Item {
        DArray* current {nullptr};
        int index {-1};
 
    public:
        Item(DArray* obj, int idx) : current(obj), index(idx)
            { }
 
        operator int() const;
        int operator=(int right);
        int operator+=(int right);
        int operator*=(int right);
        int operator%=(int right);
    };
```

Я прописал только три расширенные операции присваивания, но вы самостоятельно легко можете добавить все остальные. Соответственно, реализации этих методов будут располагаться в файле `darray.cpp`:

```c++
int DArray::Item::operator+=(int right) {
    if(index >= current->length || index < 0)
        return right; // операцию += можно выполнять только с существующими элементами массива
 
    current->data[index] += right;
    return current->data[index];
}
 
int DArray::Item::operator*=(int right) {
    if(index >= current->length || index < 0)
        return right; // операцию *= можно выполнять только с существующими элементами массива
 
    current->data[index] *= right;
    return current->data[index];
}
 
int DArray::Item::operator%=(int right) {
    if(index >= current->length || index < 0)
        return right; // операцию %= можно выполнять только с существующими элементами массива
 
    current->data[index] %= right;
    return current->data[index];
}
```

Мы здесь, фактически, получаем дублирование кода. Как можно было бы это поправить? Один из вариантов – вынести общие действия в отдельный метод. Например, так:

```c++
    class Item {
        enum type_assign {
            iadd_operator, imul_operator, iddiv_operator
        };
 
        DArray* current {nullptr};
        int index {-1};
 
        int _assign_operator(int right, type_assign t);
    public:
    ...
    };
```

Со следующей реализацией:

```c++
int DArray::Item::_assign_operator(int right, type_assign t)
{
    if(index >= current->length || index < 0)
        return right; // операции +=, -=, *=, /= и т.п. можно выполнять только с записанными элементами массива
 
    switch(t) {
        case iadd_operator: 
            current->data[index] += right;
            break;
        case imul_operator: 
            current->data[index] *= right;
            break;
        case iddiv_operator: 
            current->data[index] %= right;
            break;
    }
    return current->data[index];
}
```

А в методах операций лишь вызывать этот приватный метод:

```c++
int DArray::Item::operator+=(int right) {
    return _assign_operator(right, iadd_operator);
}
 
int DArray::Item::operator*=(int right) {
    return _assign_operator(right, imul_operator);
}
 
int DArray::Item::operator%=(int right) {
    return _assign_operator(right, iddiv_operator);
}
```

Получим тот же самый результат.

Конечно, все расширенные операции присваивания можно переопределять только на уровне методов класса, но не функций, так же, как и операцию простого присваивания.

В заключение этого занятия продемонстрирую пример переопределения операции `+=` на уровне объектов класса `DArray`.

Операция `+=` в нашем примере будет добавлять элементы одного массива в конец другого:

```c++
ar1 += ar2;
```

Метод этой операции, очевидно, нужно записать в классе `DArray`. Объявим его прототип следующим образом:

```c++
const DArray& operator+=(const DArray& other);
```

Обратите внимание, здесь параметр передается по константной ссылке и возвращается тоже константная ссылка. Почему именно так? Да, для того, чтобы не выполнять лишних операций копирования объектов динамического массива. Как вы понимаете, это может заметно тормозить выполнение программы, тогда как избежать этого очень просто за счет применения ссылок.

Также обратите внимание, что операция `+=` не обязана возвращать константную ссылку на объект класса `DArray`. Как вариант, можно записать тип `void`. Но по философии языка C++ операция `+=` возвращает сформированный результат. Поэтому я повторяю эту идею.

Давайте теперь пропишем реализацию этого метода в файле `darray.cpp`:

```c++
const DArray& DArray::operator+=(const DArray& other) {
    int size_new = length + other.length;
    if(size_new > max_length_array)
        size_new = max_length_array;
 
    _resize_array(size_new);
 
    for(int i = length, j = 0; i < size_new; ++i, ++j)
        data[i] = other.data[j];
 
    length = size_new;
    return *this; 
}
```

Здесь все достаточно очевидно. Увеличивается (при необходимости) физический размер массива `data`. И, затем, добавляются в него новые данные из переданного массива. В конце возвращаем результат в виде текущего объекта.

Теперь, мы можем выполнять операции соединения двух динамических массивов операцией `+=`. По аналогии реализуйте операцию сложения массивов, которая так же соединяет два массива во временный объект класса `DArray`. Сами объекты, участвующие в сложении, менять свое состояние не должны.

<hr>

[Содержание](#содержание)


# 2.6 Переопределение операций инкремента и декремента

[Смотреть материал на видео](https://www.youtube.com/watch?v=zd4nAiRt18Y&list=PLA0M1Bcd0w8ye84Jmv9yaI5eRTCBTcePE)

На этом занятии в классе `DArray` добавим возможность применять операции инкремента и декремента для значений элементов динамического массива.

Очевидно, для этого нужно в классе `Item` объявить следующие методы:

```c++
    class Item {
    ...
    public:
    ...
        int operator++();
        int operator--();
    };
```

А их реализацию пропишем в файле `darray.cpp` следующим образом:

```c++
int DArray::Item::operator++() {
    if(index >= current->length || index < 0)
        return value_error; // операции ++ и -- можно выполнять только с записанными элементами массива
 
    current->data[index]++;
    return current->data[index];
}
 
int DArray::Item::operator--() {
    if(index >= current->length || index < 0)
        return value_error; // операции ++ и -- можно выполнять только с записанными элементами массива
 
    current->data[index]--;
    return current->data[index];
}
```

Здесь снова получается дублирование кода, но это можно поправить так же, как это мы делали с арифметическими операциями.

Итак, после объявления этих методов, ожидается, что мы можем использовать операции инкремента и декремента с элементами массива, например, так:

```c++
#include <iostream>
#include "darray.h"
 
int main() {
    DArray ar1, ar2;
 
    ar1[10] = 100;
    ar1[3] = 5;
 
    int v1 = ar1[3]++; // ошибка
    int v2 = ++ar1[3]; // ok
 
    std::cout << v1 << " " << v2 << std::endl;
 
    for(int i = 0;i < ar1.size(); ++i)
        std::cout << ar1.get_data()[i] << " ";
 
    return 0;
}
```

Но, как видим, операция инкремента в постфиксной форме выдает ошибку, говоря, что такого метода не существует. Почему так? Дело в том, что мы с вами хорошо знаем, инкремент в префиксной и постфиксной формах должен работать по разному. Следовательно, и методы, которые их реализуют, так же должны быть разными. То, что было объявлено в классе `Item`, соответствует операциям инкремента и декремента в префиксной форме. Чтобы добавить аналогичные операции для постфиксной формы, было решено воспользоваться механизмом перегрузки методов и объявлять их с одним параметром (в классе `Item`):

```c++
        int operator++(); // для префиксной формы
        int operator--(); // для префиксной формы
        int operator++(int); // для постфиксной формы
        int operator--(int); // для постфиксной формы
```

Реализации последних двух методов запишем в виде:

```c++
int DArray::Item::operator++(int) {
    if(index >= current->length || index < 0)
        return value_error; // операции ++ и -- можно выполнять только с записанными элементами массива
 
    int value = current->data[index];
    current->data[index]++;
    return value;
 
    /*
    или в виде:
    return current->data[index]++;
    */
}
 
int DArray::Item::operator--(int) {
    if(index >= current->length || index < 0)
        return value_error; // операции ++ и -- можно выполнять только с записанными элементами массива
 
    return current->data[index]--;
}
```

Теперь, мы совершенно свободно можем использовать любую форму операций инкремента и декремента:

```c++
int main() {
    DArray ar1, ar2;
 
    ar1[10] = 10;
    ar1[3] = 5;
 
    int v1 = ar1[3]--;
    int v2 = ++ar1[10];
 
    std::cout << v1 << " " << ar1[3] << std::endl;
    std::cout << v2 << " " << ar1[10] << std::endl;
 
    for(int i = 0;i < ar1.size();++i)
        std::cout << ar1.get_data()[i] << " ";
 
    return 0;
}
```

Дублирование кода, которое получилось при определении этих операций, я предлагаю вам убрать самостоятельно.

<hr>

[Содержание](#содержание)


# 2.7 Переопределение операции (). Функторы

[Смотреть материал на видео](https://www.youtube.com/watch?v=IveZ9y7rnQ0&list=PLA0M1Bcd0w8ye84Jmv9yaI5eRTCBTcePE)

На этом занятии мы с вами рассмотрим возможность обращаться с объектом класса, словно с объектом-функцией, то есть, применять к нему операцию круглые скобки `()`. Классы, объекты которых можно вызывать подобно функциям, носят название __функторы__.

Я начну с классического и простого примера реализации счетчика. Объявим следующий класс:

```c++
class Counter {
    double start {0.0};
    double step {1.0};
    double count {start};
 
public:
    Counter(double start = 0.0, double step = 1.0) : start(start), step(step)
        { count = start; }
    
    operator double() const { return count; }
    double operator()()
    {
        double ret = count;
        count += step;
        return ret;
    }
};
```

Каждый объект этого класса будет иметь три переменные:
+ `start` – начальное значение счетчика;
+ `step` – шаг изменения счетчика;
+ `count` – текущее значение счетчика.

С помощью конструктора можно задавать начальные величины `start` и `step`. А также преобразовывать объект класса к типу `double` (возвращается значение `count`) и применять к объектам операцию вызова функции `()`.

Давайте посмотрим, как это можно использовать:

```c++
int main() {
    Counter c1, c2(0.0, 0.5);
 
    double r1 = c1();
    c1();
    double r2 = c1;
 
    std::cout << r1 << " " << r2 << std::endl;
    
    return 0;
}
```

Создается два счетчика `c1` и `c2`. Затем, объект `c1` вызывается, как функция. В результате возвращается начальное значение `count` и увеличивается на величину `step`. Далее, мы просто применяем операцию `()` к объекту `c1` и `count` еще раз увеличивается на `step`. А дальше вещественной переменной `r2` присваиваем объект `c1`. В результате сработает операция приведения типа объекта к `double`, при которой возвращается текущее значение `count`. Те же самые действия можно выполнять и с объектом `c2`.

Конечно, в практике программирования вполне можно обойтись и без переопределения операции `()`. Но в ряде случаев она бывает крайне удобной. Например, представим, что нам нужно вычислять производные разных функций, заданных сигнатурой:

```c++
double <имя функции>(double);
```

Это могут быть стандартные функции `sin`, `cos` и так далее. Решить эту задачу можно по разному, но мы с вами сделаем это с помощью следующего класса:

```c++
using func_diff_dobule = double(*)(double);
 
class Diff {
    func_diff_dobule func {nullptr};
    double dt {0.001};
 
public:
    Diff(func_diff_dobule f, double delta = 0.001) : func(f), dt(delta)
        { }
 
    double operator()(double x)
    {
        return (func(x+dt)-func(x)) / dt;
    }
};
```

Здесь определяется тип `func_diff_dobule` указателя на функцию. А в самом классе `Diff` две переменные:
+ `func` – указатель на функцию, для которой будут вычисляться производные;
+ `dt` – интервал для численного получения значения производной любой непрерывной функции.

Напомню, что производную любой функции `f` в точке `x` можно найти по формуле:

$diff(x) = \dfrac{f(x + dt) - f(x)}{dt}$

Именно это происходит при вызове операции `()`.

Воспользоваться классом `Diff` можно следующим образом:

```c++
#include <iostream>
#include <math.h>
 
int main() {
    Diff sin_diff(sin);
 
    double res = sin_diff(3.1415/2.0);
    std::cout << res << std::endl;
 
    return 0;
}
```

Получилось очень удобно и интуитивно понятно.

<hr>

[Содержание](#содержание)


# 2.8 Понятия lvalue и rvalue выражений, rvalue-ссылки

[Смотреть материал на видео](https://www.youtube.com/watch?v=5hY0PMgqSiA&list=PLA0M1Bcd0w8ye84Jmv9yaI5eRTCBTcePE)

## Понятия lvalue и rvalue выражений

Представьте, что имеется следующая программа на языке C++:

```c++
int main() {
    int b {3};
    int a = 7 - b;
 
    return 0;
}
```

Здесь `a`, `b` – обычные целочисленные переменные, расположенные где-то в памяти устройства. Про такие переменные можно сказать, что они являются леводопустимыми (`lvalue`) выражениями, то есть, выражениями, которым можно присваивать значения определенного типа.

Конечно, простые переменные – это частный случай леводопустимых выражений. Другой пример – это указатель на выделенную область памяти:

```c++
    double* ptr_b = new double;
    *ptr_b = 6.43;
    delete ptr_b;
```

Или доступ к отдельным элементам массива:

```c++
    char str[] = "Hello";
    str[0] = 'D';
```

Или ссылка на тот или иной тип данных:

```c++
    int& count = b;
```

Или объект класса (структуры):

```c++
class Point {
public:
    int x{0}, y{0};
};
…
Point pt = {1, 2};
```

Или даже метод (функция), который возвращает конструкцию, связанную с областью памяти:

```c++
class Point {
public:
    int x{0}, y{0};
public:
    int& get_x() { return x; }
};
…
    Point pt = {1, 2};
    pt.get_x() = 10;
```

также является леводопустимым.

Характерной особенностью всех `lvalue` выражений является то, что они связаны прямо или косвенно с областью памяти, в которой хранятся данные определенного типа. И часто эти данные можно изменить (присвоить им другие значения), если конечно, нет ограничений модификатора `const`.

<hr>

[Содержание](#содержание)

## Выражения rvalue

Однако не все выражения в программе можно воспринимать, как `lvalue`. Например, нельзя целочисленной константе присвоить какое-либо другое значение:

```c++
int main() {
    int b {3};
    int a = 7 - b;
 
    5 = a; // ошибка
    
    return 0;
}
```

Такие величины относятся к `rvalue` выражениям. Или, если взять две переменные и попытаться что-либо присвоить их сумме:

```c++
    a + b = 10;
```

то будет ошибка, так как каждая из переменных – это `lvalue` выражение, но их сумма уже не связана с какой-либо постоянной областью памяти, в которую можно занести новое значение, а потому относится к `rvalue` выражению. Даже обычный унарный плюс перед переменной:

```c++
    +b = 10;
```
превращает ее в `rvalue` выражение.

То же самое будет наблюдаться и с любыми другими `lvalue` выражениями:

```c++
int main() {
    int b {3};
    int a = 7 - b;
 
    short ar[5] {0};
    ar[0] + b = 5;      // ошибка
 
    int* ptr_a = &a;
    int& lnk_b = b;
 
    (lnk_b * 5) = 10;      // ошибка
    (*ptr_a + b) = 10;     // ошибка
 
    return 0;
}
Одно из немногих исключений – это операция разыменывания адреса указателя:

```c
    *(ptr_a + b) = 10;     // ok
```

Но это уже относится к адресной арифметике, и ничего необычного в этом нет.

<hr>

[Содержание](#содержание)

## Ссылки на lvalue и rvalue выражения

Почему в языке C++ так важно различать `lvalue` и `rvalue` выражения? Одна из причин, чтобы мы корректно в программах формировали конструкции для присвоения тех или иных значений в допустимые области памяти. Другая причина состоит в том, что только на `lvalue` выражения можно формировать знакомые нам ссылки. Например:

```c++
int main() {
    int b {3};
    int a = 7 - b;
 
    Point pt;
 
    int& lnk_a = a;
    Point& lnk_pt = pt;
 
    return 0;
}
```

Соответственно, на `rvalue` выражения ссылки вести не могут, кроме константных:

```c++
int main() {
    int b {3};
    int a = 7 - b;
 
    Point pt;
 
    int& lnk_a = 7 - b;         // rvalue
    Point& lnk_pt = Point();    // rvalue
    
    const int& lnk_a_cnst = 7 - b;         // ok
    const Point& lnk_pt_cnst = Point();    // ok
 
    return 0;
}
```

Однако, начиная со стандарта C++11, появился новый тип ссылок для `rvalue` выражений, который записывается с двумя амперсандами следующим образом:

```c++
int main() {
...
    int&& lnk_a = 7 - b;         // rvalue
    Point&& lnk_pt = Point();    // rvalue
...
    return 0;
}
```

При этом временные объекты, на которые они ссылаются, продолжают существовать, пока существуют на них эти ссылки. Соответственно, через такие ссылки мы совершенно спокойно можем менять состояние объектов или выражений:

```c++
    std::cout << lnk_a << " " << lnk_pt.x << std::endl;
    lnk_a = 10;
    lnk_pt.x = 5;
    std::cout << lnk_a << " " << lnk_pt.x << std::endl;
```

Конечно, то же самое мы могли бы сделать и через константные ссылки, но, во-первых, это было бы неправильно, т.к. убирать модификатор `const` – часто порочная практика, а, во-вторых, в C++ имеются специальные конструкции, которые работают исключительно со ссылками на rvalue выражения, о которых речь пойдет на следующем занятии.

<hr>

[Содержание](#содержание)

## Функция std::move

Обратите внимание, что `rvalue`-ссылкам нельзя напрямую присваивать `lvalue`-ссылки и вообще любые `lvalue` выражения:

```c++
int main() {
    int b {3};
    int a = 7 - b;
...
    int &lnk_la = a;
    int* ptr_a = &a;
 
    int&& lnk_ra_1 = a;          // ошибка
    int&& lnk_ra_2 = *ptr_a;  // ошибка
    int&& lnk_ra_3 = lnk_a;  // ошибка
 
    return 0;
}
```

Однако мы можем обойти это ограничение, если воспользоваться операцией преобразования типов, либо специальной функцией `std::move` следующим образом:

```c++
    int&& lnk_ra_1 = static_cast<int&&>(a);
    int&& lnk_ra_2 = std::move(*ptr_a);
    int&& lnk_ra_3 = std::move(lnk_a);
```

На практике предпочтение следует отдавать функции `std::move`, т.к. она, по сути, является надстройкой над оператором `static_cast<T&&>` и обеспечивает более безопасное преобразование типов ссылок.

А вот обратное присвоение `lvalue` ссылкам `rvalue` ссылок можно делать без каких-либо операций преобразования типов:

```c++
    lnk_la = lnk_ra_1;
    *ptr_a = lnk_ra_1;
```

Итак, из этого занятия вы должны четко различать `lvalue` и `rvalue` выражения, и знать, как формируются ссылки на `rvalue` выражения.

<hr>

[Содержание](#содержание)

# 2.9 Конструктор перемещения. Оператор присваивания перемещением

[Смотреть материал на видео](https://www.youtube.com/watch?v=Jw3uUe-NuLE&list=PLA0M1Bcd0w8ye84Jmv9yaI5eRTCBTcePE)

## Оператор присваивания перемещением

На предыдущем занятии мы с вами познакомились с новым видом ссылок на `rvalue` выражения, которые записываются по синтаксису:

```c++
<тип данных>&& <имя r-ссылки> = <rvalue значение>;
```

Такие ссылки появились в стандарте C++11 и, спрашивается, для чего они нужны и какую роль играют при написании программ? В этом занятии мы с вами, как раз, ответим на этот вопрос.

Начнем с простого примера. Допустим, нам нужно прописать класс `DArray` для работы с динамическим массивом. Мы с вами это уже делали на одном из прошлых занятий, здесь, я запишу его в очень упрощенном виде следующим образом:

```c++
class DArray {
    int *data {nullptr};
    int length {0};
    int capacity {0};
 
public:
    DArray(int size = 0) : length(0), capacity(size) {
        std::cout << "DArray create" << std::endl;         
        data = new int[capacity];       
    }
 
    DArray(const DArray& other) : length(other.length), capacity(other.capacity) {
        std::cout << "DArray copy" << std::endl;         
        data = new int[capacity];
        for(int i = 0; i < length; ++i)
            data[i] = other.data[i];
    }
 
    ~DArray() { 
        std::cout << "DArray delete" << std::endl; 
        delete[] data; 
    }
 
    const DArray& operator=(const DArray& right) {
        if(this == &right)
            return *this;
 
        std::cout << "DArray assigment" << std::endl;
 
        length = right.length;
        capacity = right.capacity;
 
        delete[] data;
        data = new int[capacity];
 
        for(int i = 0; i < length; ++i)
            data[i] = right.data[i];
 
        return *this;
    }
};
```

Здесь присутствуют три поля: `length` – число записанных данных; `capacity` – физический размер массива; `data` – указатель на область памяти с данными. Затем, идет конструктор по умолчанию, конструктор копирования и деструктор. В конце прописано переопределение операции присваивания. Все методы выводят в консоль соответствующие сообщения (строки).

Давайте теперь представим, что объявляется функция для формирования объекта класса `DArray` с заданной длиной массива:

```c++
DArray create_array(int size) {
    DArray ar(size);
    return ar;
}
```

А в функции `main` создается массив с помощью функции `create_array`:

```c++
int main() {
    DArray ard;
    ard = create_array(10);
 
    return 0;
}
```

Если сейчас запустить эту программу (в Visual Studio 2019), то в консоли увидим следующие строчки:

```c++
DArray create
DArray create
DArray copy
DArray delete
DArray assigment
DArray delete
DArray delete
```


Объект класса DArray был создан три раза: первый раз в функции main, второй раз – в функции create_array и третий раз – при передаче объекта ar из функции create_array (сработал конструктор копирования). Кроме того, была выполнена переопределенная операция присваивания, где данные массива также копируются. И того четыре ресурсоемкие операции по созданию и копированию данных объекта класса `DArray`.

<hr>

[Содержание](#содержание)

## Конструктор перемещения

Спрашивается, можно ли как-то улучшить этот код и повысить его производительность? Очевидно, да. И первое, что напрашивается – это пробросить временный объект `ar` из функции `create_array` сразу в функцию `main` без его копирования. Но как это сделать? Просто записать ссылку не получится:

```c++
DArray& create_array(int size) ...
```

так как она в итоге будет вести на удаленный объект и программа завершится аварийно. Поэтому мы оставим формально операцию копирования:

```c++
DArray create_array(int size) ...
```

но в класс `DArray` добавим еще один конструктор специального вида – конструктор перемещения:

```c++
class DArray {
...
    DArray(DArray&& move) noexcept : length(move.length), capacity(move.capacity)
    {
        std::cout << "DArray move" << std::endl;
        data = move.data;
        move.data = nullptr;
    }
...
};
```

Чаще всего он записывается именно так. В качестве параметра `rvalue`-ссылка на объект класса `DArray`, а сам конструктор помечается ключевым словом `noexcept`, чтобы компилятор мог его совершенно свободно использовать для любых подходящих целей.

Что это за конструктор и какова его роль? 

С его помощью также создается новый объект класса `DArray`, но при его вызове предполагается, что все данные объекта `move` будут просто «забираться» новым созданным объектом, без копирования. В частности, именно так происходит с массивом `data`. Мы лишь сохраняем указатель на ту же область памяти, что и в объекте `move`, не создавая ее копию. Тем самым, сокращаем объем вычислений. В конце указатель `data` для объекта `move` устанавливается в значение `nullptr`, чтобы при удалении этих двух объектов (`move` и нового созданного) память `data` не освобождалась дважды. В этом и состоит суть перемещения объекта с помощью конструктора перемещения. Что именно и как будет перемещаться, решает сам программист, при реализации этого конструктора. Но в любом случае создается новый объект класса (в нашем случае `DArray`). Прежний объект `move` считается более не используемым и при проектировании программы это должно соблюдаться.

Теперь, при запуске программы, в консоли появляются строчки:

```c++
DArray create
DArray create
DArray move
DArray delete
DArray assigment
DArray delete
DArray delete
```

Объект был создан дважды, при третьем создании использовался конструктор перемещения и объем вычислений здесь, как правило, существенно ниже, чем при копировании объекта. Причем, компилятор сам выбрал именно конструктор перемещения, а не копирования. Это связано с тем, что возвращаемое значение оператора `return` воспринимается как `rvalue` выражение. И ему, как раз соответствует конструктор перемещения.

Если же возникает возможность выбора одного конструктора из множества, то компилятор руководствуется следующими простыми правилами приоритетов использования ссылок:

![02](/OOP_C_C++/img/02_01.png)

Отсюда хорошо видно, что если можно использовать или конструктор копирования или конструктор перемещения, то будет выбран конструктор перемещения, как наиболее приоритетный. Учитывая, что возвращаемое из функции значение воспринимается как `rvalue`, то у компилятора появляется возможность выбора и он выбирает конструктор перемещения.

<hr>

[Содержание](#содержание)

## Правило пяти

Также обратите внимание, что при объявлении конструктора перемещения, стандартные конструкторы (по умолчанию и копирования) перестают существовать, а также пропадает стандартная операция присваивания для объектов класса. Поэтому, как только объявляется конструктор перемещения, то дополнительно, как правило, нужно объявлять конструктор по умолчанию, конструктор копирования, операцию присваивания и еще одну операцию присваивания перемещением. Это в программировании называется правилом пяти, которое гласит, что при переопределении одного из следующих пяти методов:
+ конструктора копирования;
+ деструктор;
+ операции присваивания;
+ конструктора перемещения;
+ операции присваивания перемещением

скорее всего, следует переопределить и четыре остальных.

Давайте посмотрим, как и для чего переопределяется последняя операция присваивания перемещением. Она прописывается для класса `DArray` следующим образом:

```c++
class DArray {
...
    DArray& operator=(DArray&& right) noexcept {
        if (this == &right) return *this;
        std::cout << "DArray move assigment" << std::endl;
 
        delete[] data;
        length = right.length;
        capacity = right.capacity;
        data = right.data;
        right.data = nullptr;
 
        return *this;
    }
};
```

И компилятор вызывает ее всякий раз, когда временный объект присваивается текущему объекту. В нашем примере именно так и происходит. При этом сама операция работает по аналогии с конструктором перемещения. Все ресурсы объекта `right` захватываются текущим объектом без создания копий, что ускоряет процесс присваивания. После этого объект `right` уже не может использовать свои данные и предполагается, что в программе будет вскоре удален. Поэтому перемещение можно использовать только с временными объектами, которые нет смысла копировать.

Компилятор сам четко различает ситуации, когда какую операцию присваивания вызывать. Например, если ниже в функции `main` прописать:
```c++
    DArray a;
    a = ard;
```

то здесь будет использована обычная операция присваивания, т.к. слева и справа стоят `lvalue` выражения.

<hr>

[Содержание](#содержание)

