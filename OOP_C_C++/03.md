# 3. Наследование. Виртуальные методы

## Содержание

+ [3.1 Наследование классов. Режим protected](#31-наследование-классов-режим-protected)
    + [Наследование классов](#наследование-классов)
    + [Режим доступа protected](#режим-доступа-protected)
+ [3.2 Объект дочернего класса. Переопределение методов и переменных](#32-объект-дочернего-класса-переопределение-методов-и-переменных)
    + [Объект дочернего класса](#объект-дочернего-класса)
    + [Сокрытие имен методов в дочерних классах](#сокрытие-имен-методов-в-дочерних-классах)
    + [Режимы наследования public, private и protected](#режимы-наследования-public-private-и-protected)
    + [Сокрытие переменных в дочерних классах](#сокрытие-переменных-в-дочерних-классах)
+ [3.3 Порядок вызовов конструкторов и деструкторов при наследовании](#33-порядок-вызовов-конструкторов-и-деструкторов-при-наследовании)
+ [3.4 Виртуальные (virtual) методы (функции)](#34-виртуальные-virtual-методы-функции)
    + [Виртуальные (virtual) методы (функции)](#виртуальные-virtual-методы-функции)
    + [Как работают виртуальные методы](#как-работают-виртуальные-методы)
+ [3.5 Ключевые слова override, final. Виртуальные деструкторы](#35-ключевые-слова-override-final-виртуальные-деструкторы)
    + [Ключевое слово override](#ключевое-слово-override)
    + [Ключевое слово final](#ключевое-слово-final)
    + [Виртуальные деструкторы](#виртуальные-деструкторы)
+ [3.6 Чисто виртуальные методы. Абстрактные классы](#36-чисто-виртуальные-методы-абстрактные-классы)
    + [Чисто виртуальные методы](#чисто-виртуальные-методы)
    + [Абстрактные классы](#абстрактные-классы)
+ [3.7 Множественное наследование. Порядок вызова конструкторов и деструкторов](#37-множественное-наследование-порядок-вызова-конструкторов-и-деструкторов)
    + [Множественное наследование](#множественное-наследование)
    + [Порядок вызовов конструкторов и деструкторов](#порядок-вызовов-конструкторов-и-деструкторов)
    + [Объект дочернего класса при множественном наследовании](#объект-дочернего-класса-при-множественном-наследовании)
+ [3.8 Ромбовидное наследование. Закрытый конструктор и деструктор](#38-ромбовидное-наследование-закрытый-конструктор-и-деструктор)
    + [Ромбовидное наследование](#ромбовидное-наследование)
    + [Виртуальное наследование](#виртуальное-наследование)
    + [Защищенный конструктор](#защищенный-конструктор)
    + [Защищенный деструктор](#защищенный-деструктор)

[Оглавдение](/OOP_C_C++/README.md)

# 3.1 Наследование классов. Режим protected

[Смотреть материал на видео](https://www.youtube.com/watch?v=GnmVdjDioSw&list=PLA0M1Bcd0w8ye84Jmv9yaI5eRTCBTcePE)

## Наследование классов

Итак, мы с вами подошли, наверное, к самому главному моменту в ООП – __наследованию__ классов. 

Наследование – это то, что превращает программу из простого набора объектов в настоящую концепцию программирования, то, что выводит нас на совершенно новый уровень проектирования и написания программного кода. И совсем скоро, вы своими глазами сможете в этом убедиться.

Для объяснения работы механизма наследования я возьму классический пример работы с геометрическими фигурами на плоскости. Будем полагать, что их можно описать четырьмя числами: координатами левого верхнего угла и правого нижнего углов:

![03](/OOP_C_C++/img/03_01.png)

Тогда, например, класс для прямых линий (`Line`) можно объявить следующим образом:

```c++
class Line {
    int x0{0}, y0{0}, x1{0}, y1{0};
    double length{0.0};
 
public:
    void set_coords(int x0, int y0, int x1, int y1) {
        this->x0 = x0; this->y0 = y0;
        this->x1 = x1; this->y1 = y1;
    }
};
```

Здесь дополнительно прописана переменная `length`, содержащая длину линии, и эта переменная характерна только для класса `Line`.

По аналогии можно было бы объявить и остальные классы, но я пока не стану этого делать. Мы отметим следующее. Все фигуры имеют общие элементы в описании – это координаты `x0`, `y0`, `x1`, `y1`. Было бы логично выделить их в общий класс. Давайте это сделаем. Определим класс для произвольных геометрических фигур с именем `GeomBase`:

```c++
class GeomBase {
private:
    int x0{0}, y0{0}, x1{0}, y1{0};
};
```

И класс `Line` унаследуем от этого класса:

```c++
class Line : public GeomBase {
private:
    double length{0.0};
 
public:
    void set_coords(int x0, int y0, int x1, int y1) {
        this->x0 = x0; this->y0 = y0;
        this->x1 = x1; this->y1 = y1;
    }
};
```

Обратите внимание, как записывается наследование классов в языке C++. Ставится двоеточие, затем, режим наследование (в примере `public`) и имя базового класса `GeomBase`. О режимах наследования речь еще впереди.

![03](/OOP_C_C++/img/03_02.png)

Соответственно, класс, от которого выполняется наследование, называют базовым, родительским, а класс наследник – дочерним, производным.

Однако при такой организации у нас возникли некоторые проблемы. В методе `set_coords` стали недоступны переменные `x0`, `y0`, `x1`, `y1`. 

С чем это связано? 

Смотрите, эти переменные расположены в секции `private` базового класса `GeomBase`. А эта секция ограничивает доступ к ее элементам в пределах текущего класса, и не важно, что класс `Line` является дочерним для класса `GeomBase`. Мы можем работать с координатами только в классе `GeomBase`. Например, если перенести метод `set_coords` в базовый класс, то никаких ошибок не будет:

```c++
class GeomBase {
private:
    int x0{0}, y0{0}, x1{0}, y1{0};
public:
    void set_coords(int x0, int y0, int x1, int y1) {
        this->x0 = x0; this->y0 = y0;
        this->x1 = x1; this->y1 = y1;
    }
};
```

При этом в дочернем классе `Line` совершенно спокойно можно вызывать публичный метод `set_coords` и обращаться к любым другим публичным полям базового класса. Давайте для примера добавим в базовый класс еще один метод для получения текущих координат:

```c++
    void get_coords(int& x0, int& y0, int& x1, int& y1) {
        x0 = this->x0; y0 = this->y0;
        x1 = this->x1; y1 = this->y1;
    }
```

А в дочернем классе определим метод `draw` для отображения объекта линии:

```c++
class Line : public GeomBase {
private:
    double length{0.0};
public:
    void draw() {
        int x0, y0, x1, y1;
        get_coords(x0, y0, x1, y1);
        printf("Line: %d, %d, %d, %d\n", x0, y0, x1, y1);
    }
};
```

После этого в функции `main` можно создать объект класса `Line` и вызвать для него соответствующие методы:

```c++
int main() {
    Line ln;
    
    ln.set_coords(1, 2, 10, 20);
    ln.draw();
 
    return 0;
}
```

<hr>

[Содержание](#содержание)

## Режим доступа protected

Однако обращение к переменным-координатам базового класса `GeomBase` в методе `draw` дочернего класса `Line` через публичные методы – не лучшее решение. Было бы хорошо эти координаты сделать закрытыми от доступа извне, но сделать доступными во всех производных от него классах. И такой режим в ООП существует. Он называется `protected`. Если мы в базовом классе вместо режима `private` укажем `protected`:

```c++
class GeomBase {
protected:
    int x0{0}, y0{0}, x1{0}, y1{0};
public:
...
};
```

то к переменным `x0`, `y0`, `x1`, `y1` можно обращаться напрямую из всех его дочерних классов. Соответственно, метод `draw` класса `Line` значительно упрощается до одной строчки:

```c++
class Line : public GeomBase {
private:
    double length{0.0};
public:
    void draw() {
        printf("Line: %d, %d, %d, %d\n", x0, y0, x1, y1);
    }
};
```

Видите, как это бывает удобно. При этом вне классов получить доступ к этим переменным по-прежнему запрещено. Следующая команда приведет к ошибке:

```c++
Line ln;
ln.x0 = 10; // ошибка
```

То есть, в классах можно прописывать три разных режима:
+ `private` – доступ в пределах текущего класса;
+ `protected` – доступ в пределах текущего и всех дочерних от него классах;
+ `public` – общий доступ (внутри и за пределами класса).

Надо отметить, что помещать переменные в секцию `protected` следует с особой осторожностью, т.к. дочерние классы получают к ним прямой доступ с произвольной логикой их обработки. Поэтому `protected`-переменные следует воспринимать, как особый вид публичных переменных и при проектировании логики класса (где они объявлены) относиться к ним как к публичным.

<hr>

[Содержание](#содержание)

# 3.2 Объект дочернего класса. Переопределение методов и переменных

[Смотреть материал на видео](https://www.youtube.com/watch?v=oynDaI-ZR7w&list=PLA0M1Bcd0w8ye84Jmv9yaI5eRTCBTcePE)

## Объект дочернего класса

На предыдущем занятии мы с вами объявили базовый класс `GeomBase` геометрических фигур и дочерний от него класс `Line` прямых линий. Также узнали о новом режиме доступа `protected`. Давайте теперь поближе познакомимся с порядком работы объектов такого составного класса `Line`.

Пусть в функции main создается следующий объект:

```c++
int main() {
    Line *ptr_ln = new Line;
 
    ptr_ln->set_coords(1, 2, 10, 20);
    ptr_ln->draw();
 
    delete ptr_ln;
 
    return 0;
}
```

Видим, что через него совершенно спокойно можно вызывать публичные методы, как базового класса (метод `set_coords`), так и дочернего (метод `draw`). Первый вопрос, что содержит объект, на который ссылается указатель `ptr_ln`?

![03](/OOP_C_C++/img/03_03.png)

В объекте, по-прежнему, будут находиться только данные, то есть переменные `x0`, `y0`, `x1`, `y1`, `length`. Причем порядок их расположения в памяти объекта будет именно такой: сначала переменные базового класса `GeomBase`, а сразу после – переменная `length` дочернего класса `Line`. Методов в объекте нет, они остаются на уровне классов и существуют в единственных экземплярах для всех объектов этих классов. Мы с вами об этом уже говорили. В частности, вызов:

```c++
ptr_ln->set_coords(1, 2, 10, 20);
```

означает, что компилятор должен найти такой метод сначала в дочернем классе `Line`. Если его там нет, то в базовом классе `GeomBase` и подставить его вызов с передачей в этот метод неявного указателя `this`. Причем тип этого указателя будет соответствовать типу объекта, из которого метод был вызван, то есть, тип `Line*`, а не `GeomBase*`, несмотря на то, что это метод базового класса.

__Возможность вызова методов базового класса через объекты дочернего, называется полиморфизмом адресов.__

Но для методов базового класса большого значения не имеет тип указателя. Главное, чтобы это был тип одного из его дочерних классов. В этом случае указатель, например, типа `Line*` всегда можно привести к типу базового класса `GeomBase*`, благодаря тому, что данные в объекте располагаются в порядке от базового класса к дочерним:

```c++
    GeomBase* ptr_b = ptr_ln;
 
    int a, b, c, d;
    ptr_b->get_coords(a, b, c, d);
```

Причем, явно прописывать преобразование типов в этом случае не нужно. Это довольно частая ситуация в ООП и разработчик языка C++ решил сделать эту операцию неявной для удобства записи.

<hr>

[Содержание](#содержание)

## Сокрытие имен методов в дочерних классах

Давайте для примера в дочерний класс `Line` так же добавим метод `set_coords` с такой же сигнатурой, что и в базовом классе:

```c++
class Line : public GeomBase {
private:
    double length{0.0};
public:
    void set_coords(int x0, int y0, int x1, int y1) {
        std::cout << "Line: set_coords()" << std::endl;
    }
...
};
```

Теперь, вызов:

```c++
ptr_ln->set_coords(1, 2, 10, 20);
```

будет связан именно с этим новым методом дочернего класса. Этот пример, во-первых, показывает, что мы совершенно спокойно можем переопределять методы базовых классов в дочерних. И, во-вторых, поиск методов ведется от дочерних классов к базовым.

Однако если мы сделаем вызов метода `set_coords` через указатель на базовый класс:

```c++
ptr_b->set_coords(1, 2, 10, 20);
```

то будет вызван метод именно базового класса.

А, что если, мы бы хотели сделать вызов какого-либо переопределенного метода именно из базового класса? Например, в методе `set_coords` дочернего класса можно было бы вызвать соответствующий метод базового, чтобы не повторять его логику. Сделать это можно, явно указав область видимости этого метода следующим образом:

```c++
    void set_coords(int x0, int y0, int x1, int y1)
    {
        GeomBase::set_coords(x0, y0, x1, y1);
        std::cout << "Line: set_coords()" << std::endl;
    }
```

И можно сделать даже так:

```c++
ptr_ln->GeomBase::set_coords(1, 2, 10, 20);
```

Мы через указатель на дочерний класс вызвали метод базового класса. Правда, в практике программирования использование последнего варианта, скорее, будет говорить о неверной логике описания программы. Все же, встроенные правила и возможности ООП, как правило, ведут нас по верному пути проектирования программных архитектур.

<hr>

[Содержание](#содержание)

## Режимы наследования public, private и protected

Следует отметить, что вызывать публичные методы базового класса через объекты дочерних классов можно только в том случае, если используется режим наследования `public`:

```c++
class Line : public GeomBase {...};
```

Если же ключевое слово `public` в наследовании классов не прописывать:

```c++
class Line : GeomBase {...};
```

то это будет эквивалентно использованию ключевого слова `private`:

```c++
class Line : private GeomBase {...};
```

Что в итоге изменится? Публичные методы базового класса по-прежнему можно будет вызывать в методах дочернего класса, но нельзя обращаться к ним извне через объект дочернего класса, например, так:

```c++
ptr_ln->set_coords(1, 2, 10, 20); // ошибка из-за режима наследования private
```

А вот через указатель на базовый класс его публичные методы будут по-прежнему вызываться. Например:

```c++
GeomBase* ptr_b = (GeomBase*)ptr_ln;
ptr_b->set_coords(1, 2, 10, 20);
```

Обратите внимание, что из-за режима наследования `private` компилятор теперь требует явного указания преобразования типа к базовому классу.

По аналогии работает режим наследования `protected`:

```c++
class Line : protected GeomBase {...};
```

В этом случае все публичные атрибуты класса `GeomBase` при доступе к ним извне воспринимаются как `protected` со всеми вытекающими отсюда следствиями. Вот, по сути, отличия между режимами наследования `public`, `private` и `protected`.

<hr>

[Содержание](#содержание)

## Сокрытие переменных в дочерних классах

Наряду с методами также можно делать переопределение переменных в дочерних классах. Например, если в классе `Line` прописать переменные `x0`, `y0`:

```c++
class Line : public GeomBase {
private:
    int x0{0}, y0{0};
    double length{0.0};
public:
...
};
```

то именно они по умолчанию будут использованы. При этом аналогичные переменные `x0`, `y0` базового класса по-прежнему будут располагаться в самом начале объекта:

![03](/OOP_C_C++/img/03_04.png)

Мы легко можем в этом убедиться. Если выполнить программу:

```c++
int main() {
    Line *ptr_ln = new Line;
 
    ptr_ln->set_coords(1, 2, 10, 20);
    ptr_ln->draw();
 
    delete ptr_ln;
 
    return 0;
}
```

то в консоли отобразится:

```
Line: set_coords()
Line: 0, 0, 10, 20
```

Первые два нуля, как раз и говорят о том, что данные были записаны в переменные `x0`, `y0` базового класса, а выводятся (с помощью метода `draw`) из дочернего, и в нем уже берутся свои значения `x0`, `y0`. Кроме того, если воспользоваться методом `get_coords` базового класса и прочитать значения его переменных:

```c++
    int a, b, c, d;
    ptr_ln->get_coords(a, b, c, d);
    printf("Coords: %d, %d, %d, %d\n", a, b, c, d);
```

то в консоли появится строчка:
```
Coords: 1, 2, 10, 20
```

Видите, первые два значения уже не нулевые. Они были взяты из одноименных переменных `x0`, `y0` базового класса, которые хранятся в текущем объекте.

Надо сказать, что на практике редко делают переопределение переменных в дочерних классах. Хотя, в ряде случаев это нужно, например, чтобы поменять значение какой-либо предопределенной константы. Но, как вы понимаете, злоупотреблять этим не стоит, т.к. переопределение переменных вносит путаницу в программный код.

<hr>

[Содержание](#содержание)

# 3.3 Порядок вызовов конструкторов и деструкторов при наследовании

[Смотреть материал на видео](https://www.youtube.com/watch?v=L6DCrdSFBB8&list=PLA0M1Bcd0w8ye84Jmv9yaI5eRTCBTcePE)

На предыдущем занятии мы с вами объявили два класса: базовый `GeomBase` и дочерний `Line`, которые я запишу в следующем виде:

```c++
class GeomBase {
protected:
    int x0{0}, y0{0}, x1{0}, y1{0};
public:
    void set_coords(int x0, int y0, int x1, int y1) {
        this->x0 = x0; this->y0 = y0;
        this->x1 = x1; this->y1 = y1;
    }
 
    void get_coords(int& x0, int& y0, int& x1, int& y1) {
        x0 = this->x0; y0 = this->y0;
        x1 = this->x1; y1 = this->y1;
    }
};

class Line : public GeomBase {
private:
    double length{0.0};
public:
    void draw() {
        printf("Line: %d, %d, %d, %d\n", x0, y0, x1, y1);
    }
};
```

Зададимся вопросом: в каком порядке происходит вызов конструкторов и деструкторов базового и дочернего классов? Я напомню, что отсутствие явно объявленных конструкторов в классах не освобождает компилятор от их использования. В этом случае он применяет предопределенные стандартные конструкторы и деструкторы. Однако чтобы увидеть порядок их вызовов, мы с вами пропишем конструкторы и деструкторы по умолчанию в базовом и дочернем классах следующим образом:

```c++
class GeomBase {
protected:
    int x0{0}, y0{0}, x1{0}, y1{0};
public:
    GeomBase()
        { std::cout << "Base: constructor" << std::endl; }
    ~GeomBase()
        { std::cout << "Base: destructor" << std::endl; }
...
};

 
class Line : public GeomBase {
private:
    double length{0.0};
public:
    Line()
        { std::cout << "Line: constructor" << std::endl; }
    ~Line()
        { std::cout << "Line: destructor" << std::endl; }
...
};
```

Если теперь в функции `main` создать объект класса `Line`:

```c++
int main() {
    Line ln;
 
    return 0;
}
```

то при выполнении программы в консоль будут выведены строчки:

```
Base: constructor
Line: constructor
Line: destructor
Base: destructor
```

И этот порядок вполне логичен. Если мы с вами вспомним структуру объекта дочернего класса `Line`, то увидим вначале формирование данных базового класса `GeomBase`, а затем, производного от него класса `Line`:

![03](/OOP_C_C++/img/03_05.png)

Как раз за формирование первой части класса `GeomBase` отвечает конструктор базового класса. Именно поэтому он вызывается первым. А за формирование второй части – конструктор дочернего класса `Line` (он вызывается вторым). И этот порядок всегда должен быть именно таким, иначе объект не будет сформирован корректно.

А вот деструкторы вызываются уже в обратном порядке и это тоже логично, так как в деструкторе дочернего класса `Line` мы вполне можем использовать данные базового класса, поэтому они должны существовать. В результате, сначала следует освободить ресурсы, занимаемые дочерним классом и только потом – базовым классом. Это определяет порядок вызова деструкторов. В действительности, компилятор подставляет вызов деструктора базового класса в конец тела деструктора дочернего класса:

```c++
~Line()
{
    // освобождение ресурсов дочернего класса
    ~GeomBase();
}
```

Конечно, нам явно это прописывать не нужно, компилятор все сделает за нас. А вот с конструкторами не всегда все срабатывает на автомате. Компилятор может без проблем вызывать конструктор по умолчанию базового класса, но если его не будет, то вызов любого другого ложится на плечи программиста. Например, если в базовом классе объявить конструктор с четырьмя параметрами (вместо конструктора по умолчанию):

```c++
    GeomBase(int a, int b, int c, int d)
        : x0(a), y0(b), x1(c), y1(d)
        { std::cout << "Base: constructor" << std::endl; }
```

то прежняя программа не скомпилируется. Компилятор не сможет самостоятельно сделать вызов такого конструктора и сформировать объект базового класса. Это мы должны будем прописать явно при вызове конструктора дочернего класса, например, следующим образом:

```c++
    Line() : GeomBase(0, 0, 0, 0)
        { std::cout << "Line: constructor" << std::endl; }
```

Обратите внимание, что, так как конструктор базового класса должен вызываться перед конструктором дочернего класса, то вызов `GeomBase` размещен в секции инициализации. Расположить вызов в теле конструктора будет ошибкой:

```c++
    Line()
    { 
        GeomBase(0, 0, 0, 0);
        std::cout << "Line: constructor" << std::endl; 
    }
```

В таком виде программа не скомпилируется.

Конечно, если в дочернем классе `Line` предполагается несколько перегруженных конструкторов, то каждый из них должен вызывать прежде конструктор базового класса GeomBase:

```c++
    Line() : GeomBase(0, 0, 0, 0)
        { std::cout << "Line: constructor 1" << std::endl; }
    Line(int a, int b, int c, int d) : GeomBase(a, b, c, d)
        { std::cout << "Line: constructor 2" << std::endl; }
```

Но это только в том случае, если нет конструктора по умолчанию или нужно делегировать некоторые действия, используя другой конструктор базового класса.

Если помимо вызова конструктора базового класса нужно выполнить инициализацию каких-либо переменных создаваемого объекта, то эта инициализация записывается после конструктора базового класса:

```c++
    Line() : GeomBase(0, 0, 0, 0), length {0}
        { std::cout << "Line: constructor 1" << std::endl; }
```

И это очевидно, т.к. возможно, что для формирования переменных дочернего класса потребуются какие-либо значения базового класса и они должны быть уже сформированы.

<hr>

[Содержание](#содержание)

# 3.4 Виртуальные (virtual) методы (функции)

[Смотреть материал на видео](https://www.youtube.com/watch?v=26hu2dIcLYc&list=PLA0M1Bcd0w8ye84Jmv9yaI5eRTCBTcePE)

## Виртуальные (virtual) методы (функции)

На этом занятии мы с вами познакомимся с одной из ключевых возможностей ООП языка C++ - виртуальными методами классов. Во многом именно виртуальные методы совместно с наследованием переводят нас на абстрактный уровень проектирования программного кода без необходимости сразу прописывать какую-либо конкретику. Также виртуальные методы – это яркий представитель настоящего динамического полиморфизма. В отличие от статического, с которым мы сталкивались при перегрузке функций и вызовов обычных методов базовых классов через объекты дочерних классов.

Начнем с того, что у нас имеются два уже знакомых нам класса: базовый `GeomBase` для обобщенного представления геометрических фигур на плоскости; `Line` – класс для описания объектов прямых линий:

```c++
class GeomBase {
protected:
    int x0{0}, y0{0}, x1{0}, y1{0};
public:
    void set_coords(int x0, int y0, int x1, int y1) {
        this->x0 = x0; this->y0 = y0;
        this->x1 = x1; this->y1 = y1;
    }
};

 
class Line : public GeomBase {
private:
    double length{0.0};
public:
    void draw() const
    {
        printf("Line: %d, %d, %d, %d\n", x0, y0, x1, y1);
    }
};
```

Я их записал в упрощенном виде, чтобы ничто нас не отвлекало от магии виртуальных методов. Давайте посмотрим, что будет, если в классе `GeomBase` тоже объявить публичный метод `draw` с той же сигнатурой:

```c++
class GeomBase {
protected:
    int x0{0}, y0{0}, x1{0}, y1{0};
public:
...
    void draw() const
    {
        printf("GeomBase: %d, %d, %d, %d\n", x0, y0, x1, y1);
    }    
};
```

Теперь, если в функции `main` создать объект дочернего класса `Line` и вызвать через него метод `draw`:

```c++
int main() {
    Line* ptr_ln = new Line;
 
    ptr_ln->draw();
 
    delete ptr_ln;
    return 0;
}
```

то будет вызван метод дочернего класса `Line` и в консоли отобразится строка:

```
Line: 0, 0, 0, 0
```

Однако если привести указатель объекта `Line` к указателю типа `GeomBase` и через него вызвать метод `draw`:

```c++
int main() {
    Line* ptr_ln = new Line;
    GeomBase* ptr_b = ptr_ln;
 
    ptr_ln->draw();
    ptr_b->draw();
 
    delete ptr_ln;
    return 0;
}
```

то вызовется уже метод базового класса:

```
Line: 0, 0, 0, 0
GeomBase: 0, 0, 0, 0
```

Об этом мы с вами подробно уже говорили. Если же в базовом классе не будет метода `draw`, то команда:

```c++
ptr_b->draw();
```

приведет к ошибке: метод не найден.

Но, что если нам нужно сделать так, чтобы через указатель базового класса вызывался метод дочернего класса? Как раз для этого и предназначены виртуальные методы. Если в базовом классе метод `draw` обозначить, как виртуальный:

```c++
class GeomBase {
...
public:
...
    virtual void draw() const {
        printf("GeomBase: %d, %d, %d, %d\n", x0, y0, x1, y1);
    }    
};
```

то при выполнении программы в консоли увидим строчки:

```
Line: 0, 0, 0, 0
Line: 0, 0, 0, 0
```

Но, если в дочернем классе убрать метод `draw` и снова запустить программу, то увидим:

```
GeomBase: 0, 0, 0, 0
GeomBase: 0, 0, 0, 0
```

Метод был взят из базового класса, так как в дочернем он отсутствует.

Вернем метод `draw` в дочернем классе `Line` и вместо операции приведения типа указателя создадим объект базового класса:

```c++
int main() {
    Line* ptr_ln = new Line;
    GeomBase* ptr_b = new GeomBase;
 
    ptr_ln->draw();
    ptr_b->draw();
 
    delete ptr_ln;
    delete ptr_b;
    return 0;
}
```

Теперь в консоли появляются строки:

```
Line: 0, 0, 0, 0
GeomBase: 0, 0, 0, 0
```

То есть, самостоятельный объект базового класса ведет себя так, словно у него нет никаких дочерних классов. И это логично, мы же создаем именно объект класса `GeomBase` и именно с ним, как с единым целым собираемся работать, поэтому никаких переопределений виртуальных методов здесь быть не должно.

__Класс, который переопределяет или наследует виртуальный метод, еще называются полиморфным (`polymorphic class`).__

В нашем примере класс `Line` является полиморфным.

<hr>

[Содержание](#содержание)

## Как работают виртуальные методы

Это была демонстрация объявления и работы виртуального метода. Давайте теперь детальнее изучим принцип, поднаготную их работы.

Когда создается объект класса, в котором имеется хотя бы одна виртуальная функция (например, класса `Line`):

```c++
Line* p = new Line;
```

то компилятор автоматически в этом объекте размещает специальный указатель `vptr` на таблицу виртуальных функций, связанной с этим классом:

![03](/OOP_C_C++/img/03_06.png)

В нашем примере таблица для класса `Line` будет состоять из одной виртуальной функции (метода) `draw`. Обратите внимание, что, несмотря на то, что метод `draw` в дочернем классе `Line` не помечен как виртуальный, тем не менее, компилятором он рассматривается как виртуальный. Поэтому часто у таких методов при их переопределении прописывают ключевое слово `virtual`, чтобы подчеркнуть факт наличия виртуального метода.

Итак, при создании объекта `p` вначале помещается указатель `vptr` на таблицу виртуальных функций класса `Line`. Зачем нужна эта таблица? Во-первых, теперь при вызове метода `draw`:

```c++
p->draw();
```

компилятор читает значение указателя `vptr`, по нему переходит к таблице виртуальных методов (функций), находит там нужный виртуальный метод и формирует код его вызова.

Во-вторых, если выполнить операцию приведения типа к указателю на базовый класс:

```c++
GeomBase* b = p;
```

А, затем, через него вызвать метод `draw`:

```c++
b->draw();
```

то компилятор обратится все к тому же объекту `p`, прочитает значение его указателя `vptr` и вызовет метод `draw` для класса `Line`, а не базового класса `GeomBase`, как это было бы без наличия таблицы виртуальных функций.

Если же мы создаем изначально объект базового класса `GeomBase`:

```c++
GeomBase* b = GeomBase;
```

то указатель `vptr` будет вести на таблицу виртуальных функций именно этого класса и вызов:

```c++
b->draw();
```

будет связан с методом `draw` класса `GeomBase`.

Вот так, через таблицу виртуальных методов реализуется механика их вызовов.

<hr>

[Содержание](#содержание)

# 3.5 Ключевые слова override, final. Виртуальные деструкторы

[Смотреть материал на видео](https://www.youtube.com/watch?v=ioYKM6lXrHE&list=PLA0M1Bcd0w8ye84Jmv9yaI5eRTCBTcePE)

## Ключевое слово override

На предыдущем занятии мы с вами определили базовый класс `GeomBase` и производный от него класс `Line`:

```c++
class GeomBase {
protected:
    int x0{0}, y0{0}, x1{0}, y1{0};
public:
    void set_coords(int x0, int y0, int x1, int y1)
    {
        this->x0 = x0; this->y0 = y0;
        this->x1 = x1; this->y1 = y1;
    }
 
    virtual void draw() const
    {
        printf("GeomBase: %d, %d, %d, %d\n", x0, y0, x1, y1);
    }    
};
 
class Line : public GeomBase {
private:
    double length{0.0};
public:
    virtual void draw() const
    {
        printf("Line: %d, %d, %d, %d\n", x0, y0, x1, y1);
    }
};
```

Как правило, виртуальные методы объявляются с целью их переопределения в дочерних классах (иначе виртуальность теряет смысл). При этом сигнатура переопределяемого метода должна четко соблюдаться. Например, если в дочернем классе `Line` виртуальный метод `draw` переопределить, добавив один параметр:

```c++
class Line : public GeomBase {
private:
    double length{0.0};
public:
    virtual void draw(bool fl_draw=true) const
    {
        printf("Line: %d, %d, %d, %d\n", x0, y0, x1, y1);
    }
};
```

А, затем, в функции `main` создать объект этого класса и вызвать метод `draw`:

```c++
int main() {
    Line* ptr_ln = new Line;
 
    ptr_ln->draw();
 
    delete ptr_ln;
    return 0;
}
```

То программа скомпилируется без каких-либо ошибок и замечаний. Однако виртуальный метод `draw` базового класса `GeomBase` при этом не был переопределен. Если мы сформируем указатель `ptr_b` типа `GeomBase` и через него вызовем метод `draw`:

```c++
int main() {
    Line* ptr_ln = new Line;
    GeomBase* ptr_b = ptr_ln;
 
    ptr_ln->draw();
    ptr_b->draw();
 
    delete ptr_ln;
    return 0;
}
```

то вызовется метод базового класса, в консоли увидим строчки:

```
Line: 0, 0, 0, 0
GeomBase: 0, 0, 0, 0
```

И все из-за наличия параметра у метода `draw` дочернего класса `Line`. Если этот параметр убрать, то в обоих случаях будет вызван метод дочернего класса:

```
Line: 0, 0, 0, 0
Line: 0, 0, 0, 0
```

Видите, как легко совершить ошибку, случайно прописав лишний параметр при переопределении виртуального метода. При этом компилятор никак на это не реагирует. Похожая ситуация может возникнуть, если в базовом классе меняется сигнатура виртуального метода. Из-за этого его переопределение  в дочерних классах перестает существовать. Чтобы в процессе разработки программы исключить подобные ошибки переопределяемый виртуальный метод следует явно помечать ключевым словом `override`:

```c++
class Line : public GeomBase {
private:
    double length{0.0};
public:
    virtual void draw() const override
    {
        printf("Line: %d, %d, %d, %d\n", x0, y0, x1, y1);
    }
};
```

Тогда при совпадении сигнатур программа скомпилируется без ошибок. А если сигнатура изменится, например, добавим прежний параметр:

```c++
    virtual void draw(bool fl_draw=true) const override
    {
        printf("Line: %d, %d, %d, %d\n", x0, y0, x1, y1);
    }
```

то компилятор сообщит об ошибке. Поэтому все переопределяемые виртуальные методы следует помечать в дочерних классах ключевым словом `override`. И это касается именно виртуальных методов. С обычными таких проблем не возникает, т.к. они всегда вызываются каждый из своего класса (либо берутся из базового при отсутствии переопределения).

<hr>

[Содержание](#содержание)

## Ключевое слово final

Давайте теперь представим, что мы объявляем еще один дочерний класс от класса `Line`:

```c++
class PolyLine : public Line {
public:
    virtual void draw() const override
    {
        printf("PolyLine: %d, %d, %d, %d\n", x0, y0, x1, y1);
    }
};
```

Так тоже можно делать. В качестве базового, в общем случае, может выступать любой класс. В результате, получается следующая цепочка наследования:

![03](/OOP_C_C++/img/03_07.png)

Очевидно, если создается объект класса `PolyLine`, то метод `draw` будет вызываться из этого класса, как бы мы это не делали:

```c++
int main() {
    Line* ptr_ln = new Line;
    PolyLine* poly = new PolyLine;
 
    GeomBase* ptr_b = ptr_ln;
    GeomBase* ptr_b_poly = poly;
 
    ptr_b->draw();
    ptr_b_poly->draw();
 
    delete ptr_ln;
    delete poly;
    return 0;
}
```

После запуска программы в консоли увидим:

```
Line: 0, 0, 0, 0
PolyLine: 0, 0, 0, 0
```

Но, что если по каким-либо причинам, мы бы захотели запретить дальнейшее переопределение метода `draw`? То есть, оставить только одну реализацию в классе `Line`. Для этого в конце прототипа метода следует прописать ключевое слово `final` следующим образом:

```c++
class Line : public GeomBase {
...
    virtual void draw() const override final
    {
        printf("Line: %d, %d, %d, %d\n", x0, y0, x1, y1);
    }
};
```

После этого переопределение `draw` в классе `PolyLine` приведет к ошибке на этапе компиляции программы. И программисту ничего не останется, как убрать определение этого метода из класса.

Обратите внимание, что ключевое слово `final` можно применить только к виртуальным методам. С обычными методами оно не работает.

<hr>

[Содержание](#содержание)

## Виртуальные деструкторы

В заключение этого занятия рассмотрим еще один важный момент, связанный с наследованием классов. Давайте представим, что в программе создается объект дочернего класса `Line` следующим образом:

```c++
int main() {
    GeomBase* ptr_ln = new Line;
    ptr_ln->draw();
    delete ptr_ln;
 
    return 0;
}
```

На первый взгляд здесь все кажется корректным. Добавим теперь в классы `GeomBase` и `Line` деструкторы следующим образом:

```c++
class GeomBase {
...
    ~GeomBase() { puts("Delete: GeomBase"); }
};
 
class Line : public GeomBase {
...
    ~Line() { puts("Delete: Line"); }
};
```

После запуска программы в консоли увидим:

```c
Line: 0, 0, 0, 0
Delete: GeomBase
```

То есть, был вызван только один деструктор базового класса `GeomBase`. Очевидно, это произошло по той причине, что мы работаем с объектом через указатель на базовый класс. Как же нам тогда поправить описание классов, чтобы вызывались оба деструктора: и базового и дочернего классов? Здесь нам на помощь приходят виртуальные методы. Деструкторы классов разрешено тоже делать виртуальными. И, если пометить деструктор базового класса, как виртуальный:

```c++
class GeomBase {
...
    virtual ~GeomBase() { puts("Delete: GeomBase"); }
};
```

то вместо него будет вызван деструктор дочернего класса `Line` – того объекта, который уничтожается. А деструктор дочернего класса, как мы уже знаем, автоматически вызывает и деструктор базового. В результате, при выполнении программы, в консоли увидим:

```c++
Line: 0, 0, 0, 0
Delete: Line
Delete: GeomBase
```

Вас может удивить, что деструктор, имеющий имя` ~GeomBase` был переопределен деструктором с именем `~Line()`. 

Да, это особенность именно деструкторов. Их сигнатуры, на самом деле, в разных классах полностью совпадают на уровне таблиц виртуальных методов. Поэтому виртуальный деструктор базового класса успешно переопределяется деструктором любого дочернего класса. И если мы знаем, что класс предполагается использовать при наследовании, то его деструктор лучше сразу помечать, как виртуальный, даже если он ничего не делает. Иначе мы рискуем не вызвать деструктор дочернего класса, а это уже может быть критично. 

Вообще, если класс имеет хотя бы один виртуальный метод, то его деструктор следует делать виртуальным. Некоторые компиляторы даже выдают предупреждение, если этого не сделать. Этот факт еще раз подчеркивает важность объявления виртуальных деструкторов в классах, которые участвуют в наследовании.

<hr>

[Содержание](#содержание)

# 3.6 Чисто виртуальные методы. Абстрактные классы

[Смотреть материал на видео](https://www.youtube.com/watch?v=G1cRf56qM84&list=PLA0M1Bcd0w8ye84Jmv9yaI5eRTCBTcePE)

## Чисто виртуальные методы

На этом занятии мы с вами рассмотрим одну из ключевых возможностей ООП языка C++ – чисто виртуальные методы (функции) и абстрактные классы. 

Благодаря этим конструкциям и механизму наследования появляется возможность описывать логику программы на обобщенном уровне, не привязываясь к конкретной реализации. И сейчас мы с вами начнем знакомиться с магией такого подхода, дарованного объектно-ориентированным программированием.

На предыдущем занятии были описаны два класса: базовый `GeomBase` и дочерний `Line`:

```c++
class GeomBase {
protected:
    int x0{0}, y0{0}, x1{0}, y1{0};
public:
    void set_coords(int x0, int y0, int x1, int y1)
    {
        this->x0 = x0; this->y0 = y0;
        this->x1 = x1; this->y1 = y1;
    }
 
    virtual void draw() const
    {
        printf("GeomBase: %d, %d, %d, %d\n", x0, y0, x1, y1);
    }    
};
 
class Line : public GeomBase {
private:
    double length{0.0};
public:
    virtual void draw() const override
    {
        printf("Line: %d, %d, %d, %d\n", x0, y0, x1, y1);
    }
};
```

В базовом классе мы разместили виртуальный метод `draw`, который переопределили, затем, в дочернем классе `Line`. И было бы логично метод `draw` в базовом классе объявить без какой-либо реализации, т.к. рисование неизвестной фигуры занятие крайне странное. Но может нам тогда совсем убрать этот метод из базового класса? Если мы так сделаем, то следующая конструкция завершится ошибкой:

```c++
int main() {
    Line* ptr_ln = new Line;
    GeomBase* ptr_b = ptr_ln;
 
    ptr_b->draw(); // ошибка, нет метода draw в классе GeomBase
 
    delete ptr_ln;
    delete ptr_b;
    return 0;
}
```

Чтобы это работало, метод `draw` должен с одной стороны присутствовать в классе `GeomBase`, но с другой – не иметь никакой реализации (тела). А вызываться будет аналогичный метод дочернего класса. Может нам тогда его записать в виде прототипа:

```c++
virtual void draw() const;
```

Но и это не решение, т.к. прототип требует последующего определения тела метода, как правило, вне класса. В таком виде мы снова получим ошибку при его вызове.

Конечно, можно сделать своеобразный костыль и прописать пустое тело метода:

```c++
virtual void draw() const { }
```

Но тогда  в случае отсутствия этого метода в дочернем классе вызовется метод `draw` с пустым телом. А нам хотелось бы так объявить виртуальный метод `draw`, чтобы он гарантированно брался из дочернего класса, а вызов из базового был бы невозможен. Тогда программист случайно не совершит ошибку, если какой-либо важный метод забудет переопределить.

Так вот, существует еще один способ объявления виртуальных методов с отсутствующим телом, который предложил автор языка Бьерн Страуструп:

```c++
virtual void draw() const = 0;
```

Здесь мы говорим компилятору, что в базовом классе объявлена сигнатура виртуального метода `draw` (без реализации), который должен быть переопределен в дочернем классе. Затем, используя этот прототип и указатель на базовый класс, по таблице виртуальных функций дочернего класса следует брать метод аналогичный метод уже с реализацией. То есть, определяя метод без тела, мы в базовом классе создам универсальный интерфейс для вызова произвольных методов с аналогичной сигнатурой из дочерних классов. Сами же виртуальные методы без реализаций получили название чисто виртуальных методов (`pure virtual function, method`).

Хорошо, но зачем нам все это понадобилось? Я напомню, что мы начинали тему наследования с примера описания различных графических примитивов:

![03](/OOP_C_C++/img/03_08.png)

Геометрия каждого примитива определяется двумя координатами на плоскости (четырьмя переменными: `x0`, `y0`, `x1`, `y1`). Давайте добавим еще два дочерних класса для прямоугольников и эллипсов:

```c++
class Rect : public GeomBase {
public:
    virtual void draw() const override
        { printf("Rect: %d, %d, %d, %d\n", x0, y0, x1, y1); }
};
 
class Ellipse : public GeomBase {
public:
    virtual void draw() const override
        { printf("Ellipse: %d, %d, %d, %d\n", x0, y0, x1, y1); }
};
```

И, так как у всех у них единый базовый класс, то мы можем на программном уровне хранить эти объекты следующим образом:

```c++
int main() {
    GeomBase* g1 = new Line;
    GeomBase* g2 = new Rect;
    GeomBase* g3 = new Line;
    GeomBase* g4 = new Ellipse;
 
    delete g1;
    delete g2;
    delete g3;
    delete g4;
 
    return 0;
}
```

Или, сделать еще лучше, воспользоваться массивом указателей, например, так:

```c++
enum {max_geoms = 1000};
 
int main() {
    size_t count_g = 4; // число геометрических фигур
    GeomBase* geoms[max_geoms] = {nullptr};
 
    geoms[0] = new Line;
    geoms[1] = new Rect;
    geoms[2] = new Line;
    geoms[3] = new Ellipse;
 
    for(size_t i = 0;i < count_g; ++i)
        geoms[i]->draw();
 
    for(size_t i = 0;i < count_g; ++i)
        delete geoms[i];
        
    return 0;
}
```

Смотрите, используя указатели на базовый класс каждого примитива, мы на общем уровне прописали их отображение, используя чисто виртуальный метод `draw`, который изначально (в базовом классе) не имел никакой реализации. По сути, фрагмент программы:

```c++
    for(size_t i = 0;i < count_g; ++i)
        geoms[i]->draw();
```

никак не связан с конкретной реализацией отображения графических примитивов. Конкретика появляется только в дочерних классах. А раз так, то в будущем совершенно спокойно в эту программу можно добавить любой другой новый дочерний класс для нового примитива. И он автоматически встроится в работу программного кода, описанного на уровне виртуальных функций базового класса. Например, если прописать класс для представления кругов:

```c++
class Circle : public GeomBase {
public:
    virtual void draw() const override
        { printf("Circle: %d, %d, %d, %d\n", x0, y0, x1, y1); }
};
```

То в функции `main` он достаточно просто встраивается в работу общей логики программы:

```c++
int main() {
    size_t count_g = 5; // число геометрических фигур
    GeomBase* geoms[max_geoms] = {nullptr};
 
    geoms[0] = new Line;
    geoms[1] = new Rect;
    geoms[2] = new Line;
    geoms[3] = new Ellipse;
    geoms[4] = new Circle;
 
    for(size_t i = 0;i < count_g; ++i)
        geoms[i]->draw();
 
    for(size_t i = 0;i < count_g; ++i)
        delete geoms[i];
 
    return 0;
}
```

Все, что нам нужно было сделать – это добавить новый объект класса `Circle` в массив `geoms`. После этого он будет обрабатываться наряду с другими, ранее существующими  объектами. Видите, как легко и просто можно расширять функционал программы, просто добавляя новые дочерние классы. И все благодаря использованию чисто виртуальных функций и механизму наследованию. А вызов в цикле метода `draw`:

```c++
    for(size_t i = 0;i < count_g; ++i)
        geoms[i]->draw();
```

это пример динамического полиморфизма, когда вызываемый метод (`draw`) определяется не в момент компиляции программы, а в момент ее работы.

<hr>

[Содержание](#содержание)

## Абстрактные классы

В заключение этого занятия несколько замечаний о классе `GeomBase`, который стал содержать один чисто виртуальный метод. Наличие такого метода превращает класс `GeomBase` в абстрактный класс. Что это значит? Это значит, что объекты этого класса создавать не получится. Следующая команда приведет к ошибке на этапе компиляции:

```c++
GeomBase* p = new GeomBase;
```

С чем это связано? 

Да, в классе имеется чисто виртуальный метод `draw`, без реализации и это переводит класс на такой уровень абстракции, где существование объектов становится уже невозможным. Поэтому любой класс в языке C++, который содержит или наследует без переопределения хотя бы один чисто виртуальный метод, является абстрактным. Абстрактные классы, как мы уже видели из примера геометрических фигур, можно использовать при наследовании, создавая на их основе другие полноценные дочерние классы. Объекты дочерних классов можно спокойно создавать (при переопределении в них чистых виртуальных методов).

<hr>

[Содержание](#содержание)

# 3.7 Множественное наследование. Порядок вызова конструкторов и деструкторов

[Смотреть материал на видео](https://www.youtube.com/watch?v=lB75BY9kobI&list=PLA0M1Bcd0w8ye84Jmv9yaI5eRTCBTcePE)

## Множественное наследование

До сих пор мы с вами наследовали дочерний класс от одного базового. И это относительно частая ситуация. Однако иногда требуется выполнять наследование сразу от нескольких базовых классов. Такой подход называется __множественным наследованием__.

![03](/OOP_C_C++/img/03_09.png)

Надо сказать, что не все языки программирования предоставляют такой функционал. Например, в `Java` множественное наследование запрещено. Правда, там есть классы специальных видов – интерфейсы, которые несколько сглаживают это ограничение. 

С чем это связано? 

При наличии нескольких базовых классов можно легко нарушить логику работы всей этой конструкции, так как классы не редко разрабатываются разными программистами и учесть их согласованную работу становится не так то просто. Или же, один и тот же программист спустя определенное время может легко внести в один из классов такие правки, которые приведут к краху всей программы. Поэтому применять множественное наследование следует с крайней осторожностью и лучше здесь придерживаться устоявшихся подходов к построению таких конструкций.

Тем не менее, язык C++, наряду с другими ЯП, позволяет нам наследоваться сразу от нескольких классов. И в ряде случаев это бывает весьма полезной возможностью. Поэтому давайте внимательно рассмотрим этот механизм.

На предыдущих занятиях у нас с вами использовался базовый класс `GeomBase` и дочерний `Line`. Запишем их в следующем виде:

```c++
class GeomBase {
protected:
    int x0{0}, y0{0}, x1{0}, y1{0};
public:
    GeomBase(int a = 0, int b = 0, int c = 0, int d = 0)
        : x0(a), y0(b), x1(c), y1(d)
        { }
 
    void set_coords(int x0, int y0, int x1, int y1)
    {
        this->x0 = x0; this->y0 = y0;
        this->x1 = x1; this->y1 = y1;
    }
 
    virtual void draw() const = 0;
};
 
class Line : public GeomBase {
private:
    double length{0.0};
public:
    Line(int a = 0, int b = 0, int c = 0, int d = 0) : GeomBase(a, b, c, d)
        { }
 
    virtual void draw() const
        { printf("Line: %d, %d, %d, %d\n", x0, y0, x1, y1); }
};
```

Здесь все должно быть вам знакомо и понятно. Но допустим, что затем, мы решили разработать функционал для сохранения геометрических фигур в файл. Так как это самостоятельная задача, то ее целесообразно выделить в отдельный класс. Для простоты опишем его следующим образом (в самом начале):

```c++
#include <fstream>
 
class GeomSerialize {
protected:
    bool fl_saved {false};
public:
    virtual void save(std::ostream& os) const = 0;
    virtual void load(std::istream& is) = 0;
};
```

И, затем, унаследует класс `Line` сразу от двух классов:

```c++
class Line : public GeomBase, public GeomSerialize {
...
};
```

Обратите внимание, как прописано множественное наследование. Перед каждым классом указывается его режим наследования (`public`), а сами классы записаны через запятую.

После этого в классе `Line` можно переопределить виртуальные методы `save` и `load` класса `GeomSerialize`. В самом простом варианте это можно сделать так:

```c++
class Line : public GeomBase, public GeomSerialize {
...
public:
...
    virtual void save(std::ostream& os) const override
        { os.write((char *)this, sizeof(*this)); }
 
    virtual void load(std::istream& is) override
        { is.read((char *)this, sizeof(*this)); }
};
```

Если эти методы не переопределять в дочернем классе `Line`, то при компиляции возникла бы ошибка из-за отсутствия определения чисто виртуальных методов базового класса.

В результате мы получили следующую схему наследования классов:

![03](/OOP_C_C++/img/03_10.png)

<hr>

[Содержание](#содержание)

## Порядок вызовов конструкторов и деструкторов

Первый вопрос, который здесь возникает, в каком порядке вызываются конструкторы и деструкторы этих классов. Давайте посмотрим. Добавим в каждый класс публичный конструктор и деструктор с выводом сообщений:

```c++
class GeomSerialize {
protected:
    bool fl_saved {false};
public:
    GeomSerialize()
        { std::cout << "GeomSerialize: constructor" << std::endl; }
    virtual ~GeomSerialize()
        { std::cout << "GeomSerialize: destructor" << std::endl; }
...
};
 
class GeomBase {
...
public:
    GeomBase(int a = 0, int b = 0, int c = 0, int d = 0)
        : x0(a), y0(b), x1(c), y1(d)
        { std::cout << "GeomBase: constructor" << std::endl; }
    virtual ~GeomBase()
        { std::cout << "GeomBase: destructor" << std::endl; }
...
};
 
class Line : public GeomBase, public GeomSerialize {
...
public:
    Line(int a = 0, int b = 0, int c = 0, int d = 0) : GeomBase(a, b, c, d)
        { std::cout << "Line: constructor" << std::endl; }
    ~Line()
        { std::cout << "Line: destructor" << std::endl; }
...
};
```

Если теперь создать в функции `main` объект класса `Line`:

```c++
int main() {
    Line ln(1, 2, 10, 20);
    
    return 0;
}
```

То в консоли увидим строчки:

```
GeomBase: constructor
GeomSerialize: constructor
Line: constructor
Line: destructor
GeomSerialize: destructor
GeomBase: destructor
```

То есть, сначала вызываются конструкторы базовых классов в порядке их указания при наследовании, затем, конструктор дочернего класса `Line`. А деструкторы отрабатывают в обратном порядке: сначала деструктор класса `Line`, затем, базовых классов `GeomSerialize` и `GeomBase`. Все вполне логично и ожидаемо.

Однако здесь есть один нюанс. Конструктор дочернего класса `Line` вызывает конструктор базового класса `GeomBase`. При этом порядок вызовов конструкторов при делегировании следует записывать в том же порядке, что и классы при наследовании. Например, если поменять порядок следования классов, то правильно было бы вызывать их конструкторы так:
1
```c++
class Line : public GeomSerialize, public GeomBase {
...
public:
    Line(int a = 0, int b = 0, int c = 0, int d = 0) : GeomSerialize(), GeomBase(a, b, c, d)
        { std::cout << "Line: constructor" << std::endl; }
...
};
```

Правда, современные компиляторы расположат вызовы конструкторов базовых классов в правильном порядке, вне зависимости от их записи при делегировании. Поэтому, можно специально не вызывать конструктор по умолчанию класса `GeomSerialize`:

```c++
    Line(int a = 0, int b = 0, int c = 0, int d = 0) : GeomBase(a, b, c, d)
        { std::cout << "Line: constructor" << std::endl; }
```

Все по-прежнему будет работать. Но, по возможности, порядок все же следует соблюдать.

<hr>

[Содержание](#содержание)

## Объект дочернего класса при множественном наследовании

С порядком конструирования объектов дочерних классов при множественном наследовании мы разобрались. Следующий вопрос, что из себя представляет объект класса `Line`?

Пусть базовые классы при наследовании записаны в порядке:

```c++
class Line : public GeomBase, public GeomSerialize { ... };
```

Тогда сначала создается объект класса `GeomBase`, а затем класса `GeomSerialize`. В результате объект дочернего класса будет содержать данные в следующем порядке:

![03](/OOP_C_C++/img/03_11.png)

Благодаря строгому порядку расположения переменных, мы можем преобразовать объект дочернего класса к указателю или ссылки любого базового. Например:

```c++
int main() {
    Line ln(1, 2, 10, 20);
 
    GeomBase* ptr_b = &ln;
    GeomSerialize* ptr_sz = &ln;
 
    GeomBase& lnk_b = ln;
    GeomSerialize& lnk_sz = ln;
 
    return 0;
}
```

При этом операции приведения типов в таких случаях прописывать не обязательно, компилятор языка C++ это сделает автоматически. Соответственно, через указатель или ссылку мы можем работать только с фрагментом соответствующего базового класса. Например:

```c++
int main() {
...
    ptr_b->draw();
    
    std::ofstream ofs("line.dat");
    lnk_sz.save(ofs);
    ofs.close();
 
    return 0;
}
```

На следующем занятии мы продолжим эту тему и рассмотрим некоторые проблемы и способы их решения при множественном наследовании.

<hr>

[Содержание](#содержание)

# 3.8 Ромбовидное наследование. Закрытый конструктор и деструктор

[Смотреть материал на видео](https://www.youtube.com/watch?v=bTvoVPmPUgg&list=PLA0M1Bcd0w8ye84Jmv9yaI5eRTCBTcePE)

Продолжаем тему множественного наследования. На прошлом занятии мы с вами объявили два базовых класса `GeomSerialize` и `GeomBase`, от которых формируется дочерний класс `Line`. Пока эти классы содержат совершенно разные методы, никаких проблем их совместного использования не возникает. Но, что если в этих классах прописать метод с одинаковой сигнатурой? Например:

```c++
class GeomSerialize {
...
    size_t get_size_obj() const { return sizeof(*this); }
};
 
class GeomBase {
...
    size_t get_size_obj() const { return sizeof(*this); }
};
```

Пока нет вызова этого метода, программа работает, как и ранее. Но, если попытаться его вызвать через объект дочернего класса `Line`:

```c++
int main() {
    Line ln(1, 2, 10, 20);
 
    size_t sz = ln.get_size_obj(); // ошибка
 
    return 0;
}
```

то компилятор выдаст ошибку, что метод `get_size_obj` неоднозначен, то есть, объявлен в обоих базовых классах и какой именно вызывать непонятно. Один из вариантов решения этой неопределенности – явно прописать область видимости одного из базовых классов, где этот метод прописан:

```c++
size_t sz = ln.GeomBase::get_size_obj();
```

Или же получить ссылку или указатель на один из классов и через него вызвать такой метод:

```c++
GeomSerialize& lnk_sz = ln;
sz = lnk_sz.get_size_obj();
```

Но, во-первых, это выглядит несколько коряво, и, во-вторых, скорее всего не совсем то, что нам нужно. 

Часто подобная коллизия методов – это признак неверно описанных классов. Возможно, достаточно сменить названия методов и проблема будет решена. Однако тот же самый эффект может возникнуть даже если в классах не прописывать одинаковые методы. Они могут унаследоваться от вышестоящего класса.

<hr>

[Содержание](#содержание)

## Ромбовидное наследование

Например, перенесем в следующий по иерархии базовый класс `General` метод `get_size_obj`:

```c++
class General {
public:
    size_t get_size_obj() const { return sizeof(*this); }
};
```

И унаследуем от него классы `GeomSerialize` и `GeomBase`:

```c++
class GeomSerialize : public General { ... };
class GeomBase : public General { ... };
```

Получим следующую иерархию наследования:

![03](/OOP_C_C++/img/03_12.png)

В результате метод `get_size_obj` оказывается в области видимости обоих классов `GeomSerialize` и `GeomBase`. Соответственно, при его вызове через объект класса `Line`, возникает все та же неопределенность. Мало того, конструктор класса `General` будет вызван дважды. Если его явно прописать в классе `General`:

```c++
class General {
public:
    General()
        { std::cout << "General: constructor" << std::endl; }
 
    size_t get_size_obj() const { return sizeof(*this); }
};
```

то после запуска программы увидим (при создании объекта класса `Line`):

```
General: constructor
GeomBase: constructor
General: constructor
GeomSerialize: constructor
Line: constructor
Line: destructor
GeomSerialize: destructor
GeomBase: destructor
```

<hr>

[Содержание](#содержание)

## Виртуальное наследование

Конечно, подобных ситуаций лучше избегать еще в процессе проектирования архитектуры программы. Если же использование такого наследования считается необходимым и оправданным, то спрашивается, как исправить возникшую ситуацию? Здесь нам на помощь приходит механизм виртуального наследования базовых классов.

Если при определении наследования классов `GeomSerialize` и `GeomBase` прописать ключевое слово `virtual`:

```c++
class GeomSerialize : virtual public General { ... };
class GeomBase : virtual public General { ... };
```

То мы видим, как радикально меняется ситуация. Теперь объект класса `General` формируется только один раз и в единственном экземпляре содержится в объекте дочернего класса `Line`. Это как раз то, что нам нужно. Благодаря этому метод `get_size_obj` так же появляется в единственном экземпляре. Поэтому вызов:

```c++
size_t sz = ln.get_size_obj();
```

больше не приводит к каким-либо ошибкам на этапе компиляции программы. Причем, мы по прежнему можем вызывать этот метод с указанием той или иной области видимости:

```c++
size_t sz = ln.GeomBase::get_size_obj();
```

или

```c++
size_t sz = ln.GeomSerialize::get_size_obj();
```

Это будет все тот же самый один метод, прописанный в классе `General`. Дублирование не возникает благодаря использованию виртуального наследования.

<hr>

[Содержание](#содержание)

## Защищенный конструктор

Давайте еще раз посмотрим на наши полученные классы. Вероятно, что объекты классов `General`, `GeomSerialize`, `GeomBase` создавать в программе вряд ли необходимо. И было бы правильно явно запретить эту операцию. Конечно объекты абстрактных классов `GeomSerialize` и `GeomBase` мы так и так создать не сможем, но если чисто виртуальные методы будут заменены на обычные виртуальные, то ситуация изменится. Один из надежных способов запрета создания объектов классов – это поместить их конструкторы в секции `protected`. Почему именно `protected`, а не `private`? Если конструкторы пометить, как `private`, то нельзя будет создавать и объекты производных от них классов. Нам же нужно, только определить запрет создания объектов базовых классов. Поэтому выбираем секцию `protected`.

После изменения, запускаем программу, видим, что все работает по прежнему. Но, если попытаться создать какой-либо объект любого базового класса:

```c++
int main() {
    Line ln(1, 2, 10, 20); // ok
 
    General gb; // ошибка
    GeomSerialize* ptr_sz = new GeomSerialize; // ошибка
 
    return 0;
}
```

то возникнет ошибка на этапе компиляции программы.

<hr>

[Содержание](#содержание)

## Защищенный деструктор

А какой эффект можно получить, если в раздел `protected` или `private` поместить деструктор класса? Давайте это пропишем у класса `Line`:

```c++
class Line : public GeomBase, public GeomSerialize {
    double length{0.0};
protected:
    ~Line()
        { std::cout << "Line: destructor" << std::endl; }
public:
...
};
```

Тогда мы сможем сформировать объект класса только с использованием оператора `new` следующим образом:

```c++
int main() {
    Line ln(1, 2, 10, 20);  // ошибка
    Line* ptr_ln = new Line(1, 2, 10, 20);  // ok
 
    delete ptr_ln;  // ошибка
    
    return 0;
}
```

Почему возникает ошибка в строчке:

```c++
Line ln(1, 2, 10, 20); 
```

Очевидно, здесь компилятор не может вставить вызов деструктора этого объекта, т.к. он является защищенным или приватным. Но создать объект с помощью оператора `new` все еще можно, т.к. на этом этапе вызов деструктора не предусмотрен. Он должен сработать в момент освобождения памяти в команде:

```c++
delete ptr_ln;
```

Именно поэтому она также приведет к ошибке на этапе компиляции.

Таким образом, защищенный деструктор не позволяет формировать объекты класса в стековом фрейме, но разрешает в куче. Но, как же тогда удалять такие объекты и освобождать память? Для этого в классе `Line` достаточно прописать статический метод, например:

```c++
class Line : public GeomBase, public GeomSerialize {
...
    static void delete_object(Line* ptr)
    {
        delete ptr;
    }
};
```

И вызывать его для удаления объектов этого класса:

```c++
int main() {
    Line* ptr_ln = new Line(1, 2, 10, 20);
    Line::delete_object(ptr_ln);
    return 0;
}
```

Этот прием с закрытым деструктором иногда полезно использовать на практике, если предполагается размещать объекты класса исключительно в куче.

<hr>

[Содержание](#содержание)
