# 4. Обработка исключений. Шаблоны классов и функций. Операторы приведения типов

## Содержание

+ [4.1 Операторы const_cast и reinterpret_cast](#41-операторы-const_cast-и-reinterpret_cast)
    + [Оператор const_cast](#оператор-const_cast)
    + [Оператор reinterpret_cast](#оператор-reinterpret_cast)
+ [4.2 Операторы static_cast и dynamic_cast](#42-операторы-static_cast-и-dynamic_cast)
    + [Оператор static_cast](#оператор-static_cast)
    + [Оператор dynamic_cast](#оператор-dynamic_cast)
    + [Операторы static_cast и dynamic_cast с указателями shared_ptr](#операторы-static_cast-и-dynamic_cast-с-указателями-shared_ptr)
+ [4.3 Обработка исключений. Введение](#43-обработка-исключений-введение)
    + [Оператор throw](#оператор-throw)
    + [Операторы try/catch](#операторы-trycatch)
+ [4.4 Объект исключения. Вложенные блоки try/catch](#44-объект-исключения-вложенные-блоки-trycatch)
    + [Удаление объектов при генерации исключений](#удаление-объектов-при-генерации-исключений)
    + [Вложенные блоки try/catch](#вложенные-блоки-trycatch)
+ [4.5 Правила идентификации типов исключений. Пользовательские классы исключений](#45-правила-идентификации-типов-исключений-пользовательские-классы-исключений)
    + [Использование собственных классов (типов) исключений](#использование-собственных-классов-типов-исключений)
    + [Базовый класс исключений std::exception](#базовый-класс-исключений-stdexception)
    + [Заключение](#заключение)
+ [4.6 Введение в шаблоны функций](#46-введение-в-шаблоны-функций)
    + [Инстанцирование шаблона. Вызов шаблонных функций](#инстанцирование-шаблона-вызов-шаблонных-функций)
    + [Прототип шаблонной функции](#прототип-шаблонной-функции)
    + [Вариации использования параметра типа](#вариации-использования-параметра-типа)
+ [4.7 Шаблоны функций. Продолжение](#47-шаблоны-функций-продолжение)
    + [Параметры шаблонов с явным указанием типа](#параметры-шаблонов-с-явным-указанием-типа)
    + [Аргументы параметров шаблонов по умолчанию](#аргументы-параметров-шаблонов-по-умолчанию)
    + [Перегрузка шаблонов функций](#перегрузка-шаблонов-функций)
+ [4.8 Введение в шаблоны классов](#48-введение-в-шаблоны-классов)
    + [Шаблоны с параметрами по умолчанию](#шаблоны-с-параметрами-по-умолчанию)
    + [Инстанцирование шаблонов классов](#инстанцирование-шаблонов-классов)
    + [Объявление методов шаблона класса](#объявление-методов-шаблона-класса)
+ [4.9 Специализация и наследование шаблонов классов](#49-специализация-и-наследование-шаблонов-классов)
    + [Наследование шаблонных классов](#наследование-шаблонных-классов)
    + [Заключение](#заключение-2)

[Оглавдение](/OOP_C_C++/README.md)

# 4.1 Операторы const_cast и reinterpret_cast

[Смотреть материал на видео](https://www.youtube.com/watch?v=vUbmafYRdKU&list=PLA0M1Bcd0w8ye84Jmv9yaI5eRTCBTcePE)

На этом занятии мы с вами отдельно поговорим об операторах преобразования типов, которые были введены в язык C++. Как вы помните, в курсе по языку Си мы уже говорили про операцию приведения типов и часто ей пользовались. Например, с ее помощью можно указателем с типом `char` просмотреть побайтно содержимое любой переменной:

```c++
    int a = 10;
    char * ptr = (char *)&a; // приведение типа int* к char *
```

Однако эта операция не так безобидна, как может показаться на первый взгляд. Например, можно константный указатель сделать обычным, не константным:

```c++
    int a = 10;
    const int* ptr_cnst = &a;
    int * ptr = (int *)ptr_cnst;
```

Или, с типом `char` работать, словно это тип `int`:

```c++
    char a = 10;
    int* ptr_a = (int *)&a;
```

И так далее. Операции преобразования типов легко могут стать причинами трудноуловимых ошибок. Тем более что программисту здесь дается полная свобода действий, без каких-либо особых ограничений со стороны компилятора. И эту анархию решил хоть как-то ограничить разработчик языка C++ Бьерн Страуструп, введя для преобразования типов четыре новых оператора:
+ `const_cast` – снимает или добавляет модификатор `const` (и `volatile`) для текущего типа данных;
+ `reinterpret_cast` – преобразование одного типа в другой, с некоторой дополнительной проверкой со стороны компилятора на возможность указанного действия;
+ `static_cast` – преобразование типов с учетом цепочки наследования классов или структур;
+ `dynamic_cast` – преобразование типов с учетом цепочки наследования классов или структур в процессе выполнения программы (динамически).

Давайте детальнее посмотрим, как они работают и чем отличаются от обычной операции приведения типов, которую по-прежнему можно использовать в языке C++.

<hr>

[Содержание](#содержание)

## Оператор const_cast

Первый оператор `const_cast` просто снимает или добавляет модификатор `const` к текущему типу данных. Работает он следующим образом:

```c++
    int a = 10;
    const int* ptr_a = &a;
    int * ptr = const_cast<int *>(ptr_a); // снятие const
    const int * ptr_cnst = const_cast<const int *>(&a); // добавление const
```

Обратите внимание, как он записан. После его имени обязательно следуют угловые скобки, в которых прописывается тип, к которому приводится указатель, а затем, в круглых скобках идет сам указатель. Результат присваивается другому указателю того же типа.

Ту же самую операцию можно записывать и для ссылок:

```c++
    const double a = 10;
    const double& lnk_a_var = a;
    double& lnk_a = const_cast<double &>(lnk_a_var); // снятие const
    const double& lnk_a_cnst = const_cast<const double &>(lnk_a); // добавление const
```

А вот с обычными переменными функция `const_cast` работать не будет:

```c++
double b = const_cast<double>(a);
```

В качестве аргумента допускается прописывать либо указатель, либо ссылку.

Также, если типы приводимых данных не будут совпадать:

```c++
float& lnk_a = const_cast<double &>(lnk_a_var);
```

то тоже возникнет ошибка на этапе компиляции. То есть, `const_cast` только снимает/добавляет модификатор `const` у ссылок и указателей без изменения их базового типа.

Конечно, у вас может возникнуть вопрос, зачем все же понадобилось вводить этот оператор, если он по-прежнему вносит в программу небезопасное поведение? Наверное, модификатор `const` прописывается не случайно и снимать его не следует? 

Все верно. Именно поэтому нужно избегать использования оператора `const_cast` в тексте программы. Если вдруг он вам по каким-либо причинам потребовался, то лучше пересмотреть структуру программы и понять, почему так произошло. Исправить этот момент без привлечения небезопасного оператора `const_cast`. И только в очень, очень редких случаях его применение оправданно.

<hr>

[Содержание](#содержание)

## Оператор reinterpret_cast

Следующий оператор `reinterpret_cast` очень похож по своему действию на обычную операцию приведения типов языка Си, но работает с некоторыми ограничениями.

Во-первых, он применим все так же к указателям и ссылкам. С обычными переменными работать не будет. Например:

```c++
    int a = 10;
    int b = reinterpret_cast<int>(a); // ok
    char c = reinterpret_cast<char>(a); // ошибка
```

Если изменение типа не происходит, то выполнится обычное присвоение (инициализация) одной переменной другой переменной. Если же указать разные типы, то возникнет ошибка.

Во-вторых, оператор `reinterpret_cast` не может снимать модификаторы `const` и `volatile`. За это, как мы уже знаем, отвечает другой оператор `const_cast` и их действия не пересекаются. Например:

```c++
    int a = 10;
    const int* ptr_a_cnst = &a;
    int* ptr_a = reinterpret_cast<int *>(ptr_a_cnst); // ошибка
```

Во всем остальном он похож на обычную операцию приведения типов языка Си. Преобразование типов между указателями:

```c++
    int a = 10;
    int* ptr_a = &a;
    char* ptr_ch = reinterpret_cast<char *>(ptr_a);
    void* ptr_v = reinterpret_cast<void *>(ptr_a);
    double* ptr_d = reinterpret_cast<double *>(ptr_a);
```

Преобразование типов между ссылками:

```c++
    double b = 0.5;
    double &lnk_b = b;
 
    int& lnk_bi = reinterpret_cast<int&>(lnk_b);
    long double& lnk_bld = reinterpret_cast<long double&>(lnk_b);
```

Также мы можем делать приведение типов и между пользовательскими типами данных. Например, объявим две структуры:

```c++
struct point {
    int x, y;
};
 
struct point3D {
    int x, y, z;
};
```

И, затем:

```c++
    point pt {1, 2};
    point3D* ptr_3d = reinterpret_cast<point3D *>(&pt);
    point& lnk_pt = reinterpret_cast<point &>(*ptr_3d);
```

В языке C++ предпочтение отдается именно таким операторам преобразования типов, а не классической операции языка Си.

На следующем занятии мы продолжим эту тему и рассмотрим две оставшихся операции static_cast и dynamic_cast.

<hr>

[Содержание](#содержание)


# 4.2 Операторы static_cast и dynamic_cast

[Смотреть материал на видео](https://www.youtube.com/watch?v=Idj2DHT1Ti8&list=PLA0M1Bcd0w8ye84Jmv9yaI5eRTCBTcePE)

## Оператор static_cast

Продолжаем тему операторов преобразования типов языка C++ и рассмотрим следующий оператор `static_cast`. Это некий аналог предыдущего оператора `reinterpret_cast`, но с более строгими ограничениями. Лучше всего отличия и возможности `static_cast` показать на конкретных примерах.

Пусть в программе объявлены переменные разных типов и указатели на них:

```c++
int main() {
    char ch {0};
    short sh {0};
    int i {0};
    double d {0};
 
    char* ptr_ch {&ch};
    short* ptr_sh {&sh};
    int* ptr_i {&i};
    double* ptr_d {&d};
 
    ch = static_cast<char>(sh);
    ch = reinterpret_cast<char>(sh); // ошибка
 
    d = static_cast<double>(i);
    d = reinterpret_cast<double>(i); // ошибка
 
    sh = static_cast<short>(ptr_i);  // ошибка 
    sh = reinterpret_cast<short>(ptr_i);
 
    ptr_d = static_cast<double *>(ptr_ch); // ошибка 
    ptr_d = reinterpret_cast<double *>(ptr_ch);
 
    return 0;
}
```

Как видим, оператор `static_cast` может совершенно спокойно выполнять преобразования типов между переменными, в отличие от оператора `reinterpret_cast`. А вот с указателями ситуация несколько иная. Во-первых, мы не можем с помощью `static_cast` приводить указатели к обычной переменной (и наоборот), и, во-вторых, приводить разные несвязанные между собой типы указателей. В отличие от оператора `reinterpret_cast`, который может выполнять подобные действия.

Что значит не связанные между собой типы указателей? Смотрите, если мы в программе объявим две независимые структуры:

```c++
struct point2D {
    int x, y;
};
 
struct point3D {
    int x, y, z;
};
```

То с точки зрения оператора `static_cast` эти типы независимы между собой. И, соответственно, приведение одного к другому будет невозможно:

```c++
int main() {
    point2D* ptr_2d = new point2D {1, 2};
 
    point3D* ptr_3d = static_cast<point3D *>(ptr_2d); // ошибка
    point3D* ptr_3d_2 = reinterpret_cast<point3D *>(ptr_2d);
 
    delete ptr_2d;
    return 0;
}
```

Однако, если прописать наследование одного типа от другого:

```c++
struct point3D : point2D { ... };
```

то ошибки не будет. В этом смысл зависимостей одного типа от другого, который важен для оператора `static_cast` и не важен для оператора `reinterpret_cast`. Даже если цепочка наследования будет более длинной:

```c++
struct point { };
 
struct point2D : point {
    int x, y;
};
 
struct point3D : point2D {
    int x, y, z;
};
```

Оператор `static_cast` по-прежнему будет отслеживать взаимосвязь между типами:

```c++
int main() {
    point* ptr_pt = new point;
 
    point3D* ptr_3d = static_cast<point3D *>(ptr_pt);
    point3D* ptr_3d_2 = reinterpret_cast<point3D *>(ptr_pt);
 
    delete ptr_pt;
    return 0;
}
```

Формально, можем записать и обратное преобразование типов от дочернего класса (структуры) к базовому:

```c++
int main() {
    point3D* ptr_3d = new point3D;
 
    point* ptr_pt = static_cast<point *>(ptr_3d);
    point* ptr_pt_2 = reinterpret_cast<point *>(ptr_3d);
 
    delete ptr_3d;
    return 0;
}
```

Однако в таком преобразовании смысла нет, т.к. компилятор это способен делать автоматически (для связанных типов) без каких-либо дополнительных операций. Поэтому `static_cast` рассматривают именно как оператор обратного приведения типа от базового к дочернему.

<hr>

[Содержание](#содержание)

## Оператор dynamic_cast

Все рассмотренные операторы приведения типов:

`const_cast`, `reinterpret_cast`, `static_cast`

отрабатывают на этапе компиляции программы, а потому относятся к статическим операторам. Последний же оператор `dynamic_cast` выполняет приведение связанных типов указателей или ссылок подобно операции `static_cast`, но делает это в процессе работы программы. Отсюда и пошло его название  `dynamic` (динамический). Давайте посмотрим, зачем понадобился такой оператор и как он работает.

Довольно часто в ООП используется механизм наследования классов с применением виртуальных функций. И давайте представим, что у нас имеется несколько классов для описания товаров магазина:

```c++
class Thing {
public:
    virtual void print() const { }
};
 
class Ball : public Thing {
    int radius;
    int color;
public:
    virtual void print() const override { puts("Ball"); }
    void get_data(int& r, int& c) const { r = radius; c = color; }
};
 
class Mouse : public Thing {
public:
    virtual void print() const override { puts("Mouse"); }
};
```

Здесь объявлен базовый класс `Thing` и производные от него классы `Ball` и `Mouse`. Затем, объявим класс `Cart` (тележка) для выбора покупаемых товаров:

```c++
class Cart {
public:
    void add_thing(const Thing& th)
    {
        th.print();
 
        const Ball* ptr_ball = dynamic_cast<const Ball *>(&th);
 
        if(ptr_ball) {
            int radius, color;
            ptr_ball->get_data(radius, color);
            puts("th is a Ball");
        }
        else
            puts("th is not a Ball");
    }
};
```

Это очень упрощенный класс исключительно для демонстрации работы оператора `dynamic_cast`. В метод `add_thing` передается константная ссылка на добавляемый в тележку товар. Затем, через виртуальный метод `print()` печатается переданный объект. И после этого, допустим, нам необходимо определить: относится ли объект `th` к объекту дочернего класса `Ball`? Так как через параметр можно передать совершенно любой класс, унаследованный от `Thing`, то его принадлежность к классу `Ball` следует определять в момент выполнения программы. На момент компиляции такой определенности мы не имеем. Поэтому следует использовать оператор `dynamic_cast` для динамического приведения типа указателя.

Если переданный объект действительно является объектом класса `Ball`, то указатель `ptr_ball` будет ссылаться на него. Если же это не так, то `dynamic_cast` вернет значение `nullptr` и указатель `ptr_ball` будет принимать это значение. Поэтому дальше можно прописать проверку на значение `nullptr`. И, если указатель не равен ему, то, например, вызвать метод `get_data`, который объявлен именно в классе `Ball` и ни в каком другом.

В функции `main` мы можем воспользоваться этими классами следующим образом:

```c++
int main() {
    Cart cr;
 
    Ball b;
    Mouse m;
 
    cr.add_thing(b);
    cr.add_thing(m);
 
    return 0;
}
```

После запуска программы увидим в консоли строчки:

```
Ball
th is a Ball
Mouse
th is not a Ball
```

Обратите внимание, что оператор `dynamic_cast` работает только с указателями и реже со ссылками. Кроме того, для определения типа того или иного класса `dynamic_cast` использует адрес виртуальной таблицы методов классов. Поэтому он может работать только с классами, содержащими хотя бы один виртуальный метод.

Вообще, на практике лучше воздерживаться от применения оператора `dynamic_cast`, по крайней мере, по двум причинам. Во-первых, само приведение базового типа к дочернему – это сомнительная практика и, скорее всего, свидетельство неверно спроектированной архитектуры программы. И, во-вторых, оператор `dynamic_cast` использует механизм `RTTI` (`Run-Time Type Identification`), который позволяет идентифицировать тип объекта в процессе выполнения программы. Из-за этого скорость работы оператора `dynamic_cast` заметно снижается и его лучше не использовать при реализации высокоскоростных алгоритмов.

<hr>

[Содержание](#содержание)

## Операторы static_cast и dynamic_cast с указателями shared_ptr

В заключение этого занятия отмечу возможность применения операторов `static_cast` и `dynamic_cast` со смарт-указателями типа `shared_ptr`. Для этого используются следующие специальные функции:

```c++
#include <iostream>
#include <memory>
 
int main() {
    std::shared_ptr<Thing> th{std::make_shared<Thing>()};
 
    std::shared_ptr<Ball> d_bl{std::dynamic_pointer_cast<Ball>(th)};
    std::shared_ptr<Ball> s_bl{std::static_pointer_cast<Ball>(th)};
 
    if(d_bl)
        puts("Ball");
    else
        puts("Not Ball");
 
    return 0;
}
```

Во всем остальном их работа идентична.

<hr>

[Содержание](#содержание)

# 4.3 Обработка исключений. Введение

[Смотреть материал на видео](https://www.youtube.com/watch?v=D0HO1af1kQo&list=PLA0M1Bcd0w8ye84Jmv9yaI5eRTCBTcePE)

Язык C++ имеет встроенный инструмент для обработки ошибок во время выполнения программы. Он получил название «обработка исключений». Хотя это и не относится напрямую к ООП, тем не менее, в сочетании с классами он становится особенно красивым и гибким в реализации.

Первый закономерный вопрос, зачем вообще понадобился такой отдельный инструмент для обработки ошибок? Смотрите, выполнение прикладной программы начинается с функции `main`. Она, в свою очередь, как правило, вызывает другие функции. А те еще одни. И глубина вызовов может быть довольно большой.

![04](/OOP_C_C++/img/04_01.jpg)

Предположим теперь, что на каком-либо уровне вызова возникла ошибочная ситуация. Например, деление на ноль, или не найден файл, или ошибка связи с сервером, и так далее. Мало зафиксировать ошибку, нужно еще указать программе, как ей выполняться дальше. И вот здесь кроется главная проблема. Часто отдельные функции лишь выполняют свои локальные задачи, фиксируя возможные ошибки. Однако не всегда имеют возможность сразу же их обработать, то есть, «сказать» программе, что нужно сделать, при их возникновении. Например, не найден указанный файл, или недостаточно прав для записи в него данных. Что в этом случае должна сделать вспомогательная функция? Часто ответ можно дать лишь на уровне общей логики программы, то есть, на уровне функции `main` или специально предназначенных для этого функциях. То есть, возникшую ошибку нужно передать обратно по стеку вызова функций, пока не дойдем до такой, которая в состоянии ее обработать. При этом выполнение других функций должно быть прекращено.

Это довольно типовая ситуация и до появления механизма обработки исключений решалась либо возвратом специального значения из функции, либо через специальные глобальные переменные, либо каким-то еще изощренным способом. Дополнительные сложности здесь представляют вызовы методов через объекты классов. Каждый объект и класс – это отдельная и независимая программная единица и вопрос обработки возникающих ошибок здесь особенно актуален. Поэтому и понадобился отдельный механизм обработки исключений, который бы брал на себя реализацию логики выполнения программы при той или иной непредвиденной ситуации.

![04](/OOP_C_C++/img/04_02.jpg)

Лично у меня этот инструмент ассоциируется с канализацией. Если в доме ее нет, то сами представляете, с какими трудностями столкнутся жильцы. А если она уже встроена, то достаточно к ней подключиться и жизнь дома и города в целом преобразится в лучшую сторону. Обработка исключений подобным образом освобождает нас от многих сложностей, которые бы иначе пришлось реализовывать вручную, как это было на заре эры программирования.

<hr>

[Содержание](#содержание)

## Оператор `throw`

Давайте теперь посмотрим, как можно воспользоваться обработкой исключений непосредственно в программе на языке C++.

Предположим, у нас имеется некоторая функция, которой передаются длины сторон треугольника и она возвращает его периметр:

```c++
int perimetr_tr(int a, int b, int c) {
    if(a < 0 || b < 0 || c < 0 || a > b+c || b > a+c || c > a+b)
        return ???;
 
    return a+b+c;
}
```

Особенность этой функции в том, что она дополнительно проверяет корректность переданных длин сторон. И здесь нужно решить, что возвращать, если параметры a, b, c не образуют стороны треугольника. Например, можно вернуть значение -1, т.к. периметр не может быть отрицательным значением и это хороший сигнал для ошибки. Однако в практике программирования не всегда удается так легко и просто определиться с ошибочным возвращаемым значением. Например, если взять известную из языка Си функцию `atoi`:

```c++
int res = atoi("a123");
```

то она возвращает `0` при ошибке конвертации строки в число. Очевидно, это не лучшее решение, т.к. строка может содержать число `0`:

```c++
int res = atoi("0");
```

и как тогда понять, где `0` означает ошибку, а где – корректное преобразование? Если бы подобные функции проектировались с возможностью генерации исключений, то такой проблемы бы не возникало. И мы, в качестве примера, в нашей функции `perimetr_tr`, как раз так и поступим.

Итак, вместо возвращения числа `-1` при ошибочных длинах сторон треугольника, мы сгенерируем исключение. Делается это с помощью оператора `throw` (англ. – бросить), после которого можно прописать практически любой тип данных, например, так:

```c++
int perimetr_tr(int a, int b, int c) {
    if(a < 0 || b < 0 || c < 0 || a > b + c || b > a + c || c > a + b)
        throw "Error: a, b, c are not triangle lengths";
 
    return a + b + c;
}
```

Если теперь в функции main вызвать функцию `perimetr_tr` с неверными длинами:

```c++
int main() {
    int p = perimetr_tr(5, 1, 2);
 
    return 0;
}
```
то в консоли увидим сообщение:

```
terminate called after throwing an instance of 'char const*'
```

Что оно означает и откуда взялось? Смотрите, при возникновении (генерировании) исключения с помощью оператора `throw`, функция `perimetr_tr` завершает свою работу и управление передается вышестоящей функции `main`. Функция `main` никак не реагирует на это исключение (то есть, не обрабатывает его), поэтому вызывается функция:

```c++
std::terminate()
```

из модуля `<exception>` стандартной библиотеки C++ с выводом соответствующего сообщения в выходной поток. После этого функция `std::terminate` вызывает функцию:

```c++
std::abort()
```

для экстренного (аварийного) завершения всей программы.

<hr>

[Содержание](#содержание)

## Операторы `try`/`catch`

Конечно, мы бы хотели избежать аварийного завершения программы, а значит, должны перехватить и обработать возникшее исключение. Как это сделать? Для этого в языке C++ появились два оператора: `try` и `catch`. Оператор `try` определяет программный блок, в котором возможно возникновение исключений, а оператор `catch` описывает тип отлавливаемого исключения и способ его обработки. Например, для нашей функции `perimetr_tr` обработка исключений может быть записана так:

```c++
int main() {
    try {
        int p = perimetr_tr(5, 1, 2);
    }
    catch(const char* e) {
        std::cout << e << std::endl;
    }
    return 0;
}
```

Обратите внимание, сначала обязательно должен быть записан блок `try`, а после него один или несколько блоков `catch` для обработки разных типов исключений. Сейчас мы отлавливаем только один тип – строковый литерал, представленный в виде константного указателя типа `char`. А обработка заключается в выводе перехваченного сообщения в консоль. Если теперь запустить программу, то увидим строку:

```
Error: a, b, c are not triangle lengths
```

Если же все длины сторон будут корректны:

```c++
        int p = perimetr_tr(2, 1, 2);
```

то блок `catch` не сработает и в консоль ничего выводиться не будет.

То есть, в блоке `try` прописывается критический программный код, который может генерировать различные ошибки (исключения). Следом за ним прописываются блоки `catch` (от одного и более) для обработки возникающих исключений, если они появляются.

Давайте для примера в функции `perimetr_tr` будем генерировать два разных типа исключений следующим образом:

```c++
int perimetr_tr(int a, int b, int c) {
    if(a < 0 || b < 0 || c < 0)
        throw -1;
 
    if(a > b + c || b > a + c || c > a + b)
        throw "Error: a, b, c are not triangle lengths";
 
    return a + b + c;
}
```

Если сейчас вызвать функцию с отрицательными длинами:

```c++
    try {
        int p = perimetr_tr(-5, 1, 2);
    }
    catch(const char* e) {
        std::cout << e << std::endl;
    }
```

то блок `catch` не поймает исключение типа `int` и в консоли появится строка:

```
terminate called after throwing an instance of 'int'
```

Чтобы это исправить, добавим еще один блок `catch`:

```c++
    try {
        int p = perimetr_tr(-5, 1, 2);
    }
    catch(const char* e) {
        std::cout << e << std::endl;
    }
    catch(int) {
        std::cout << "Lengths must be positive digitals." << std::endl;
    }
```

Обратите внимание, что после `catch` указан просто тип `int` без какой-либо переменной, т.к. она нам в данном случае не нужна.

В итоге отработает второй блок `catch`, а первый будет проигнорирован. Причем блоки просматриваются в порядке их записи: сначала для строки, а затем, для целого типа `int`. Сработать может только один из них (или ни одного). Как только какой-либо блок `catch` отрабатывает, все последующие блоки игнорируются (пропускаются). Если исключение не было поймано ни одним из блоков, то оно пробрасывается дальше по стеку вызова функций.

В качестве демонстрации этого механизма пропишем прямо в функции `perimetr_tr` обработку исключения типа `int` следующим образом:

```c++
int perimetr_tr(int a, int b, int c) {
    try {
        if(a < 0 || b < 0 || c < 0)
            throw -1;
    }
    catch(int x) {
        std::cout << x << std::endl;
        return x;
    }
 
    if(a > b + c || b > a + c || c > a + b)
        throw "Error: a, b, c are not triangle lengths";
 
    return a + b + c;
}
```

Здесь при отрицательных сторонах треугольника формируется целочисленное исключение со значением `-1` и сразу же отлавливается в блоке `catch`. В самом блоке идет вывод в консоль значения `-1` и завершение функции с помощью оператора `return`. Если этого не сделать, то программа продолжилась бы, и по условию сгенерировалось бы следующее исключение.

После запуска увидим в консоли значение `-1`. То есть, возникшее исключение типа `int` было обработано в функции `perimetr_tr` и дальше (в функцию `main`) уже не распространялось. Это очень удобно. Исключения можно обрабатывать на разных уровнях выполнения программы, там, где это возможно и необходимо. Ну а самые высокоуровневые ошибки могут отправляться по цепочке вызовов вплоть до функции `main`.

Интересно, что вместо оператора `return` в блоке `catch` можно прописать оператор `throw` без параметров, который бы пробрасывал исключение дольше после некоторой обработки:

```c++
int perimetr_tr(int a, int b, int c) {
    try {
        if(a < 0 || b < 0 || c < 0)
            throw -1;
    }
    catch(int x) {
        std::cout << x << std::endl;
        throw;
    }
 
    if(a > b+c || b > a+c || c > a+b)
        throw "Error: a, b, c are not triangle lengths";
 
    return a+b+c;
}
```

В этом случае сработают два блока `catch`: один на уровне функции `perimetr_tr`, а второй – на уровне функции `main`. Этот прием используют на практике, если нужно выполнить промежуточную обработку исключения и пробросить его дальше. Например, пусть имеется функция, которая читает целочисленное значение из файла:

```c++
void load_data(const char* path, int& x) {
    std::ifstream ifs;
    ifs.exceptions( std::ios::failbit ); // для включения генерации исключений
 
    try {
        ifs.open(path);
        ifs >> x;
        ifs.close();
    }
    catch(...) {
        ifs.close();
        throw;
    }
}
```

Обратите внимание, что блок `catch` записан с многоточием. Это допустимый синтаксис, который означает отлавливать любые типы исключений. В данном случае нам не важно, что произойдет, главное, закрыть файловый поток, а потом, бросить исключение дальше по стеку вызова функций.

Если в функции `main` прописать:

```c++
int main() {
    int data {0};
 
    try {
        load_data("123", data);
        std::cout << data << std::endl;
    }
    catch(const std::exception & ex) {
        std::cout << "Error read data from file." << std::endl;
    }
 
    return 0;
}
```

то при отсутствии файла `123` будет сгенерировано исключение в виде объекта класса `std::exception` и в блоке `catch` в консоль будет выведена строка.

<hr>

[Содержание](#содержание)

# 4.4 Объект исключения. Вложенные блоки try/catch

[Смотреть материал на видео](https://www.youtube.com/watch?v=gztov3w7eb8&list=PLA0M1Bcd0w8ye84Jmv9yaI5eRTCBTcePE)

Давайте теперь внимательнее посмотрим на объект исключения. В последнем случае он был передан по ссылке:

```c++
catch(const std::exception & ex) …
```

Но абсолютно тот же самый результат будет, если передавать его по значению:

```c++
catch(const std::exception ex) …
```

В чем отличие между этими двумя вариантами? Начнем с самого начала – с момента зарождения этого объекта. Где это происходит? В нашем примере – в функции `load_data`. Давайте сделаем это явным образом. Для этого мы объявим свой класс в качестве типа исключения:

```c++
class Exception {
public:
    static int count_create;
    static int count_delete;
 
    Exception() { count_create++; }
    Exception(const Exception& ) { count_create++; }
    ~Exception() { count_delete++; }
};

 
int Exception::count_create {0};
int Exception::count_delete {0};
```

Этот класс содержит статические поля:
+ `count_create` – число созданий объектов класса;
+ `count_delete` – число удалений объектов класса.

А также конструктор по умолчанию и конструктор копирования, которые увеличивают счетчик переменной `count_create`. И деструктор, который увеличивает счетчик `count_delete`.

Функцию `load_data` и функцию `main` запишем в виде:

```c++
void load_data(const char* path, int& x) {
    std::ifstream ifs;
 
    try {
        ifs.open(path);
        if(!ifs.is_open()) {
            throw Exception();
        }
 
        ifs >> x;
        ifs.close();
    }
    catch(const Exception e) {
        ifs.close();
        throw e;
    }
}
 
int main()
{
    int data {0};
 
    try {
        load_data("123", data);
        std::cout << data << std::endl;
    }
    catch(const Exception ex) {
        std::cout << Exception::count_create << std::endl;
        std::cout << Exception::count_delete << std::endl;
    }
 
    return 0;
}
```

После запуска программы в консоли увидим числа: `4` – для создания объектов; `2` – для удаления объектов. Давайте разберем порядок работы этой программы.

Очевидно, первый объект класса `Exception` был создан в функции `load_data` при вызове оператора `throw`. Затем, этот же объект передается в блок `catch`, который отслеживает этот тип исключения. Но в этом блоке дополнительно создается еще один объект (копия) класса `Exception`. Внутри тела блока срабатывает еще один оператор `throw`, который пробрасывает исключение дальше по стеку вызова функций. При этом оператор `throw` создает копию еще одного объекта класса `Exception`. При завершении выполнения конструкции `try`/`catch` первые два объекта удаляются. А в функции `main` блоком `catch` отлавливается последний созданный объект класса `Exception` и дополнительно создается еще один. Отсюда и получаются такие величины: `4` – для создания объектов; `2` – для удаления объектов. Последние два объекта будут удалены при выходе из блока `try`/`catch` функции `main`. Если после него прописать строчки:

```c++
    std::cout << Exception::count_create << std::endl;
    std::cout << Exception::count_delete << std::endl;
```

то увидим числа `4` и `4`.

Вот такой круговорот объектов исключений происходит при их генерации и обработки. Также этот пример показывает, что классы исключений практически всегда должны иметь конструктор копирования, иначе в ряде распространенных случаев объект исключения не может создан. И здесь возникает закономерный вопрос, можно ли сократить количество создаваемых копий этих объектов? Да, и самый очевидный шаг, как раз использовать ссылки в блоках `catch`:

```c++
catch(const Exception& ex) …
```

Теперь создаются только два объекта. Но и это число можно сократить, если в функции `load_data` в блоке `catch` сделать проброс исключения без создания его копии:

```c++
void load_data(const char* path, int& x) {
...
    catch(const Exception& e) {
        ifs.close();
        throw;
    }
}
```

Именно поэтому для ускорения работы программы исключения в блоках `catch` следует получать по ссылке, а пробрасывать пустым оператором `throw`.

<hr>

[Содержание](#содержание)

## Удаление объектов при генерации исключений

Как я уже отмечал, в момент возникновения исключения в функции дальнейшее ее выполнение прекращается и управление передается функции уровнем выше. Она так же должна либо обработать исключение, либо будет завершена с передачей управления следующей функции. И так, пока не дойдем до функции `main`. Если и в ней нет обработки возникшего исключения, то программа завершается аварийно. Так вот, при завершении каждой функции (в момент возникновения исключения), для всех ее объектов, которые были созданы в стековом фрейме, автоматически вызываются деструкторы. Давайте я покажу это на следующем примере.

Объявим еще один простой класс с именем `FileTry`:

```c++
class FileTry {
    std::ifstream& ifs;
public:
    FileTry(std::ifstream& ifs) : ifs(ifs)
        { }
    ~FileTry()
    {
        std::cout << "FileTry: destructor" << std::endl;
 
        if(ifs.is_open()) {
            ifs.close();
            std::cout << "Close file" << std::endl;
        }
    }
};
```

Здесь есть один конструктор и один деструктор. В конструкторе инициализируется ссылка на файловый поток, а в деструкторе он закрывается с выводом сообщений в консоль, чтобы мы видели, как он отрабатывает. С использованием этого класса функцию `load_data` можно переписать в следующем виде:

```c++
void load_data(const char* path, int& x)
{
    std::ifstream ifs;
 
    try {
        FileTry file(ifs);
        
        ifs.open(path);
        if(!ifs.is_open()) {
            throw Exception();
        }
 
        ifs >> x;
    }
    catch(const Exception& e) {
        throw;
    }
}
```

Смотрите, мы здесь создаем объект класса `FileTry` в стековом фрейме текущей функции. Деструктор объекта этого класса будет гарантированно вызван либо при возникновении исключения, либо при штатном завершении блока `try`/`catch`. После запуска программы увидим строчку:

```
FileTry: destructor
```

Исключение возникло, но деструктор объекта был вызван. И это всегда так для любых объектов классов в стековом фрейме. Конечно, если объект создается в куче с помощью оператора `new`:

```c++
FileTry* file = new FileTry(ifs);
```

то деструктор уже не вызывается. И это логично, т.к. при таком создании программист самостоятельно должен его удалять. Автоматически уничтожаются только локальные объекты.

Вернем запись, как было и вынесем ее за пределы блока `try`:

```c++
void load_data(const char* path, int& x) {
    std::ifstream ifs;
    FileTry file(ifs);
 
    try {
    ...
    }
    ...
}
```

В этом случае деструктор тоже отработает для объекта `file`. То есть, не важно где был создан объект в теле функции, для любого из них автоматически вызывается деструктор при возникновении исключения.

Если же исключение не генерируется, то, очевидно, объект удаляется после завершения функции. Или, если он расположен в блоке `try`, то после его завершения. Таким образом, гарантируется штатное завершение работы функций при возникновении исключений.

<hr>

[Содержание](#содержание)

## Вложенные блоки try/catch

Внутри блока `try` можно записывать любые конструкции языка C++, в том числе и другие, вложенные блоки `try`. На практике это встречается крайне редко, но тем не менее, в учебных целях я покажу на простом примере порядок работы таких вложенных блоков.

Вернемся к функции вычисления периметра треугольника, которая генерирует два типа исключений:

```c++
int perimetr_tr(int a, int b, int c) {
    try {
        if(a < 0 || b < 0 || c < 0)
            throw -1;
    }
    catch(int x) {
        std::cout << x << std::endl;
        throw;
    }
 
    if(a > b+c || b > a+c || c > a+b)
        throw "Error: a, b, c are not triangle lengths";
 
    return a+b+c;
}
```

А в функции `main` выполним обработку этих исключений следующим образом:

```c++
int main() {
    try {
        try {
            int res = perimetr_tr(5, 3, 1);
        }
        catch(int e) {
            std::cout << e << std::endl;
        }
    }
    catch(const char* e) {
        std::cout << e << std::endl;
    }
 
    return 0;
}
```

Работает все достаточно просто. Сначала для возникшего исключения ищется подходящий блок `catch` во вложенном операторе `try`/`catch`. Если он находится, то ошибка считается обработанной и выше к внешнему блоку она не распространяется. Если же нужного блока `catch` не найдено, то исключение передается во внешний блок, где оно так же может быть обработано своими блоками `catch`. В нашем примере функция `perimetr_tr` генерирует исключение типа `const char*` и оно обрабатывается внешним блоком. Если же во внутреннем блоке добавить обработчик того же типа, например, так:

```c++
int main() {
    try {
        try {
            int res = perimetr_tr(5, 3, 1);
        }
        catch(int e) {
            std::cout << e << std::endl;
        }
        catch(const char* e) {
            std::cout << "Inner: " << e << std::endl;
        }
    }
    catch(const char* e) {
        std::cout << e << std::endl;
    }
 
    return 0;
}
```

То будет отработан именно он и до внешнего блока исключение уже не дойдет. Во всем остальном эта конструкция работает по аналогии с обычным одиночным блоком `try`/`catch`.

<hr>

[Содержание](#содержание)

# 4.5 Правила идентификации типов исключений. Пользовательские классы исключений

[Смотреть материал на видео](https://www.youtube.com/watch?v=nK4hJOsZWkk&list=PLA0M1Bcd0w8ye84Jmv9yaI5eRTCBTcePE)

Продолжаем тему обработки исключений и вначале подробнее рассмотрим, как происходит идентификация типов исключений в блоках `catch`. Пусть для примера у нас имеется следующий класс для работы с банковскими картами:

```c++
class BankCard {
    const int length_number {19};
    std::string number; // 1234-5678-1234-5678
 
    void verify_correct(const std::string& card) const
    {
        if(card.length() != length_number)
            throw length_number;
 
        const char* p = card.c_str();
        for(int i = 0;i < length_number; ++i) {
            if(i == 4 || i == 9 || i == 14) {
                if(p[i] != '-')
                    throw "incorrect format";
            }
            else if(p[i] < '0' || p[i] > '9')
                throw "only numbers are allowed";
        }
    }
 
public:
    void set_number(const std::string& card)
    {
        verify_correct(card);
        number = card;
    }
 
    const std::string& get_number() const { return number; }
};
```

Здесь приватное поле `number` является строкой и хранит текущий номер карты. Приватный метод `verify_correct` выполняет проверку корректности формата номера и если что-то записано не верно, то генерирует различные исключения. Два публичных метода `set_number` и `get_number` служат для сохранения и чтения номера банковской карты.

Воспользуемся этим классом в функции `main` следующим образом:

```c++
int main() {
    BankCard card;
 
    try {
        card.set_number("123-4567-1234-5678");
    }
    catch(int e) {
        std::cout << e << std::endl;
    }
    catch(const char* e) {
        std::cout << e << std::endl;
    }
 
    return 0;
}
```

В блоке `try` выполняется критический код (который может сгенерировать исключение) при записи номера карты. И два блока `catch` для отслеживания исключений типа `int` и `const char*`.

Если сейчас запустить программу, то сработает первый блок `catch` и в консоли отобразится целое число `19`. Однако тот же самый тип исключения можно отловить, если прописать следующие варианты:

```c++
catch(const int e) ...
catch(const int& e) ...
catch(int& e) ...
```

Правило здесь такое. Любой тип `T` или `const T` можно идентифицировать по самому типу `T`, или константному типу `const T` или по ссылке на один из этих типов: `T&` или `const T&`. Причем, сам тип `T` здесь имеет первостепенное значение, если, например, вместо типа `int` сгенерировать такое же целое число типа `long`:

```c++
throw (long)length_number;
```

то ни один из обработчиков его уже не поймает. Никаких неявных приведений типов здесь не выполняется и программист должен четко указывать тип исключения. (Из этого правила есть только одно исключение, касающееся наследуемых типов, но об этом позже.)

Однако если пробрасывается не сам объект, а указатель на него, то константный указатель можно идентифицировать только константным указателем, обычный не сработает. Например, если вместо `const char*` записать просто `char*`:

```c++
catch(char* e)
```

то этот блок пропустит исключение типа `const char*`. Однако, если бросить исключение типа `char*`:

```c++
throw (char *)"only numbers are allowed";
```

то оно будет поймано этим блоком или, если вернуть `const`:

```c++
catch(const char* e)
```

то и таким.

В результате, мы получаем следующие правила идентификации типов исключений:

Тип в throw | Идентифицируемый тип в catch
-|-
T; const T | T; const T; T&; const T&
T* | T*; const T*
const T* | const T*

<hr>

[Содержание](#содержание)

## Использование собственных классов (типов) исключений

В практике программирования при использовании механизма исключений очень часто (практически всегда) в качестве типов фигурируют имена поставляемых или пользовательских классов. Давайте посмотрим на нашем примере, как это реализуется и какие особенности здесь возникают.

Вначале объявим следующие классы для описания пользовательских типов исключений при работе с банковскими картами:

```c++
class CardError {
    std::string msg;
public:
    CardError(const char* error) : msg(error)
        { }
    CardError(const CardError& other) : msg(other.msg)
        { }
    const char * what() const noexcept { return msg.c_str(); }
};
 
class CardLengthError : public CardError {
public:
    CardLengthError(const char* error) : CardError(error)
        { }
};
 
class CardFormatError : public CardError {
public:
    CardFormatError(const char* error) : CardError(error)
        { }
};
 
class CardNumberError : public CardError {
public:
    CardNumberError(const char* error) : CardError(error)
        { }
};
```

Ключевое слово `noexcept` используется, чтобы подчеркнуть факт отсутствия генерации каких-либо исключений методом `what`.

Пропишем классы в методе `verify_correct` для генерации соответствующих исключений:

```c++
class BankCard {
    const int length_number {19};
    std::string number; // 1234-5678-1234-5678
 
    void verify_correct(const std::string& card) const
    {
        if(card.length() != length_number)
            throw CardLengthError("incorrect length card number");
 
        const char* p = card.c_str();
        for(int i = 0;i < length_number; ++i) {
            if(i == 4 || i == 9 || i == 14) {
                if(p[i] != '-')
                    throw CardFormatError("incorrect format");
            }
            else if(p[i] < '0' || p[i] > '9')
                throw CardNumberError("only numbers are allowed");
        }
    }
...
};
```

Теперь, как вы уже догадались, в функции `main` для определения того или иного типа исключения нам нужно использовать эти новые классы, например, следующим образом:

```c++
int main() {
    BankCard card;
 
    try {
        card.set_number("123a-4567-1234-5678");
    }
    catch(CardLengthError& e) {
        std::cout << e.what() << std::endl;
    }
    catch(CardFormatError& e) {
        std::cout << e.what() << std::endl;
    }
    catch(CardNumberError& e) {
        std::cout << e.what() << std::endl;
    }
 
    return 0;
}
```

Видите, насколько более понятным становится текст программы? Мало того, вместо одного типа исключения `const char*` у нас появляется два независимых: `CardFormatError` и `CardNumberError`. И количество этих типов может быть любым, столько, сколько нужно для корректного описания всевозможных ошибочных ситуаций.

А теперь одна из ключевых особенностей использования классов в блоках `catch`. Благодаря наследованию всех классов от базового класса `CardError`, мы можем все эти типы идентифицировать им одним, если прописать:

```c++
int main() {
    BankCard card;
 
    try {
        card.set_number("123a-4567-1234-5678");
    }
    catch(CardError& e) {
        std::cout << "CardError: " << e.what() << std::endl;
    }
    catch(CardLengthError& e) {
        std::cout << e.what() << std::endl;
    }
    catch(CardFormatError& e) {
        std::cout << e.what() << std::endl;
    }
    catch(CardNumberError& e) {
        std::cout << e.what() << std::endl;
    }
 
    return 0;
}
```

Теперь любое исключение типов `CardLengthError`, `CardFormatError` и `CardNumberError` будет отлавливаться первым блоком `catch`, а остальные игнорироваться. Конечно, это не то, что нам нужно, поэтому тип с базовыми классами прописывают в самом конце:

```c++
int main() {
    BankCard card;
 
    try {
        card.set_number("123a-4567-1234-5678");
    }
    catch(CardLengthError& e) {
        std::cout << e.what() << std::endl;
    }
    catch(CardFormatError& e) {
        std::cout << e.what() << std::endl;
    }
    catch(CardNumberError& e) {
        std::cout << e.what() << std::endl;
    }
    catch(CardError& e) {
        std::cout << "CardError: " << e.what() << std::endl;
    }
 
    return 0;
}
```

Обратите внимание, что при использовании собственных классов исключений их объекты рекомендуется передавать по ссылке, чтобы избежать лишнего не нужного копирования объектов классов. Также рекомендуется эти ссылки обозначать константными, так как объекты классов исключений практически никогда не меняются:

```c++
int main() {
    BankCard card;
 
    try {
        card.set_number("123a-4567-1234-5678");
    }
    catch(const CardLengthError& e) {
        std::cout << e.what() << std::endl;
    }
    catch(const CardFormatError& e) {
        std::cout << e.what() << std::endl;
    }
    catch(const CardNumberError& e) {
        std::cout << e.what() << std::endl;
    }
    catch(const CardError& e) {
        std::cout << "CardError: " << e.what() << std::endl;
    }
 
    return 0;
}
```

Такое определение типов исключений с использованием классов будет наиболее корректным.

<hr>

[Содержание](#содержание)

## Базовый класс исключений std::exception

И самый последний штрих, который здесь следует сделать – это унаследовать класс `CardError` от стандартного класса `std::exception`, который в языке C++ принято использовать, как базовый для всех остальных классов исключений:

```c++
class CardError : public std::exception {
    std::string msg;
public:
    CardError(const char* error) : msg(error)
        { }
    const char * what() const noexcept override { return msg.data(); }
};
```

Если посмотреть на содержимое класса `std::exception`, то в упрощенном виде его можно представить следующим образом:

```c++
namespace std
{
    class exception
    {
    public:
        exception() noexcept;
        exception(const exception&) noexcept;
        exception& operator=(const exception&) noexcept;
        virtual ~exception(); // Destructor
        virtual const char* what() const noexcept; // возвращает сообщение об исключении
    };
}
```

Видим, что здесь имеются все необходимые конструкторы и деструкторы, операция присваивания копированием и специальный виртуальный метод `what`, который принято использовать для отображения возникшей ошибки. Именно поэтому в нашем классе `CardError` имеется переопределение этого метода. Теперь, благодаря такой цепочке наследования, для отлавливания произвольных исключений в самом конце можно записать блок `catch` с типом `std::exception`:

```c++
int main() {
    BankCard card;
 
    try {
        card.set_number("123a-4567-1234-5678");
    }
    catch(const CardLengthError& e) {
        std::cout << e.what() << std::endl;
    }
    catch(const CardFormatError& e) {
        std::cout << e.what() << std::endl;
    }
    catch(const CardNumberError& e) {
        std::cout << e.what() << std::endl;
    }
    catch(const CardError& e) {
        std::cout << "CardError: " << e.what() << std::endl;
    }
    catch(const std::exception& e) {
        std::cout << e.what() << std::endl;
    }
 
    return 0;
}
```

<hr>

[Содержание](#содержание)

## Заключение

Итак, на этом занятии мы с вами познакомились с порядком (правилами) идентификации различных типов исключений, которые можно представить следующей таблицей:

Тип в throw | Идентифицируемый тип в catch
-|-
T; const T | T; const T; T&; const T&
T* | T*; const T*
const T* | const T*
При наследовании B : A (A – базовый класс или структура; B – дочерний)
A; const A | A; const A; A&; const A&
B; const B  | B; const B; B&; const B&;<br>A& const A&
A* | A*; const A*
const A* | const A*
B* | B*; const B*; A*; const A*
const B* | const B*; const A*

<hr>

[Содержание](#содержание)

# 4.6 Введение в шаблоны функций

[Смотреть материал на видео](https://www.youtube.com/watch?v=XzpkiD53sZ8&list=PLA0M1Bcd0w8ye84Jmv9yaI5eRTCBTcePE)

Начиная с этого занятия, затронем еще одну важную тему – обобщенное программирование на C++ или просто шаблоны (`templates`). Если рассматривать их во всех деталях, то этому можно посвятить целый, отдельный курс. Однако реальное практическое применение шаблонов часто сводится к использованию их основных конструкций. Именно с ними мы с вами и познакомимся. Если же впоследствии потребуется углубиться в эту тему, то базовый задел у вас уже будет.

Итак, что же такое шаблоны, для чего они были придуманы и как реализуются в языке C++? 

Начнем с самого простого – шаблона функций, а затем перейдем к шаблонам классов. Как мы уже знаем, язык C/C++ имеет строгую типизацию, то есть, при объявлении переменных, параметров функций и методов нужно явно прописывать те или иные типы. Например, нам понадобилась функция вычисления площади прямоугольника. Сразу возникает вопрос, какие типы переменных использовать при ее объявлении? Особенно он актуален, если дальнейшее применение функции предполагается в самых разных проектах и при разных исходных данных. В этом случае, зачастую, объявляют перегруженные функции следующим образом:

```c++
int sq_rect(int a, int b) {
    return a * b;
}
 
double sq_rect(double a, double b) {
    return a * b;
}
```

Но при таком подходе получаем один существенный недостаток – дублирование текста программы (реализации таких функций, как правило, очень схожи). Конечно, функция `sq_rect` очень проста и особых проблем с ней не возникло бы. Но, представьте, что мы написали свой непростой алгоритм сортировки данных и его нужно распространить на произвольные типы. Тогда отладка и изменение алгоритма в нескольких перегруженных функциях превратилась бы в сущий мрак для программиста. Поэтому и был предложен инструмент, который бы решал эту задачу, а именно, позволял бы объявлять функции и классы на более высоком, общем уровне, не привязываясь к конкретным типам данных.

Как же в языке C++ возможно объявление функций без привязки к определенным типам? На самом деле используется один очевидный и хитрый ход: на уровне текста программы функция описывается с типами, заданными, как параметры. Применительно к функции `sq_rect`, это можно записать следующим образом:

```c++
template <typename T>
T sq_rect(T a, T b) {
    return a * b;
}
```

Здесь `template` – ключевое слово, говорящее компилятору, что дальше будет идти объявление шаблона функции (или класса) с некоторым типом `T`. Ключевое слово `typename` в угловых скобках определяет параметр типа. Буква `T` – идентификатор параметра. В общем случае, вместо `T` можно прописать любое другое допустимое имя, так же, как и имя переменной. Но принято использовать заглавные буквы и дополнительно еще цифры, если это необходимо.

Итак, `T` – это параметр типа, который, на момент описания шаблона функции, не связан ни с каким конкретным типом данных. Далее, мы используем этот идентификатор, объявляя через него параметры функции и возвращаемый тип. В теле функции прописывается операция умножения переменных `a` и `b` этого параметаризованного типа данных.

<hr>

[Содержание](#содержание)

## Инстанцирование шаблона. Вызов шаблонных функций

Так как тип `T` на момент описания шаблона функции не определен, то компилятор не может перевести ее в машинный код. Чтобы это стало возможным, функцию `sq_rect` необходимо вызвать, например, так:

```c++
int main() {
    int res_1 = sq_rect(1, 2);          // T = int
    double res_2 = sq_rect(3.5, 8.9);   // T = double
    short res_3 = sq_rect(5, 4);        // T = int
    double res_4 = sq_rect(4.2f, 3.2f); // T = float
 
    int x {5}, int y{7};
    int res_5 = *sq_rect(&x, &y);     // T = int *
 
    return 0;
}
```

В зависимости от типа переданных аргументов, параметр `T` в шаблоне функции `sq_rect` принимает соответствующий тип. При этом компилятор на основе этого шаблона формирует код функции с этим определенным типом. В результате получаем реализации перегруженных функций с типами `int`, `double` и `float`. Этот процесс получил название инстанцирование шаблона.

![04](/OOP_C_C++/img/04_03.jpg)

То есть, пока шаблон не используется, он не преобразуется в машинный код. Это некая абстракция на уровне текста программы языка C++ и не более того. Благодаря этому появляется возможность описывать типы на уровне параметров и таким образом объявлять шаблоны.

При необходимости, мы можем явно прописывать тип для параметра `T` в момент вызова функции:

```c++
    short res_3 = sq_rect<short>(5, 4);    // T = short
    double res_4 = sq_rect<float>(4, 3);   // T = float
```

В этом случае автоматическое вычисление типа компилятором отключается и функция формируется с указанным в угловых скобках типом (или типами, если их несколько).

Преимущество такого подхода может быть в том, что если через аргументы в шаблонную функцию передаются разные типы:

```c++
    int res_1 = sq_rect(5, 2.5);
```

то возникает неопределенность, какого типа должен быть параметр `T`. Компилятор в этом случае генерирует ошибку. Но, если в угловых скобках будет явно прописан желаемый тип:

```c++
    int res_1 = sq_rect<double>(5, 2.5);
```

то все аргументы будут неявно приводиться к нему и ошибки никакой не будет (конечно, если аргументы можно привести к указанному типу).

<hr>

[Содержание](#содержание)

## Прототип шаблонной функции

Шаблон любой функции по-прежнему можно разделить на ее прототип и полное описание. Делается это следующим очевидным образом:

```c++
template <typename T> T sq_rect(T a, T b); // прототип шаблонной функции
 
int main() {
...
    return 0;
}
 
template <typename T>
T sq_rect(T a, T b)  // шаблон с телом функции
{
    return a * b;
}
```

Также следует отметить, что в ранних стандартах языка C++ (до C++11) вместо ключевого слова `typename` нужно было прописывать ключевое слово `class`:

```c++
template <class T>
T sq_rect(T a, T b)
{
    return a * b;
}
```

Для шаблонов функций – это одно и то же. И, вообще, в большинстве случаев `typename` и `class` работают совершенно одинаково. Но, все же, на мой взгляд, слово `typename` более информативно, чем слово `class`, поэтому в программах чаще всего применяют именно его.

<hr>

[Содержание](#содержание)

## Вариации использования параметра типа

Параметр типа в шаблоне можно расширять различными модификаторами, а также оформлять его в виде ссылок или указателей, например, следующим образом:

```c++
template <typename T>
T sq_rect(const T& a, const T& b)
{
    return a * b;
}
 
template <typename T>
void swap(T* x, T* y)
{
    T temp = *x;
    *x = *y;
    *y = temp;
}
```

Обратите внимание, что возвращаемый тип функции `swap` указан явно `void`, т.е. мы можем совершенно свободно комбинировать явные типы с параметрами типов при описании шаблона. Также в теле функции `swap` объявляется дополнительная переменная `temp` типа `T`. Так тоже можно делать, то есть, идентификатор типа допустимо использовать в любом месте описания функции.

Использовать эти шаблоны можно очевидным образом:

```c++
int main() {
    double a {7.8}, b {-5.6};
 
    swap(&a, &b);       // T = double; void swap(double*, double*);
    std::cout << a << " " << b << std::endl;
 
    int res_1 = sq_rect(5, 2);  // T = int; int sq_rect(const int& a, const int& b);
    std::cout << res_1 << std::endl;
 
    return 0;
}
```

<hr>

[Содержание](#содержание)

# 4.7 Шаблоны функций. Продолжение

[Смотреть материал на видео](https://www.youtube.com/watch?v=A0wZ7rqnAuE&list=PLA0M1Bcd0w8ye84Jmv9yaI5eRTCBTcePE)

Продолжаем тему шаблонов функций и давайте обобщим описание шаблона для функции `sq_rect` следующим образом:

```c++
template <typename T1, typename T2>
auto sq_rect(T1 a, T2 b)
{
    return a * b;
}
```

Смотрите, здесь у нас два параметра типа `T1` и `T2`, а в качестве возвращаемого типа записано ключевое слово `auto`, указывающее компилятору вычислить его самому на основе значения, которое возвращается оператором `return`.

Следует отметить, что ключевое слово `auto` в качестве возвращаемого типа допустимо прописывать, начиная со стандарта C++14. В более ранних стандартах приходилось использовать те или иные костыли, о которых теперь уже нет смысла даже вспоминать.

Давайте посмотрим на варианты вызова этой функции:

```c++
int main() {
    int res_1 = sq_rect(5, 6.5); // double sq_rect<int, double>(int a, double b)
    double res_2 = sq_rect(5, 6); // int sq_rect<int, int>(int a, int b)
    short res_3 = sq_rect<short, short>(2, 3); // int sq_rect<short, short>(short a, short b)
    short res_4 = sq_rect<double>(2, 3); // double sq_rect<double, int>(double a, int b)
 
    return 0;
}
```

Как видите, теперь в функцию можно передавать аргументы разных типов благодаря использованию двух параметров `T1` и `T2` в шаблоне функции. Результаты формирования перегруженных функций везде ожидаемы, кроме, может быть функции с двумя типами `short`. Если вы ожидали, что возвращаемый тип так же будет иметь тип `short`, то, как видите, он был вычислен, как `int`. И это логично, т.к. возвращается целочисленное значение, тип которого по умолчанию начинается с `int`.

<hr>

[Содержание](#содержание)

## Параметры шаблонов с явным указанием типа

При необходимости мы можем определять параметры шаблонов с некоторыми начальными значениями, например, следующим образом:

```c++
template <typename RT = double, typename T1, typename T2> 
RT sq_rect(T1 a, T2 b)
{
    return a * b;
}
```

А, затем, использовать этот шаблон в функции `main`:

```c++
int main() {
    int res_1 = sq_rect(5, 6.5); // double sq_rect(int a, double b)
    double res_2 = sq_rect(5, 6); // double sq_rect(int a, int b)
    short res_3 = sq_rect<short>(2, 3); // short sq_rect(short a, short b)
    int res_4 = sq_rect<int>(2.3, 3.5); // int sq_rect(double a, double b)
 
    return 0;
}
```

В результате, мы получили возможность управлять типом возвращаемого значения, прописывая его, при необходимости, в угловых скобках при вызове функции. Иногда это бывает полезно.

<hr>

[Содержание](#содержание)

## Аргументы параметров шаблонов по умолчанию

Помимо параметров типов, заданных ключевым словом `typename`, в шаблонах можно прописывать параметры с явным указанием того или иного типа. Например:

```c++
template <int calc_t = 1, typename T1, typename T2>
auto get_rect(T1 width, T2 height)
{
    if(calc_t == 1)
        return width * height;  // площадь
    else
        return 2 * (width + height); // периметр
}
```

А, затем, воспользоваться им следующим образом:

```c++
int main() {
    double res_1 = get_rect(5, 6.5); // площадь
    int res_2 = get_rect<2>(5, 6); // периметр
 
    std::cout << res_1 << " " << res_2 << std::endl;
 
    return 0;
}
```

Конечно, это искусственный, учебный пример для демонстрации возможности использования обычных переменных в качестве параметров шаблонов. Конечно, в данном случае смысла в параметре `calc_t`, как параметра шаблона, никакого нет, лучше было бы прописать его непосредственно в заголовке функции:

```c++
template <typename T1, typename T2>
auto get_rect(T1 width, T2 height, int calc_t = 1)
{
    if(calc_t == 1)
        return width * height;  // площадь
    else
        return 2 * (width + height); // периметр
}
```

И это было бы правильнее. Однако бывают ситуации, когда такие параметры действительно имеют смысл. Например, при передаче массива по ссылке и вычисления суммы значений всех его элементов:

```c++
template <typename T, size_t N>
T ar_sum(const T (&ar)[N]) {
    std::cout << N << std::endl;
    
    T res = 0;
    for(size_t i = 0; i < N; ++i)
        res += ar[i];
    return res;
}
```

Когда массив передается по ссылке, то размер `N` является частью его типа и компилятор имеет возможность вычислить значение этого параметра при инстанцировании шаблона. В результате, этот параметр появляется как целочисленная переменная `N` в теле функции `ar_sum`.

Воспользоваться этим шаблоном можно следующим образом:

```c++
int main() {
    double data[] = {0.5, 3.2, 7.8, 3, 10.4, 5.6};
    int marks[] = {2, 2, 3, 2, 3};
 
    auto s = ar_sum(data); // double ar_sum<double, 6>(const double (&ar)[6])
    auto s2 = ar_sum(marks); // int ar_sum<int, 5>(const int (&ar)[5])
 
    std::cout << s << std::endl;
 
    return 0;
}
```

Видите, как удобно можно передавать в функцию массив любой длины для вычисления его суммы. Правда, расплачиваться за это приходится генерацией множества перегруженных функций для массивов разной длины и типов. Поэтому, в общем случае, это не лучшее решение для вычисления суммы элементов массивов произвольных типов. Правильнее будет передать дополнительный параметр – длину массива.

<hr>

[Содержание](#содержание)

## Перегрузка шаблонов функций

В заключение этого занятия отмечу, что шаблоны функций можно также перегружать между собой и даже с другими отдельными функциями. Например:

```c++
template <typename T> 
T add(T a, T b) { puts("add: 1"); return a + b; }
 
template <typename T> 
T add(T* a, T* b) { puts("add: 2"); return *a + *b; }
 
template <typename T1, typename T2> 
auto add(T1 a, T2 b) { puts("add: 3"); return a + b; }
 
void add(std::string& dest, const std::string& src)
{
    puts("add: 4");
    dest.append(src);
}
```

Воспользуемся ими в функции `main` следующим образом:

```c++
int main() {
    std::string str_1 {"Hello"}, str_2 {"World"};
    int a {0}, b{3};
 
    add(&a, &b);        // add: 2
    add(str_1, str_2);  // add: 4
    add(1, 2);          // add: 1
    add(1.3, 2.7);      // add: 1
    add(1, 2.5);        // add: 3
    
    return 0;
}
```

Правило выбора того или иного шаблона или функции следующее. Если под типы аргументы подходит явно объявленная (не шаблонная) функция, то компилятор выбирает именно ее. Поэтому для строк типа `std::string` была вызвана последняя функция с выводом «add: 4». Остальные шаблоны выбираются между собой в соответствии с типами. Если типы обоих аргументов функции add совпадают, то вызывается шаблон «add: 1» или «add: 2». Если же типы различаются, то шаблон «add: 3». Тип возвращаемого значения здесь не играет никакой роли.

Обратите внимание, если вместо функции «add: 4» требуется явно вызвать именно шаблонный вариант, то это можно сделать так:

```c++
    add<>(str_1, str_2);  // add: 1
```

Здесь угловые скобки указывают компилятору генерировать (инстанцировать) функцию из подходящего шаблона.

<hr>

[Содержание](#содержание)

# 4.8 Введение в шаблоны классов

[Смотреть материал на видео](https://www.youtube.com/watch?v=cllQKruYMP8&list=PLA0M1Bcd0w8ye84Jmv9yaI5eRTCBTcePE)

В языке C++ помимо шаблонов функций можно определять и шаблоны классов (и по аналогии шаблоны структур). Давайте представим, что в программах предполагается использовать класс Point для представления точки на плоскости. Пусть для простоты он будет такой:

```c++
class Point {
         int x {}, y {};
public:
         Point(int a, int b) : x(a), y(b)
                   { }
};
```

Типы координат `x`, `y` здесь определены как `int`. Однако, в общем случае, нам могут понадобиться и другие типы, например, `double`. Как тогда быть? Объявлять еще один подобный класс, который будет отличаться только типом данных для `x`, `y`? Например:

```c++
class DoublePoint {
         double x {}, y {};
public:
         DoublePoint(double a, double b) : x(a), y(b)
                   { }
};
```

Как вы понимаете, это приводит к дублированию кода, которого следует избегать при проектировании программ. И здесь, как раз, очень хорошо помогают шаблоны, в частности, шаблоны классов.

Чтобы описать шаблон какого-либо класса используется следующий синтаксис:

```c++
template <параметры шаблона>
class имя_класса {
    // тело шаблонного класса
};
```

Параметр шаблона может быть один или несколько (можно, конечно, не указывать ни одного, но это обычно специализация шаблона). Если параметров несколько, то они прописываются через запятую.

Итак, для класса `Point` шаблон можно записать следующим образом:

```c++
template <typename T>
class Point {
         T x{}, y{};
public:
         Point(T a, T b) : x(a), y(b)
                   { }
};
```

Обратите внимание, что ключевое слово `typename` определяет параметр типа, который, затем, можно использовать внутри класса `Point`. В частности, мы его прописываем у переменных `x`, `y`, а также в конструкторе `Point`. Однако вместо `typename` допустимо использовать ключевое слово `class`:

```c++
template <class T>
…
```

которое имеет практически тот же самый смысл, что и `typename`. Однако на практике сейчас в основном пользуются ключевым словом `typename`, т.к. оно точнее подчеркивает смысл параметра `T`.

После объявления шаблона класса `Point`, мы можем использовать его для создания объектов, например, в функции `main`, следующим образом:

```c++
int main() {
         Point<int> pt_i(1, 2);
         Point<double> pt_d(1, 2);
 
         Point pt_i2(10, 20);       // начиная с C++17
         Point pt_d2(1.2, 2.5);    // начиная с C++17
 
         return 0;
}
```

В первых двух вариантах после класса `Point` в угловых скобках явно прописан тип для параметра `T`. И это было строго обязательно до стандарта C++17. Начиная со стандарта C++17, параметры шаблона класса могут быть вычислены по аргументам, передаваемыми в конструктор класса.

<hr>

[Содержание](#содержание)

## Шаблоны с параметрами по умолчанию

Сразу отмечу, что компилятор не всегда имеет возможность вычислить параметры шаблонов с использованием конструктора. Например, если из конструктора убрать все параметры и записать шаблон класса в виде:

```c++
template <typename T>
class Point {
         T x{}, y{};
public:
         Point() {}
};
```

То, очевидно, его нельзя будет использовать без явного указания типа для параметра `T`:

```c++
int main() {
         Point<int> pt_i;
         Point<double> pt_d;
 
         Point pt_i2;    // ошибка
 
         return 0;
}
```

Однако в шаблонах можно указывать начальные значения параметров, например, так:

```c++
template <typename T=int>
class Point {
         T x{}, y{};
public:
         Point() {}
};
```

Тогда при создании объекта `pt_i2` ошибки не будет, так как вместо `T` подставляется значение по умолчанию `int`.

<hr>

[Содержание](#содержание)

## Шаблоны классов с несколькими параметрами

При этом вычисление типов происходит так же, как и при вызове шаблонных функций. Например, если передать аргументы разных типов:

```c++
    Point pt_d2(1.2, 2);       // ошибка
```

то компилятор не сможет вычислить единый тип для параметра `T` и выдаст ошибку. Выйти из подобных ситуаций легко, достаточно в угловых скобках прописать желаемый тип:
```c++
    Point<double> pt_d2(1.2, 2);           // ok
```

Именно так было бы правильно использовать шаблон `Point`. Однако на этом примере я покажу, как можно использовать несколько параметров в шаблоне класса. Пусть у нас каждая координата `x`, `y` может иметь разные типы данных. Тогда шаблон запишется в виде:

```c++
template <typename T1, typename T2>
class Point {
public:
         T1 x{};
         T2 y{};
public:
         Point(T1 a, T2 b) : x(a), y(b)
                   { }
};
```

Использовать его теперь следует так:

```c++
int main() {
         Point<int, int> pt_i(1, 2);
         Point<double, int> pt_d(1, 2);
 
         Point pt_i2(10, 20);       // начиная с C++17
         Point pt_d2(1.2, 2);       // начиная с C++17
 
         return 0;
}
```

Теперь, при вычислении типов `T1` и `T2` при создании объекта `pt_d2` не возникает никаких ошибок, так как `T1` будет соответствовать `double`, а `T2` – `int`.

<hr>

[Содержание](#содержание)

## Инстанцирование шаблонов классов

Шаблоны классов, так же, как и шаблоны функций, не описывают конкретный класс – это лишь инструкция компилятору по созданию различных классов с разными типами данных. Когда шаблон класса используется непосредственно в программе, как правило, для создания объектов, компилятор вычисляет параметры шаблона и на их основе формирует соответствующий класс. Этот процесс называется инстацированием классов.

![04](/OOP_C_C++/img/04_04.jpg)

<hr>

[Содержание](#содержание)

## Объявление методов шаблона класса

Давайте теперь посмотрим, как выполняется объявление методов в шаблонах классов. Для класса `Point` можно прописать следующие очевидные методы:

```c++
template <typename T>
class Point {
         T x{}, y{};
public:
         Point(T a = 0, T b = 0) : x(a), y(b)
                   { }
 
         T get_x() { return x; }
         T get_y() { return y; }
 
         void set_xy(T a, T b)
         {
                   x = a;
                   y = b;
         }
};
```

Как видите, все достаточно очевидно и просто. Воспользоваться ими можно следующим образом:

```c++
int main() {
         Point<int> pt1;
         Point<double> pt2(5.6, -3.4);
 
         pt1.set_xy(10, 20);
         
         std::cout << pt1.get_x() << std::endl;
 
         return 0;
}
```

При инстацировании класса `Point` для объекта `pt1` шаблонный параметр `T` равен типу `int` и подставляется при объявлении методов этого класса. Аналогично для объекта `pt2`, только там будет сгенерирован класс с типом `T=double`.

Но, что если мы бы хотели объявить реализацию метода вне шаблона класса, например, для `set_xy`? Делается это следующим образом:

```c++
template <typename T>
void Point<T>::set_xy(T a, T b)
{
         x = a;
         y = b;
}
```

Фактически, метод описывается, как шаблон функции, только дополнительно вначале указывается его область видимости, а именно, шаблон класса `Point<T>`. То же самое следует делать и при описании конструкторов и деструкторов вне шаблона. Например:

```c++
template <typename T>
Point<T>::Point(T a, T b) : x(a), y(b)
         { }
 
template <typename T>
Point<T>::~Point()
         { }
```

А так же для статических переменных:

```c++
template <typename T>
class Point {
         static T counter_obj;
         T x{}, y{};
...
};
 
template <typename T>
T Point<T>::counter_obj = 0;
```

Вот в целом идея шаблонов классов. На следующем занятии мы продолжим эту тему и рассмотрим некоторые возможности и особенности работы шаблонов классов.

<hr>

[Содержание](#содержание)

# 4.9 Специализация и наследование шаблонов классов

[Смотреть материал на видео](https://www.youtube.com/watch?v=5YcZMDKygOs&list=PLA0M1Bcd0w8ye84Jmv9yaI5eRTCBTcePE)

Продолжаем тему шаблонов классов и давайте представим, что имеется уже знакомый нам шаблон класса `Point`:


```c++
template <typename T>
class Point {
         T x{}, y{};
public:
         Point(T a, T b) : x(a), y(b)
                   { }
 
         T get_x() { return x; }
         T get_y() { return y; }
};
```

и дополнительно объявим два обычных класса для представления цветов в разных форматах:

```c++
class ColorRGB {
         unsigned char r{}, g{}, b{};
};
 
class ColorUVB {
         unsigned char u{}, v{}, b{};
};
```

А следом объявим еще один шаблонный класс `Rectangle` для представления прямоугольников на плоскости, заданных двумя координатами: верхнего левого и нижнего правого углов:

```c++
template <typename PT, typename CL>
class Rectangle {
         Point<PT> sp, ep; // координаты прямоугольника
         CL color; // цвет прямоугольника
public:
         Rectangle(Point<PT> pt1, Point<PT> pt2) : sp{pt1}, ep{pt2}
                   { puts("Rectangle"); }
 
         void set_color(CL cl) { color = cl; }
};
```

Здесь первый шаблонный параметр `PT` определяет тип координат точек прямоугольника, а второй параметр `CL` – цвет при отображении прямоугольника.

Теперь мы можем воспользоваться этим шаблоном следующим образом:

```c++
int main() {
         Point<int> start(0, 0), end(10, 20);
 
         Rectangle<int, ColorRGB> rect1(start, end);
 
         return 0;
}
```

Обратите внимание, что в качестве второго типа указан класс `ColorRGB`. Очевидно, так тоже можно делать, т.к. имя класса (или структуры) – это полноценный пользовательский тип данных.

Однако при использовании шаблонов у нас может возникнуть ситуация, когда логика работы класса меняется для некоторых типов и эту логику следовало бы описывать в отдельном шаблоне. Например, мы так спроектировали программу, что для класса `ColorUVB` обработка цвета в классе `Rectangle` происходит несколько иначе, чем в стандартной палитре `RGB`. Поэтому для типа `ColorUVB` было бы правильно объявить свой шаблон класса `Rectangle`. Сделать это можно следующим образом:

```c++
template <typename PT>
class Rectangle<PT, ColorUVB> {
         Point<PT> sp, ep; // координаты прямоугольника
         ColorUVB color; // цвет прямоугольника
public:
         Rectangle(Point<PT> pt1, Point<PT> pt2) : sp{pt1}, ep{pt2}
                   { puts("Rectangle<PT, ColorUVB>"); }
 
         void set_color(ColorUVB cl) { color = cl; }
};
```

Теперь, при создании объекта с типом `ColorUVB` будет использован именно этот шаблон класса:

```c++
Rectangle<int, ColorUVB> rect2(start, end);
```

В языке C++ такой подход называется специализацией шаблонов классов. Шаблон специализируется под строго определенные типы. В нашем примере под тип `ColorUVB`, который уже не нужно прописывать в списке параметров. Причем специализация шаблонов обязательно должна идти после общего шаблона класса.

Если в шаблоне заменяются (специализируются) все типы. Например:

```c++
template <>
class Rectangle<double, ColorUVB> {
         Point<double> sp, ep; // координаты прямоугольника
         ColorUVB color; // цвет прямоугольника
public:
         Rectangle(Point<double> pt1, Point<double> pt2) : sp{pt1}, ep{pt2}
                   { puts("Rectangle<double, ColorUVB>"); }
 
         void set_color(ColorUVB cl) { color = cl; }
};
```

То это называется полной специализацией шаблона. В противовес частичной специализации предыдущего примера.

Соответственно, использование всех этих шаблонов выглядит следующим образом:

```c++
int main() {
         Point<int> start(0, 0), end(10, 20);
         Point<double> sd(0, 0), ed(10, 20);
 
         Rectangle<int, ColorRGB> rect1(start, end);
         Rectangle<int, ColorUVB> rect2(start, end);
         Rectangle<double, ColorUVB> rect3(sd, ed);
 
         return 0;
}
```

Увидим в консоли строчки:

```
Rectangle
Rectangle<PT, ColorUVB>
Rectangle<double, ColorUVB>
```

Вот принцип специализации шаблонов классов и их назначение.

<hr>

[Содержание](#содержание)

## Наследование шаблонных классов

Давайте теперь предположим, что у нас есть базовый класс `GeomBase`, представленный в виде следующего шаблона:

```c++
template <typename T>
class GeomBase {
protected:
    T x0{0}, y0{0}, x1{0}, y1{0};
public:
         GeomBase(T x0, T y0, T x1, T y1) : x0{x0}, y0{y0}, x1{x1}, y1{y1}
                   { }
};
```

От этого шаблонного класса наследуется шаблонный класс `Rectangle`. Записывается такое наследование следующим образом:

```c++
template <typename PT>
class Rectangle : public GeomBase<PT> {
public:
         Rectangle(PT x0, PT y0, PT x1, PT y1) : GeomBase<PT>(x0, y0, x1, y1)
                   { puts("Rectangle"); }
};
```

Как видите, все достаточно очевидно. Главное помнить, что при использовании шаблонного класса (при наследовании или при инициализации) всегда нужно указывать параметры этого шаблона в угловых скобках. Во всем остальном наследование работает так же, как и с обычными классами.

Если же нам нужно прописать наследование для обычного не шаблонного класса, то это делается так:

```c++
class Rectangle : public GeomBase<int> {
public:
         Rectangle(int x0, int y0, int x1, int y1) : GeomBase<int>(x0, y0, x1, y1)
                   { puts("Rectangle"); }
};
```

То есть, вместо параметра шаблона нужно указать конкретный тип данных, тем самым инстанцировать шаблон `GeomBase` и сформировать на его основе конкретный класс, от которого, затем, и происходит наследование.

<hr>

[Содержание](#содержание)

## Заключение 2

Это было краткое введение в шаблоны функций и классов. Но его достаточно для первых шагов в их применении и понимании текста программ, которые их используют. В качестве небольшого практического задания предлагаю переписать класс `DArray` для работы с динамическим массивом в виде шаблонного класса, в котором тип элементов массива определялся бы параметром шаблона T. Сам класс `DArray`, я напомню, мы ранее создавали в этом курсе.

<hr>

[Содержание](#содержание)
