# 2. Переменные и арифметические операции

## Содержание

+ [2.1 Переменные и их базовые типы. Модификаторы unsigned и signed](#21-переменные-и-их-базовые-типы-модификаторы-unsigned-и-signed)
    + [Переменные. Константы и литералы.](#переменные-константы-и-литералы)
    + [Базовые типы данных](#базовые-типы-данных)
    + [Модификаторы signed и unsigned](#модификаторы-signed-и-unsigned)
    + [Рекомендации по выбору типов для переменных](#рекомендации-по-выбору-типов-для-переменных)
+ [2.2 Присваивание, числовые и символьные литералы, sizeof](#22-присваивание-числовые-и-символьные-литералы-sizeof)
    + [Присваивание](#присваивание)
    + [Инициализация переменных](#инициализация-переменных)
    + [Целочисленные и символьные литералы](#целочисленные-и-символьные-литералы)
    + [Вещественные литералы](#вещественные-литералы)
    + [Операция sizeof](#операция-sizeof)
    + [Заключение](#заключение-2)
+ [2.3 Потоки ввода/вывода. Функции `putchar()` и `getchar()`](#23-потоки-вводавывода-функции-putchar-и-getchar)
    + [Потоки ввода/вывода.](#потоки-вводавывода)
    + [Функции для работы со стандартными потоками](#функции-для-работы-со-стандартными-потоками)


[Оглавление курса](/Good_good_C_C++/README.MD)


# 2.1 Переменные и их базовые типы. Модификаторы unsigned и signed

## Переменные. Константы и литералы.
На прошлых занятиях мы с вами настроили рабочее место и разобрали структуру простой программы. Теперь, можно приступать к непосредственному изучению конструкций языка Си.

Первое, с чего следует начать – это познакомиться со способами хранения данных. На уровне программы они могут быть представлены в двух видах:
+ переменные – изменяемые значения;
+ константы и литералы – неизменяемые значения.

Начнем с переменных. Как мы с вами уже говорили, данные в памяти компьютера хранятся в виде неделимых ячеек в один байт, которые образуют непрерывную последовательность определенной длины:

![02](/Good_good_C_C++/img/02_01.jpg)

В современных компьютерах каждой запущенной программе отводится своя независимая рабочая область памяти. 

И адреса ячеек становятся уже не физическими, то есть, реальными, а логическими – теми, которые определит для программы ОС. 

Это сделано для повышения надежности работы сразу нескольких программ в один и тот же момент времени. Но нам, как программистам, важно лишь, что есть ячейки в один байт, каждая ячейка имеет свой адрес (логический или физический – не имеет большого значения) и все они следуют друг за другом в пронумерованном порядке.

Причем, адреса всегда увеличиваются на единицу при переходе к следующей ячейке памяти.

Так вот, в самом простом случае, мы можем в любую доступную для записи ячейку, поместить значение в виде целого числа из диапазона `[0; 255]`. Кратко напомню, что этот диапазон определяется тем, что один байт состоит из восьми бит, а каждый бит кодирует информацию двумя состояниями: 0 или 1. Получаем число возможных комбинаций $2^8 = 256$. Значит, в один байт можно записывать произвольные целые числа в диапазоне от 0 до 255 включительно. Чтобы в программе на языке Си работать с отдельной ячейкой памяти, следует воспользоваться такой конструкцией:

```c
char byte_memory;
```

Здесь `char` – это тип переменной; `byte_memory` – имя переменной. Именно так следует объявлять переменные в языке Си: сначала указывается тип данных для переменной, а затем, ее имя. На уровне синтаксиса это выглядит следующим образом:

`<тип переменной>` `<имя переменной>` `;`

Обратите внимание на точку с запятой в конце объявления переменной. 

Точка с запятой в языке Си является неотъемлемой частью оператора, а не разделителем между операторами, как иногда полагают. 

В данном случае символ точка с запятой указывает компилятору, где заканчивается операция объявления переменной и превращает запись в полноценный, законченный оператор. 

Далее мы с вами увидим, как символ точка с запятой входит в состав синтаксиса оператора цикла `for` и там она играет свою особую роль. А на данный момент нужно просто запомнить, что запись оператора объявления переменной (или нескольких переменных) должна завершаться точкой с запятой.

Но вернемся к типу `char`. Он описывает хранилище данных размером в один байт и позволяет хранить 256 вариаций из целых чисел. А имя переменной – это, по сути, название хранилища, где расположено некоторое целое число.

![02](/Good_good_C_C++/img/02_01.jpg)

На рисунке переменная `byte_memory` условно находится в 103-й ячейке памяти. В действительности, расположение переменных определяет `менеджер памяти` ОС. Когда в программе объявляется очередная переменная, то ОС располагает ее в найденной свободной последовательности ячеек. 

И, как вы понимаете, в общем случае, адрес хранения переменной может быть самым разным.

Но на уровне программы для нас это не имеет особого значения. Мы всегда легко можем обратиться к хранилищу данных по имени переменной, прочитать или записать туда нужные значения. Делается это с помощью `операции присваивания` следующим образом:

```c
byte_memory = 100;
char a;
a = byte_memory;
```

В конце каждого оператора ставится точка с запятой. 

Об операции присваивания мы с вами еще подробнее будем говорить. Здесь лишь отмечу, что в левый операнд заносится значение, записанное в правом операнде. То есть, при выполнении первой строчки, в переменную `byte_memory` будет занесено целое значение 100. 

В нашем случае, это автоматически означает, что ячейка с адресом 103 будет содержать число 100. В этом и есть смысл переменных: они могут менять свои значения в процессе выполнения программы.

В двух следующих строчках происходит объявление еще одной байтовой переменной с именем a и копирование в эту переменную значения из переменной `byte_memory`. 

Обратите внимание, я употребил слово «копирование». Так как в языке Си переменные – это непосредственно хранилища данных, поэтому в момент присваивания происходит копирование информации из одного хранилища в другое. То есть, переменные a и `byte_memory` – совершенно независимы между собой.

Я думаю, что вы в целом поняли, что из себя представляют переменные языка Си, как можно объявлять байтовые переменные, заносить и считывать из них данные. Дополнительно укажу лишь некоторые терминологические моменты.

![02](/Good_good_C_C++/img/02_03.png)

Тип `char` относится к одному из ключевых, то есть, зарезервированных слов языка Си. В программе оно воспринимается компилятором исключительно как байтовый тип переменной и не может быть использовано в каком-либо другом качестве, например, как имя переменной.

Далее, имя переменной также еще называют идентификатором, то есть, имя как бы идентифицирует область памяти, которую представляет. 

Забегая вперед, отмечу, что идентификаторами также являются имена функций и некоторых других конструкций языка Си. 

Применительно к имени переменной, в соответствии со стандартом С99, ее максимальная длина внутри модуля составляет 63 символа. Конечно, можно задавать имена и длиннее 63 символов, но компилятор будет учитывать только первые 63. 

Если же переменная используется за пределами модуля, где она объявлена, то ее максимальная длина составляет 31 символ. Это следует учитывать, хотя размер переменных более чем достаточен, чтобы не переходить указанные границы.

Теперь, как правильно задавать имена переменных. Так как они представляют собой хранилища, то они должны быть существительными, например:

    data, name, total, count, size, fl_view и т.п.

Следует иметь в виду, что язык Си различает большие и малые буквы в названиях переменных, да и вообще любых идентификаторов. Поэтому переменные:

    Comp, comp, COMP, cOmp

это разные переменные. В их именах можно использовать только символы латинского алфавита, цифры и символ подчеркивания:

    a-z, A-Z, 0-9, _

Причем, в качестве первого символа может идти или буква или символ подчеркивания. Цифра может появляться только, начиная со второго символа в названии переменной.

Вот примеры правильных и неправильных имен:


Правильные имена | Неправильные имена 
-|-
total_digits | 1_house 
a | don’t 
b | K&R 
fl_mine | 100 
_arg | find@10 
__Apple1 | si# 
Count_Views100 | array[] 

Вообще, принято имена переменных записывать малыми буквами латинского алфавита без первого символа подчеркивания. Например, так:

    swift, book_si, text_array, counter и т.д.

Именно такого написания я буду придерживаться в данном курсе.

Думаю излишне говорить, что имена переменных должны быть уникальными в пределах одной области видимости.

<hr>

[Содержание](#содержание)


## Базовые типы данных

Итак, мы с вами использовали базовый тип `char`, который описывает один байт памяти устройства. Конечно, в языке Си есть и другие встроенные типы данных. Они следующие:

Тип данных | Для 16-битных | Для 32-битных | Для 64-битных | Описание | Диапазон
-|-|-|-|-|-
char | 1 | 1 | 1 | Символьный и целочисленный | [0; 255] или  [-128; 127] 
short [int] | 2 | 2 | 2 | Целочисленный | [-32 768; 32 767] 
int | 2 | 4 | 4 | Целочисленный | [-32 768; 32 767] или<br> [-2 147 483 648; 2 147 483 648] 
long [int] | 4 | 4 | 8 | Целочисленный | … 
long long [int] | 8 | 8 | 8 | Целочисленный | … 
float | 4 | 4 | 4 | Вещественный | … 
double | 8 | 8 | 8 | Вещественный | … 
long double | 10 | 10 | 10 | Вещественный | … 

Тип long long помечен оранжевым, так как он поддерживается не всеми компиляторами. В стандарте С99 были добавлены некоторые другие типы, но они не часто используются на практике, поэтому я не стал их приводить, чтобы не перегружать материал.

Первое, что бросается в глаза, глядя на эту таблицу – это плавающий размер типов в зависимости от разрядности процессора и ОС. 

Да и они приведены лишь, как некий ориентир. 

В действительности стандарты языка Си никак не оговаривают конкретные размеры типов данных. А значит, компиляторы могут использовать такие, какие заложит в них разработчик. 

Конечно, большинство компиляторов согласуют размеры как в приведенной  таблице. Но гарантии никакой нет. И, конечно же, здесь возникает закономерный вопрос: почему бы эти размеры строго не определить и договориться использовать вполне определенные значения? Но на это есть одно веское основание. 

Вспоминаем, язык Си разработан как заменитель языка Ассемблер и программы на Си должны наилучшим образом переводиться в машинный код. 

А машинный код жестко привязан к архитектуре компьютера:
+ разрядности регистров процессора,
+ шины и ячеек памяти. 

Например, тип `char` введен для работы с отдельными ячейками памяти. Если в компьютере они составляют 8 бит, то и компилятор будет описывать тип `char` восьмью битами. Если же представить вычислительную технику с ячейками в 12 бит, то логично тип `char` также сделать 12-битным. 

Вот почему размеры типов жестко не регламентируются спецификациями языка Си. И так со всеми остальными. Например, тип `int` – это основной среди целочисленных. 

Почему так? Потому что вплоть до появления 64-битных процессоров он совпадал по размеру с машинным словом процессора. 

Поэтому в эпоху 16-битных процессоров `int` составлял 16 бит (2 байта), при 32-битных – 32 бита (4 байта). 

А вот при появлении 64-битных он остался 32-битным. Опять же, казалось бы, давайте его по логике увеличим до 64 бит? Но здесь возникла другая проблема. Если int сделать 64-битным, то у нас не будет целочисленного типа в 32 бита. Вводить новый было бы неразумно, т.к. существует масса ранее уже написанных программ с использованием только таких типов данных. 

А компиляторы стараются создавать так, чтобы программы на Си были переносимыми, то есть, чтобы их можно было впоследствии перекомпилировать под другую платформу или для другого процессора. Все это и обусловливает такую неопределенность типов данных.

Но одно мы все же можем сказать. Относительное распределение размеров типов следующее:

    char <= short <= int <= long <= long long

    float <= double <= long double

Но более ни на что рассчитывать не приходится. Хотя, как я уже сказал, большинство компиляторов для стандартной вычислительной техники, придерживаются размеров, указанных в таблице.

Итак, примем как данность неопределенность размеров типов и будем ориентироваться на данные из таблицы. В ней мы видим еще такую запись:

    short [int] или long [int] или long long [int]

Что означает `int` в квадратных скобках? Это значит, что формально эти типы можно записывать как с `int` в конце, так и без него, например:

```c
short int a;
short b;
long d;
long int m;
```

Причем, от добавления слова `int` тип данных никак не меняется, поэтому в современной практике программирования на Си это ключевое слово совместно с модификаторами `short` и `long` не указывают, а пишут просто:

```c
short b;
long d;
```

Зачем тогда вообще появились эти сочетания `short int`, `long int`? 

Все это пришло из глубокой древности языка Си. 

Вероятно, Деннис Ритчи изначально задумывал один общий целочисленный тип `int` и два модификатора к нему: `short` и `long`, чтобы иметь возможность определять более короткие и длинные по размеру памяти целочисленные переменные. 

Но, так как `short` и `long`, кроме как к целочисленным переменным не применяется (кроме, разве что `long double`, который появился позже), то особого смысла дописывать `int` просто нет.

<hr>

[Содержание](#содержание)

## Модификаторы signed и unsigned
Вообще подобные «неряшливые» моменты время от времени встречаются и их нужно правильно понимать и учитывать при написании программ, особенно, когда программа пишется под заказ. Поэтому важно отметить еще одну такую «неряшливость», связанную с типом `char`.

Когда мы в программе задаем переменную этого типа:

```c
char fl_view;
```

то в зависимости от компилятора она может принимать или целые числа в диапазоне $[0; 255]$, или целые числа в диапазоне $[-128; 127]$. 

Стандартом это также никак не оговорено. Откуда взялись эти диапазоны?
+ Первый (от 0 до 255) – это, по сути, беззнаковое представление целого числа в одном байте.
+ А второй – это те же 256 вариаций, но для представления целых чисел со знаком.

Спрашивается, как же нам в программе гарантированно описать переменную `fl_view` как беззнаковую или, наоборот, как знаковую? Для этого в языке Си существуют два модификатора:
+ `unsigned` – беззнаковый;
+ `signed` – знаковый (появился в стандарте ANSI C90).

Если при объявлении явно указать:

```c
unsigned char fl_view;
```

то переменная `fl_view` будет описывать целые числа в интервале `[0; 255]`. Если же указать:

```c
signed char fl_view;
```

то переменная `fl_view` будет описывать целые числа со знаком в интервале `[-128; 127]`.

А теперь, внимание! Все остальные целочисленные типы (`short`, `int`, `long`, `long long`) по умолчанию всегда идут как знаковые. Поэтому определение вида:

```c
int arg;
```

создает переменную `arg` как целочисленную и знаковую. И так со всеми другими типами, кроме `char`. Кстати, именно по этой причине в языке Си появился модификатор `signed`, чтобы гарантированно объявлять переменную типа `char` со знаком. У других целых типов модификатор `signed` указывать не имеет смысла, он идет по умолчанию. А вот второй модификатор `unsigned` вполне имеет смысл. Например:

```c
unsigned short d;
```

Получаем целочисленную беззнаковую переменную с именем `d`. И так со всеми целыми типами.

Обратите внимание, когда я говорю о модификаторах `signed` и `unsigned`, то отмечаю именно целочисленные типы данных. Дело в том, что вещественные типы `float` и `double` всегда знаковые и применять к ним эти модификаторы нельзя.

<hr>

[Содержание](#содержание)

## Рекомендации по выбору типов для переменных

Итак, перед нами множество самых разных типов переменных. Спрашивается, как ориентироваться в этом многообразии и выбирать наиболее подходящий вариант? На этот счет есть довольно простые рекомендации.

Если нам требуется хранить отдельные символы или работать с отдельными ячейками памяти, то для этого существует только один тип `char`. Если предполагается оперировать целочисленными значениями, то изначально следует подумать о типе `int`. Этот тип нам может не подойти в двух ситуациях: если мы создаем в программе большое число целочисленных переменных (от 1000 и более), то следует посмотреть в сторону типа `short` в целях экономии памяти. Конечно, тип `short` можно использовать, только если его диапазона значений достаточно для представления данных в рамках решаемой задачи. Иначе, придется опять же обратиться к типу `int`, или даже типу `long`. Типы `long` или `long long` (если его поддерживает компилятор) следует использовать только в случае, если диапазон значений int недостаточно. Наконец, для описания вещественных чисел (чисел с плавающей точкой), следует изначально рассматривать тип `double`. И обращаться к типу `float` только если в программе предполагается создавать много вещественных чисел (от 1000 и более). Тип `long double` практически не используется за редким исключением сложных математических вычислений.

Итак, по результатам этого занятия вы должны хорошо себе представлять, как выбирать имена переменных, какие базовые типы данных существуют в языке Си и какого они бывают размера (в битах или байтах), как объявлять переменные и как правильно применять модификаторы `signed` и `unsigned`.

Видео по теме [Переменные и их базовые типы. Модификаторы unsigned и signed](https://www.youtube.com/watch?v=tSOksGcGJCI&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

<hr>

[Содержание](#содержание)

### Подвиг 1. Выберите все верные утверждения, касающиеся имен переменных языка Си.


+ [x] компилятор языка Си различает большие и малые буквы в именах переменных, поэтому переменные var, Var, VAR образуют три разных, независимых хранилища данных
+ [ ] имена переменных следует выбирать глаголами (например: go, get, run, start и т.п.)
+ [x] в именах переменных допустимо использовать только символ подчеркивания, буквы латинского алфавита и цифры (начиная со второго символа в имени переменной)
+ [x] имена переменных следует выбирать существительными (например: colors, width, data и т.п.)
+ [ ] в именах переменных допустимо использовать только буквы латинского алфавита и цифры (начиная со второго символа в имени переменной)

### Подвиг 2. Выберите все верные утверждения, касающиеся переменных языка Си.

+ [x] переменные в языке Си представляют собой непосредственные хранилища данных в памяти устройства
+ [x] максимальная длина имени внешней переменной (за пределами модуля), учитываемое компилятором, составляет 31 символ
+ [ ] переменные в языке Си объявляются согласно синтаксису: <имя переменной> <тип переменной>;
+ [x] максимальная длина имени переменной внутри модуля, учитываемое компилятором, составляет 63 символа
+ [ ] обычные переменные в языке Си представляют собой ссылки на данные, хранящиеся в памяти устройства
+ [x] порядковый номер ячейки в памяти, начиная с которой переменная хранится в памяти, называется адресом переменной
+ [x] переменные в языке Си объявляются согласно синтаксису: <тип переменной> <имя переменной>;

### Подвиг 3. Отметьте все допустимые имена переменных.

+ [x] `_2a`
+ [ ] it's
+ [x] `__name__`
+ [ ] 123
+ [x] `_VAR`
+ [x] `a2`
+ [x] `b_2`
+ [x] `qWertY`
+ [ ] 2a
+ [x] `a`
+ [ ] Str[1]

### Подвиг 4. Установите соответствия между типами переменных и их описаниями.

![02](/Good_good_C_C++/img/02_04.PNG)

### Подвиг 5. Пусть в программе объявлены две переменные:

```c
int d;
double b;
```

Отметьте все верные утверждения, касающиеся этих переменных.

+ [x] переменные d и b не содержат одних и тех же ячеек памяти
+ [ ] переменные d и b могут содержать общие ячейки памяти
+ [x] переменная b хранит данные в виде вещественных знаковых чисел
+ [x] переменная d хранит данные в виде целых знаковых чисел
+ [x] в современных ОС и компиляторах языка Си под переменную d, скорее всего, будет отведено 4 ячейки памяти, а под переменную b - восемь
+ [ ] переменная d хранит данные в виде целых беззнаковых чисел

### Подвиг 6. Отметьте верные объявления переменных.

+ [ ] char int ch;
+ [x] short int a;
+ [ ] long float lf;
+ [x] long long int LLi;
+ [ ] short double sd;
+ [x] long int b;
+ [x] long double ld;
+ [x] long long d;

Подвиг 7. Выберите все верные утверждения, касающиеся следующего объявления переменной:

```c
char symbol;
```

+ [x] для переменной symbol знак хранимого числа не определен стандартом языка Си
+ [ ] переменная symbol представляет байтовые числа со знаком
+ [x] переменная symbol хранит данные в виде целых байтовых чисел
+ [ ] переменная symbol представляет беззнаковые байтовые числа
+ [x] переменная symbol будет занимать один байт в памяти устройства (обычно 1 байт = 8 бит)

### Подвиг 8. Выберите все объявления переменных, которые хранят числа со знаком.

+ [x] int var_i;
+ [ ] unsigned char uh;
+ [ ] unsigned long d;
+ [x] short s;
+ [x] signed char h;

### Подвиг 9. Выберите верные варианты использования модификаторов signed и unsigned.

+ [x] unsigned long ul;
+ [x] signed int var_si;
+ [x] unsigned long int var_ul;
+ [ ] signed float var_sf;
+ [ ] unsigned double var_ud;
+ [x] unsigned char byte8;

### Подвиг 10 (на повторение). Отметьте принципы, изначально заложенные в язык Си.

+ [x] доверять программисту
+ [x] операция должна выполняться максимально быстро, даже в ущерб переносимости языка
+ [x] каждая операция языка должна иметь только один способ выполнения
+ [x] без необходимости не усложнять язык, сохранять его простоту
+ [x] не мешать программисту делать то, что он считает необходимым

<hr>

[Содержание](#содержание)

# 2.2 Присваивание, числовые и символьные литералы, sizeof

## Присваивание
На этом занятии подробнее рассмотрим операцию присваивания, а также числовые и символьные литералы. Начнем с операции присваивания.

На предыдущем занятии мы с вами научились объявлять переменные. Например, так:

```c
#include <stdio.h>
 
int main(void) {
    int var;
    return 0;
}
```

Создается целочисленная переменная с именем `var` внутри функции `main`. 

Так как мы не присваивали ей пока никакого значения, то она будет содержать произвольные данные. 

Давайте следующей строчкой занесем в целочисленное хранилище `var` значение `100`. Сделать это можно с помощью операции присваивания, которая в языке Си определена символом равно:

```c
var = 100;
```

Обратите внимание, я говорю операция присваивания, а не оператор.

Дело в том, что в языке Си присваивание реализовано как выражение и помимо копирования данных эта операция еще возвращает скопированное значение. 

В данном случае – это целое число 100. 

И только благодаря точки с запятой, записанной в конце, компилятор понимает, где заканчивается данная конструкция и начинается следующая. 

То есть, точка с запятой превращает операцию присваивания в оператор – завершенную конструкцию языка Си.

Как я уже отмечал на предыдущем занятии, операция присваивания копирует значение из правого операнда в левый операнд. 

Соответственно левый операнд должен явно или косвенно определять ячейки памяти, куда можно занести значение, указанное в правой части.

Как говорят в программировании, слева должно стоять модифицируемое лево-допустимое выражение (`l-value`). 

В простейшем случае – это просто имя переменной. Но могут быть и другие конструкции, с которыми мы познакомимся в будущем.

Учитывая, что присваивание это операция, мы могли бы записать ее и в таком виде:

```c
int var, size;
size = var = 100;
```

Смотрите:
+ во-первых, в программе объявляются две целочисленные переменные, которые перечисляются через запятую после типа данных `int`. <br>
Так тоже можно делать и это вполне распространенная и допустимая практика объявления сразу нескольких переменных одного и того же типа. 
+ Во-вторых, в следующей строчке присваивается целое значение `100` сразу двум переменным. Такая запись допустима, как раз благодаря тому факту, что присваивание является операцией, а не законченным оператором. <br>
Вначале число `100` будет присвоено переменной `var`, а затем, возвращенное значение `100` присваивается переменной `size`. 

Точка с запятой в конце завершает эту конструкцию и определяет ее как оператор.

Конечно, эту же программу мы могли бы записать и так:

```c
int var, size;
var = 100;
size = 100;
```

Современные компиляторы в обоих случаях сформируют оптимальный машинный код и корректно переведут эту программу в наборы машинных инструкций. 

Поэтому, какой вариант присваивания использовать решает сам программист, исходя из удобства оформления программы.

Сразу же отмечу еще один важный момент, связанный с объявлением переменных. 

Правило хорошего тона предполагает, что все значимые переменные следует объявлять вначале каждого блока операторов (то есть, фигурных скобок). 

А уже затем, выполнять операции с ними. Именно так сделано в нашей программе: сначала идет объявление двух переменных, а ниже описаны действия с ними. 

Благодаря этому упрощается понимание и редактирование программ. 

При необходимости, каждую переменную можно сопроводить поясняющим комментарием. 

Конечно, это относится только к значимым переменным. Любые другие, временные, можно объявлять в любом месте программы, чтобы визуально она не засорялась лишними деталями.

<hr>

[Содержание](#содержание)

## Инициализация переменных

В языке Си, равно как и во многих других языках высокого уровня, можно определять значение переменной сразу в момент ее объявления. 

Например, так:

```c
int total = 1024;
```

Визуально это выглядит как обычное присваивание переменной значения.

Но в действительности – это совершенно другая операция, которая называется инициализацией переменной. 

То есть, когда мы объявляем какую-либо переменную (любого типа) и сразу указываем для нее некоторые начальные данные, то в этот момент запускается механизм инициализации этой переменной. 

Компилятор четко различает эти две ситуации:
+ инициализация и
+ обычное присваивание. 

На уровне машинных кодов они также могут быть реализованы по разному. 

Да и синтаксически, как мы в будущем увидим, при инициализации возможны конструкции, которые нельзя использовать при присваивании. 

А пока на данном этапе достаточно знать и запомнить, что
+ есть процесс инициализации переменных,
+ а есть присваивание данных 

и, в общем случае, это разные вещи.

Для полноты картины приведу еще один пример, когда мы комбинируем обычное объявление и инициализацию переменных:

```c
int total = 1024, buffer;
```

Синтаксически так тоже можно делать и использовать в своих программах.

<hr>

[Содержание](#содержание)

## Целочисленные и символьные литералы

Теперь давайте внимательнее посмотрим на число `100` в нашей программе. 

И зададимся вопросом:
+ как его воспринимает компилятор и
+ где оно хранится? 

В программировании явно прописанные числовые значения называются числовыми литералами и представляется как целочисленная константа типа `int`. 

Почему именно типом `int`? 

Так решил создатель языка Си Деннис Ритчи: все целочисленные константы, записанные в программе в десятичном виде, хранить на уровне типа `int`. 

Но только в том случае, если число умещается в диапазон этого типа.

Напомню, что в современных 32- и 64-битных компьютерах тип `int`, как правило, составляет 4 байта (32 бита) и описывает диапазон значений:

$[-2147483648; 2147483647]$

Если целочисленный литерал положителен и не умещается в этот диапазон, то компилятор подбирает соответствующий размер типов данных в порядке возрастания:

+ int,
+ unsigned int,
+ long,
+ unsigned long,
+ long long,
+ unsigned long long

Если же и самого большого недостаточно (что сложно себе представить в реальных задачах), то компилятор выдаст ошибку.

Но так только с целыми числами, записанными в десятичном виде. 

Язык Си позволяет определять в программе числовые литералы еще в шестнадцатеричной и восьмеричной форме. Делается это очень просто, например:

```c
int dec, hex, oct;
dec = 100;
hex = 0x1FA;
oct = 0123;
```

Здесь
+ `100` – это десятичная форма записи;
+ `0x1FA` – шестнадцатеричная (число 1FA);
+ `0123` – восьмеричная. 

То есть, для записи шестнадцатеричных чисел перед ними ставится префикс в виде символов `0x`, а для записи восьмеричных – префикс в виде `0`. 

Так можно прописывать любые числа в нужном нам формате. 

Разумеется, на уровне машинных кодов они представляются единым образом в виде набора бит и запись числовых литералов в той или иной форме служит исключительно для удобства восприятия программистом. Не более того.

Но с шестнадцатеричными и восьмеричными литералами есть один важный нюанс. 

Их компилятор изначально представляет не типом `int`, как десятичные, а типом `unsigned int`. 

Соответственно, если литерал не умещается в этот тип, то берутся другие больших размеров в порядке:

+ unsigned int,
+ unsigned long,
+ unsigned long long

При желании мы можем явно указать компилятору тип числового литерала. Для этого используются следующие суффиксы:

+ `U` или `u` – использование модификатора `unsigned` в определении литерала;
+ `L` или `l` – использование типа `long` при определении литерала;
+ `LL` или `ll` – использование типа `long long` при определении литерала.

Обычно в программах прописывают большие буквы `L`, так как малые случайно можно спутать с изображением числа `1`. Суффикс `U` можно записывать и отдельно, но можно комбинировать с суффиксами `L` и `LL`:

```c
int dec_i, dec_ui, dec_l, dec_ul;
dec_i = 100;        // тип литерала int
dec_ui = 100U;      // тип литерала unsigned int
dec_l = 100L;       // тип литерала long
dec_ul = 100UL;     // тип литерала unsigned long
```

Хорошо, с запись литералов разобрались. 

Но как они сохраняются непосредственно в программе? 

Конечно же компилятор переводит их в машинный код и хранит непосредственно в скомпилированной программе как неизменяемые данные, то есть, как константы. 

Когда программа загружается в память компьютера, то вместе с ней загружаются все данные, которые мы явно определяем в тексте.

Отлично, с этим разобрались. 

Давайте теперь посмотрим на тип `char`, который формально определен и как символьный и как целочисленный. 

Первый вопрос, как такое может быть? На самом деле все очень просто. Объявим переменную этого типа, например:

```c
char ch;
```

а, затем, присвоим ей какой-либо символ, например, буквы d:

```c
ch = 'd';
```

Обратите внимание, как прописан символ в тексте программы: он заключен в одинарные кавычки (их еще называют апострофами). 

И только так можно определять символьные литералы в языке Си. 

Когда компилятор видит одинарные кавычки, то он воспринимает информацию в них, как символ. 

Никакие другие кавычки для этого использовать нельзя. 

Например, двойные зарезервированы для определения строк, поэтому запись:

```c
ch = "d";
```

приведет к ошибке на этапе компиляции. 

Если же совсем убрать кавычки, то символ d в программе будет восприниматься как переменная:

```c
ch = d;
```

Поэтому следует запомнить, что для определения символьного литерала используются только одинарные кавычки.

Хорошо, на уровне программы мы теперь знаем, как прописывать отдельные символы. Но спрашивается, как эти символы представляются в машинных кодах. 

Там же могут быть только числа. Все верно. И это очень важный момент.

Все символьные литералы в программе автоматически переводятся в соответствующие коды. Как я вам уже говорил на самом первом занятии, каждому символу ставится в соответствии определенный код (целое число). 

И приводил фрагмент таблицы ASCII. Так вот, компилятор, используя текущую кодовую таблицу (не обязательно ASCII), переводит все числа в соответствующие коды. 

В частности, символ буквы `d` в нашем случае имеет код `100`. Любой другой символ будет иметь другой код. И, по сути, строчка программы:

```c
ch = 'd';
```

в нашем конкретном случае, может быть заменена на:

```c
ch = 100;
```

Хотя, явно прописывать так не следует, потому что при другой кодовой таблице код символа d может быть другим.

Далее, мы можем вывести это значение переменной `ch` с помощью функции `printf()` в двух форматах: символьном и числовом:

```c
printf("ch = %c, code = %d\n", ch, ch);
```

Об этой функции мы еще подробнее будем говорить, пока только отмечу, что вместо символов `%c` будет подставлено значение `ch` и переведено в символ. А вместо `%d` будет также подставлено также значение из `ch`, но выведено в виде целого десятичного числа.

После запуска программы увидим:

```c
ch = d, code = 100
```

Этот факт показывает, что компьютеру важно лишь какое число хранится в переменной `ch`, а его интерпретация может быть самой разной:
+ или как символ,
+ или как целое число. 

Причем, обратите внимание, компилятор преобразовывает символьные литералы в числа типа `int`, а не `char`, как можно было бы ожидать. Это, как раз связано с тем, что он воспринимает любой символ, как десятичное число, а оно по умолчанию представляется типом `int`.

Конечно, при работе с символами мы формально можем использовать любой другой целочисленный тип. Например, прописать так:

```c
int ch;
ch = 'd';
```

В данном случае на работу программы это никак не повлияет. 

Но, все же, если планируется в переменных хранить коды символов, то лучше использовать тип `char` в целях экономии памяти, т.к. этого типа достаточно для представления всех основных символов, включая и русские буквы.

<hr>

[Содержание](#содержание)

## Вещественные литералы

Помимо целочисленных в программе можно прописывать и вещественные литералы. Определять их можно следующими способами:

```c
double d1, d2, d3, d4;
d1 = 10.0;
d2 = -7.;
d3 = 1e2;
d4 = 5e-3;
```

В первых двух случаях используется символ точки. Причем, обратите внимание, несмотря на то, что числа 10.0 и -7.0 с математической точки зрения соответствуют целым числам 10 и -7, на уровне программы они будут вещественными и иметь тип double.

Все вещественные литералы компилятор языка Си по умолчанию представляет этим типом данных. Соответственно, математические операции с числами 10.0 и -7.0 будут выполняться несколько иначе, чем с аналогичными целыми числами. Это следует иметь в виду.

Последние два варианта – запись числа в экспоненциальной форме:


`<число>` `e` `<степень десятки>`

Например, запись:

$1e2 = 1 \cdot 10^2 = 100$<br>
$5e-3 = 1 \cdot 10^{-3} = 0.005$

Такую форму удобно использовать в научных расчетах, когда используются или очень маленькие или очень большие числа. В любом случае экспоненциальная форма переводится в вещественное число типа `double`, даже если оно математически является целым, а не дробным.

При желании мы можем явно указать компилятору переводить вещественный литерал в тип `float`. Для этого после числа следует прописать суффикс `f`, например, так:

```c
d1 = 10.0f;
```

В такой записи вещественное число 10.0 будет представляться типом `float`, а не `double`. Это бывает полезно, когда используется переменная типа `float` и ей правильно было бы присвоить значение того же типа:

```c
float var_f;
var_f = 10.0f;
```

Тогда компилятор не выдаст предупреждение (warning) о возможной потере данных в момент присваивания значения переменной `var_f`.

<hr>

[Содержание](#содержание)

## Операция sizeof
В заключение этого занятия отмечу довольно распространенную операцию `sizeof` языка Си. 

Она возвращает число байт, занимаемых в памяти переменной или, отведенных под тип данных. Синтаксис этой операции следующий:

```c
sizeof(<тип | имя переменной>);

sizeof <имя переменной>;
```

Обратите внимание, во втором случае мы можем записать ключевое слово `sizeof` без круглых скобок, но тогда эта операция применяется только к переменным, но не к типам. 

Чтобы не запоминать эти тонкости, обычно `sizeof` записывают с круглыми скобками и указывают либо тип данных, либо имя переменных.

Например:

```c
int size_float = sizeof(float);
int size_var_f = sizeof(var_f);
```
На выходе получаем число байт, которое занимает тип `float` и переменная `var_f`. Соответственно:

```c
int size_ch = sizeof(char);
```

всегда равно единице.

<hr>

[Содержание](#содержание)

## Заключение 2

Итак, на этом занятии вы должны хорошо понимать, как работает операция присваивания и инициализация переменных в языке Си. Знать, как записываются и представляются на уровне машинных кодов числовые и символьные литералы, а также какие суффиксы у них можно пописывать. И, конечно же, уметь применять операцию `sizeof` для определения размера типа данных или переменной.

Видео по теме [#6. Операция присваивания. Числовые и символьные литералы. Операция sizeof](https://www.youtube.com/watch?v=e9CVbaW9kSc&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)



### Подвиг 1. Пусть имеется следующая программа на языке Си:

```c
int main(void) {
    short d;
    d = 5;
    return 0;
}
```

Выберите все верные утверждения, касающиеся этой программы.

+ [x] точка с запятой после присваивания превращает операцию присваивания в завершенный оператор
+ [x] операция присваивания (=) выполняет копирование числа 5 в ячейки памяти переменной d
+ [ ] в результате операции присваивания (=) переменная d ссылается на ячейки памяти, в которых хранится числовой литерал 5
+ [ ] в момент объявления переменной d ее значение равно нулю
+ [x] в момент объявления переменной d ее значение не определенно
+ [x] операция присваивания возвращает присвоенное значение (число 5)

### Подвиг 2. В программе ниже объявите целочисленную переменную типа int с именем my_var_i и присвойте ей значение 78.

```c
int main(void) {
    int my_var_i = 78;
    __ASSERT_TESTS__ // макроопределение для тестирования (не убирать и должно идти непосредственно перед return 0)
    return 0;
}
```

### Подвиг 3. Выберите все верные выражения с оператором присваивания.

P.S. Здесь a, b, c, d - целочисленные переменные.

+ [ ] 30 = b;
+ [x] с = 5; d = c;
+ [x] a = b = -23;
+ [x] a = 100;

### Подвиг 4. В программе ниже объявите две вещественные переменные типа double с именами var_d1, var_d2. После этого (следующим оператором) присвойте им значение 0.5 по цепочке, используя конструкцию вида a = b = c = d.

```c
int main(void) {
    double var_d1, var_d2;
    var_d1 = var_d2 = 0.5;
    __ASSERT_TESTS__ // макроопределение для тестирования (не убирать и должно идти непосредственно перед return 0)
    return 0;
}
```

### Подвиг 5. Отметьте все выражения, в которых выполняется инициализация переменных.

+ [ ] long c, d, e; d = c = e = 0;
+ [x] int var_i = 100; var_i = -10;
+ [ ] short a; a = 4;
+ [x] float var_f = 0.01f;
+ [x] double digit = -65.4;

### Подвиг 6. Выберите все верные утверждения, касающиеся числовых литералов.

+ [x] если в тексте программе встречается число 45.55, то оно представляется вещественной константой типа double
+ [ ] числовые литералы можно записывать только в десятичной системе счисления
+ [x] если положительный числовой литерал по значению превышает диапазон типа unsigned long long, то компилятор выдает предупреждение или ошибку
+ [x] числовым литералом является любое явно прописанное число в тексте программы
+ [x] если в тексте программе встречается число 128, то оно представляется целочисленной константой типа int
+ [ ] если положительный числовой литерал по значению превышает диапазон типа unsigned long long, то происходит переполнение и значение числового литерала в программе искажается
+ [ ] если в тексте программе встречается число 128, то оно представляется целочисленной константой типа short
+ [x] числовые литералы можно записывать в десятичной, шестнадцатеричной, восьмеричной системах счисления

## Подвиг 7. Установите соответствия между суффиксами числовых литералов и их описаниями.

![02](/Good_good_C_C++/img/02_05.PNG)

## Подвиг 8. Выберите все верные утверждения, касающиеся символьных литералов.

+ [ ] символьный литерал можно записывать в одинарных или двойных кавычках (например, 's' или "s")
+ [x] числовое значение символьного литерала зависит от текущей кодовой таблицы
+ [ ] компилятор языка Си вместо символьного литерала подставляет целочисленный код типа char этого символа
+ [x] компилятор языка Си вместо символьного литерала подставляет целочисленный код типа int этого символа
+ [x] символьный литерал должен записываться только в одинарных кавычках (например, 's')

### Подвиг 9. Выберите все верные записи вещественных числовых литералов.

P.S. Здесь d - вещественная переменная типа double.

+ [ ] d = e - 2;
+ [x] d = -.5;
+ [x] d = 123.;
+ [ ] d = e2;
+ [x] d = 3.2e5;
+ [x] d = 1e-2;
+ [x] d = -1e2;
+ [x] d = 32e-5;

### Подвиг 10. Выберите все верные утверждения, касающиеся операции sizeof.

+ [x] операция sizeof возвращает число байт, занимаемых переменной или типом
+ [ ] операция sizeof может быть записана по синтаксису: sizeof <тип | имя переменной>;
+ [ ] операция sizeof возвращает число байт, занимаемых переменной (с типами данных она не работает)
+ [x] операция sizeof может быть записана по синтаксису: sizeof(<тип | имя переменной>);
+ [x] операция sizeof может быть записана по синтаксису: sizeof <имя переменной>;
+ [x] операция sizeof может быть записана по синтаксису: sizeof(<имя переменной>);

### Подвиг 11. Ниже в программе объявите вещественную переменную типа double. С помощью операции sizeof вычислите размер, который занимает эта переменная в памяти устройства. Результат сохраните в переменной res.

P.S. На экран ничего выводить не нужно.

```c
int main(void) {
    double vol;
    int res = sizeof(vol);
    
    __ASSERT_TESTS__ 
    return 0;
}
```

<hr>

[Содержание](#содержание)

# 2.3 Потоки ввода/вывода. Функции `putchar()` и `getchar()`

## Потоки ввода/вывода.
На этом занятии затронем тему стандартных потоков ввода/вывода. Вначале ответим на вопрос, что это за потоки и для чего они нужны?

Я думаю, вы все прекрасно понимаете, что программы часто выводят результаты своей работы на монитор, а считывают информацию с клавиатуры. Хотя это и не обязательно так, но чаще всего мы имеем дело именно с монитором и клавиатурой. Так вот, на уровне операционной системы, как правило, имеются три стандартных потока ввода/вывода:

+ stdout – поток вывода информации (как правило, на монитор);
+ stderr – поток вывода ошибок (как правило, на монитор);
+ stdin – поток ввода информации (как правило, с клавиатуры).

![02](/Good_good_C_C++/img/02_06.jpg)

Конечно, все эти потоки можно настроить на любые другие устройства.

Например, в некоторых случаях поток ошибок `stderr` ассоциируется с самописцем (принтером), который сразу на бумаге выдает ошибки, произошедшие в процессе работы программы. 

А поток вывода `stdout` можно связать с файлом, куда будет выводиться вся информация. 

Аналогично поток ввода `stdin`. Вместо клавиатуры можно использовать любое устройство ввода, вплоть до магнитных лент, информация с которых в битовом представлении поступает в поток ввода. 

То есть, монитор и клавиатура – это всего лишь частные, хотя и частые случаи. 

Благодаря использованию стандартных потоков ввода/вывода, программы способны универсальным образом работать с любыми устройствами, связанными с этими потоками. И это очень удобно.

На программном уровне все эти потоки организованы в виде буферов приема или передачи информации. 

То есть, данные сначала поступают в буфер, а затем, уже либо на устройство вывода, либо в переменные программы. 

Это очень важный момент. 

Данные поступают в программу, например, с клавиатуры, не напрямую, а через буфер ввода. 

То же самое с выводом. 

Сначала данные из программы попадаю в буфер вывода и только потом, например, отображаются на мониторе или записываются в файл. Запомним этот момент. Он нам в будущем пригодится.

<hr>

[Содержание](#содержание)

## Функции для работы со стандартными потоками
Язык Си предоставляет набор библиотечных функций для работы со стандартными потоками ввода/вывода. Мы рассмотрим некоторые из них, которые наиболее часто используются на практике:

+ `putchar()` – вывод символа через поток `stdout`;
+ `printf()` – форматный вывод строки через поток `stdout`;
+ `perror()` – вывод ошибок в виде строки через поток `stderr`;
+ `getchar()` – чтение одного байта (символа) из потока `stdin`;
+ `scanf()` – форматный ввод данных из потока `stdin`.

Описания (прототипы) всех этих функций даны в заголовочном файле `stdio.h`. То есть, для их использования в программе вначале должна быть прописана директива:

```c
#include <stdio.h>
```

## Функция `getchar()`

Давайте рассмотрим эти функции и начнем с `getchar()`. Она имеет следующее определение:

```c
int getchar(void);
```


Целочисленный тип `int` перед функцией означает, что она возвращает целое число, а `void` в круглых скобках говорит об отсутствии каких-либо параметров. Поэтому мы можем вызвать ее в программе следующим образом:

```c
#include <stdio.h>
 
int main(void) {
    int value = getchar();
 
    return 0;
}
```

После запуска этой программы будет ожидаться ввод значения в поток `stdin`. Так как он по умолчанию ассоциирован с клавиатурой, то нам нужно набрать один символ, любой, например, буквы ‘s’ и нажать клавишу `Enter`. После этого программа продолжится, перейдет к следующему оператору `return` и завершится.

Я напомню, что функция `getchar()` предназначена для чтения одного байта из входного потока `stdin`. И здесь возникает вопрос, почему эта функция возвращает целое число типа `int`, а не данные типа `char`, который и описывает один байт памяти? Дело в том, что стандартный поток ввода работает несколько более сложным образом, нежели просто выдача очередного байта из буфера. В частности, он дополнительно генерирует некоторые служебные значения. Например, значение:

```
EOF (End of File – конец файла)
```

которое определено как `-1` в заголовочном файле `stdio.h`. То есть, помимо байтового диапазона $[0; 255]$ целых чисел функция `getchar()` дополнительно может вернуть значения вне этого диапазона, в частности, `-1`.

Вам может показаться странным, что мы говорим про константу `EOF`, когда речь идет о вводе данных с клавиатуры? Но, во-первых, стандартный поток ввода `stdin` вполне можно связать с файлом и тогда данные будут читаться из него, а не с клавиатуры и при достижении конца файла будет сгенерировано значение `EOF`. И, во-вторых, при вводе с клавиатуры мы также можем симитировать достижение конца файла путем ввода специального символа комбинацией клавиш `Ctrl+Z` для ОС Windows и `Ctrl+D` для ОС Linux.

Таким образом, функции `getchar()` нужно возвращать целые значения, превышающий байтовый диапазон $[0; 255]$. Поэтому разработчик языка Си решил использовать тип `int`.

## Функция `putchar()`

Следующая аналогичная функция – это `putchar()`, которая служит для вывода одного байта (символа) в выходной поток `stdout` и определена следующим образом:

```c
int putchar(int ch);
```

Она также возвращает целое число типа `int` и в качестве аргумента принимает целое значение этого же типа `int`. 

В действительности, тип `int` здесь использован для сопряжения (по типам данных) с функцией `getchar()`. Иначе бы можно было прописать тип `char`, так как функция `putchar()` в качестве аргумента принимает код символа в диапазоне $[0;255]$. 

Любое другое значение за пределами этого диапазона просто будет приводиться к восьми битам и затем помещаться в выходной поток `stdout`. Возвращает эта функция код символа, переданного в выходной поток:

```c
#include <stdio.h>
 
int main(void) {
    int value = getchar();
    int res = putchar(value);
    printf("\n%d\n", res);
 
    return 0;
}
```

При выполнении этой программы, нам необходимо будет ввести какой-либо символ с клавиатуры, и затем, он продублируется вызовом функции `putchar()`. Возвращаемое значение (код введенного символа) будет выведено на экран с помощью функции `printf()`.

Конечно, на практике функцию `putchar()` обычно вызывают исключительно для вывода информации в стандартный поток `stdout`.

Поэтому возвращаемое значение просто игнорируют:

```c
putchar(value);
```

То есть, если функция что-либо возвращает, нет необходимости в программе учитывать это значение. В этом случае говорят, что функция вызвана ради побочного эффекта. Надо сказать, что в языке Си это обычная практика.

## Буферы приема/передачи стандартных потоков

На протяжении всего занятия я акцентирую ваше внимание на наличие буферов приема/передачи информации у стандартных потоков ввода/вывода. При запуске программы они пустые, в них нет никаких посторонних значений. Но, в процессе ввода или вывода информации они заполняются и это может повлиять на ход исполнения программы.

Давайте я это покажу на конкретном примере. Запишем два подряд идущих вызова функции `getchar()` следующим образом:

```c
#include <stdio.h>
 
int main(void) {
    int value1 = getchar();
    int value2 = getchar();
 
    printf("%c %c\n", value1, value2);
 
    return 0;
}
```

И после запуска этой программы введем с клавиатуры два символа: `ds`. В результате, оба символа помещаются во входной буфер, первый считывается при первом вызове функции `getchar()`, а второй – при втором вызове функции `getchar()`. 

Поэтому программа не ждет от нас ввода какой-либо дополнительной информации, а сразу переходит к функции `printf()`. Соответственно в переменной `value1` будет храниться код символа `d`, а в переменной `value2` – код символа `s`. Затем, функция `printf()` выводит на экран оба прочитанных символа.

Вот наглядный эффект работы входного буфера. Мало того, если бы мы ввели не два, а, скажем, три символа, то после чтения первых двух, последний так бы и остался во входном буфере до момента завершения программы. При завершении, все буферы автоматически очищаются.

На этом мы завершим вводное занятие по стандартным потокам ввода/вывода, а также по функциям `getchar()` и `putchar()`. На следующем занятии продолжим эту тему и поговорим о функции `printf()`.

### Подвиг 1. Выберите все верные утверждения о стандартных потоках.

+ [ ] стандартный поток ввода имеет обозначение stdout
+ [x] стандартный поток вывода имеет обозначение stdout
+ [x] стандартный поток ошибок имеет обозначение stderr
+ [x] все стандартные потоки, как правило, имеют буфер приема/передачи данных
+ [x] поток stdin часто связан с клавиатурой
+ [x] потоки stdout и stderr часто ассоциированы с монитором
+ [ ] стандартный поток вывода имеет обозначение stdin
+ [x] стандартный поток ввода имеет обозначение stdin

### Подвиг 2. Установите соответствия между функциями и их описаниями.

![02](/Good_good_C_C++/img/02_06.PNG)

### Подвиг 3. Продолжите программу, которая должна читать из входного потока один символ (байт) с помощью функции getchar() и выводить его в выходной поток с помощью функции putchar().

```c
#include <stdio.h>

int main(void) {
    int value = getchar();
     putchar(value);

    return 0;
}
```

```c
#include <stdio.h>

int main(void) {
    int ch;
    ch = getchar();
    while(ch != EOF) {
        putchar(ch);
        ch = getchar();
    }
    return 0;
}
```

```c
#include <stdio.h>

int main(void) {
    putchar(getchar());

    return 0;
}
```

### Подвиг 4. Выберите все верные утверждения, касающиеся функции getchar().

+ [x] функция getchar() возвращает специальный символ EOF (код 256 или -1), когда достигается конец потока данных
+ [ ] функция getchar() принимает один аргумент - максимальное число читаемых данных
+ [x] для использования функции getchar() необходимо подключить заголовочный файл stdio.h
+ [ ] функция getchar() возвращает значение типа char - текущий прочитанный символ из потока stdin
+ [x] функция getchar() возвращает целочисленное значение int - код прочитанного символа из потока stdin
+ [x] функция getchar() не принимает никаких аргументов

### Подвиг 5. Продолжите программу, которая должна читать из входного потока три первых подряд идущих символа с помощью функции getchar(), а затем вывести их в выходной поток в обратном порядке (от последнего к первому) с помощью функции putchar().

P.S. В тестах гарантируется, что во входном потоке присутствуют, как минимум, три символа.

```c
#include <stdio.h>
#define MAX 3

int main(void) {
    int input[MAX];
    for (int i = 0; i < MAX; i++) {
        input[i] = getchar();
    }
    for (int i = MAX - 1; i >= 0; i--) {
        putchar(input[i]);
    }
    return 0;
}
```

```c
#include <stdio.h>
int main(void){
    int value1 = getchar();
    int value2 = getchar();
    int value3 = getchar();
    putchar(value3);
    putchar(value2);
    putchar(value1);
    return 0;
}
```

### Подвиг 6. Выберите все верные утверждения, касающиеся функции putchar().

+ [x] функция `putchar()` принимает один аргумент типа `int`
+ [x] функция `putchar()` помещает один байт данных в буфер потока `stdout`
+ [ ] функция `putchar()` принимает один аргумент типа `char` - символ, который помещается в выходной поток
+ [ ] функция `putchar()` ничего не возвращает
+ [x] для использования функции `putchar()` необходимо подключить заголовочный файл `stdio.h`
+ [x] функция `putchar()` возвращает код символа, помещенного в выходной поток
+ [ ] функция `putchar()` помещает один байт данных в буфер потока `stdin`

### Подвиг 7 (на повторение). Выберите все верные утверждения, касающиеся имен переменных языка Си.

+ [ ] в именах переменных допустимо использовать только буквы латинского алфавита и цифры (начиная со второго символа в имени переменной)
+ [ ] имена переменных следует выбирать глаголами (например: go, get, run, start и т.п.)
+ [x] в именах переменных допустимо использовать только символ подчеркивания, буквы латинского алфавита и цифры (начиная со второго символа в имени переменной)
+ [x] имена переменных следует выбирать существительными (например: colors, width, data и т.п.)
+ [x] компилятор языка Си различает большие и малые буквы в именах переменных, поэтому переменные var, Var, VAR образуют три разных, независимых хранилища данных

### Подвиг 8 (на повторение). Установите соответствия между типами переменных и их описаниями.

![02](/Good_good_C_C++/img/02_07.PNG)

# 2.4 Функция printf() для форматированного вывода

На этом занятии речь пойдет о функции `printf()`, с которой нам ранее уже приходилось сталкиваться, начиная с самой первой программы. 

Как я отмечал, название функции – это сокращение от английских слов:

```
print formatted (форматированный вывод)
```

А само определение (прототип) функции следующее:

```c
int printf(const char* format, …);
```

Первый параметр `format` – это указатель на строку. 

Пока его можно воспринимать просто как строку, в которой определен формат для вывода информации в стандартный поток `stdout`. 

А троеточие определяет произвольное число дополнительных параметров.

Обычно, это переменные или выражения, значения которых следует выводить в заданном формате. 

В качестве возвращаемого типа указан `int`, то есть функция возвращает целое число. 

Это число соответствует количеству выведенных символов в стандартный поток `stdout` (в нашем случае на экран). 

Обычно, на практике, этим значением пренебрегают и вызывают функцию `printf()`, как говорят, ради побочного эффекта, т.е. ради передачи данных в выходной поток.

В самом простом варианте мы с вами использовали эту функцию для вывода строки на экран:

```c
#include <stdio.h>
 
int main(void) {
    printf("Hello, World!\n");
    return 0;
}
```

Но, как вы уже догадались, функция `printf()` способна на гораздо большее! 

На этом занятии мы рассмотрим лишь основные ее возможности, которые наиболее часто применяются на практике. Если вам понадобится больше информации, то справочные руководства всегда к вашим услугам.

Итак, первый параметр `format` функции `printf()` определяет не просто выводимую строку, а формат выдаваемых данных. И для этого в нашем распоряжении имеются, так называемые, спецификаторы преобразования. Основные из них следующие.

Спецификатор | Описание
-|-
`%d` или `%i` | Целое число со знаком в десятичной форме.
`%u` | Целое беззнаковое (unsigned) число в десятичной форме.
`%o` | Целое беззнаковое (unsigned) число в восьмеричной форме.
`%x` или `%X` | Целое беззнаковое (unsigned) число в шестнадцатеричной форме.
`%f` или `%F` | Вещественное число в виде десятичной дроби.
`%e` или `%E` | Вещественное число в экспоненциальной форме.
`%c` | Символ в соответствии с текущей кодовой таблицей.
`%s` | Строка (последовательность символов).
`%%` | Запись символа % в форматной строке.

В действительности существуют и другие спецификаторы, но мы остановимся только на этих. Также спецификатор `%s` для вывода строк рассмотрим позже, когда будем рассматривать строки.

Итак, давайте посмотрим, как можно воспользоваться этими спецификаторами преобразования. Пусть у нас в программе определена целочисленная переменная `var_i` с начальным значением `1208`:

```c
int var_i = 1208;
```

И мы бы хотели вывести ее значение на экран в виде десятичного числа с помощью функции `printf()`. 

Из таблицы видим, что для этого подходит спецификатор `%d`. Им и воспользуемся, следующим образом:

```c
printf("value = %d\n", var_i);
```

После запуска программы на экран будет выведено:

```
value = 1208
```

Почему так и как это работает? 

Сморите, вначале функция `printf()` выполняет анализ форматной строки. 

В некотором смысле она работает как ее интерпретатор. 

Как только в строке встречается символ `%`, скорее всего, это некоторый спецификатор. 

И, действительно, дальше идет символ `d`, функция «понимает», что это спецификатор `%d`, на место которого нужно подставить значение переменной в виде целого десятичного числа со знаком (если он есть; знак + не ставится). При этом берется первая переменная, записанная после форматной строки. В нашем случае – это `var_i` со значением `1208`. В результате получаем итоговую строку `value = 1208`.

А теперь, давайте, вместо спецификатора `%d` запишем, например, спецификатор `%x`:

```c
printf("value = %x\n", var_i);
```

В результате будет выведена строка:

```
value = 4b8
```

То есть, спецификатор `%x` преобразовывает данные из переменной `var_i` в шестнадцатеричный формат и подставляет на свое место. И так работает каждый спецификатор. Даже если прописать:

```c
printf("value = %f\n", var_i);
```

для вывода значение переменной `var_i` как вещественное число, то ошибки никакой не будет, но отображаемое значение будет, конечно же, некорректным:

```
value = 0.000000
```

Но, если изменить тип переменной `var_i` на вещественный:

```c
double var_i = 1208;
```

то увидим правильное значение:

```
value = 1208.000000
```

## Суффиксы типов для спецификаторов

Этот пример показывает, что спецификаторы должны быть согласованы с типами данных переменных или выражений. Причем, целочисленные типы `char` и `short`, при передаче значений функции `printf()`, автоматически приводятся к типу `int`. Поэтому спецификатор `%d` охватывает все три типа: `char`, `short`, `int`. Если же переменная имеет тип `long` или `long long`, то перед спецификаторами допустимо прописывать малые буквы `l` и `ll` соответственно:

+ l – суффикс для типов `long` или `unsigned long`;
+ ll – суффикс для типов `long long` или `unsigned long long`.

Так как в моей версии компилятора типы `long` и `int` по размеру совпадают и имеют 4 байта (32 бита), то приведу пример с типом `long long`, который занимает 8 байтов (64 бита):

```c
printf("value = %lld\n", -12345678901234LL);
printf("value = %llu\n", 12345678901234LL);
```

Если при выводе в спецификаторах убрать буквы `ll`, то значение будет отображено некорректно:

```c
printf("value = %d\n", -12345678901234LL);
```

Увидим:

```
value = -1942892530
```

Аналогично и с вещественными типами: `float` автоматически преобразовывается в `double`, поэтому спецификаторы `%f`, `%F`, `%e` и `%E` корректно обрабатывают оба из них. А вот для типа `long double` следует прописывать суффикс в виде заглавной буквы `L`:

`L` – суффикс для типа `long double`.

Например:

```c
long double var_ld = 0.5;
printf("value = %Lf\n", var_ld);
```

Увидим строку:

```
value = 0.500000
```

Но, при использовании спецификатора без суффикса `L`, вывод окажется некорректным:

```c
printf("value = %f\n", var_ld);
```

На выходе:

```
value = -0.000000
```

Так с помощью суффиксов учитываются все базовые типы переменных языка Си.

## Вывод нескольких переменных

Конечно, с помощью функции `printf()` можно выводить сразу несколько переменных в одной форматной строке. 

Делается это очевидным образом. Достаточно указать нужное количество спецификаторов, а затем, перечислить такое же количество переменных или выражений. Например, для вывода трех переменных разного типа:

```c
short var_h = 100;
int var_i = 1024;
long double var_ld = 0.5;
```

Функцию `printf()` можно записать в виде:

```c
printf("var_h = %d, var_i = %d, %Lf\n", var_h, var_i, var_ld);
```

Так как тип `short` преобразуется в тип `int`, то для переменных `var_h` и `var_i` допустимо использовать спецификатор `%d`. А вот для переменной `var_ld` типа `long double` обязательно следует использовать суффикс `L` перед спецификатором вещественного типа. 

В результате обработки этой форматной строки слева-направо, функция `printf()` вместо первого спецификатора `%d` подставит значение из переменной `var_h`; вместо второго `%d` – значение из переменной `var_i`; вместо третьего `%Lf` – значение из переменной `var_ld`. 

И этот порядок всегда такой: в n-й по счету спецификатор подставляется n-я по счету переменная или выражение. В результате, получим вывод в виде строки:

```
var_h = 100, var_i = 1024, 0.500000
```

## Флаги спецификаторов
Каждый спецификатор может быть дополнительно снабжен, так называемыми, флагами, которые предоставляют возможность более тонкой настройки выводимой информации. Ниже в таблице приведены основные из них.

Флаг | Описание
-|-
Десятичное число | Задает минимальную ширину поля выводимой информации.
Знак «-» | Задает выравнивание по левому краю в пределах спецификатора.
Знак «+» | Задает отображение чисел со знаками «+» и «-».
Цифра 0 | Заполнение нулями свободной области в пределах спецификатора.
Пробел | Задает отображение положительных чисел с пробелом в начале и со знаком «-» для отрицательных.
Символ «#» | Задает отображение префикса числа (0x – для шестнадцатеричных; 0 – для восьмеричных).

Давайте посмотрим на конкретных примерах, как можно использовать эти флаги по отдельности и в комбинации с другими флагами. Объявим в программе две переменные `var_i` и `var_d` с некоторыми начальными значениями, а затем выведем их в столбик с шириной поля 10:

```c
#include <stdio.h>
 
int main(void) {
    int var_i = -1283;
    double var_d = 54.34675;
 
    printf("[%10d]\n", var_i);
    printf("[%10f]\n", var_d);
    return 0;
}
```

Я здесь для наглядности прописал две функции `printf()`, хотя, можно было бы обойтись и одним вызовом. Квадратные скобки приведены для обозначения границ полей спецификаторов. После запуска программы увидим:

```
[     -1283]
[ 54.346750]
```

В обоих случаях ширина равна 10 символов и выводимые данные выровнены по правому краю. Можно изменить это поведение и сделать выравнивание по левому краю следующим образом:

```c
printf("[%-10d]\n", var_i);
printf("[%-10f]\n", var_d);
```

Увидим строчки:

```
[-1283     ]
[54.346750 ]
```

Если указанная ширина поля будет меньше размера выводимых данных, то она автоматически будет увеличена до нужных размеров. Например:

```c
printf("[%-5d]\n", var_i);
printf("[%-5f]\n", var_d);
```
Увидим строчки:

```
[-1283]
[54.346750]
```

Если вместо целого числа указывать дробное, то в случае с целыми числами число до точки (12) будет задавать общую ширину вывода, а число после точки (7) – ширину отображаемых данных, которая дополняется нулями:

```c
printf("[%12.7d]\n", var_i);
printf("[%12.2f]\n", var_d);
```

В случае с вещественными числами, значение 12 определяет общую минимальную ширину вывода, а число после точки (2) – точность выводимого значения. После запуска программы увидим:

```
[    -0001283]
[       54.35]
```

Или в таком виде:

```c
printf("[%.7d]\n", var_i);
printf("[%.2f]\n", var_d);
```

Получим вывод:

```
[-0001283]
[54.35]
```

Следующие два флага `#` и `+` работают следующим образом:

```c
printf("[%#X]\n", var_i);
printf("[%+.2f]\n", var_d);
```

Получим:

```c
[0XFFFFFAFD]
[+54.35]
```

И так далее. Чтобы лучше понять, как можно комбинировать разные флаги и какие эффекты при этом получать, попробуйте самостоятельно с ними поэкспериментировать.

### Подвиг 1. Установите соответствия между спецификаторами функции printf() и их описаниями.

![02](/Good_good_C_C++/img/02_08.PNG)

### Подвиг 2. Продолжите программу, которая должна вывести все объявленные переменные (в порядке их объявления) в одну строчку через пробел. Воспользуйтесь для этого функцией printf(). Символьная переменная должна быть выведена как символ.

```c
#include <stdio.h>

int main(void) {
    char ch = 'u';
    short sh = -55;
    int var_i = 1024;
    double var_d = 3.1415;

    printf("%c %d %d %f", ch, sh, var_i, var_d);

    return 0;
}
```

### Подвиг 3. Продолжите программу, которая должна вывести все объявленные переменные (в порядке их объявления) каждую с новой строки. При этом никаких пробелов в выводе быть не должно. Воспользуйтесь для такого форматированного вывода функцией printf(). Символьная переменная должна быть выведена как символ.

```c
#include <stdio.h>

int main(void) {
    char byte = 65;
    unsigned short height = 1055;
    int distance = 1000000;
    float pi = 3.1415f;

    printf("%c\n%d\n%d\n%f", byte, height, distance, pi);

    return 0;
}
```

### Подвиг 4. Установите соответствия между суффиксами спецификаторов функции printf() и их описаниями.

![02](/Good_good_C_C++/img/02_09.PNG)

### Подвиг 5. Продолжите программу, которая должна вывести с помощью функции printf() все объявленные переменные (в порядке их объявления) в одну строчку через пробел. Вещественное число выведите с точностью до десятитысячных (4 знака после запятой).

```c
#include <stdio.h>

int main(void) {
    unsigned height = 12345012;
    long long dist = 1234567890LL;
    long double weight = 45.7845;

    printf("%d %lld %.4Lf", height, dist, weight);

    return 0;
}
```

### Подвиг 6. Установите соответствия между флагами спецификаторов функции printf() и их описаниями.

![02](/Good_good_C_C++/img/02_10.PNG)

### Подвиг 7. Продолжите программу, которая должна вывести с помощью одной функции printf() значения переменных следующим образом:

```
[ -123]
[    6]
[ 1024]
```

(внутри каждой квадратной скобки 5 символов). Для форматного вывода используйте флаги спецификаторов.

P.S. В форматной строке функции printf() не использовать символ пробела.

### Подвиг 8. Продолжите программу, которая должна с помощью функции printf() вывести значение вещественной переменной с точностью до тысячных (три знака после запятой).

```c
#include <stdio.h>

int main(void) {
    double d = 546e-3;

    printf("%.3lf", d);

    return 0;
}
```

### Подвиг 9. Продолжите программу, которая должна с помощью функции printf() вывести текущее время, хранимое в переменных: h - часы; m - минуты; s - секунды в формате:

hh:mm:ss

Например, для h = 12, m = 3, s = 9 должно быть:

12:03:09

(обратите внимание на незначащий ноль, если число меньше 10).

```c
#include <stdio.h>

int main(void) {
    unsigned char h = 11, m = 8, s = 1;

    printf("%02d:%02d:%02d", h, m, s);

    return 0;
}
```

### Подвиг 10. Продолжите программу, которая должна с помощью функции printf() вывести текущее время, хранимое в переменных: h - часы; m - минуты; s - секунды в формате шестнадцатеричных чисел с выводом префикса 0x:

0xhh:0xmm:0xss

Например, для h = 12, m = 3, s = 9 должно быть:

0x0c:0x03:0x09

(обратите внимание на незначащий ноль, если число меньше 16).

```c
#include <stdio.h>

int main(void) {
    unsigned char h = 17, m = 45, s = 5;

    printf("%#04x:%#04x:%#04x", h, m, s);

    return 0;
}
```

Видео по теме [#8. Функция printf() для форматированного вывода](https://www.youtube.com/watch?v=sbdBgONbu88&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

# 2.5 Функция `scanf()` для форматированного ввода

На этом занятии речь пойдет о функции `scanf()`, которая выполняет форматированное чтение данных из стандартного входного потока `stdin`. Эта функция имеет следующее определение (прототип):

```c
int scanf(const char* format, …);
```

Здесь первый параметр `format` – это указатель на форматную строку, на подобие той, что мы рассматривали в функции `printf()`. Последующее троеточие указывает на произвольное число дополнительных параметров, как правило, переменных. Функция возвращает целое значение типа `int`, равное числу прочитанных элементов из входного потока `stdin`.

Чтобы воспользоваться функцией `scanf()` нужно знать, как правильно задавать формат считываемых данных. Для этого, также как и в функции `printf()`, предусмотрены спецификаторы преобразований. Но они несколько иные.

Спецификатор | Описание
-|-
`%d` | Целое число со знаком в десятичной форме. (Приводится к типу int).
`%i` | Целое число в десятичной, шестнадцатеричной или восьмеричной системах. (Приводится к типу int).
`%u` | Целое беззнаковое (unsigned) число в десятичной форме. (Приводится к типу unsigned int).
`%o` | Целое число в восьмеричной форме. (Приводится к типу int).
`%x`, `%X` | Целое число в шестнадцатеричной форме. (Приводится к типу int).
`%f`, `%e`, `%g` <br>`%F`, `%E`, `%G` | Вещественное число. (Приводится к типу float).
`%c` | Символ в соответствии с текущей кодовой таблицей. (Приводится к типу char).
`%s` | Строка (последовательность символов). Читается до первого пробела, перевода строки или символа табуляции.

Существуют и другие спецификаторы, но мы остановимся только на этих. Также спецификатор `%s` для ввода строк рассмотрим позже, когда будем проходить строки.

Самый простой вариант использования функции `scanf()` соответствует чтению отдельных символов из входного потока. Для этого, очевидно, следует использовать спецификатор `%c` следующим образом:

```c
#include <stdio.h>
 
int main(void) {
    char byte;
 
    int count = scanf("%c", &byte);
    printf("count = %d, byte = %c\n", count, byte);
 
    return 0;
}
```

Давайте подробно разберемся, как это работает. Так как в форматной строке записан спецификатор `%c`, то функция `scanf()` читает один байт из буфера входного потока `stdin`. 

Предположим, там находятся числа `100` и `53`. Значит, функция читает первое значение `100`. Далее, необходимо этот байт данных скопировать в переменную `byte`. 

И здесь возникает вопрос, как это сделать? 

Вначале, я напомню, что любая переменная – это непрерывная последовательность байт. 

В нашем примере – это одна ячейка, т.к. переменная `byte` имеет тип `char`. А значение переменной определяется тем, что записано в этих ячейках. То есть, для записи прочитанных данных из входного потока `stdin` в переменную `byte` достаточно в соответствующую ячейку памяти скопировать эти прочитанные данные. 

Именно поэтому функции `scanf()` передается не значение переменной (как это было в функции `printf()`), а адрес переменной. 

Забегая вперед отмечу, что оператор `&` перед именем переменной, как раз и возвращает адрес этой переменной. 

Зная этот адрес, функция `scanf()` имеет возможность менять значение переменной `byte`, записывая определенные данные напрямую в указанную ячейку памяти. Так происходит передача данных из входного потока в указанные переменные с помощью функции `scanf()`.

Если данные были успешно прочитаны и занесены в переменную `byte`, то функция `scanf()` возвратит значение `1`. Это говорит нам, что в одну переменную были успешно занесены данные из потока `stdin`.

Давайте для примера запишем два подряд вызова функции `scanf()` следующим образом:

```c
#include <stdio.h>
 
int main(void) {
    char byte1 = '0', byte2 = '0';
 
    int res1 = scanf("%c", &byte1);
    int res2 = scanf("%c", &byte2);
 
    printf("byte1 = %c, byte2 = %c\n", byte1, byte2);
    
    return 0;
}
```

Если при запуске программы введем сразу два символа, например `cd`, то во входном буфере окажутся эти символы и второй вызов функции `scanf()` автоматически прочитает букву `d`. После запуска программы увидим результат:

```c
byte1 = c, byte2 = d
```

То есть, здесь всегда следует помнить о входном буфере и если в нем имеется какая-либо информация, то последующий вызов функции `scanf()` будет читать эти данные, не ожидая ввода с клавиатуры новых данных.

Конечно, эти два вызова можно объединить в один, например, так:

```c
int res = scanf("%c%c", &byte1, &byte2);
printf("res = %d: byte1 = %c, byte2 = %c\n", res, byte1, byte2);
```

После ввода тех же символов `cd`, увидим строку:

```
res = 2: byte1 = c, byte2 = d
```

Обратите внимание, переменная `res` принимает значение `2`, т.к. данные были успешно записаны в две переменные `byte1` и `byte2`. 

Перед каждой переменной базового типа не забываем прописывать оператор амперсанд.

Пока, я думаю, все понятно. Давайте теперь поставим символ пробела между спецификаторами в форматной строке:

```c
int res = scanf("%c %c", &byte1, &byte2);
```

Этот пробел означает любые пробельные символы, которые могут присутствовать между двумя порциями данных. 

Сразу отмечу, что к пробельным относят символы: пробела, перевода строки, табуляции (и реже некоторые другие). 

Кроме того, этот символ может и вовсе отсутствовать. Например, мы можем ввести с клавиатуры два символа следующими способами:

```
cd; c d; c    d; c\nd; c\td
```

Во всех вариантах будут прочитаны два символа `c` и `d` и занесены в переменные `byte1` и `byte2`. То есть, форматная строка `%c %c` указывает сделать следующее:
+ прочитать первый символ из входного буфера (любой символ),
+ затем, пропустить все пробельные символы
+ и прочитать следующий не пробельный.

А теперь давайте вместо пробела поставим, например, запятую:

```c
int res = scanf("%c,%c", &byte1, &byte2);
```

При таком формате ввода будет ожидаться первый символ (любой), затем обязательно должна идти запятая, а затем еще один любой символ. 

Например, так:

```
c,d
```

А вот если входные данные не соответствуют формату, например:

```
cd
```

то функция `scanf()` успешно прочитает только первый символ, а следующий (второй) оставит во входном потоке, т.к. вместо запятой записана буква `d`. Переменная `res` в этом случае будет равна уже `1`, а в переменной `byte2` останется прежнее значение.

Конечно, мы можем комбинировать разные символы разделители в форматной строке, например, так:

```c
int res = scanf("%c, %c", &byte1, &byte2);
```
Тогда будет читаться первый символ, затем должна идти запятая, возможные пробельные символы, а затем, следующий непробельный символ. То есть, теперь возможны такие варианты ввода данных:

```
c,d; c, d; c,\nd, c,\td и т.п.
```

## Чтение числовых значений из входного потока stdin
Я думаю, с чтением отдельных символов (байт) с помощью функции `scanf()` в целом все понятно. Теперь можно сделать следующий шаг и посмотреть, как выполняется чтение числовой информации из входного потока.

Если данные представлены в виде целых десятичных чисел со знаком, то для этого часто используют спецификатор `%d`. Причем, этот спецификатор приводит целые числа к типу `int`. И это очень важный момент. Сейчас я покажу почему. Запишем нашу программу следующим образом:

```c
#include <stdio.h>
 
int main(void) {
    long long var_lli = 0;
 
    int res = scanf("%d", &var_lli);
    printf("res = %d: var_lli = %lld\n", res, var_lli);
 
    return 0;
}
```

Здесь на входе функция scanf() ожидает целое число со знаком, умещающееся в тип `int`. Если ввести с клавиатуры значение:

```
1234567890
```

то на выходе увидим строку:

```
res = 1: var_lli = 1234567890
```

То есть, все было прочитано успешно. Но, если значение увеличить, например, до:

```
12345678901234
```

то это значение сначала будет приведено к типу `int` и только затем записано в переменную `var_lli` типа `long long`. Поэтому на выходе увидим некорректное значение:

```
res = 1: var_lli = 1942892530
```

Вот почему важно правильно сочетать спецификаторы преобразований с типами переменных.

Для указания в форматной строке функции `scanf()` разных типов входных данных применяются следующие модификаторы, перечисленные в таблице.

Модификатор | Описание
-|-
`h` | `%hd`, `%hi` – для short int;<br>`%hx`, `%ho`, `%hu` – для unsigned short
`hh` | `%hhd` – для signed char;<br>`%hhu` – для unsigned char
`l` | `%ld`, `%li` – для long int;<br>`%lx`, `%lo`, `%lu` – для unsigned long;<br>`%lf`, `%lg`, `%le` – для double
`L` | `%Lf`, `%Lg`, `%Le` – для long double
`ll` (в стандарте C99) | `%lld` – для long long int;<br>`%llu` – для unsigned long long
цифры | Максимальная ширина ввода (либо достигается максимальная ширина, либо служебный символ).
`*` | Пропуск данных.

Например, если нам нужно прочитать очень длинное целое число и сохранить его в типе `long long`, то следует в функции `scanf()` использовать модификатор `%lld`:

```c
int res = scanf("%lld", &var_lli);
```

Теперь, при вводе длинного числа `12345678901234` мы его и увидим в выходной строке:

```
res = 1: var_lli = 12345678901234
```

И так со всеми остальными типами данных. Причем, обратите внимание, спецификаторы `%f`, `%e`, `%g` выполняют преобразование данных к типу `float`, а не `double`, как это делает функция `printf()`. Если в функции `scanf()` используется переменная типа `double`, то для нее следует применять модификаторы `%lf`, `%le`, `%lg`. Например:

```c
#include <stdio.h>
 
int main(void) {
    long long var_lli = 0;
    double var_d = 0;
 
    int res = scanf("%lld %lf", &var_lli, &var_d);
    printf("res = %d: var_lli = %lld, var_d = %.2f\n", res, var_lli, var_d);
 
    return 0;
}
```

В этом случае ожидается ввод сначала целого числа, а затем, вещественного, которое будет приведено к типу `double`. В частности, при вводе значений:

```
123 56.54
```

получим на выходе строку:

```
res = 2: var_lli = 123, var_d = 56.54
```

А вот если в функции `scanf()` будет указан модификатор для типа `float`:

```c
int res = scanf("%lld %f", &var_lli, &var_d);
```

то после ввода тех же значений получим строку:

```
res = 2: var_lli = 123, var_d = 0.00
```

Обратите внимание, что переменная `res` по-прежнему принимает значение `2`, т.к. формально входные данные соответствовали форматной строке, но копирование данных типа `float` в переменную типа `double` не дало ожидаемого результата. И все из-за неверного спецификатора `%f`.

Другие модификаторы подобные работают аналогичным образом. Интересной особенностью обладает модификатор `*`, который позволяет пропускать вводимые данные. Например, мы знаем, что на входе ожидаются данные в формате:


id | price | weight
-|-|-
целое число без знака | целое число | вещественное число

Нас интересуют только поля `price` и `weight`. Причем, будем полагать, что числа записаны через разделитель точка с запятой «;». Это частый формат csv-файла. Так вот, для считывания только двух последних значений форматную строку в функции `scanf()` можно записать следующим образом:

```c
#include <stdio.h>
 
int main(void) {
    unsigned int price = 0;
    double weight = 0.0;
 
    int res = scanf("%*llu; %u; %lf", &price, &weight);
    printf("res = %d: price = %d, weight = %.2f\n", res, price, weight);
 
    return 0;
}
```

Введем с клавиатуры данные:

```
10; 1000; 54.65
```

На выходе получим строку:

```
res = 2: price = 1000, weight = 54.65
```

Как видите, функция `scanf()` возвратила значение `2` и переменные `price`, `weight` принимают правильные значения (последние два).

Первое значение 10 было прочитано, но проигнорировано. Конечно, оно при это должно соответствовать спецификатору `%llu`, то есть, быть десятичным. Если указать, скажем, вещественное значение:

```
10.34; 1000; 54.65
```

то это будет ошибка формата и последующие два числа прочитаны не будут:

```
res = 0: price = 0, weight = 0.00
```

Вот так, в целом, работает функция `scanf()`, которая позволяет читать данные из буфера стандартного входного потока `stdin` данные в указанном формате. При этом считывание останавливается либо после получения всех необходимых данных, либо при ошибке формата ввода. И следует помнить, что ошибочные данные остаются во входном буфере.

Этой информации будет вполне достаточно для большинства практических задач (кроме считывания строк, о которых мы будем говорить позже, когда дойдем до этой темы). Все остальное вам должно быть понятно.

### Подвиг 1. Выберите все верные утверждения, касающиеся функции scanf().

+ [ ] функция scanf() выполняет форматное чтение данных из потока stdout
+ [ ] функция scanf() возвращает число прочитанных байт из входного потока
+ [x] для использования функции scanf() в программе необходимо подключить файл stdio.h
+ [x] функция scanf() возвращает число прочитанных элементов (набора данных для каждой переменной)
+ [x] функция scanf() выполняет форматное чтение данных из потока stdin

### Подвиг 2. Установите соответствия между спецификаторами функции scanf() и их описаниями.

![02](/Good_good_C_C++/img/02_11.PNG)

### Подвиг 3. Выберите все верные утверждения, касающиеся форматной строки функции scanf().

+ [x] пробел в форматной строке означает наличие пробелов, символов табуляции, символов перевода строки
+ [x] форматные строки "%d, %d" и "%d,%d" эквивалентны (одинаковы по действию)
+ [ ] пробел в форматной строке означает наличие только пробелов и символов табуляции
+ [x] если в форматной строке прописаны два спецификатора "%d,%d", то читаются целые числа идущие через запятую (пробельные символы также допустимы после запятой)
+ [x] если в форматной строке прописаны два спецификатора "%d%d", то читаются целые числа идущие через пробельный символ
+ [x] если в форматной строке прописаны два спецификатора "%d %d", то читаются целые числа идущие через пробельный символ
+ [ ] если в форматной строке прописаны два спецификатора "%d%d", то читаются целые числа идущие друг за другом без каких-либо разделительных символов
+ [ ] если в форматной строке прописаны два спецификатора "%d,%d", то читаются целые числа идущие через запятую (пробельные символы недопустимы)
+ [x] если в форматной строке прописаны два спецификатора "%c%c", то читаются два подряд идущих байта из потока stdin
+ [x] если в форматной строке прописан спецификатор "%c", то из входного потока читается текущий байт

### Подвиг 4. Установите соответствия между модификаторами спецификаторов функции scanf() и их описаниями.

![02](/Good_good_C_C++/img/02_12.PNG)

### Подвиг 5. Продолжите программу, в которой из стандартного входного потока с помощью функции `scanf()` необходимо прочитать данные, следующие через пробел, в объявленные переменные a, b, c, d (в порядке их объявления). Вывести прочитанные значения с помощью функции `printf()` в одну строчку через пробел в порядке считывания. Вещественные числа отображать с точностью до сотых.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/2.5.5

```c
#include <stdio.h>

int main(void) {
    int a;
    short b;
    float c;
    double d;

    scanf("%d %hd %f %lf", &a, &b, &c, &d);
    printf("%d %hd %.2f %.2lf", a, b, c, d);

    return 0;
}
```

### Подвиг 6. Продолжите программу, в которой из стандартного входного потока с помощью функции `scanf()` необходимо прочитать два целых числа (в диапазоне [-16000; 16000]), записанных через точку с запятой. Вывести прочитанные значения с помощью функции `printf()` в одну строчку через пробел в порядке считывания.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/2.5.6

```c
#include <stdio.h>

int main(void) {
    int a, b;

    scanf("%d; %d", &a, &b);
    printf("%d %d", a, b);

    return 0;
}
```

### Подвиг 7. Продолжите программу, в которой из стандартного входного потока с помощью функции scanf() необходимо прочитать данные по следующей схеме:

<целое число>, <целое число>, <пропуск вещественного числа>, <вещественное число>

То есть, третье значение заносить в переменную не нужно, оно должно пропускаться. 

Вывести прочитанные значения с помощью функции printf() в одну строчку через пробел в порядке считывания. Вещественные числа отображать с точностью до сотых.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/2.5.7

```c
#include <stdio.h>

int main(void) {
    int a, b;
    float c;

    scanf("%d, %d, %*f, %f", &a, &b, &c);
    printf("%d %d %.2lf", a, b, c);

    return 0;
}
```

### Подвиг 8. Напишите программу, которая читает три числа из потока stdin, каждое записанное с новой строки. При этом, первое число - целочисленное в диапазоне [-64000; 100000], второе и третье - вещественные. Выполните чтение этих чисел с помощью функции scanf() и выведите их на экран в одну строчку через пробел в порядке считывания, причем вещественные числа следует выводить с точностью до сотых (два знака после запятой).

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/2.5.8

```c
#include <stdio.h>

int main(void) {
    int a;
    float b, c;

    scanf("%d %f %f", &a, &b, &c);
    printf("%d %.2lf %.2lf", a, b, c);

    return 0;
}
```

### Подвиг 9. Напишите программу для чтения из входного потока stdin чисел, записанных в одну строчку через запятую, в следующие переменные (в порядке их объявления):

```c
long long var_ll = 0;
long double var_ld = 0.;
short sh = 0;
```

Выведите в выходной поток с помощью функции printf() переменные var_ll и sh в одну строчку через пробел.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/2.5.9

```c
#include <stdio.h>

int main(void) {
    
    long long var_ll = 0;
    long double var_ld = 0.;
    short sh = 0;
    
    scanf("%lld, %Lf, %hd", &var_ll, &var_ld, &sh);
    printf("%lld %d", var_ll, sh);

    return 0;
}
```

### Подвиг 10. Во входном потоке stdin находятся не менее 10 вещественных чисел со значениями температуры по дням, записанных в одну строчку через точку с запятой. Необходимо прочитать первые 10 чисел и вывести в выходной поток stdout последние пять в одну строчку через пробел с точностью до десятых.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/2.5.10

```c
#include <stdio.h>
#define MAX 10
#define OUT 5

int main(void) {
    double temp[MAX] = {0};
    for (int i = 0; i < MAX; i++) {
        scanf("%lf%*c", &temp[i]);
    }
    for (int i = OUT; i < MAX; i++) {
        printf("%0.1lf ", temp[i]);
    }

    return 0;
}
```

```c
#include <stdio.h>
int main(){
    float a,b,c,d,e;
    scanf("%*f; %*f; %*f; %*f; %*f; %f; %f; %f; %f; %f",&a,&b,&c,&d,&e);
    printf("%.1f %.1f %.1f %.1f %.1f",a,b,c,d,e);
}
```

### Подвиг 11. Напишите программу, которая считывает из входного потока два целых числа a, b, записанных в одну строку через пробел. Поменяйте местами значения переменных a и b так, чтобы a принимало значение b, а b принимало значение a. Программу реализовать с добавлением еще одной целочисленной переменной. Выведите значения переменных a и b в консоль в одну строчку через пробел.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/2.5.11

```c
#include <stdio.h>

int main(void) {
    int a, b;
    
    scanf("%d %d", &a, &b);
    int tmp = a;
    a = b;
    b = tmp;

    printf("%d %d", a, b);

    return 0;
}
```

Видео по теме [#9. Функция scanf() для форматированного ввода](https://www.youtube.com/watch?v=jhCddpQ40yw&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

# 2.6 Сложение, вычитание, умножение и деление

## Арифметические операции: сложение, вычитание, умножение и деление

После изучения базовых типов данных, переменных и функций ввода/вывода пришло время познакомиться с арифметическими операциями языка Си. 

Начнем с самых очевидных:

Операция | Обозначение
-|-
Сложение | `+`
Вычитание | `-`
Умножение | `*`
Деление | `/`

Все эти операции можно использовать как бинарные, то есть, слева и справа от них записываются выражения, над которыми выполняется соответствующая операция:

`<левый операнд>` `+` `<правый операнд>`<br>
`<левый операнд>` `-` `<правый операнд>`<br>
`<левый операнд>` `*` `<правый операнд>`<br>
`<левый операнд>` `/` `<правый операнд>`<br>

Здесь левые и правые операнды могут быть любыми выражениями, над которыми можно выполнять соответствующую арифметическую операцию. В самом простом случае – это переменные и числовые литералы.

Обратите внимание, все рассматриваемые арифметические операции являются именно операциями, а не операторами. Это значит, они вычисляют значение и возвращают его. 

Именно поэтому мы можем совершенно свободно присвоить вычисленный результат какой-либо переменной следующим образом:

```c
int result = 10 + 5;
```

Или так:

```c
int result;
result = 10 - 5;
```

Здесь точка с запятой в конце превращает арифметическую операцию в завершенный оператор. 

В частности, это означает, что арифметические операции можно продолжать, пока не встретится символ точка с запятой:

```c
int result = 10 + 5 - 7 * 3;
```

Но обо всем по порядку. Давайте непосредственно в программе посмотрим на работу операций сложения, вычитания и умножения:

```c
#include <stdio.h>
 
int main(void) {
    short a = -5;
    int b = 10;
    float c = 5.4f;
    double d = -6.5;
 
    int res_1 = a + b;
    short res_2 = 100 - b;
    float res_3 = 5.4 - c;
    double res_4 = d * 4;
 
    return 0;
}
```

Вначале идет объявление четырех переменных разных типов с определенными начальными значениями. Затем, эти переменные используются в арифметических операциях наряду с числовыми литералами. 

Наверное, первое, что бросается в глаза, возможность использования смешанных типов данных при арифметических вычислениях. 

Да, язык Си нас в этом не ограничивает, в отличие от некоторых других языков высокого уровня, где смешение типов не допускается. Но возникает вопрос, как это в деталях работает? 

Начнем с первой операции сложения двух целочисленных переменных `a` и `b`. Они имеют разные типы: `short` и `int`. 

Так вот, компилятор языка Си целочисленные значения по умолчанию приводит к единому типу `int` и только потом выполняет их сложение. 

То есть, переменная a будет приведена к типу `int` и мы получаем сложение двух значений одного типа.

Я думаю, вы понимаете, почему переменная a приводится именно к типу `int`? Как мы с вами уже говорили, тип `int` может превышать по размеру тип `short`, то есть, он является более общим и наиболее употребительным для представления целых числовых значений. Когда меньший тип приводится к большему, такая операция называется __повышением__ типа.

Конечно, в общем случае, типа `int` может быть недостаточно, например, когда используются очень большие числовые значения. В этом случае компилятор повышает тип до `long` или `long long` так, чтобы не происходило потери данных при их представлении.

В следующей строчке программы записана операция вычитания:

```c
short res_2 = 100 - b;
```

Здесь все работает аналогичным образом. 

Литерал `100` по умолчанию представляется типом `int`, переменная `b` также имеет тип `int` и результат тоже сохраняется в памяти как число типа `int`. 

А далее, полученное значение типа `int` присваивается переменной `res_2` типа `short`. 

Перед присваиванием также происходит приведение типов, в данном случае значение int к типу `short`, т.к. тип переменной `res_2` компилятор поменять самовольно не может. 

В результате получаем операцию понижения типа, которая может привести к потере данных, если присваиваемое значение не укладывается в меньший по размеру тип `short`. 

Вот на это всегда следует обращать внимание, при реализации арифметических операций. Как только встречается понижение типа данных, потенциально возможна потеря данных.

В следующей строчке:

```c
float res_3 = 5.4 - c;
```

мы тоже видим понижение типа от `double` к `float`. Как мы помним, числовой литерал вещественного числа представляется типом `double`. Переменная c также приводится к типу `double` и результат вычитания сохраняется на уровне этого типа данных. После этого, значение `double` присваивается переменной `res_3` меньшего типа `float`. Снова имеем понижение типов и потенциальную возможность потери данных. Поэтому, чаще всего на практике вещественные числа описываются типом `double`, чтобы избежать подобных преобразований.

Наконец, последняя строчка:

```c
double res_4 = d * 4;
```

Здесь вещественное число `d` типа `double` умножается на целочисленное значение `4`. Строго говоря, компьютер не умеет выполнять арифметические операции с вещественными и целыми числами. В нем реализована арифметика либо над целыми, либо над вещественными числами, не смешивая их. Поэтому здесь число `4` сначала будет приведено к более общему типу `double`, и только потом выполнена операция умножения над вещественными числами.

И у нас остается еще одна операция деления. Я думаю, вы теперь легко поймете принцип ее работы. Запишем ее в нескольких вариациях:

```c
#include <stdio.h>
 
int main(void) {
    short a = -5;
    int b = 10;
    float c = 5.4f;
    double d = -6.5;
 
    int res_1 = 7 / 2;      /* 3 */
    double res_2 = -9 / 2;     /* -4 */
    float res_3 = a / c;    /* -0.9259... */
    double res_4 = d / b;   /* -0.65 */
 
    return 0;
}
```

Смотрите, когда происходит деление двух целочисленных значений, то результат также получается целочисленным. 

Причем, в соответствии со стандартом C99, дробная часть просто отбрасывается.

Именно так образуются целые значения. 

То есть, здесь нет округления по правилам математики, а просто отбрасывание дробной части, какой бы она ни была. 

Это следует запомнить. 

Если же один из операндов является вещественным значением, то все числа приводятся к типу `double` и после этого выполняется операция деления. Поэтому переменные `res_3` и `res_4` принимают дробные значения.

## Операция приведения типов

Вот такой нюанс есть у операции деления в языке Си и начинающие программисты здесь очень часто совершают ошибки, когда делят два целых числа, ожидая получить вещественное значение. В действительности же происходит обычное целочисленное деление. И здесь может возникнуть вопрос: а как нам разделить две целочисленные переменные, чтобы получилось вещественное число? То есть, ситуация выглядит следующим образом:

```c
#include <stdio.h>
 
int main(void) {
    short a = -5;
    int b = 10;
 
    double res_1 = a / b;      /* 0 */
 
    return 0;
}
```

Для этого необходимо одну, а лучше обе переменные привести к вещественному типу `double`, используя операцию приведения типов:

```c
double res_1 = (double)a / (double)b;      /* -0.5 */
```

То есть, перед выражением (в данном случае переменной) в круглых скобках указывается тип, к которому должны быть приведены данные. В нашем примере значения переменных `a` и `b` сначала приводятся к типу `double`, а затем, выполняется операция деления над вещественными числами. Как результат получаем вещественное значение `-0,5`.

Если же мы оперируем конкретными числовыми значениями, например:

```c
double res_2 = 7 / 2;
```

то для получения вещественного значения их удобнее записать в виде вещественных чисел:

```c
double res_2 = 7.0 / 2.0;
```

вместо того, чтобы приводить целые числа к вещественному типу.

## Унарные операции `-` и `+`

Далее, операции `+` и `-` можно использовать не только как бинарные, но и как унарные, то есть, перед выражением ставить знаки минус и плюс следующим образом:

```c
#include <stdio.h>
 
int main(void) {
    short a = -5;       // -5
    int b = -a;         // 5
    int d = -(7 + a);   // -(7 + -5) = -2
 
    return 0;
}
```

В первом случае знак минус стоит перед числовым литералом `5` и определяет его как отрицательное число, которое, затем, присваивается переменной `a`. 

В следующей строчке минус указан перед переменной и инвертирует знак числового значения, которое присваивается переменной `b`. При этом значение в переменной `a` не меняется. 

Наконец, в третьей строчке унарный минус поставлен перед выражением `(7 + a)`.

Соответственно, сначала вычисляется операция внутри скобок, а затем, выполняется инвертирование знака.

По аналогии можно использовать и унарный плюс, хотя, на практике он почти никогда не используется, т.к. по умолчанию значения определяются как положительные и лишний раз подчеркивать этот факт не имеет особого смысла.

## Приоритеты арифметических операций

Важно знать, что приоритет любой унарной операции в языке Си выше, чем бинарной. Например, в следующей строчке:

```c
int res = -10 + 7;
```

сначала будет выполнен унарный минус и только после этого бинарная операция сложения. Или так:

```c
int res = -10 * 7;
```

Здесь также сначала унарный минус будет применен к числу `10` и только после этого выполнится бинарная операция умножения.

Если рассматривать бинарные арифметические операции, то сначала выполняются умножение и деление, а затем, сложение и вычитание. 

То есть, приоритет операций умножения и деления выше, чем у сложения и вычитания. Здесь все ровно так, как нас учат в школе на уроках математики. Например:

```c
short a = -5, b = 7, c = 4;
double D = b * b - 4 * a * c;
```

Сначала вычисляются умножения, а затем, бинарная операция вычитания. 

Причем, обратите внимание, порядок вычисления первого умножения `b * b` и второго `4 * a * c` стандартом языка Си не определен. 

Разработчики компиляторов могут делать это в произвольном порядке с целью повышения скорости работы программы. 

Поэтому нет гарантии, что сначала вычислится `b * b` и только потом `4 * a * c`.

Порядок может быть другим. 

Это очень важный момент. А вот порядок вычисления подряд идущих арифметических операций с одинаковым приоритетом всегда выполняется слева-направо. 

То есть в выражении `4 * a * c` сначала будет выполнено первое умножение и только потом – второе. В этом мы можем быть уверены. Поэтому запись вида:

```c
double res = 5 / 3 * 2;
```

означает, что сначала `5` делится на `3` и результат умножается на `2`. 

Это эквивалентно выражению `(5 / 3) * 2`. 

Иногда путаются и считают, что оно соответствует выражению `5 / (3 * 2)`. Но это неверно из-за строго порядка вычислений слева-направо.

Если нужно изменить порядок вычислений, то есть, приоритеты, то для этого используются круглые скобки, например, следующим образом:

```c
int perimetr = 2 * (b + c);
```

Сначала будет вычислено выражение внутри скобок и только потом умножение на два.

В заключение этого занятия приведу простой пример программы, которая запрашивает два числа и на их основе вычисляет площадь треугольника:

```c
#include <stdio.h>
 
int main(void) {
    double height, a;
    
    printf("Enter the height and length of the triangle's base: ");
    int res = scanf("%lf %lf", &height, &a);
 
    if(res != 2) {      // проверка, что res не равна двум
        printf("Data entry error\n");
        return 0;       // завершение функции main и программы
    }
 
    double sq = height * a / 2.0;
    printf("The square of the triangle is: %.2f", sq);
 
    return 0;
}
```

Вначале с помощью функции `scanf()` осуществляется ввод высоты и основания треугольника, затем, проверка, что данные были прочитаны корректно. 

Для этого, забегая вперед, я воспользовался условным оператором `if`, в котором проверяю, что переменная `res` не равна двум. Если это так, значит, произошла ошибка ввода значений. В этом случае выводится сообщение об ошибке в консоль и программа завершается. 

Если же данные введены верно, то вычисляется площадь треугольника и это значение выводится в консоль. Как видите, все достаточно просто.

На следующем занятии мы продолжим эту тему и рассмотрим следующую (заключительную) группу арифметических операций, а также особенности их работы.

Видео по теме  [#9. Функция scanf() для форматированного ввода](https://www.youtube.com/watch?v=jhCddpQ40yw&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, касающиеся арифметических операций языка Си.

+ [x] приоритет унарной операции всегда выше бинарной
+ [x] для изменения приоритетов арифметических операций используются круглые скобки
+ [x] порядок вычисления арифметических операций одного приоритета (например: `2-3+6`) выполняется строго слева-направо
+ [x] в выражении `-1*2 + 3*4*5` порядок вычисления слагаемых `(-1*2 и 3*4*5)` не определен стандартом языка Си
+ [ ] в выражении `-1*2 + 3*4*5` порядок вычисления слагаемых `(-1*2 и 3*4*5)` выполняется строго слева-направо
+ [x] приоритет операций сложения и вычитания ниже, чем умножения и деления
+ [ ] приоритет унарной операции всегда ниже бинарной
+ [ ] порядок вычисления арифметических операций одного приоритета (например: `2-3+6`) не определен стандартом языка Си

### Подвиг 2. Пусть имеется следующий фрагмент программы:

```c
signed char byte = -55;
double res = byte + 1;
```

Выберите все верные утверждения, касающиеся этого фрагмента.

+ [ ] при сложении число 1 приводится к типу signed char
+ [x] так как приоритет операции присваивания наименьший, то сначала выполняется сложение, а затем, присваивание
+ [x] в момент присваивания переменной res вычисленное значение приводится к типу double
+ [x] при сложении значение переменной byte преобразуется к типу int

### Подвиг 3. Продолжите программу, в которой выполняется вычисление значения:

$6\cdot(\dfrac{1}{3})^2 −15 \cdot \dfrac{1}{3}$
​

Результат выведите в консоль с точностью до сотых.

```c
#include <math.h>
#include <stdio.h>

int main(void) {
    double res = 6.0 * pow(1.0 / 3.0, 2) - 15.0 / 3.0;
    printf("%.2lf", res);
    return 0;
}
```

### Подвиг 4. Продолжите программу, в которой выполняется чтение данных из входного потока stdin в целочисленные переменные h и w, записанные в одну строчку через пробел. Необходимо вычислить частное h деленное на w с получением корректного вещественного значения. Выведите с помощью функции printf() полученный результат в выходной поток stdout с точностью до сотых.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/2.6.4

```c
#include <stdio.h>

int main(void) {
    int h, w;
    scanf("%d %d", &h, &w);

    double res = (double)h / (double)w;
    printf("%.2lf", res);

    return 0;
}
```

### Подвиг 5. В программе вводится (из потока stdin) одно целое значение в переменную count. Необходимо увеличить значение этой переменной на единицу (используя рассмотренные арифметические операции) и вывести результат в консоль.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/2.6.5

```c
#include <stdio.h>

int main(void) {
    int count = 0;
    scanf("%d", &count);

    printf("%d", count + 1);

    return 0;
}
```

### Подвиг 6. В программе вводится (из потока stdin) одно целое значение в переменную total. Необходимо уменьшить значение этой переменной на два (используя рассмотренные арифметические операции) и вывести результат в консоль.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/2.6.6

```c
#include <stdio.h>

int main(void) {
    int total = 0;
    scanf("%d", &total);

    printf("%d", total - 2);

    return 0;
}
```

### Подвиг 7. В программе вводятся (из потока stdin) два значения арифметической прогрессии в переменные a1 и a50. Необходимо вычислить сумму первых 50-ти членов этой прогрессии, используя формулу:

$S_n = \dfrac{a_1+a_{50}}{2} \cdot 50$

Результат вывести в консоль в виде целого числа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/2.6.7

```c
#include <stdio.h>

int main(void) {
    int a1;   // первый член прогрессии
    int a50;  // 50-й член прогрессии

    scanf("%d, %d", &a1, &a50);

    int res = (int)(a1 + a50) / 2.0 * 50;
    printf("%d", res);
    return 0;
}
```

### Подвиг 8. В программе вводятся (из потока stdin) два значения геометрической прогрессии в переменные b1 и q. Необходимо вычислить сумму первых четырех (n = 4) членов этой прогрессии, используя формулу:

$S_n = \dfrac{(q^n − 1)  \cdot b_1}{q−1}$
​
 

Результат вывести в консоль в виде целого числа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/2.6.8

```c
#include <math.h>
#include <stdio.h>

int main(void) {
    int b1;  // первый член прогрессии
    int q;   // знаменатель прогрессии

    scanf("%d, %d", &b1, &q);

    int res = (int)(pow(q, 4) - 1) * b1 / (q - 1);
    printf("%d", res);
    return 0;
}
```

### Подвиг 9. Напишите программу, которая читает из входного потока сторону равностороннего треугольника длиной a (целое число в диапазоне [1; 100]) и вычисляет радиус вписанной в него окружности по формуле:

$r= \dfrac{\sqrt{3} \cdot a}{6}$

Результат вывести в консоль в виде вещественного числа с точностью до тысячных.

P.S. Корень из трех возьмите равным $1.732$.

```c
#include <math.h>
#include <stdio.h>

int main(void) {
    int a;

    scanf("%d", &a);

    double res = sqrt(3.0) * a / 6;

    printf("%.3lf", res);
    return 0;
}
```

### Подвиг 10. Напишите программу, которая читает из входного потока радиус окружности R (вещественное число) и вычисляет длину этой окружности по формуле:

$length=2⋅π⋅R$

Результат вывести в консоль в виде вещественного числа с точностью до тысячных.

P.S. Константу `pi` возьмите равной 3.1415.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/2.6.10

```c
#include <stdio.h>
#define PI 3.1415

int main(void) {
    double R;

    scanf("%lf", &R);

    double res = 2 * PI * R;

    printf("%.3lf", res);
    return 0;
}
```

### Подвиг 11. Напишите программу, которая читает из входного потока основания a, b и высоту h трапеции (целые числа в диапазоне [1; 100]), записанные в одну строчку через запятую. Необходимо вычислить площадь этой трапеции по формуле:

$S = \dfrac{(a+b)⋅h}{2}$
​
 

и результат вывести в консоль в виде вещественного числа с точностью до десятых.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/2.6.11

```c
#include <stdio.h>

int main(void) {
    int a, b, h;

    scanf("%d, %d, %d", &a, &b, &h);

    double res = (a + b) * h / 2.0;

    printf("%.1lf", res);
    return 0;
}
```

### Подвиг 12 (на повторение). Установите соответствия между спецификаторами функции printf() и их описаниями.

![02](/Good_good_C_C++/img/02_13.PNG)

Видео по теме [#10. Арифметические операции: сложение, вычитание, умножение и деление](https://www.youtube.com/watch?v=DjEPQw-Nxqo&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

# 2.7 Операции деления по модулю, инкремента и декремента

## Арифметические операции деления по модулю, инкремента и декремента

Мы продолжаем изучение арифметических операций. На этом занятии речь пойдет о следующих:

Операция | Обозначение
-|-
Деление по модулю | `%`
Инкремент | `++`
Декремент | `--`

Начнем с операции деления по модулю, которая имеет тот же приоритет, что и операции умножения и деления. Она вычисляет остаток от деления двух целых значений (с вещественными числами данный оператор не работает). Например:

```c
#include <stdio.h>
 
int main(void) {
    int res = 10 % 3;
    printf("res = %d\n", res);
 
    return 0;
}
```

После запуска программы увидим значение `1` переменной `res`. Как это работает?



Смотрите, значение `3` трижды умещается в число `10` и остается еще единица. Эта единица и есть результат вычисления оператора деления по модулю. Аналогично, если взять два других целых числа, например:

```c
int res = 10 % 4;
```

то увидим значение `2`. И так для любых двух целых положительных чисел.

Ситуация кардинально не меняется и при использовании отрицательных целых чисел. Имеем здесь следующие комбинации и результаты вычислений в соответствии со стандартом `C99`:

```c
int res_1 = -10 % 4;    // -2
int res_2 = 10 % -4;    // 2
int res_3 = -10 % -4;   // -2
```

Запомнить просто: если левый операнд отрицателен, то и результат отрицательный, иначе получаем положительное значение вне зависимости от знака правого операнда.

Внимательный слушатель может заметить, что эту же операцию деления по модулю можно реализовать на основе уже известных нам операций вычитания, деления и умножения для положительных целых чисел следующим образом:

```c
int res_4 = 10 - 10 / 4 * 4;    // 2
```

Но все же лучше использовать операцию `%`, т.к. она компактнее записывается и эффективнее реализуется на уровне машинного кода, чем несколько операций деления, умножения и вычитания.

Ну и, наконец, самый главный вопрос, зачем вообще нужна эта операция? В каких задачах ее целесообразно использовать? 

На самом деле, здесь все упирается в чистую математику. 

Но есть несколько приемов, где эта операция используется довольно часто. 

Например, нам в программе нужно определить, является ли число четным или нечетным. Сделать это можно следующим образом:

```c
#include <stdio.h>
 
int main(void) {
    int digit;
    scanf("%d", &digit);
 
    int res = digit % 2;
    printf("res = %d\n", res);
 
    return 0;
}
```

Сначала в переменную `digit` вводится некоторое целое значение. После этого вычисляется остаток от деления на `2` и результат сохраняется в переменной `res`. Очевидно, если переменная `res` будет равна `1` или `-1`, то число в `digit` нечетное, а если `res` равна `0`, то четное.

Следующий пример. Возьмем ту же программу, но поставим другую цель: мы бы хотели диапазон значений переменной `digit` ограничить некоторым целым значением `range`. Сделать это также можно с помощью операции деления по модулю:

```c
#include <stdio.h>
 
int main(void) {
    int digit;
    scanf("%d", &digit);
 
    int range = 10;
    int length = digit % range;     // [0; range-1]
    printf("length = %d\n", length);
 
    return 0;
}
```

В итоге переменная `length` будет принимать значения, не выходящие за диапазон $[0; range-1]$.

Наконец, еще один общий математический пример использования операции деления по модулю. Предположим, что в переменной `time` хранится время в секундах. Наша задача представить его в формате:

```
часы : минуты : секунды
```

Сделать это можно следующим образом:

```c
#include <stdio.h>
 
int main(void) {
    unsigned int time = 4*3600 + 32*60 + 18;
 
    unsigned int sec = time % 60;
    unsigned int min = (time / 60) % 60;
    unsigned int hour = time / 3600;
 
    printf("%02d:%02d:%02d\n", hour, min, sec);
 
    return 0;
}
```

Как видите, арифметическая операция деления по модулю бывает весьма полезной при разработке программ на языке Си.

## Операции инкремента и декремента

Следующая группа арифметический операций – это инкремент и декремент. Работают они схожим образом, только операция инкремента увеличивает значение на единицу, а декремента – уменьшает на единицу. Начнем с инкремента.

Формально, инкремент определяется оператором `++`, который можно прописывать у любого изменяемого выражения (как говорят, `l-value`). Часто это обычные переменные. Например, следующим образом:

```c
#include <stdio.h>
 
int main(void) {
    int count = 0;
 
    printf("count = %d\n", count);
    count++;
    printf("count = %d\n", count);
 
    return 0;
}
```

Вначале значение переменной `count` равно нулю, а затем, с помощью операции инкремент, ее значение увеличивается на единицу.

На самом деле, в нашем примере эту же операцию можно было бы записать и в таком виде:

```c
count = count + 1;
```

Суть от этого не поменялась бы. Но между этими двумя записями есть существенные отличия. Ранние компиляторы языка Си (без оптимизаторов) переводили операцию инкремента в виде одной машинной команды, а вторую аналогичную конструкцию – в набор из нескольких команд. 

В результате, программы с использованием записи вида `count = count + 1` работали несколько дольше. 

Хотя в наше время компиляторы достаточно «сообразительные» чтобы такие команды эффективно транслировать в машинный код. Но, теме не менее, вариант инкремента более предпочтителен и, как мы далее увидим, обладает дополнительными возможностями.

Второй момент отличия этих конструкций заключается в том, что при использовании оператора инкремента переменная `count` фигурирует в операторе только один раз, тогда как в команде `count = count + 1` дважды. 

Сейчас вам это может показаться несущественным, но в действительности, если вместо переменной используется некоторое вычисляемое выражение и оно может меняться при каждой записи, то вариант `count = count + 1` к нему будет просто неприменим.

Итак, на данный момент вы должны просто запомнить, что для увеличения или уменьшения значения на единицу лучше использовать операции инкремента и декремента соответственно.

Далее, эти операции можно записывать в двух формах: префиксной и постфиксной:

```c
count++;    // постфиксная форма
++count;    // префиксная форма
```

В чем между ними разница? Если в нашей программе использовать или первую или вторую запись, то это никак не скажется на результатах ее работы. Но, если операция инкремента участвует в более сложном выражении, то отличия становятся очевидными. Для демонстрации отличий я приведу следующий программный код:

```c
#include <stdio.h>
 
int main(void) {
    int count = 0, size = 5;
 
    int current = count++;
    int width = ++size;
 
    printf("count = %d, size = %d, current = %d, width = %d\n", 
                                    count, size, current, width);
 
    return 0;
}
```

+ Вначале определены две переменные `count` и `size` с начальными значениями `0` и `5`. 
+ Затем, объявляется переменная `current`, которой присваивается значение переменной `count`, записанной с операцией инкремента в постфиксной форме. 
+ Следом объявляется еще одна переменная `width`, которой присваивается значение переменной `size` с операцией инкремента в префиксной форме. После запуска программы на экране увидим следующую строку:

    ```c
    count = 1, size = 6, current = 0, width = 6
    ```
    + Во-первых, обе переменные `count` и `size` были увеличены на единицу, что и должно было произойти. 
    + А вот дальше видим отличия:
        + переменная `current` принимает значение `0`,
        + а переменная `width` – значение `6`. 
        
        Почему так произошло? 

Очевидно, что операций инкремента, записанная в постфиксной форме, срабатывает после использования переменной `count`. 
+ То есть, сначала была выполнена операция присваивания нулевого значения переменной `current`
+ и только после этого в переменной `count` значение было увеличено на единицу. 

Именно так работает инкремент в постфиксной форме записи. 

Во втором случае инкремент записан перед переменной и срабатывает до ее использования в арифметических и других операциях. 

Поэтому, сначала было увеличено значение переменной `size` на единицу и только после этого число `6` было присвоено переменной `width`. Вот так работает инкремент в префиксной и постфиксной формах записи. По аналогии отрабатывает и операция декремента.

Операции инкремента и декремента являются унарными и имеют очень высокий приоритет среди остальных арифметических операций. Например, если записать выражение вида:

```c
int p = 2 * size++;
int r = 3 * --width;
```

+ То в первом случае сначала два будет умножено на `size`, а затем, `size` увеличена на единицу. 
+ Во второй строчке сначала переменная `width` уменьшается на единицу и только потом умножается на три. Кстати, если записать следующее выражение:

```c
int p = width * size++;
```

то здесь также сначала будет выполнено умножение и только потом увеличение переменной `size` на единицу. А вот если заключить переменные в круглые скобки:

```c
int p = (width * size)++;
```

то при компиляции программы появится ошибка недопустимого леводопустимого (`l-value`) выражения. 

Дело в том, что операции инкремента и декремента могут быть применены лишь к изменяемой области памяти, например, переменным. Тогда как произведение (`width * size`) следует воспринимать как промежуточное константное значение, которое нельзя изменить с помощью операции инкремента. 

Это все равно, что записать инкремент у числового литерала:

```c
int p = 100++;
```

также увидим ошибку при компиляции.

Да, в языке Си очень много нюансов, которые следует знать и начинающие программисты часто совершают нелепые ошибки. Хотя и умудренные опытом разработчики также делают не мало ошибок, особенно, при работе с указателями и выделением памяти. 

Как я говорил в самом начале, язык Си предоставляет нам большую свободу и богатый функционал, но взамен требуется очень высокая ответственность при написании программного кода. Как пример приведу следующий фрагмент вычисления:

```c
int width = 5;
int size = width * width + 2 * (10 + width--);
```

Спрашивается, чему будет равна переменная `size`? В действительности, на этот вопрос нет ответа, т.к. компилятор может вначале вычислить значение в скобках и уменьшить значение `width`, а затем перейти к вычислению квадрата `width * width`. 

Или, наоборот, сначала вычислится квадрат, а затем, все остальное. 

То есть, такая конструкция – источник потенциальных ошибок и некая запрограммированная уязвимость в коде. Следует избегать на практике совместного использования операций инкремента или декремента, если переменная несколько раз присутствует в одном и том же выражении. И тем более, если операции `++` и `–` используются несколько раз с одной и той же переменной:

```c
int res = ++width * width + 2 * (10 + width--);
```

Предугадать, как поведет себя этот оператор после компиляции, не возьмется ни один благоразумный программист. 

Здесь следует придерживаться простого правила: по возможности, все операции инкремента и декремента лучше выносить за пределы составных арифметических выражений. 

Как пример, вычисление переменной `size` было бы правильнее выполнить следующим образом:

```c
int size = width * width + 2 * (10 + width);
width--;
```

<hr>

[Содержание](#содержание)

## Заключение 7
По итогам двух занятий вы должны на данный момент хорошо себе представлять, как работают следующие арифметические операции:

Операция | Обозначение | Приоритет
-|-|-
Сложение | `+` | `1`
Вычитание | `-` | `1`
Умножение | `*` | `2`
Деление | `/` | `2`
Деление по модулю | `%` | `2`
Инкремент | `++` | `3`
Декремент | `--` | `3`

Здесь условно приоритет обозначен числами: чем выше число – тем выше приоритет.

На следующем занятии продолжим эту тему и поговорим о возможных сокращениях рассмотренных арифметических операций.

Видео по теме [#11. Арифметические операции деления по модулю, инкремента и декремента](https://www.youtube.com/watch?v=x7HeGJowsW8&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Укажите приоритеты арифметических операций.

P.S. Приоритет 1 - самый низкий; 3 - самый высокий.

### Подвиг 2. Продолжите программу, в которой выполняется чтение целочисленного неотрицательного значения в переменную angle (угол). Необходимо представить угол angle в диапазоне [0; 359]. То есть, все значения в 360 вычесть из переменной angle.

Например:

```
angle = 540; 540 - 360 = 180;
angle = 800; 800 - 2*360 = 80.
```

Результат вывести в консоль в виде одного полученного целого числа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/2.7.2

```c
#include <stdio.h>

int main(void) {
    int angle;
    scanf("%d", &angle);

    int res = angle % 360;
    printf("%d", res);
    return 0;
}
```

### Подвиг 3. На плоскости размером rect_width на rect_height (ширина x высота) размещены непересекающиеся прямоугольники одинаковых размеров w x h, следующих друг за другом, как показано на рисунке ниже.

![02](/Good_good_C_C++/img/02_14.png)

Необходимо продолжить программу, вычислив оставшуюся ширину и высоту не покрытую целыми прямоугольниками. Результат вывести в консоль в виде двух целых чисел в одну строчку через пробел.

```c
#include <stdio.h>

int main(void) {
    int rect_width = 1280, rect_height = 720;
    int w = 8, h = 8;
    scanf("%d; %d", &w, &h);

    int res_w = rect_width % w;
    int res_h = rect_height % h;

    printf("%d %d", res_w, res_h);

    return 0;
}
```

### Подвиг 4. Необходимо продолжить программу, которая складывает время, указанное в часах, минутах и секундах. Исходное время хранится в переменных time_h, time_m, time_s, а добавляемое - в переменных h, m, s. Гарантируется, что сумма времен не превышает одни сутки. Вывести полученное суммарное время в консоль в формате:

```
hh:mm:ss
```

Например:

```
12:05:09
```

(обратите внимание на наличие незначащих нулей при выводе чисел меньше 10).

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/2.7.4

```c
#include <stdio.h>

int main(void) {
    unsigned short time_h = 10;  // часы
    unsigned short time_m = 33;  // минуты
    unsigned short time_s = 5;   // секунды

    unsigned short h, m, s;  // добавляемое время: h - часы; m - минуты; s - секунды
    scanf("%hu; %hu; %hu", &h, &m, &s);

    int total_time = time_s + s + (time_m + m) * 60 + (time_h + h) * 3600;

    unsigned short total_h = total_time / 3600;
    unsigned short total_m = (total_time - total_h * 3600) / 60;
    unsigned short total_s = total_time % 60;

    printf("%02hu:%02hu:%02hu", total_h, total_m, total_s);

    return 0;
}
```

### Подвиг 5. Отметьте все верные выражения использования операций инкремента и декремента.

P.S. В выражениях `b` и `d` - переменные.

+ [ ] (d + 10)++;
+ [ ] --(b + d);
+ [x] d++;
+ [ ] 10++;
+ [x] --b;
+ [x] ++(b);
+ [ ] (b++)++;

### Подвиг 6. В программе записано следующее вычисляемое выражение:

```c
int size = 10;
int res = (size - 1) * 5 + (++size - 1) * 2;
```

Какое значение будет принимать переменная `res`?

+ [ ] операцию инкремента нельзя использовать совместно с другими арифметическими операциями
+ [x] неопределенное (может быть разное в зависимости от используемых компиляторов)
+ [ ] 65
+ [ ] 70

### Подвиг 7. В программе записано следующее вычисляемое выражение:

```c
int size = 10, w = 8;
int res = size++ * w + 20;
```
Какое значение будет принимать переменная `res`?

+ [ ] операцию инкремента нельзя использовать совместно с другими арифметическими операциями
+ [x] 100
+ [ ] неопределенное (может быть разное в зависимости от используемых компиляторов)
+ [ ] 108

### Подвиг 8. Напишите программу, которая читает из стандартного входного потока вещественное значение в некоторую переменную. Затем, запишите функцию printf(), в которой сразу уменьшите значение переменной на единицу и выведите в консоль с точностью до десятых.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/2.7.8

```c
#include <stdio.h>

int main(void) {
    double a;
    scanf("%lf", &a);

    printf("%.1lf", --a);
    return 0;
}
```

### Подвиг 9. Напишите программу, которая читает из стандартного входного потока два целых значения, записанных через запятую, в две переменные h и w. Затем, запишите функцию printf(), в которой сразу вычислите произведение этих двух переменных, увеличенных на единицу (то есть, значение каждой переменной сначала увеличивается на 1, а затем, они перемножаются) и выведите результат в консоль в виде одного целого числа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/2.7.9

```c
#include <stdio.h>

int main(void) {
    int h, w;
    scanf("%d, %d", &h, &w);

    printf("%d", ++h * ++w);
    return 0;
}
```

### Подвиг 10 (на повторение). На плоскости размером rect_width x rect_height (ширина x высота) размещены непересекающиеся прямоугольники одинаковых размеров w x h, следующих друг за другом, как показано на рисунке ниже.

![02](/Good_good_C_C++/img/02_14.png)

Необходимо продолжить программу, вычислив общее число прямоугольников целиком умещающихся на плоскости. Результат вывести в консоль в виде одного целого числа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/2.7.10

```c
#include <stdio.h>

int main(void) {
    int rect_width = 640, rect_height = 480;
    int w = 1, h = 1;
    scanf("%d; %d", &w, &h);

    int res = (rect_width / w) * (rect_height / h);
    printf("%d", res);

    return 0;
}
```

# 2.8 Арифметические операции `+=`, `-=`, `*=`, `/=`, `%=`

Видео по теме [#12. Арифметические операции +=, -=, *=, /=, %=](https://www.youtube.com/watch?v=RAKwrjVXRbc&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

На прошлых занятиях мы с вами подробно познакомились с работой следующих арифметических операций:

Операция | Обозначение | Приоритет
-|-|-
Сложение | `+` | `1`
Вычитание | `-` | `1`
Умножение | `*` | `2`
Деление | `/` | `2`
Деление по модулю | `%` | `2`
Инкремент | `++` | `3`
Декремент | `--` | `3`

Так вот на практике первые пять из них довольно часто используются (помимо всего прочего) для изменения существующего значения, например, переменной. 

О чем здесь речь? Давайте предположим, что имеется целочисленная переменная с именем `count` и начальным значением 1:

```c
#include <stdio.h>
 
int main(void) {
    int count = 1;
 
    return 0;
}
```

Наша задача изменить ее, скажем, увеличить на три. Очевидно, сделать это можно следующим образом:

```c
count = count + 3;
```

Вначале будет взято значение `1` из переменной `count`, затем, операция сложения вычислит выражение `1+3` и полученное значение `4` присвоится переменной `count`. В результате она будет увеличена на `3`.

Но это же самое действие в языке Си можно записать и в более краткой форме, а именно:

```c
count += 3;
```

В данном случае результат действия операции `+=` будет эквивалентно предыдущей строчке программы, то есть, значение переменной count увеличится на `3`.

На первый взгляд кажется, что операция `+=` просто подменяет собой запись из операций сложения и последующего присваивания (`count = count + 3`). Однако между этими действиями есть существенное различие. В операторе:

```c
count = count + 3;
```

переменная count указана дважды, тогда как в операторе:

```c
count += 3;
```

только один раз. Казалось бы, какая разница сколько раз прописывать переменную в операторах? 

И вы будете совершенно правы, если речь идет об обычных переменных. 

Однако язык Си позволяет выполнять арифметические операции не только с переменными, но вообще с любыми леводопустимыми (`l-value`) выражениями. Например:


`<выражение l-value>` = `<выражение l-value>` + 1;<br>
`<выражение l-value>` += 1;

Так вот, выражение `l-value` вполне может при каждом обращении к ней (то есть, вычислении) выдавать разные области памяти. Тогда в первом случае будет получаться один результат, а во втором – другой. 

Как пример, выражение `l-value` может быть массивом, а его индексы каждый раз вычисляются при обращении к нему через некоторую функцию. Забегая вперед, формально, это можно записать так:

```c
ar[get_indx()] = ar[get_indx()] + 1;
ar[get_indx()] += 1;
```

В зависимости от работы функции `get_indx()` первая и вторая строчки могут приводить к разным результатам вычислений.

Если вам все это пока кажется сложным и непонятным, то на данном этапе достаточно запомнить, что операции `count = count + 3` и `count += 3` в общем случае не взаимозаменяемы и могут приводить к разным результатам вычислений. 

И лучше для изменения значения переменной или, в общем случае, леводопустимого выражения, использовать операцию `+=`, так как в ней только один раз фигурирует это самое выражение.

## Список сокращенных арифметических операций

Конечно, кроме операции += можно использовать и другие, а именно:

`+=`, `-=`, `*=`, `/=`, `%=`

Это не полный список, но наиболее употребительный. Приоритеты этих операций совпадают с соответствующими приоритетами арифметических выражений. И все они выполняются после любых арифметических действий. Например, в операторе:

```c
count -= 3-5;
```

сначала будет вычислена разность `3-5 = -2`, и только после этого значение `-2` вычитается из значения переменной count в соответствии математическим действием:

```c
count - (-2) = count + 2 = 1+2 = 3
```

И результирующее значение будет равно `3`.

Аналогично со всеми остальными сокращенными арифметическими операциями:

```c
#include <stdio.h>
 
int main(void) {
    int count = 1;
    double var_d = 10;
    short p = 2;
 
    count -= 3 - 5;
    var_d /= 3.0 + p;
    p *= 20 - 5;
 
    printf("count = %d, var_d = %.2f, p = %d\n", count, var_d, p);
 
    return 0;
}
```

Обратите внимание, при использовании операций `/=` и `*=` они выполняются после арифметических действий сложения и вычитания, так как приоритет действий `/=` и `*=` ниже любой арифметической операции.

Довольно часто сокращенные арифметические операции используются в операторах циклов, о которых мы еще с вами будем говорить. Поэтому примеры использования этих операций вы увидите далее по ходу изложения материала.

### Подвиг 1. Расположите арифметические операции по возрастанию их приоритетов.

![02](/Good_good_C_C++/img/02_15.PNG)

### Подвиг 2. Расположите арифметические операции по возрастанию их приоритетов.

![02](/Good_good_C_C++/img/02_16.PNG)

### Подвиг 3. Отметьте все верные (работающие) варианты арифметических выражений.

P.S. Здесь `var`, `digit`, `b`, `res` - числовые переменные.


+ [x] digit *= 3 + b;
+ [ ] int t += 5;
+ [ ] 128 /= digit;
+ [x] var %= (b -= 1) * 5;
+ [x] var += 10 / 2;
+ [x] res = (b *= 5) - 10;
+ [ ] 54 -= 4;

### Подвиг 4. Напишите программу, в которой выполняется чтение двух целочисленных значений, записанных в одну строчку через пробел, затем, первая переменная (первое прочитанное значение) увеличиваются в 3 раза, вторая - уменьшается на 10 и полученные значения перемножаются. Выведите полученный результат в консоль в виде одного целого числа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/2.8.4

```c
#include <stdio.h>

int main(void) {
    int a, b;
    scanf("%d %d", &a, &b);

    int res = (a *= 3) * (b -= 10);
    printf("%d", res);

    return 0;
}
```

### Подвиг 5. Напишите программу, в которой вводятся два вещественных числа - ширина и длина прямоугольника, в одну строчку через пробел. Вычислите периметр этого прямоугольника и выведите в консоль сообщение в формате:

"Периметр: <число с точностью до десятых>"

Например, если периметр равен 12.56, то в консоли должна появиться строка (без кавычек):

"Периметр: 12.6"

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/2.8.5

```c
#include <stdio.h>

int main(void) {
    double a, b;
    scanf("%lf %lf", &a, &b);

    double res = (a + b) * 2;
    printf("Периметр: %.1lf", res);

    return 0;
}
```

### Подвиг 6 (на повторение). В программе должен быть реализован алгоритм решения следующей задачи. Набор полотенец, который стоил s рублей, продается со скидкой m%. Сколько рублей стоят два набора полотенец со скидкой? Переменные s и m читаются из входного потока, записанные в виде целых чисел одну строчку через пробел. Результат вывести в консоль в виде вещественного числа с точностью до сотых.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/2.8.6

```c
#include <stdio.h>

int main(void) {
    double s, m;
    scanf("%lf %lf", &s, &m);

    double res = s * (1 - m / 100.0) * 2;
    printf("%.2lf", res);

    return 0;
}
```

### Подвиг 7 (на повторение). Напишите программу, которая переводит скорость из м/с (метры в секунду) в км/ч (километры в час). Скорость в м/с считывается из входного потока в виде целого числа. Формула перевода имеет вид:

$s_{km/h} = \dfrac{x⋅3600}{1000}$
​
, где $x$ - скорость в м/с.

Результат вывести в консоль в виде вещественного числа с точностью до десятых.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/2.8.7

```c
#include <stdio.h>

int main(void) {
    int x;
    scanf("%d", &x);

    double res = x * 3600. / 1000.0;
    printf("%.1lf", res);

    return 0;
}
```

### Подвиг 8.8 (на повторение). Установите соответствия между типами переменных и их описаниями.

![02](/Good_good_C_C++/img/02_17.PNG)

#### Подвиг 8.9 (на повторение). Выберите все верные утверждения, касающиеся числовых литералов.

+ [x] если в тексте программы встречается число 128, то оно представляется целочисленной константой типа int
+ [x] если в тексте программы встречается число 45.55, то оно представляется вещественной константой типа double
+ [x] числовые литералы можно записывать в десятичной, шестнадцатеричной, восьмеричной системах счисления
+ [x] если положительный числовой литерал по значению превышает диапазон типа unsigned long long, то компилятор выдает предупреждение или ошибку
+ [ ] числовые литералы можно записывать только в десятичной системе счисления
+ [ ] если в тексте программы встречается число 128, то оно представляется целочисленной константой типа short
+ [ ] если положительный числовой литерал по значению превышает диапазон типа unsigned long long, то происходит переполнение и значение числового литерала в программе искажается
+ [x] числовым литералом является любое явно прописанное число в тексте программы

<hr>

[Содержание](#содержание)

[Оглавление курса](/Good_good_C_C++/README.MD)