# 5. Массивы и строки

## 5.1 Введение в массивы

На этом занятии речь пойдет о массивах. Что это такое и зачем они нужны? Давайте представим, что нам в программе нужно хранить значения функции синуса `sin(x)` в отдельных дискретных отсчетах `x`:

$f(x) = sin(x),    x = 0; 0,1; …, 2π$

![05](/Good_good_C_C++/img/05_01.png)

Как в программе организовать такое хранилище? 

Очевидно, отдельными переменными здесь не обойтись. 

К тому же все это множество значений относится к одному объекту – функции синуса. 

То есть, хотелось бы логически представлять их единым образом. 

Один из способов сделать это заключается в выделении непрерывной области памяти, в которой последовательно друг за другом размещались бы значения функции:

![05](/Good_good_C_C++/img/05_02.jpg)

Причем, тип данных у всех значений единый. Например, все числа можно определить как вещественные типа `double`, или типа `int` и так далее. 

Смешанных типов здесь нет. 

Для определенности положим, что все значения имеют тип `double` и занимают по `size = 8` байт в памяти. 

Соответственно, чтобы получить первый элемент этой последовательности, нужно взять первые 8 байт, для второго – следующие 8 байт и так далее. Математически операцию вычисления первого байта произвольного элемента можно записать в виде:

$addres_k = f + k \cdot size,   k = 0, 1, 2, …, n-1$

Здесь `f` – номер первого байта первого элемента в памяти устройства; `size` – размер одного элемента в памяти (в нашем примере `size = 8`). Значения `k` в такой структуре данных получили название индексы. 

То есть, если всего имеется `n` элементов, то индекс первого элемента всегда равен `0`, а индекс последнего равен `n-1`.

Как вы уже догадались, в языке Си для такой организации хранения данных в памяти устройства используют массивы. Для их объявления в программе можно воспользоваться следующим синтаксисом:

```
<тип элементов массива> <имя массива>[<число элементов массива>];
```

Например, в нашем случае с функцией синус массив можно объявить так:

```c
double f[30];
```

В итоге получаем массив, состоящий из элементов типа `double`, с именем `f` и общим числом элементов, равным 30. 

Имя массива мы, конечно же, придумываем сами, так же как и имена переменных. В результате такого объявления в памяти устройства автоматически выделяется непрерывная область памяти для хранения `30` чисел типа `double` общего размера:

$30 \cdot 8 = 240$ байт.

А теперь, внимание! 

Строго говоря, в языке Си нет структуры данных под названием массив! 

То, что здесь понимается под массивом – это просто фрагмент области памяти, в которую можно записывать произвольные данные, в нашем случае через переменную `f`. 

То есть, здесь нет программной оболочки над этими данными, которая бы контролировала корректность индексов, или позволяла бы присваивать один массив другому и так далее. 

Все что здесь мы имеем – это набор элементов в непрерывной области памяти.

Больше ничего! Вся ответственность за правильное использование этого фрагмента с данными лежит на плечах программиста. 

Сделано это было не случайно. 

Вспомним, что язык Си был создан как заменитель языка Ассемблер, так, чтобы текст программы можно было эффективно переводить в машинные коды без ущерба в производительности. 

Поэтому никаких лишних надстроек, посредников между данными в памяти и их представлением на уровне языка Си здесь нет. 

С одной стороны, это ускоряет работу программ, а с другой – возлагает на программиста всю полноту ответственности за использование ресурсов вычислительной техники.

Дальше я, тем не менее, буду употреблять слово массив, т.к. это устоявшаяся терминология языка. 

Но понимать его здесь следует не как полноценную структуру данных, а просто как непрерывную область памяти для хранения множества однотипных значений.

## Способы объявлений массивов

Давайте теперь детальнее посмотрим, как можно объявлять массивы в программе. 

+ Вначале, как мы уже видели, прописывается любой существующий тип данных, который определяет тип элементов массива. 
+ Дальше имя, которое мы придумываем сами, подобно именам переменных. 
+ И, наконец, в квадратных скобках прописывается общее число элементов массива. 

Вот здесь есть несколько важных моментов. Первое, до стандарта C99 число элементов можно было определять только константными целочисленными выражениями. Например, так:

```c
#include <stdio.h>

#define SIZE_BUFFER 1024

int main(void) {
    // Корректные объявления
    double f[30];
    char buffer[SIZE_BUFFER];
    int marks[13];
    short ar[8 * 5];
    char bytes[sizeof(double)];

    // Некорректные объявления
    int n = 5;

    float func[21.5];  // вещественное количество элементов
    int array[n];      // нельзя было до стандарта C99
    int null_ar[0];    // размер должен быть больше нуля

    return 0;
}
```

Обратите внимание, при определении размера массива вполне допустимо использовать арифметические операции и операцию `sizeof`. 

А вот возможность использования целочисленных переменных появилась только в стандарте C99, а также понятие массивов переменной длины, размеры которых можно определять через целочисленные переменные. 

Однако не все последующие стандарты языка Си поддерживают такой способ объявления, или определяют его как необязательный. 

В связи с этим использование переменных при объявлении массивов лучше избегать, так как переносимость программы в этом случае ставится под вопрос.

Если уж вам действительно понадобилось объявлять массивы с размерами на основе значений переменных, то для этого лучше использовать, так называемые, динамические массивы, то есть, массивы, динамически создаваемые в памяти в процессе выполнения программы. 

О них мы еще будем говорить, когда речь пойдет об указателях и выделении памяти.

## Запись и чтение значений в массивы

Итак, в самом простом варианте мы научились объявлять массивы.

Спрашивается, как теперь в него можно занести какие-либо значения и прочитать их оттуда? 

Давайте для определенности представим, что в программе объявлен целочисленный массив из 13 элементов для хранения оценок учащегося:

```c
#include <stdio.h>
#define TOTAL_MARKS 13

int main(void) {
    int marks[TOTAL_MARKS];
    return 0;
}
```

Чтобы занести в массив `marks` какое-либо целочисленное значение, необходимо прописать имя массива, поставить квадратные скобки, в них указать индекс элемента, в который заносится число и с помощью операции присваивания занести нужное значение. 

Например:

```c
marks[2] = 4;
```

Здесь мы в 3-й элемент записали значение 4. 

Обратите внимание, индекс 2 означает 3-й элемент массива, а не второй, так как первый элемент всегда имеет индекс 0, например:

```c
marks[0] = 2 * 3;
```

Теперь, мы в первый элемент массива занесли значение `6 = 2 * 3`. И так можно делать со всеми тринадцатью элементами, то есть, индексы в нашем примере с массивом marks должны меняться в диапазоне от `0` до `12` включительно. Последнее значение:

```c
marks[12] = 7 - 2;
```

И вот здесь начинающие программисты часто делают ошибку. Для записи данных в последний элемент указывают индекс на единицу больше:

```c
marks[13] = 1;
```

При этом программа скомпилируется без каких-либо предупреждений и ошибок, но в процессе выполнения программа может из-за этого аварийно завершиться. 

Обратите внимание, на слово может. Она может выполниться и без ошибок, как в моем случае, но при этом содержит в себе фатальную ошибку: рано или поздно у какого-нибудь пользователя эта программа просто вылетит при выполнении. 

А программист потом с пеной у рта доказывает, что дело не в программе, т.к. лично у него все работает. 

Помните, если программа вылетела хотя бы один раз из миллиона запусков, значит, виноват программист, он что то не учел. 

И массивы здесь, как раз очень легко могут стать источником подобных ошибок. Нужно самим контролировать, чтобы индексы не выходили за допустимый диапазон, то есть, всегда были в пределах:

```c
[0; SIZE_ARRAY-1]
```

где `SIZE_ARRAY` – общее число элементов в массиве. 

Казалось бы, простое правило. 

Но не представляете, как бывает непросто его соблюсти. И все из-за того, что массивы в языке Си – это не структура данных, а просто непрерывная область памяти и корректное ее использование целиком и полностью лежит на плечах программиста.

Хорошо, теперь мы знаем, какие подводные камни таят в себе массивы. Давайте теперь посмотрим, как можно считывать значения из них. Как вы, наверное, уже догадались, делается это следующим образом:

```c
int x = marks[2];
```

Здесь читается значение 3-го элемента массива с индексом 2 и копируется в целочисленную переменную x. Выведем это значение на экран:

```c
printf("x = %d\n", x);
```

После запуска программы увидим строчку:

```
x = 4
```

То есть, мы прочитали значение `4`, которое ранее записывали в 3-й элемент. И так можно читать из любого элемента массива. Здесь также нужно контролировать корректность индексов и не допускать ситуаций вроде следующей:

```
x = marks[13];
```

Скорее всего, программа отработает без ошибок, т.к. мы просто читаем следующие байты за массивом. 

Это не так критично, когда происходит попытка записи в несуществующие элементы массива. Но, тем не менее, это считается потенциальной ошибкой.

А теперь давайте посмотрим, как можно прочитать все элементы из массива `marks` и вывести их на экран. Очевидно, сделать это можно с помощью циклов. И мы воспользуемся для этого оператором `for` следующим образом:

```c
#include <stdio.h>
 
#define TOTAL_MARKS                13
 
int main(void)
{
         int marks[TOTAL_MARKS];
         marks[2] = 4;
         marks[0] = 2;
         marks[12] = 5;
//       marks[13] = 1;               // никогда так не делайте!!!
 
         for(int i = 0; i < TOTAL_MARKS; ++i)
                   printf("%d ", marks[i]);
 
         return 0;
}
```

После запуска у меня на экране отобразилась следующая строчка:

```
2 6488012 4 1424847605 -2 6487816 2001366829 4200976 6487936 4201088 4200976 4199120 5
```

Смотрите, здесь элементы, которым мы ничего не присваивали, принимают случайные значения. 

Это связано с тем, что когда массивы объявляются внутри функций, под них автоматически выделяется память (в момент вызова функции) и все, что в этой памяти было, то и остается, то есть, мусор. 

Как раз этот мусор в виде случайных значений мы и видим. Кроме тех элементов, которым позже присваивали определенные значения. Это следует учитывать при составлении программы: изначально в массиве, скорее всего, будут неопределенные величины.

Видео по теме [#29. Введение в массивы](https://www.youtube.com/watch?v=f7gARd3t2sg&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, касающиеся массивов языка Си.

+ [x] массивы представляют собой непрерывную область памяти, в которой друг за другом размещены данные одного типа
+ [x] длина массива - это максимальное число элементов (определенного типа), которые он хранит
+ [x] индекс массива - это целое число от 0 до length-1 (length - длина массива); служит для доступа к определенному элементу массива
+ [x] массивы можно объявлять по синтаксису: <тип элементов массива> <имя массива>[<число элементов массива>];
+ [ ] индекс массива - это целое число от 1 до length (length - длина массива); служит для доступа к определенному элементу массива
+ [ ] длина массива - это число байт, которые он занимает в памяти устройства

### Подвиг 2. Запишите объявление массива с именем ar_f, длиной в 13 элементов, содержащий вещественные числа типа float.

P. S. Без инициализации, только используя материал текущего занятия.

```c
float ar_f[13];
```

### Подвиг 3. Пусть в программе объявлен массив:

```c
int ar_int[100];
```

И его адрес оказался равен `1000`. Вычислите адрес элемента этого массива с индексом `5`, учитывая, что размер типа `int` составляет `32` бит. В ответ запишите одно десятичное число.

$1020$

### Подвиг 4. Пусть в программе объявлен массив:

```c
short buffer[512];
```

Вычислите, сколько байт в памяти устройства занимает этот массив, учитывая, что размер типа short составляет 16 бит. В ответ запишите одно десятичное число.

$1024$

### Подвиг 5. Имеется следующая программа:

```c
#define TOTAL 1024

int main(void) {
    int total = 100;
    // здесь выполняются объявления

    return 0;
}
```
Выберите все верные (рабочие) варианты объявления массивов внутри функции main().

+ [x] unsigned short ar_1[100];
+ [ ] long long ar_6[0.5 * 2];
+ [x] signed char ar_4[total]; // (поддерживается не всеми компиляторами)
+ [ ] long ar_5[0];
+ [x] short int ar_8[(int)(0.5 * 3)];
+ [x] long double ar_7[TOTAL / 2];
+ [x] double ar_2[5 * 3 - 2];
+ [x] float ar_3[sizeof(total) * 5];

### Подвиг 6. В программе ниже объявите массив с именем buffer длиной 1024 элементов типа short. Присвойте первому элементу (первому по счету) значение 13.

P. S. В консоль ничего выводить не нужно.

```c
#include <stdio.h>
#define BUFFER 1024

int main(void) {
    short buffer[BUFFER];
    buffer[0] = 13;

    return 0;
}
```

### Подвиг 7. В программе ниже объявите массив с именем func длиной 28 элементов типа double. Прочитайте из входного потока вещественное число в переменную x и присвойте его седьмому элементу (седьмому по счету) массива func.

P. S. В консоль ничего выводить не нужно.

```c
#include <stdio.h>
#define MAX 28

int main(void) {
    double func[MAX], x;

    scanf("%lf", x);

    func[6] = x;

    return 0;
}
```

### Подвиг 8. Продолжите программу. Необходимо прочитать из входного потока пять целых чисел, записанных в одну строчку через пробел, в массив с именем digits длиной пять элементов типа int. Используя оператор цикла for, выведите в консоль все значения элементов массива digits в одну строчку через пробел.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/5.1.8

```c
#include <stdio.h>
#define MAX 5

int main(void) {
    int digits[MAX];

    for (int i = 0; i < MAX; i++) {
        scanf("%d", &digits[i]);
    }
    for (int i = 0; i < MAX; i++) {
        printf("%d ", digits[i]);
    }
    return 0;
}
```

### Подвиг 9. Продолжите программу. Необходимо объявить два массива с именами ar_1 и ar_2, содержащими элементы типа int. Длина массива ar_1 должна быть равна TOTAL, а массива ar_2 - в два раза больше (TOTAL * 2). Затем прочитайте из входного потока пять целых чисел, записанных через пробел, в массив ar_1 значения (по порядку, начиная с первого). После этого скопируйте значения массива ar_1 в массив ar_2. Оставшиеся элементы массива ar_2 должны принимать значение -1.

P. S. В консоль ничего выводить не нужно.

```c
#include <stdio.h>
#define TOTAL 5

int main(void) {
    int ar_1[TOTAL];
    int ar_2[TOTAL * 2];

    for (int i = 0; i < TOTAL; i++) {
        scanf("%d", &ar_1[i]);
        ar_2[i] = ar_1[i];
    }
    for (int i = TOTAL; i < TOTAL * 2; i++) {
        ar_2[i] = -1;
    }

    return 0;
}
```

### Подвиг 10 (на повторение). Выберите все верные утверждения, касающиеся булевых типов и данных языка Си стандарта C99 и выше.

+ [x] булево понятие "истина" определяется любым ненулевым числовым значением
+ [ ] булево понятие "ложь" определяется любым ненулевым числовым значением
+ [x] булево понятие "ложь" определяется нулевым значением
+ [x] приоритет операций сравнения выше приоритета операции присваивания
+ [x] в заголовочном файле stdbool.h определен тип bool и две константы true и false
+ [ ] приоритет операций сравнения выше приоритетов арифметических операций
+ [ ] булево понятие "истина" определяется нулевым значением
+ [x] приоритет операций сравнения ниже приоритетов арифметических операций
+ [ ] приоритет операций сравнения ниже приоритета операции присваивания

# 5.2 Вычисление размера массива. Инициализация массивов

На этом занятии вы узнаете, как можно вычислять размер произвольного массива и выполнять инициализацию его элементов. Начнем с вычисления числа элементов массива.

## Операция sizeof с массивами

В примере программы из прошлого занятия для определения размера массива используется константа `TOTAL_MARKS`, определенная директивой `define`:

```c
#include <stdio.h>

#define TOTAL_MARKS 13

int main(void) {
    int marks[TOTAL_MARKS];

    marks[2] = 4;
    marks[0] = 2 * 3;
    marks[12] = 7 - 2;
    //       marks[13] = 1;

    for (int i = 0; i < TOTAL_MARKS; ++i) printf("%d ", marks[i]);

    return 0;
}
```

Однако не всегда удается так просто определить размер массива и, соответственно, перебрать его элементы. 

В общем случае язык Си предоставляет возможность вычисления числа элементов массива с помощью уже знакомой вам операции `sizeof`. 

Делается это следующим образом. Как вы помните, `sizeof` возвращает размер переменной или типа данных в байтах. 

Но, применительно к массиву, она возвращает размер области памяти (также в байтах), которая под него выделена. Например:

```c
size_t bytes_marks = sizeof(marks);
printf("%zu\n", bytes_marks);
```

Получим значение `52` в переменной `bytes_marks`. Это, как раз, величина:

$13 \cdot 4 = 52$ байта

Обратите внимание на тип переменной `size_t`. В данном случае – это переопределение целочисленного типа `unsigned long long`. По сути, имя `size_t` введено для универсальной записи программы при использовании функций или операций подобной `sizeof`. 

В разных реализациях языках и на разных платформах имя `size_t` может быть связано с разными целочисленными типами. Но всегда является целочисленной и беззнаковой. 

Далее, мы выводим значение переменной `bytes_marks`, используя спецификатор `%zu`, специально введенный для типа `size_t`.

Итак, размер массива в байтах мы легко можем определить. Теперь, чтобы вычислить число его элементов, нужно этот общий размер разделить на число байт, занимаемых одним элементом этого массива. Очевидно, сделать это можно так:

```c
size_t size_marks = sizeof(marks) / sizeof(marks[0]);
printf("%zu\n", size_marks);
```

Увидим значение `13`, как раз столько элементов в массиве `marks`.

Конечно, вместо `sizeof(marks[0])` в данном конкретном случае можно было бы прописать тип `int`:

```c
size_t size_marks = sizeof(marks) / sizeof(int);
```

Но это менее универсальное решение, так как при изменении типа массива `marks` в программе потом придется менять и эту строчку. А если забыть это сделать (что очень легко может произойти), то можно получить ошибку в процессе выполнения программы, например, из-за выхода индексов за диапазон. 

Поэтому рекомендуется первый вариант записи или еще вот такой:

```c
size_t size_marks = sizeof(marks) / sizeof(*marks);
```

Забегая вперед, скажу, что `*marks` – это, по сути, то же самое, что и `marks[0]`.

## Инициализация массивов

Теперь посмотрим, каким образом в языке Си можно выполнять инициализацию массивов начальными значениями. Смотрите, если в момент объявления массива мы знаем, какие данные он должен содержать, то их можно сразу прописать следующим образом:

```c
int marks[TOTAL_MARKS] = {1, 2, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0};
```

То есть, после объявления массива прописывается знак равно и далее в фигурных скобках через запятую перечисляются значения, которые будут записаны в соответствующие элементы массива. В данном примере в первые четыре элемента (по порядку) будут занесены значения 1, 2, 3 и 4 соответственно. А в остальные – числа 0.

Обратите внимание, здесь равно – это не операция присваивания, это именно инициализация массива. 

Когда мы с вами рассматривали переменные, то отмечали, что есть операция инициализации, а есть операция присваивания и в общем случае – это разные вещи. 

На примере массива это очень хорошо видно. Если попробовать записать эту же конструкцию в операции присваивания:

```c
int marks[TOTAL_MARKS];
marks = {1, 2, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0};
```

то получим синтаксическую ошибку. Операция присваивания не поддерживает такое выражение. 

А вот при инициализации оно вполне допустимо. 

Поэтому нужно четко различать инициализацию и присваивание.

Итак, мы теперь знаем, как можно инициализировать элементы массива начальными значениями. Но, что если нам нужно записать данные только в первые несколько элементов, а остальные пусть принимают любые значения. 

Сделать это очень просто. Указываем только нужные данные, остальные опускаем:

```c
int marks[TOTAL_MARKS] = {1, 2, 3};
```

Тогда в первые три элемента будут занесены числа 1, 2 и 3, а вот остальные становятся равными 0. 

Да, так работает инициализатор. Если мы указываем хотя бы одно начальное значение, то все остальные элементы массива становятся равными нулю. Но, обратите внимание, мы в инициализаторе можем указывать меньшее количество данных, но большее (больше числа элементов массива) задавать нельзя. Если в начальном примере добавить хотя бы один ноль:

```c
int marks[TOTAL_MARKS] = {1, 2, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
```

то получим ошибку при компиляции программы.

Чтобы этого избежать, размер массива можно не указывать, если используется инициализатор. Тогда число элементов будет равно числу инициализируемых значений. Например:

```c
int coords[] = {10, -2, 30};
```

Массив `coords` будет состоять из трех элементов, т.к. в инициализаторе указано три значения.

Наконец, в стандарте C99 появился еще один способ инициализации с указанием индекса инициализируемого элемента. Например:

```c
short digits[10] = {-1, [2] = 5, 18, [9] = -1};
for(int i = 0 ;i < sizeof(digits) / sizeof(digits[0]); ++i)
    printf("%d ", digits[i]);
```

В результате увидим строку из значений:

```
-1 0 5 18 0 0 0 0 0 -1
```

То есть, первый элемент соответствует первому значению в инициализаторе. Затем, мы указали, что 3-й элемент должен принимать значение 5, следом прописано значение следующего 4-го элемента со значением 18 и, наконец, для последнего указали значение -1.

Все эти варианты инициализации вполне можно использовать в программах в зависимости от их удобства.

Конечно, использование инициализаторов увеличивает время выполнения программы, так как в элементы массива дополнительно выполняется копирование данных. 

Поэтому пользоваться этим инструментом следует осмотрительно. Если массив небольшой длины (до 1000 элементов), то его инициализация не сильно скажется на скорости работы. Однако при большем размере могут появляться заметные задержки. 

Особенно, когда инициализация происходит внутри функций. При каждом ее вызове будет создаваться массив и инициализироваться некоторыми значениями. Здесь следует хорошо подумать, действительно ли в программе нужна эта инициализация. 

Поэтому, чаще всего, инициализацию можно встретить при глобальном определении массива (вне каких-либо функций). Например, так:

```c
#include <stdio.h>

#define TOTAL_MARKS 13

int month[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

int main(void) {
    int marks[TOTAL_MARKS] = {1, 2, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0};

    for (int i = 0; i < TOTAL_MARKS; ++i) printf("%d ", marks[i]);

    return 0;
}
```

Тогда его значения будут инициализироваться один раз в момент загрузки программы. Из-за этого при глобальных объявлениях можно в инициализаторе использовать только константные выражения времени компиляции. Переменные или вызовы функций подставлять сюда уже недопустимо. А вот при локальной инициализации вполне можно использовать и переменные и функции, например:

```c
#include <stdio.h>
#include <stdlib.h>

#define TOTAL_MARKS 13

int month[] = {31, 28, 31 * 2, 30, 31, 30, 31, 31, 30, 31, 30, 31};

int main(void) {
    int val = -5;
    int marks[TOTAL_MARKS] = {1, 2, 3, 4, val, abs(val), 0, 0, 0, 0, 0, 0, 0};

    for (int i = 0; i < TOTAL_MARKS; ++i) printf("%d ", marks[i]);

    return 0;
}
```

Но, как я уже отмечал, инициализацию массивов внутри функций следует избегать, кроме, может быть, функции `main()`, т.к. она, как правило, вызывается только один раз в процессе работы программы.

Видео по теме [#30. Вычисление размера массива. Инициализация массивов](https://www.youtube.com/watch?v=6qlV7bCZBdE&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, касающиеся операции sizeof.

+ [x] операцию sizeof можно применить к типам данных, например, так: sizeof(short);
+ [x] операция sizeof для массива с именем ar может быть записана в виде: sizeof ar;
+ [x] операция sizeof применительно к массиву возвращает число байт, которые он занимает в памяти устройства
+ [ ] операцию sizeof можно применить к типам данных, например, так: sizeof short;
+ [x] операция sizeof для массива с именем ar может быть записана в виде: sizeof(ar);

### Подвиг 2. Выберите все верные варианты вычисления длины следующего массива (числа его элементов):

```c
double ar[13];
size_t size_ar;
```

+ [x] size_ar = sizeof(ar) / sizeof(ar[1]);
+ [x] size_ar = sizeof(ar) / sizeof(ar[0]);
+ [ ] size_ar = sizeof(*ar) / sizeof(ar);
+ [ ] size_ar = sizeof(ar);
+ [x] size_ar = sizeof(ar) / sizeof(*ar);
+ [x] size_ar = sizeof(ar) / sizeof(double);
+ [ ] size_ar = sizeof(double) / sizeof(ar);
+ [x] size_ar = sizeof ar / sizeof *ar

### Подвиг 3. В программе объявлен до функции main() массив с именем marks и типом элементов short. Этот массив скрыт в коде, но он существует. В функции main() вычислите длину массива marks (число его элементов) и размер массива (число байт, которые он занимает в памяти устройства). Выведите в консоль в одну строчку через пробел длину массива и его размер в байтах (именно в таком порядке) в виде целых чисел.

```c
#include <stdio.h>

int main(void) {
    int marks[5] = {0};
    int a, b;

    a = sizeof marks;
    b = a / sizeof(*marks);

    printf("%d %d", b, a);

    return 0;
}
```

### Подвиг 4. В программе объявлен до функции main() массив с именем pows и типом элементов float. Этот массив скрыт в коде, но он существует. В функции main() выведите в консоль в одну строчку через пробел значения его элементов в обратном порядке с точностью до десятых.

```c
#include <stdio.h>

int main(void) {
    float pows[5] = {1, 2, 3, 4, 5};

    int len = sizeof pows / sizeof(*pows);

    for (int i = len - 1; i >= 0; i--) {
        printf("%.1f ", pows[i]);
    }

    return 0;
}
```

### Подвиг 5. Выберите все верные утверждения, касающиеся инициализации массивов языка Си стандарта C99.

+ [x] при инициализации массивов в функции main() можно использовать переменные
+ [x] при инициализации массивов в глобальной области можно использовать только выражения времени компиляции программы
+ [x] операция инициализации массивов увеличивает объем вычислений (при выполнении программы) и тем больше, чем длиннее массив
+ [ ] если при инициализации указано меньше значений, чем длина массива, то оставшиеся элементы массива принимают произвольные значения
+ [x] если при инициализации указано меньше значений, чем длина массива, то оставшиеся элементы массива принимают значение 0
+ [x] число значений в инициализаторе должно быть меньше или равно длине массива
+ [ ] операция инициализации массивов не влияет на скорость выполнения программы

### Подвиг 6. Выберите все верные варианты инициализации массивов.


+ [x] double ar_d[7] = {[2]=0.5, 0.8, [6]=0.01};
+ [x] short zeros[64] = {0};
+ [x] short buf[] = {0, 0, 1, 1, 2, 2};
+ [x] long long pows[4] = {1, 2, 4, 8};
+ [ ] int ar_i[5] = {0, 1, 2, 3, 4, 5};
+ [x] int row[32] = {};
+ [x] char str[100] = {1, 2, 3, 10};

### Подвиг 7. В программе в функции main() объявите массив типа long с именем digits и длиной 128 элементов. Выполните его инициализацию так, чтобы элемент с индексом 16 был равен 4, элемент с индексом 32 был равен 5, элемент с индексом 64 был равен 6, а остальные элементы равны 0.

P. S. В консоль ничего выводить не нужно.

```c
#include <stdio.h>

int main(void) {
    long digits[128] = {[16] = 4, [32] = 5, [64] = 6};

    return 0;
}
```

### Подвиг 8. В программе ниже в функции main() объявите массив типа short, именем ar_rnd и длиной 64 элемента. Проинициализируйте этот массив нулями (используя инициализацию, а не присваивание). Прочитайте из входного потока пять целых чисел, записанных в одну строчку через пробел, и занесите их по порядку в первые пять элементов массива ar_rnd.

P. S. В консоль ничего выводить не нужно.

```c
#include <stdio.h>

int main(void) {
    short ar_rnd[64] = {0};

    for (size_t i = 0; i < 5; i++) {
        scanf("%hd", &ar_rnd[i]);
    }

    return 0;
}
```

### Подвиг 9. В программе до функции main() объявлен массив с именем marks и типом элементов short. Этот массив скрыт в коде, но он существует. В функции main() вычислите среднее арифметическое значений элементов этого массива и выведите в консоль полученное значение с точностью до сотых.

```c
#include <stdio.h>

int main(void) {
    short marks[5] = {1, 2, 3, 4, 7};
    double res = 0;

    int len = sizeof marks / sizeof(*marks);

    for (int i = 0; i < len; i++) {
        res += marks[i];
    }
    res /= len;

    printf("%.2lf", res);

    return 0;
}
```

### Подвиг 10 (на повторение). Установите соответствия между обозначениями операторов и их описаниями.

![05](/Good_good_C_C++/img/05_03.PNG)

# 5.3 Указатели на массивы

## Указатели на массивы

На этом занятии посмотрим, как указатели можно использовать совместно с массивами. Давайте предположим, что в программе объявляется следующий массив с именем ar:

```c
#include <stdio.h>
 
int main(void) {
    short ar[] = {4, 3, 2, 1, 5, 6, 7};
    return 0;
}
```

Так вот, имя массива `ar` в языке Си является указателем на массив и содержит адрес первой ячейки, начиная с которой хранятся элементы этого массива:

![05](/Good_good_C_C++/img/05_04.png)

А раз это так, то значение первого элемента можно получить с помощью операции разыменования:

```c
short a_1 = *ar;
printf("a_1 = %d\n", a_1);
```

И, действительно, после запуска программы увидим на экране значение 4 первого элемента. Мало того, используя адресную арифметику, мы можем переходить к произвольному элементу и работать с ним. Например:

```c
short a_4 = *(ar+3);
printf("a_4 = %d\n", a_4);
```

В результате, переменная `a_4` будет содержать значение `1` четвертого элемента. Наконец, мы можем через цикл вывести все значения элементов этого массива следующим образом:

```c
for(int i = 0; i < sizeof(ar) / sizeof(*ar); ++i)
    printf("%d ", *(ar+i));
```

Давайте внимательнее посмотрим на эту конструкцию. 

В цикле for вычисляется длина массива (число его элементов) с помощью операции `sizeof`. 

Вначале определяется общее число байт, занимаемое массивом `sizeof(ar)`, а затем, оно делится на число байт, отведенное под один элемент `sizeof(*ar)`.

Получаем общее число элементов в массиве. 

Однако если `ar` – это указатель на массив, то почему операция `sizeof(ar)` возвращает количество байт массива, а не указателя? 

В действительности, здесь `ar` является именно указателем на массив, а не просто указателем на ячейки памяти. 

В языке Си хоть и отсутствует массив, как структура данных, но указатель такого вида все же присутствует. 

Он формируется автоматически, как только мы объявляем какой-либо массив в программе. Его имя становится указателем на массив.

Чем же отличается указатель на массив от обычного указателя? В целом, только двумя моментами:
+ операция `sizeof` для указателя на массив возвращает число байт, занимаемых массивом в памяти устройства;
+ адрес указателя на массив формируется в момент его объявления (размещения в памяти устройства) и остается неизменным на протяжении работы программы.

Давайте я на конкретных примерах продемонстрирую эти особенности. Итак, пусть у нас имеется массив из целых чисел и указатель того же типа:

```c
#include <stdio.h>

int main(void) {
    short ar[] = {4, 3, 2, 1, 5, 6, 7};
    short *ptr_ar;

    return 0;
}
```

Так как `ar` – это указатель, то мы можем присвоить указателю `ptr_ar` адрес массива `ar` следующим образом:

```c
ptr_ar = ar;
```

или так:

```c
ptr_ar = &ar[0];
```

Но первый вариант лучше и визуально и требует меньшего числа операций.

Далее проверим, можно ли работать с массивом `ar` через указатель `ptr_ar`:

```c
short x = *ptr_ar;
*(ptr_ar+1) = -3;
```

Действительно, при отладке видим, что переменная `x` содержит значение `4`, а массив `ar` изменил второй элемент на `-3`.

Теперь проверим, как будет работать операция `sizeof` с указателями `ar` и `ptr_ar`:

```c
size_t len_1 = sizeof(ar);         // len_1 = 14
size_t len_2 = sizeof(ptr_ar);     // len_2 = 4
```

После запуска в режиме отладки видим значения переменных `len_1 = 14` и `len_2 = 4`. 

То есть, эти указатели все же немного различаются. 

Указатель на массив выдает общее число байт, отведенных под массив, а `ptr_ar` – размер указателя в памяти устройства (4 байта для 32-х разрядных систем).

Попробуем теперь изменить адрес указателя на массив:

```c
ar++;
```

При компиляции увидим сообщение об ошибке. Так делать нельзя. И, вообще, менять адрес указателя на массив запрещено. А вот с обычным указателем такая операция вполне допустима:

```c
ptr_ar++;
```

Никаких ошибок и программа успешно выполняется. Мало того, мы с помощью указателя `ptr_ar` можем обращаться к произвольным элементам массива, используя оператор квадратные скобки. Например:

```c
short a_3 = ptr_ar[2];       // a_3 = 2 (при ptr_ar = ar)
```

На самом деле, оператор `[]` – это обычная синтаксическая конструкция, подменяющая собой адресную арифметику вида:

```c
ar[index] = *(ar+index)
```

То есть, операция индексирования – это не операция над массивами, а над адресами и не более того. Мало того, в общем виде ее можно представить так:

```c
a[b] = *(a+b)
```

При этом совершенно не важно, что здесь выступает в роли `a`, а что в роли `b`. То есть, формально, обратиться к элементу массива `ar` с индексом `2` можно и так:

```c
short a_3 = 2[ar];     // *(2+ar)
```

так как это эквивалентно операции `*(2+ar)`, а она вполне допустима. 

Конечно, в реальных проектах так использовать операцию индексирования не нужно. 

Да и, вообще, никогда. 

Помните, текст программы пишется для человека, а потому не стоит прописывать различные корявые конструкции, дабы показать глубину своих познаний. 

Рабочий коллектив такое не оценит.

Видео по теме [#31. Указатели на массивы](https://www.youtube.com/watch?v=qPspc2X4lOY&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, касающиеся указателей на массивы.

+ [x] указатель на массив - это особый тип указателя, который автоматически формируется в момент объявления массива
+ [ ] операция sizeof, применительно к указателю на массив, возвращает размер самого указателя (в байтах)
+ [x] имя массива является указателем на начало области памяти с данными этого массива
+ [x] операция sizeof, применительно к указателю на массив, возвращает размер области памяти, занимаемой массивом
+ [x] в указателе на массив нельзя менять значение хранимого адреса

### Подвиг 2. Какое числовое значение будет принимать переменная size_ar при выполнении следующего фрагмента программы:

```c
int ar[10];
int size_ar = sizeof(ar);
```

Полагается: тип `int` занимает 32 бит; размер указателя 32 бит.

$40$

### Подвиг 3. Какое числовое значение будет принимать переменная size_ptr_ar при выполнении следующего фрагмента программы:

```c
int ar[10];
int* ptr_ar = ar;
int size_ptr_ar = sizeof(ptr_ar);
```
Полагается: тип `int` занимает 32 бит; размер указателя 32 бит.

$4$

### Подвиг 4. В программе до функции main() объявлены два массива типа char с именами buff_1 и buff_2. Эти массивы скрыты в коде, но они существуют. Необходимо в функции main() объявить массив того же типа char с именем buffer длиной 128 элементов. Затем, сформировать указатель с именем ptr_ar на массив buffer. Используя ptr_ar выполнить последовательное копирование значений элементов из массивов buff_1 и buff_2 в массив buffer (то есть, оператор [] для массива buffer не применять). Гарантируется, что длины массива buffer достаточно для хранения двух массивов buff_1 и buff_2.

P. S. В консоль ничего выводить не нужно.

```c
#include <stdio.h>

int main(void) {
    char buff_1[] = {4, 3, 2, 1, 5, 6, 7};
    char buff_2[] = {4, 3, 2, 1, 5, 6, 7};
    char buffer[128];

    char *ptr_ar;

    ptr_ar = buffer;

    int len_1 = sizeof(buff_1) / sizeof(*buff_1);
    int len_2 = sizeof(buff_2) / sizeof(*buff_2);

    for (int i = 0; i < len_1; i++) {
        *(ptr_ar++) = *(buff_1 + i);
    }
    for (int i = 0; i < len_2; i++) {
        *(ptr_ar++) = *(buff_2 + i);
    }

    return 0;
}
```

### Подвиг 5. Продолжите программу. Прочитайте из входного потока целое число в переменную value типа int. Объявите массив с именем ar_d типа char и длиной для побайтного хранения числа типа int. Скопируйте значение каждого байта переменной value в массив ar_d (значение самой переменной value не менять). Выведите значения элементов массива ar_d в консоль в виде десятичных чисел в одну строчку через пробел.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/5.3.5

```c
#include <stdio.h>

int main(void) {
    int value;

    scanf("%d", &value);

    int len = sizeof(int) / sizeof(char);

    char ar_d[len];

    char* bite = (char*)&value;

    for (int i = 0; i < len; i++) {
        ar_d[i] = *(bite + i);
        printf("%d ", ar_d[i]);
    }

    return 0;
}
```

### Подвиг 6. Напишите программу, которая читает целочисленные значения из входного потока в массив, записанных в одну строчку через пробел. Чтение происходит до тех пор, пока либо не закончатся данные, либо не будет прочитано 10 чисел. После этого выполните проверку: если прочитанные числа неотрицательны (больше или равны 0) и нечетны, то выведите в консоль число 1, иначе - число 0. Попробуйте реализовать эту программу без применения условных операторов.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/5.3.6

```c
#include <stdio.h>
#define MAX 10

int main(void) {
    int value, counter = MAX, res = 1;

    while (scanf("%d", &value) == 1 && counter--) {
        res *= (value > 0) * (value % 2);
    }
    printf("%d", res);

    return 0;
}
```

```c
#include <stdio.h>

int main(void)
{
    int ar[] = {}, res = 1;
    
    for(int i = 0, value = 0; scanf("%d", &value) == 1 && i < 10; i++)
    {
        ar[i] = value;
        res *= (value % 2) * (0 < value);
    }
    
    printf("%d", res);
    
    return 0;
}
```

### Подвиг 7. Напишите программу, которая читает в массив вещественные числа из входного потока, записанные через пробел. Чтение происходит до тех пор, пока не будет достигнут конец данных. Гарантируется, что максимальное количество чисел не более 20. Вычислите среднее арифметическое прочитанных чисел и выведите в консоль полученное значение с точностью до сотых.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/5.3.7

```c
#include <stdio.h>

int main(void) {
    double value, res = 0;
    int counter = 0;
    while (scanf("%lf", &value) == 1) {
        res += value;
        counter++;
    }
    res /= counter;

    printf("%.2lf", res);

    return 0;
}
```

### Подвиг 8. Продолжите программу. Прочитайте из входного потока целые числа в переменные var_1, var_2 и var_3, записанные в одну строчку через запятую. Побайтно занесите их значения в массив типа char (в порядке var_1, var_2, var_3). Выведите в одну строчку по порядку значения массива в виде беззнаковых десятичных чисел.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/5.3.8

```c
#include <stdio.h>

void bite_print(const unsigned char* ptr, int len) {
    for (int i = 0; i < len; i++) {
        printf("%d ", *(ptr + i));
    }
}

int main(void) {
    short var_1;
    int var_2;
    long var_3;

    unsigned char* ptr;

    scanf("%hd, %d, %ld", &var_1, &var_2, &var_3);

    ptr = (unsigned char*)&var_1;
    bite_print(ptr, sizeof(var_1));
    ptr = (unsigned char*)&var_2;
    bite_print(ptr, sizeof(var_2));
    ptr = (unsigned char*)&var_3;
    bite_print(ptr, sizeof(var_3));
    return 0;
}
```

### Подвиг 9 (на повторение). Выберите все верные варианты, касающиеся указателей.

+ [ ] указатели разных типов не могут ссылаться на одну и ту же область памяти
+ [x] присвоение указателей разных типов следует выполнять с операцией приведения типа одного указателя к другому
+ [x] указатели разных типов могут ссылаться на одну и ту же область памяти
+ [x] указатель с типом void* можно присваивать указателям любых других типов без возникновения каких-либо предупреждений со стороны компилятора
+ [x] константа NULL языка Си служит для обозначения неиницализированного указателя (на выделенную область памяти)
+ [x] присваивание адресов указателей разных типов приводит к предупреждению при компиляции программы

### Подвиг 10 (на повторение). Пусть в программе объявлены следующие переменные и указатели:

```c
int a = 5, b = 7;
double d = 2.0;
int* ptr_a = &a, *ptr_b = &b;
```

Выберите все верные (рабочие) варианты адресной арифметики с указателями ptr_a и ptr_b.

+ [x] --ptr_a;
+ [ ] ptr_b += ptr_a;
+ [ ] ptr_b + ptr_a;
+ [ ] ptr_a *= a;
+ [ ] ptr_b -= ptr_a;
+ [x] ptr_b - ptr_a;
+ [x] ptr_b++;
+ [ ] ptr_a /= b;
+ [x] ptr_a += 3;
+ [x] ptr_a += b * 5;
+ [ ] ptr_a -= d;

# 5.4 Ключевое слово const с указателями и переменными