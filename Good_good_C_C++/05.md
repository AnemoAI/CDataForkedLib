# 5. Массивы и строки

# 5.1 Введение в массивы

На этом занятии речь пойдет о массивах. Что это такое и зачем они нужны? Давайте представим, что нам в программе нужно хранить значения функции синуса `sin(x)` в отдельных дискретных отсчетах `x`:

$f(x) = sin(x),    x = 0; 0,1; …, 2π$

![05](/Good_good_C_C++/img/05_01.png)

Как в программе организовать такое хранилище? 

Очевидно, отдельными переменными здесь не обойтись. 

К тому же все это множество значений относится к одному объекту – функции синуса. 

То есть, хотелось бы логически представлять их единым образом. 

Один из способов сделать это заключается в выделении непрерывной области памяти, в которой последовательно друг за другом размещались бы значения функции:

![05](/Good_good_C_C++/img/05_02.jpg)

Причем, тип данных у всех значений единый. Например, все числа можно определить как вещественные типа `double`, или типа `int` и так далее. 

Смешанных типов здесь нет. 

Для определенности положим, что все значения имеют тип `double` и занимают по `size = 8` байт в памяти. 

Соответственно, чтобы получить первый элемент этой последовательности, нужно взять первые 8 байт, для второго – следующие 8 байт и так далее. Математически операцию вычисления первого байта произвольного элемента можно записать в виде:

$addres_k = f + k \cdot size,   k = 0, 1, 2, …, n-1$

Здесь `f` – номер первого байта первого элемента в памяти устройства; `size` – размер одного элемента в памяти (в нашем примере `size = 8`). Значения `k` в такой структуре данных получили название индексы. 

То есть, если всего имеется `n` элементов, то индекс первого элемента всегда равен `0`, а индекс последнего равен `n-1`.

Как вы уже догадались, в языке Си для такой организации хранения данных в памяти устройства используют массивы. Для их объявления в программе можно воспользоваться следующим синтаксисом:

```
<тип элементов массива> <имя массива>[<число элементов массива>];
```

Например, в нашем случае с функцией синус массив можно объявить так:

```c
double f[30];
```

В итоге получаем массив, состоящий из элементов типа `double`, с именем `f` и общим числом элементов, равным 30. 

Имя массива мы, конечно же, придумываем сами, так же как и имена переменных. В результате такого объявления в памяти устройства автоматически выделяется непрерывная область памяти для хранения `30` чисел типа `double` общего размера:

$30 \cdot 8 = 240$ байт.

А теперь, внимание! 

Строго говоря, в языке Си нет структуры данных под названием массив! 

То, что здесь понимается под массивом – это просто фрагмент области памяти, в которую можно записывать произвольные данные, в нашем случае через переменную `f`. 

То есть, здесь нет программной оболочки над этими данными, которая бы контролировала корректность индексов, или позволяла бы присваивать один массив другому и так далее. 

Все что здесь мы имеем – это набор элементов в непрерывной области памяти.

Больше ничего! Вся ответственность за правильное использование этого фрагмента с данными лежит на плечах программиста. 

Сделано это было не случайно. 

Вспомним, что язык Си был создан как заменитель языка Ассемблер, так, чтобы текст программы можно было эффективно переводить в машинные коды без ущерба в производительности. 

Поэтому никаких лишних надстроек, посредников между данными в памяти и их представлением на уровне языка Си здесь нет. 

С одной стороны, это ускоряет работу программ, а с другой – возлагает на программиста всю полноту ответственности за использование ресурсов вычислительной техники.

Дальше я, тем не менее, буду употреблять слово массив, т.к. это устоявшаяся терминология языка. 

Но понимать его здесь следует не как полноценную структуру данных, а просто как непрерывную область памяти для хранения множества однотипных значений.

## Способы объявлений массивов

Давайте теперь детальнее посмотрим, как можно объявлять массивы в программе. 

+ Вначале, как мы уже видели, прописывается любой существующий тип данных, который определяет тип элементов массива. 
+ Дальше имя, которое мы придумываем сами, подобно именам переменных. 
+ И, наконец, в квадратных скобках прописывается общее число элементов массива. 

Вот здесь есть несколько важных моментов. Первое, до стандарта C99 число элементов можно было определять только константными целочисленными выражениями. Например, так:

```c
#include <stdio.h>

#define SIZE_BUFFER 1024

int main(void) {
    // Корректные объявления
    double f[30];
    char buffer[SIZE_BUFFER];
    int marks[13];
    short ar[8 * 5];
    char bytes[sizeof(double)];

    // Некорректные объявления
    int n = 5;

    float func[21.5];  // вещественное количество элементов
    int array[n];      // нельзя было до стандарта C99
    int null_ar[0];    // размер должен быть больше нуля

    return 0;
}
```

Обратите внимание, при определении размера массива вполне допустимо использовать арифметические операции и операцию `sizeof`. 

А вот возможность использования целочисленных переменных появилась только в стандарте C99, а также понятие массивов переменной длины, размеры которых можно определять через целочисленные переменные. 

Однако не все последующие стандарты языка Си поддерживают такой способ объявления, или определяют его как необязательный. 

В связи с этим использование переменных при объявлении массивов лучше избегать, так как переносимость программы в этом случае ставится под вопрос.

Если уж вам действительно понадобилось объявлять массивы с размерами на основе значений переменных, то для этого лучше использовать, так называемые, динамические массивы, то есть, массивы, динамически создаваемые в памяти в процессе выполнения программы. 

О них мы еще будем говорить, когда речь пойдет об указателях и выделении памяти.

## Запись и чтение значений в массивы

Итак, в самом простом варианте мы научились объявлять массивы.

Спрашивается, как теперь в него можно занести какие-либо значения и прочитать их оттуда? 

Давайте для определенности представим, что в программе объявлен целочисленный массив из 13 элементов для хранения оценок учащегося:

```c
#include <stdio.h>
#define TOTAL_MARKS 13

int main(void) {
    int marks[TOTAL_MARKS];
    return 0;
}
```

Чтобы занести в массив `marks` какое-либо целочисленное значение, необходимо прописать имя массива, поставить квадратные скобки, в них указать индекс элемента, в который заносится число и с помощью операции присваивания занести нужное значение. 

Например:

```c
marks[2] = 4;
```

Здесь мы в 3-й элемент записали значение 4. 

Обратите внимание, индекс 2 означает 3-й элемент массива, а не второй, так как первый элемент всегда имеет индекс 0, например:

```c
marks[0] = 2 * 3;
```

Теперь, мы в первый элемент массива занесли значение `6 = 2 * 3`. И так можно делать со всеми тринадцатью элементами, то есть, индексы в нашем примере с массивом marks должны меняться в диапазоне от `0` до `12` включительно. Последнее значение:

```c
marks[12] = 7 - 2;
```

И вот здесь начинающие программисты часто делают ошибку. Для записи данных в последний элемент указывают индекс на единицу больше:

```c
marks[13] = 1;
```

При этом программа скомпилируется без каких-либо предупреждений и ошибок, но в процессе выполнения программа может из-за этого аварийно завершиться. 

Обратите внимание, на слово может. Она может выполниться и без ошибок, как в моем случае, но при этом содержит в себе фатальную ошибку: рано или поздно у какого-нибудь пользователя эта программа просто вылетит при выполнении. 

А программист потом с пеной у рта доказывает, что дело не в программе, т.к. лично у него все работает. 

Помните, если программа вылетела хотя бы один раз из миллиона запусков, значит, виноват программист, он что то не учел. 

И массивы здесь, как раз очень легко могут стать источником подобных ошибок. Нужно самим контролировать, чтобы индексы не выходили за допустимый диапазон, то есть, всегда были в пределах:

```c
[0; SIZE_ARRAY-1]
```

где `SIZE_ARRAY` – общее число элементов в массиве. 

Казалось бы, простое правило. 

Но не представляете, как бывает непросто его соблюсти. И все из-за того, что массивы в языке Си – это не структура данных, а просто непрерывная область памяти и корректное ее использование целиком и полностью лежит на плечах программиста.

Хорошо, теперь мы знаем, какие подводные камни таят в себе массивы. Давайте теперь посмотрим, как можно считывать значения из них. Как вы, наверное, уже догадались, делается это следующим образом:

```c
int x = marks[2];
```

Здесь читается значение 3-го элемента массива с индексом 2 и копируется в целочисленную переменную x. Выведем это значение на экран:

```c
printf("x = %d\n", x);
```

После запуска программы увидим строчку:

```
x = 4
```

То есть, мы прочитали значение `4`, которое ранее записывали в 3-й элемент. И так можно читать из любого элемента массива. Здесь также нужно контролировать корректность индексов и не допускать ситуаций вроде следующей:

```
x = marks[13];
```

Скорее всего, программа отработает без ошибок, т.к. мы просто читаем следующие байты за массивом. 

Это не так критично, когда происходит попытка записи в несуществующие элементы массива. Но, тем не менее, это считается потенциальной ошибкой.

А теперь давайте посмотрим, как можно прочитать все элементы из массива `marks` и вывести их на экран. Очевидно, сделать это можно с помощью циклов. И мы воспользуемся для этого оператором `for` следующим образом:

```c
#include <stdio.h>
 
#define TOTAL_MARKS                13
 
int main(void)
{
         int marks[TOTAL_MARKS];
         marks[2] = 4;
         marks[0] = 2;
         marks[12] = 5;
//       marks[13] = 1;               // никогда так не делайте!!!
 
         for(int i = 0; i < TOTAL_MARKS; ++i)
                   printf("%d ", marks[i]);
 
         return 0;
}
```

После запуска у меня на экране отобразилась следующая строчка:

```
2 6488012 4 1424847605 -2 6487816 2001366829 4200976 6487936 4201088 4200976 4199120 5
```

Смотрите, здесь элементы, которым мы ничего не присваивали, принимают случайные значения. 

Это связано с тем, что когда массивы объявляются внутри функций, под них автоматически выделяется память (в момент вызова функции) и все, что в этой памяти было, то и остается, то есть, мусор. 

Как раз этот мусор в виде случайных значений мы и видим. Кроме тех элементов, которым позже присваивали определенные значения. Это следует учитывать при составлении программы: изначально в массиве, скорее всего, будут неопределенные величины.

Видео по теме [#29. Введение в массивы](https://www.youtube.com/watch?v=f7gARd3t2sg&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, касающиеся массивов языка Си.

+ [x] массивы представляют собой непрерывную область памяти, в которой друг за другом размещены данные одного типа
+ [x] длина массива - это максимальное число элементов (определенного типа), которые он хранит
+ [x] индекс массива - это целое число от 0 до length-1 (length - длина массива); служит для доступа к определенному элементу массива
+ [x] массивы можно объявлять по синтаксису: <тип элементов массива> <имя массива>[<число элементов массива>];
+ [ ] индекс массива - это целое число от 1 до length (length - длина массива); служит для доступа к определенному элементу массива
+ [ ] длина массива - это число байт, которые он занимает в памяти устройства

### Подвиг 2. Запишите объявление массива с именем ar_f, длиной в 13 элементов, содержащий вещественные числа типа float.

P. S. Без инициализации, только используя материал текущего занятия.

```c
float ar_f[13];
```

### Подвиг 3. Пусть в программе объявлен массив:

```c
int ar_int[100];
```

И его адрес оказался равен `1000`. Вычислите адрес элемента этого массива с индексом `5`, учитывая, что размер типа `int` составляет `32` бит. В ответ запишите одно десятичное число.

$1020$

### Подвиг 4. Пусть в программе объявлен массив:

```c
short buffer[512];
```

Вычислите, сколько байт в памяти устройства занимает этот массив, учитывая, что размер типа short составляет 16 бит. В ответ запишите одно десятичное число.

$1024$

### Подвиг 5. Имеется следующая программа:

```c
#define TOTAL 1024

int main(void) {
    int total = 100;
    // здесь выполняются объявления

    return 0;
}
```
Выберите все верные (рабочие) варианты объявления массивов внутри функции main().

+ [x] unsigned short ar_1[100];
+ [ ] long long ar_6[0.5 * 2];
+ [x] signed char ar_4[total]; // (поддерживается не всеми компиляторами)
+ [ ] long ar_5[0];
+ [x] short int ar_8[(int)(0.5 * 3)];
+ [x] long double ar_7[TOTAL / 2];
+ [x] double ar_2[5 * 3 - 2];
+ [x] float ar_3[sizeof(total) * 5];

### Подвиг 6. В программе ниже объявите массив с именем buffer длиной 1024 элементов типа short. Присвойте первому элементу (первому по счету) значение 13.

P. S. В консоль ничего выводить не нужно.

```c
#include <stdio.h>
#define BUFFER 1024

int main(void) {
    short buffer[BUFFER];
    buffer[0] = 13;

    return 0;
}
```

### Подвиг 7. В программе ниже объявите массив с именем func длиной 28 элементов типа double. Прочитайте из входного потока вещественное число в переменную x и присвойте его седьмому элементу (седьмому по счету) массива func.

P. S. В консоль ничего выводить не нужно.

```c
#include <stdio.h>
#define MAX 28

int main(void) {
    double func[MAX], x;

    scanf("%lf", x);

    func[6] = x;

    return 0;
}
```

### Подвиг 8. Продолжите программу. Необходимо прочитать из входного потока пять целых чисел, записанных в одну строчку через пробел, в массив с именем digits длиной пять элементов типа int. Используя оператор цикла for, выведите в консоль все значения элементов массива digits в одну строчку через пробел.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/5.1.8

```c
#include <stdio.h>
#define MAX 5

int main(void) {
    int digits[MAX];

    for (int i = 0; i < MAX; i++) {
        scanf("%d", &digits[i]);
    }
    for (int i = 0; i < MAX; i++) {
        printf("%d ", digits[i]);
    }
    return 0;
}
```

### Подвиг 9. Продолжите программу. Необходимо объявить два массива с именами ar_1 и ar_2, содержащими элементы типа int. Длина массива ar_1 должна быть равна TOTAL, а массива ar_2 - в два раза больше (TOTAL * 2). Затем прочитайте из входного потока пять целых чисел, записанных через пробел, в массив ar_1 значения (по порядку, начиная с первого). После этого скопируйте значения массива ar_1 в массив ar_2. Оставшиеся элементы массива ar_2 должны принимать значение -1.

P. S. В консоль ничего выводить не нужно.

```c
#include <stdio.h>
#define TOTAL 5

int main(void) {
    int ar_1[TOTAL];
    int ar_2[TOTAL * 2];

    for (int i = 0; i < TOTAL; i++) {
        scanf("%d", &ar_1[i]);
        ar_2[i] = ar_1[i];
    }
    for (int i = TOTAL; i < TOTAL * 2; i++) {
        ar_2[i] = -1;
    }

    return 0;
}
```

### Подвиг 10 (на повторение). Выберите все верные утверждения, касающиеся булевых типов и данных языка Си стандарта C99 и выше.

+ [x] булево понятие "истина" определяется любым ненулевым числовым значением
+ [ ] булево понятие "ложь" определяется любым ненулевым числовым значением
+ [x] булево понятие "ложь" определяется нулевым значением
+ [x] приоритет операций сравнения выше приоритета операции присваивания
+ [x] в заголовочном файле stdbool.h определен тип bool и две константы true и false
+ [ ] приоритет операций сравнения выше приоритетов арифметических операций
+ [ ] булево понятие "истина" определяется нулевым значением
+ [x] приоритет операций сравнения ниже приоритетов арифметических операций
+ [ ] приоритет операций сравнения ниже приоритета операции присваивания

# 5.2 Вычисление размера массива. Инициализация массивов

На этом занятии вы узнаете, как можно вычислять размер произвольного массива и выполнять инициализацию его элементов. Начнем с вычисления числа элементов массива.

## Операция sizeof с массивами

В примере программы из прошлого занятия для определения размера массива используется константа `TOTAL_MARKS`, определенная директивой `define`:

```c
#include <stdio.h>

#define TOTAL_MARKS 13

int main(void) {
    int marks[TOTAL_MARKS];

    marks[2] = 4;
    marks[0] = 2 * 3;
    marks[12] = 7 - 2;
    //       marks[13] = 1;

    for (int i = 0; i < TOTAL_MARKS; ++i) printf("%d ", marks[i]);

    return 0;
}
```

Однако не всегда удается так просто определить размер массива и, соответственно, перебрать его элементы. 

В общем случае язык Си предоставляет возможность вычисления числа элементов массива с помощью уже знакомой вам операции `sizeof`. 

Делается это следующим образом. Как вы помните, `sizeof` возвращает размер переменной или типа данных в байтах. 

Но, применительно к массиву, она возвращает размер области памяти (также в байтах), которая под него выделена. Например:

```c
size_t bytes_marks = sizeof(marks);
printf("%zu\n", bytes_marks);
```

Получим значение `52` в переменной `bytes_marks`. Это, как раз, величина:

$13 \cdot 4 = 52$ байта

Обратите внимание на тип переменной `size_t`. В данном случае – это переопределение целочисленного типа `unsigned long long`. По сути, имя `size_t` введено для универсальной записи программы при использовании функций или операций подобной `sizeof`. 

В разных реализациях языках и на разных платформах имя `size_t` может быть связано с разными целочисленными типами. Но всегда является целочисленной и беззнаковой. 

Далее, мы выводим значение переменной `bytes_marks`, используя спецификатор `%zu`, специально введенный для типа `size_t`.

Итак, размер массива в байтах мы легко можем определить. Теперь, чтобы вычислить число его элементов, нужно этот общий размер разделить на число байт, занимаемых одним элементом этого массива. Очевидно, сделать это можно так:

```c
size_t size_marks = sizeof(marks) / sizeof(marks[0]);
printf("%zu\n", size_marks);
```

Увидим значение `13`, как раз столько элементов в массиве `marks`.

Конечно, вместо `sizeof(marks[0])` в данном конкретном случае можно было бы прописать тип `int`:

```c
size_t size_marks = sizeof(marks) / sizeof(int);
```

Но это менее универсальное решение, так как при изменении типа массива `marks` в программе потом придется менять и эту строчку. А если забыть это сделать (что очень легко может произойти), то можно получить ошибку в процессе выполнения программы, например, из-за выхода индексов за диапазон. 

Поэтому рекомендуется первый вариант записи или еще вот такой:

```c
size_t size_marks = sizeof(marks) / sizeof(*marks);
```

Забегая вперед, скажу, что `*marks` – это, по сути, то же самое, что и `marks[0]`.

## Инициализация массивов

Теперь посмотрим, каким образом в языке Си можно выполнять инициализацию массивов начальными значениями. Смотрите, если в момент объявления массива мы знаем, какие данные он должен содержать, то их можно сразу прописать следующим образом:

```c
int marks[TOTAL_MARKS] = {1, 2, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0};
```

То есть, после объявления массива прописывается знак равно и далее в фигурных скобках через запятую перечисляются значения, которые будут записаны в соответствующие элементы массива. В данном примере в первые четыре элемента (по порядку) будут занесены значения 1, 2, 3 и 4 соответственно. А в остальные – числа 0.

Обратите внимание, здесь равно – это не операция присваивания, это именно инициализация массива. 

Когда мы с вами рассматривали переменные, то отмечали, что есть операция инициализации, а есть операция присваивания и в общем случае – это разные вещи. 

На примере массива это очень хорошо видно. Если попробовать записать эту же конструкцию в операции присваивания:

```c
int marks[TOTAL_MARKS];
marks = {1, 2, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0};
```

то получим синтаксическую ошибку. Операция присваивания не поддерживает такое выражение. 

А вот при инициализации оно вполне допустимо. 

Поэтому нужно четко различать инициализацию и присваивание.

Итак, мы теперь знаем, как можно инициализировать элементы массива начальными значениями. Но, что если нам нужно записать данные только в первые несколько элементов, а остальные пусть принимают любые значения. 

Сделать это очень просто. Указываем только нужные данные, остальные опускаем:

```c
int marks[TOTAL_MARKS] = {1, 2, 3};
```

Тогда в первые три элемента будут занесены числа 1, 2 и 3, а вот остальные становятся равными 0. 

Да, так работает инициализатор. Если мы указываем хотя бы одно начальное значение, то все остальные элементы массива становятся равными нулю. Но, обратите внимание, мы в инициализаторе можем указывать меньшее количество данных, но большее (больше числа элементов массива) задавать нельзя. Если в начальном примере добавить хотя бы один ноль:

```c
int marks[TOTAL_MARKS] = {1, 2, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
```

то получим ошибку при компиляции программы.

Чтобы этого избежать, размер массива можно не указывать, если используется инициализатор. Тогда число элементов будет равно числу инициализируемых значений. Например:

```c
int coords[] = {10, -2, 30};
```

Массив `coords` будет состоять из трех элементов, т.к. в инициализаторе указано три значения.

Наконец, в стандарте C99 появился еще один способ инициализации с указанием индекса инициализируемого элемента. Например:

```c
short digits[10] = {-1, [2] = 5, 18, [9] = -1};
for(int i = 0 ;i < sizeof(digits) / sizeof(digits[0]); ++i)
    printf("%d ", digits[i]);
```

В результате увидим строку из значений:

```
-1 0 5 18 0 0 0 0 0 -1
```

То есть, первый элемент соответствует первому значению в инициализаторе. Затем, мы указали, что 3-й элемент должен принимать значение 5, следом прописано значение следующего 4-го элемента со значением 18 и, наконец, для последнего указали значение -1.

Все эти варианты инициализации вполне можно использовать в программах в зависимости от их удобства.

Конечно, использование инициализаторов увеличивает время выполнения программы, так как в элементы массива дополнительно выполняется копирование данных. 

Поэтому пользоваться этим инструментом следует осмотрительно. Если массив небольшой длины (до 1000 элементов), то его инициализация не сильно скажется на скорости работы. Однако при большем размере могут появляться заметные задержки. 

Особенно, когда инициализация происходит внутри функций. При каждом ее вызове будет создаваться массив и инициализироваться некоторыми значениями. Здесь следует хорошо подумать, действительно ли в программе нужна эта инициализация. 

Поэтому, чаще всего, инициализацию можно встретить при глобальном определении массива (вне каких-либо функций). Например, так:

```c
#include <stdio.h>

#define TOTAL_MARKS 13

int month[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

int main(void) {
    int marks[TOTAL_MARKS] = {1, 2, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0};

    for (int i = 0; i < TOTAL_MARKS; ++i) printf("%d ", marks[i]);

    return 0;
}
```

Тогда его значения будут инициализироваться один раз в момент загрузки программы. Из-за этого при глобальных объявлениях можно в инициализаторе использовать только константные выражения времени компиляции. Переменные или вызовы функций подставлять сюда уже недопустимо. А вот при локальной инициализации вполне можно использовать и переменные и функции, например:

```c
#include <stdio.h>
#include <stdlib.h>

#define TOTAL_MARKS 13

int month[] = {31, 28, 31 * 2, 30, 31, 30, 31, 31, 30, 31, 30, 31};

int main(void) {
    int val = -5;
    int marks[TOTAL_MARKS] = {1, 2, 3, 4, val, abs(val), 0, 0, 0, 0, 0, 0, 0};

    for (int i = 0; i < TOTAL_MARKS; ++i) printf("%d ", marks[i]);

    return 0;
}
```

Но, как я уже отмечал, инициализацию массивов внутри функций следует избегать, кроме, может быть, функции `main()`, т.к. она, как правило, вызывается только один раз в процессе работы программы.

Видео по теме [#30. Вычисление размера массива. Инициализация массивов](https://www.youtube.com/watch?v=6qlV7bCZBdE&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, касающиеся операции sizeof.

+ [x] операцию sizeof можно применить к типам данных, например, так: sizeof(short);
+ [x] операция sizeof для массива с именем ar может быть записана в виде: sizeof ar;
+ [x] операция sizeof применительно к массиву возвращает число байт, которые он занимает в памяти устройства
+ [ ] операцию sizeof можно применить к типам данных, например, так: sizeof short;
+ [x] операция sizeof для массива с именем ar может быть записана в виде: sizeof(ar);

### Подвиг 2. Выберите все верные варианты вычисления длины следующего массива (числа его элементов):

```c
double ar[13];
size_t size_ar;
```

+ [x] size_ar = sizeof(ar) / sizeof(ar[1]);
+ [x] size_ar = sizeof(ar) / sizeof(ar[0]);
+ [ ] size_ar = sizeof(*ar) / sizeof(ar);
+ [ ] size_ar = sizeof(ar);
+ [x] size_ar = sizeof(ar) / sizeof(*ar);
+ [x] size_ar = sizeof(ar) / sizeof(double);
+ [ ] size_ar = sizeof(double) / sizeof(ar);
+ [x] size_ar = sizeof ar / sizeof *ar

### Подвиг 3. В программе объявлен до функции main() массив с именем marks и типом элементов short. Этот массив скрыт в коде, но он существует. В функции main() вычислите длину массива marks (число его элементов) и размер массива (число байт, которые он занимает в памяти устройства). Выведите в консоль в одну строчку через пробел длину массива и его размер в байтах (именно в таком порядке) в виде целых чисел.

```c
#include <stdio.h>

int main(void) {
    int marks[5] = {0};
    int a, b;

    a = sizeof marks;
    b = a / sizeof(*marks);

    printf("%d %d", b, a);

    return 0;
}
```

### Подвиг 4. В программе объявлен до функции main() массив с именем pows и типом элементов float. Этот массив скрыт в коде, но он существует. В функции main() выведите в консоль в одну строчку через пробел значения его элементов в обратном порядке с точностью до десятых.

```c
#include <stdio.h>

int main(void) {
    float pows[5] = {1, 2, 3, 4, 5};

    int len = sizeof pows / sizeof(*pows);

    for (int i = len - 1; i >= 0; i--) {
        printf("%.1f ", pows[i]);
    }

    return 0;
}
```

### Подвиг 5. Выберите все верные утверждения, касающиеся инициализации массивов языка Си стандарта C99.

+ [x] при инициализации массивов в функции main() можно использовать переменные
+ [x] при инициализации массивов в глобальной области можно использовать только выражения времени компиляции программы
+ [x] операция инициализации массивов увеличивает объем вычислений (при выполнении программы) и тем больше, чем длиннее массив
+ [ ] если при инициализации указано меньше значений, чем длина массива, то оставшиеся элементы массива принимают произвольные значения
+ [x] если при инициализации указано меньше значений, чем длина массива, то оставшиеся элементы массива принимают значение 0
+ [x] число значений в инициализаторе должно быть меньше или равно длине массива
+ [ ] операция инициализации массивов не влияет на скорость выполнения программы

### Подвиг 6. Выберите все верные варианты инициализации массивов.


+ [x] double ar_d[7] = {[2]=0.5, 0.8, [6]=0.01};
+ [x] short zeros[64] = {0};
+ [x] short buf[] = {0, 0, 1, 1, 2, 2};
+ [x] long long pows[4] = {1, 2, 4, 8};
+ [ ] int ar_i[5] = {0, 1, 2, 3, 4, 5};
+ [x] int row[32] = {};
+ [x] char str[100] = {1, 2, 3, 10};

### Подвиг 7. В программе в функции main() объявите массив типа long с именем digits и длиной 128 элементов. Выполните его инициализацию так, чтобы элемент с индексом 16 был равен 4, элемент с индексом 32 был равен 5, элемент с индексом 64 был равен 6, а остальные элементы равны 0.

P. S. В консоль ничего выводить не нужно.

```c
#include <stdio.h>

int main(void) {
    long digits[128] = {[16] = 4, [32] = 5, [64] = 6};

    return 0;
}
```

### Подвиг 8. В программе ниже в функции main() объявите массив типа short, именем ar_rnd и длиной 64 элемента. Проинициализируйте этот массив нулями (используя инициализацию, а не присваивание). Прочитайте из входного потока пять целых чисел, записанных в одну строчку через пробел, и занесите их по порядку в первые пять элементов массива ar_rnd.

P. S. В консоль ничего выводить не нужно.

```c
#include <stdio.h>

int main(void) {
    short ar_rnd[64] = {0};

    for (size_t i = 0; i < 5; i++) {
        scanf("%hd", &ar_rnd[i]);
    }

    return 0;
}
```

### Подвиг 9. В программе до функции main() объявлен массив с именем marks и типом элементов short. Этот массив скрыт в коде, но он существует. В функции main() вычислите среднее арифметическое значений элементов этого массива и выведите в консоль полученное значение с точностью до сотых.

```c
#include <stdio.h>

int main(void) {
    short marks[5] = {1, 2, 3, 4, 7};
    double res = 0;

    int len = sizeof marks / sizeof(*marks);

    for (int i = 0; i < len; i++) {
        res += marks[i];
    }
    res /= len;

    printf("%.2lf", res);

    return 0;
}
```

### Подвиг 10 (на повторение). Установите соответствия между обозначениями операторов и их описаниями.

![05](/Good_good_C_C++/img/05_03.PNG)

# 5.3 Указатели на массивы

## Указатели на массивы

На этом занятии посмотрим, как указатели можно использовать совместно с массивами. Давайте предположим, что в программе объявляется следующий массив с именем ar:

```c
#include <stdio.h>
 
int main(void) {
    short ar[] = {4, 3, 2, 1, 5, 6, 7};
    return 0;
}
```

Так вот, имя массива `ar` в языке Си является указателем на массив и содержит адрес первой ячейки, начиная с которой хранятся элементы этого массива:

![05](/Good_good_C_C++/img/05_04.png)

А раз это так, то значение первого элемента можно получить с помощью операции разыменования:

```c
short a_1 = *ar;
printf("a_1 = %d\n", a_1);
```

И, действительно, после запуска программы увидим на экране значение 4 первого элемента. Мало того, используя адресную арифметику, мы можем переходить к произвольному элементу и работать с ним. Например:

```c
short a_4 = *(ar+3);
printf("a_4 = %d\n", a_4);
```

В результате, переменная `a_4` будет содержать значение `1` четвертого элемента. Наконец, мы можем через цикл вывести все значения элементов этого массива следующим образом:

```c
for(int i = 0; i < sizeof(ar) / sizeof(*ar); ++i)
    printf("%d ", *(ar+i));
```

Давайте внимательнее посмотрим на эту конструкцию. 

В цикле for вычисляется длина массива (число его элементов) с помощью операции `sizeof`. 

Вначале определяется общее число байт, занимаемое массивом `sizeof(ar)`, а затем, оно делится на число байт, отведенное под один элемент `sizeof(*ar)`.

Получаем общее число элементов в массиве. 

Однако если `ar` – это указатель на массив, то почему операция `sizeof(ar)` возвращает количество байт массива, а не указателя? 

В действительности, здесь `ar` является именно указателем на массив, а не просто указателем на ячейки памяти. 

В языке Си хоть и отсутствует массив, как структура данных, но указатель такого вида все же присутствует. 

Он формируется автоматически, как только мы объявляем какой-либо массив в программе. Его имя становится указателем на массив.

Чем же отличается указатель на массив от обычного указателя? В целом, только двумя моментами:
+ операция `sizeof` для указателя на массив возвращает число байт, занимаемых массивом в памяти устройства;
+ адрес указателя на массив формируется в момент его объявления (размещения в памяти устройства) и остается неизменным на протяжении работы программы.

Давайте я на конкретных примерах продемонстрирую эти особенности. Итак, пусть у нас имеется массив из целых чисел и указатель того же типа:

```c
#include <stdio.h>

int main(void) {
    short ar[] = {4, 3, 2, 1, 5, 6, 7};
    short *ptr_ar;

    return 0;
}
```

Так как `ar` – это указатель, то мы можем присвоить указателю `ptr_ar` адрес массива `ar` следующим образом:

```c
ptr_ar = ar;
```

или так:

```c
ptr_ar = &ar[0];
```

Но первый вариант лучше и визуально и требует меньшего числа операций.

Далее проверим, можно ли работать с массивом `ar` через указатель `ptr_ar`:

```c
short x = *ptr_ar;
*(ptr_ar+1) = -3;
```

Действительно, при отладке видим, что переменная `x` содержит значение `4`, а массив `ar` изменил второй элемент на `-3`.

Теперь проверим, как будет работать операция `sizeof` с указателями `ar` и `ptr_ar`:

```c
size_t len_1 = sizeof(ar);         // len_1 = 14
size_t len_2 = sizeof(ptr_ar);     // len_2 = 4
```

После запуска в режиме отладки видим значения переменных `len_1 = 14` и `len_2 = 4`. 

То есть, эти указатели все же немного различаются. 

Указатель на массив выдает общее число байт, отведенных под массив, а `ptr_ar` – размер указателя в памяти устройства (4 байта для 32-х разрядных систем).

Попробуем теперь изменить адрес указателя на массив:

```c
ar++;
```

При компиляции увидим сообщение об ошибке. Так делать нельзя. И, вообще, менять адрес указателя на массив запрещено. А вот с обычным указателем такая операция вполне допустима:

```c
ptr_ar++;
```

Никаких ошибок и программа успешно выполняется. Мало того, мы с помощью указателя `ptr_ar` можем обращаться к произвольным элементам массива, используя оператор квадратные скобки. Например:

```c
short a_3 = ptr_ar[2];       // a_3 = 2 (при ptr_ar = ar)
```

На самом деле, оператор `[]` – это обычная синтаксическая конструкция, подменяющая собой адресную арифметику вида:

```c
ar[index] = *(ar+index)
```

То есть, операция индексирования – это не операция над массивами, а над адресами и не более того. Мало того, в общем виде ее можно представить так:

```c
a[b] = *(a+b)
```

При этом совершенно не важно, что здесь выступает в роли `a`, а что в роли `b`. То есть, формально, обратиться к элементу массива `ar` с индексом `2` можно и так:

```c
short a_3 = 2[ar];     // *(2+ar)
```

так как это эквивалентно операции `*(2+ar)`, а она вполне допустима. 

Конечно, в реальных проектах так использовать операцию индексирования не нужно. 

Да и, вообще, никогда. 

Помните, текст программы пишется для человека, а потому не стоит прописывать различные корявые конструкции, дабы показать глубину своих познаний. 

Рабочий коллектив такое не оценит.

Видео по теме [#31. Указатели на массивы](https://www.youtube.com/watch?v=qPspc2X4lOY&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, касающиеся указателей на массивы.

+ [x] указатель на массив - это особый тип указателя, который автоматически формируется в момент объявления массива
+ [ ] операция sizeof, применительно к указателю на массив, возвращает размер самого указателя (в байтах)
+ [x] имя массива является указателем на начало области памяти с данными этого массива
+ [x] операция sizeof, применительно к указателю на массив, возвращает размер области памяти, занимаемой массивом
+ [x] в указателе на массив нельзя менять значение хранимого адреса

### Подвиг 2. Какое числовое значение будет принимать переменная size_ar при выполнении следующего фрагмента программы:

```c
int ar[10];
int size_ar = sizeof(ar);
```

Полагается: тип `int` занимает 32 бит; размер указателя 32 бит.

$40$

### Подвиг 3. Какое числовое значение будет принимать переменная size_ptr_ar при выполнении следующего фрагмента программы:

```c
int ar[10];
int* ptr_ar = ar;
int size_ptr_ar = sizeof(ptr_ar);
```
Полагается: тип `int` занимает 32 бит; размер указателя 32 бит.

$4$

### Подвиг 4. В программе до функции main() объявлены два массива типа char с именами buff_1 и buff_2. Эти массивы скрыты в коде, но они существуют. Необходимо в функции main() объявить массив того же типа char с именем buffer длиной 128 элементов. Затем, сформировать указатель с именем ptr_ar на массив buffer. Используя ptr_ar выполнить последовательное копирование значений элементов из массивов buff_1 и buff_2 в массив buffer (то есть, оператор [] для массива buffer не применять). Гарантируется, что длины массива buffer достаточно для хранения двух массивов buff_1 и buff_2.

P. S. В консоль ничего выводить не нужно.

```c
#include <stdio.h>

int main(void) {
    char buff_1[] = {4, 3, 2, 1, 5, 6, 7};
    char buff_2[] = {4, 3, 2, 1, 5, 6, 7};
    char buffer[128];

    char *ptr_ar;

    ptr_ar = buffer;

    int len_1 = sizeof(buff_1) / sizeof(*buff_1);
    int len_2 = sizeof(buff_2) / sizeof(*buff_2);

    for (int i = 0; i < len_1; i++) {
        *(ptr_ar++) = *(buff_1 + i);
    }
    for (int i = 0; i < len_2; i++) {
        *(ptr_ar++) = *(buff_2 + i);
    }

    return 0;
}
```

### Подвиг 5. Продолжите программу. Прочитайте из входного потока целое число в переменную value типа int. Объявите массив с именем ar_d типа char и длиной для побайтного хранения числа типа int. Скопируйте значение каждого байта переменной value в массив ar_d (значение самой переменной value не менять). Выведите значения элементов массива ar_d в консоль в виде десятичных чисел в одну строчку через пробел.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/5.3.5

```c
#include <stdio.h>

int main(void) {
    int value;

    scanf("%d", &value);

    int len = sizeof(int) / sizeof(char);

    char ar_d[len];

    char* bite = (char*)&value;

    for (int i = 0; i < len; i++) {
        ar_d[i] = *(bite + i);
        printf("%d ", ar_d[i]);
    }

    return 0;
}
```

### Подвиг 6. Напишите программу, которая читает целочисленные значения из входного потока в массив, записанных в одну строчку через пробел. Чтение происходит до тех пор, пока либо не закончатся данные, либо не будет прочитано 10 чисел. После этого выполните проверку: если прочитанные числа неотрицательны (больше или равны 0) и нечетны, то выведите в консоль число 1, иначе - число 0. Попробуйте реализовать эту программу без применения условных операторов.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/5.3.6

```c
#include <stdio.h>
#define MAX 10

int main(void) {
    int value, counter = MAX, res = 1;

    while (scanf("%d", &value) == 1 && counter--) {
        res *= (value > 0) * (value % 2);
    }
    printf("%d", res);

    return 0;
}
```

```c
#include <stdio.h>

int main(void)
{
    int ar[] = {}, res = 1;
    
    for(int i = 0, value = 0; scanf("%d", &value) == 1 && i < 10; i++)
    {
        ar[i] = value;
        res *= (value % 2) * (0 < value);
    }
    
    printf("%d", res);
    
    return 0;
}
```

### Подвиг 7. Напишите программу, которая читает в массив вещественные числа из входного потока, записанные через пробел. Чтение происходит до тех пор, пока не будет достигнут конец данных. Гарантируется, что максимальное количество чисел не более 20. Вычислите среднее арифметическое прочитанных чисел и выведите в консоль полученное значение с точностью до сотых.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/5.3.7

```c
#include <stdio.h>

int main(void) {
    double value, res = 0;
    int counter = 0;
    while (scanf("%lf", &value) == 1) {
        res += value;
        counter++;
    }
    res /= counter;

    printf("%.2lf", res);

    return 0;
}
```

### Подвиг 8. Продолжите программу. Прочитайте из входного потока целые числа в переменные var_1, var_2 и var_3, записанные в одну строчку через запятую. Побайтно занесите их значения в массив типа char (в порядке var_1, var_2, var_3). Выведите в одну строчку по порядку значения массива в виде беззнаковых десятичных чисел.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/5.3.8

```c
#include <stdio.h>

void bite_print(const unsigned char* ptr, int len) {
    for (int i = 0; i < len; i++) {
        printf("%d ", *(ptr + i));
    }
}

int main(void) {
    short var_1;
    int var_2;
    long var_3;

    unsigned char* ptr;

    scanf("%hd, %d, %ld", &var_1, &var_2, &var_3);

    ptr = (unsigned char*)&var_1;
    bite_print(ptr, sizeof(var_1));
    ptr = (unsigned char*)&var_2;
    bite_print(ptr, sizeof(var_2));
    ptr = (unsigned char*)&var_3;
    bite_print(ptr, sizeof(var_3));
    return 0;
}
```

### Подвиг 9 (на повторение). Выберите все верные варианты, касающиеся указателей.

+ [ ] указатели разных типов не могут ссылаться на одну и ту же область памяти
+ [x] присвоение указателей разных типов следует выполнять с операцией приведения типа одного указателя к другому
+ [x] указатели разных типов могут ссылаться на одну и ту же область памяти
+ [x] указатель с типом void* можно присваивать указателям любых других типов без возникновения каких-либо предупреждений со стороны компилятора
+ [x] константа NULL языка Си служит для обозначения неиницализированного указателя (на выделенную область памяти)
+ [x] присваивание адресов указателей разных типов приводит к предупреждению при компиляции программы

### Подвиг 10 (на повторение). Пусть в программе объявлены следующие переменные и указатели:

```c
int a = 5, b = 7;
double d = 2.0;
int* ptr_a = &a, *ptr_b = &b;
```

Выберите все верные (рабочие) варианты адресной арифметики с указателями ptr_a и ptr_b.

+ [x] --ptr_a;
+ [ ] ptr_b += ptr_a;
+ [ ] ptr_b + ptr_a;
+ [ ] ptr_a *= a;
+ [ ] ptr_b -= ptr_a;
+ [x] ptr_b - ptr_a;
+ [x] ptr_b++;
+ [ ] ptr_a /= b;
+ [x] ptr_a += 3;
+ [x] ptr_a += b * 5;
+ [ ] ptr_a -= d;

# 5.4 Ключевое слово const с указателями и переменными

## Ключевое слово const

На предыдущем занятии мы с вами увидели, что указатель на массив и обычный указатель – это практически одно и тоже. 

Через любой дополнительный указатель на массив мы также можем обращаться к любому его элементу, используя операцию квадратные скобки `[]`, записывать или считывать оттуда данные. 

Мало того, при необходимости, мы даже можем объявить обычный указатель так, чтобы его адрес нельзя было менять в процессе работы программы. 

Ровно так, как и указатель на массив. 

Сделать это возможно с помощью ключевого слова `const`, которое пришло в язык Си из языка С++ и поддерживается стандартном С99.

Давайте посмотрим на возможности ключевого слова `const`. Довольно часто в программах можно увидеть объявления указателей в виде:

```c
const short *ptr_ar;
```

Что оно означает? 

Первое, что приходит на ум, это объявление константного указателя, то есть, указателя, который не может менять значение своего адреса. 

Но это не так. 

В данной конструкции ключевое слово `const` означает, что через указатель `ptr_ar` нельзя менять значения в ячейках памяти. А вот адрес, как раз, мы вполне можем менять. 

Например:

```c
ptr_ar = ar;
ptr_ar[0] = 10;   // ошибка, т.к. ptr_ar определен с const
```

На чтение значений никаких ограничений нет:

```c
short x = ptr_ar[0];
```

В дальнейшем мы можем изменить адрес указателя `ptr_ar`:

```c
ptr_ar++;
```

и прочитать следующее значение из массива:

```c
short x2 = *ptr_ar;
```

То есть, ключевое слово `const` в представленной записи задает лишь ограничение на запись значений, но не на считывание.

Но, что если нам нужно объявить именно константный указатель, то есть, с неизменным начальным адресом? 

Для этого ключевое слово `const` следует прописывать после указания типа следующим образом:

```c
short * const ptr_ar = ar;
```

Тогда ему можно присвоить начальный адрес только в момент инициализации. Обычная операция присваивания уже недопустима:

```c
ptr_ar = ar;
```

Также недопустимы все остальные операции изменения адреса, например:

```c
ptr_ar++;
```

А вот изменение значений и считывание вполне возможно:

```c
ptr_ar[0] = 10;
short x2 = ptr_ar[1];
```

Надо сказать, что ключевое слово `const` в таком качестве в реальной практике программирования почти никогда не встречается. 

Я привел эту запись исключительно в образовательных целях, чтобы вы знали, как ее понимать, если где-нибудь встретите. 

Чаще всего `const` прописывают в самом начале, чтобы запретить изменение данных через указатель.

Давайте немного глубже посмотрим на работу ключевого слова `const`, чтобы правильно понимать, что же оно в действительности делает. Объявим в программе массив и два указателя на него:

```c
#include <stdio.h>

int main(void) {
    short ar[] = {4, 3, 2, 1, 5, 6, 7};
    const short* ptr_1 = ar;
    short* ptr_2 = ar;

    return 0;
}
```

Как видите, первый указатель объявлен с ключевым словом `const`, а второй без него. Соответственно, с помощью первого указателя можно только читать данные из массива, а с помощью второго и читать и менять. Например:

```c
ptr_2[0] = 10;
int a = ptr_1[0];
```

Смотрите, мы изменили значение первого элемента массива и это изменение было прочитано с помощью первого указателя `ptr_1`. 

То есть, ключевое слово `const` накладывает ограничения не на уровне ячеек памяти, а на уровне указателя, у которого оно прописано. 

В действительности, этот `const` учитывается только компилятором языка Си. 

На уровне машинных кодов и первый и второй указатели идентичны. Именно компилятор при трансляции программы контролирует корректность использования указателя с ключевым словом `const`. 

В данном случае, компилятор контролирует, чтобы не происходило записи в ячейки памяти с помощью указателя `ptr_1`. Если такое где-либо встречается, то компиляция прерывается и выдается ошибка. Если же указатель `ptr_1` в программе используется только для чтения, то программа успешно переводится в машинные коды.

Соответственно, чтобы нельзя было «схитрить» и обойти константное объявление указателя, язык Си накладывает некоторые ограничения на его использование. В частности, нельзя обычному указателю присвоить адрес константного указателя:

```c
short * ptr_2 = ptr_1;
```

А вот наоборот можно:

```c
short * ptr_2 = ar;
const short * ptr_1 = ptr_2;
```

Часто ключевое слово `const` можно встретить при объявлении глобальных массивов из констант, например:

```c
#include <stdio.h>

const int marks[] = {1, 2, 3, 4, 5};

int main(void) {
    // программа, использующая массива marks
    return 0;
}
```

Либо при определении параметров функции, как, например, это сделано в функции `printf()`:

```c
int printf(const char *format, ...);
```

## Ключевое слово const с переменными

В заключение этого занятия пару слов о возможности использования ключевого слова `const` при объявлении обычных переменных. В целом, здесь все то же самое. Если записать прописать `const` в самом начале:

```c
#include <stdio.h>

int main(void) {
    const int code = 13;

    return 0;
}
```

то переменную можно только инициализировать, но нельзя присваивать ей какие-либо значения:

```
code = 15;
```

То есть, операция присваивания становится недопустимой для таких переменных. Только операция инициализации.

И вот здесь обратите внимание, что переменная `code` – это, по-прежнему, обычная переменная с той лишь разницей, что мы не можем изменить ее значение в процессе работы программы. 

Неправильно воспринимать ее как константу. 

На уровне машинных кодов – это такая же переменная, как и любая другая. 

А ключевое слово `const` прописано исключительно для компилятора. 

В процессе трансляции он будет контролировать, чтобы переменная не меняла свое значение. То есть, `const` – это просто указание для компилятора, в машинные коды оно никак не переводится.

В связи с этим, константные переменные следует все же рассматривать как переменные. Например, их по-прежнему, нельзя использовать в метках `case` условного оператора `switch`:

```c
#include <stdio.h>

int main(void) {
    const int code = 13;
    int item = 1;

    switch (item) {
        case code:
            printf("error");
    }

    return 0;
}
```

Так как на момент компиляции программы значение переменной `code` не определено. Число `13` ей будет присвоено только при выполнении программы и размещения переменной `code` в памяти устройства. 

Правда, такие переменные допускается использовать при объявлении массивов:

```c
const int code = 13;
char str[code];
```

Здесь включается механизм создания массивов переменной длины на основе переменных. Делать так крайне не рекомендуется. 

Машинный код программ, использующие такие объявления, может получаться крайне неэффективным, а значит, сводит на нет главное достоинство языка Си – скорость исполнения программы и полный контроль за использованием ресурсов. Поэтому такую конструкцию лучше заменить на классическую:

```c
#define SIZE 13
char str[SIZE];
```

Видео по теме [#32. Ключевое слово const с указателями и переменными](https://www.youtube.com/watch?v=GGqgoNg2lBs&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, касающиеся следующих объявлений указателей:

```c
const int* ptr_cnst;
int * const cnst_ptr;
```

+ [x] через указатель ptr_cnst можно только читать значения из ячеек памяти, но не записывать
+ [x] указатель ptr_cnst может менять значение своего адреса в процессе выполнения программы
+ [x] указатель cnst_ptr не может менять значение своего адреса, который задается при инициализации
+ [ ] через указатель ptr_cnst можно читать и записывать значения в ячейки памяти
+ [x] через указатель cnst_ptr можно читать и записывать значения в ячейки памяти
+ [x] имя массива в языке Си подобно (по принципу использования) указателю cnst_ptr
+ [ ] через указатель cnst_ptr можно только читать значения из ячеек памяти, но не записывать

### Подвиг 2. Выберите все верные (работающие без ошибок и предупреждений) конструкции со следующими указателями:

```c
int* ptr;
const int* ptr_cnst;
int * const cnst_ptr;
```

+ [ ] cnst_ptr = ptr;
+ [ ] *ptr_cnst = 10;
+ [x] --ptr_cnst;
+ [ ] ptr = ptr_cnst;
+ [ ] cnst_ptr++;
+ [x] ptr_cnst = ptr;
+ [x] ptr = cnst_ptr;
+ [x] *cnst_ptr = 77;

### Подвиг 3. Выберите все верные (работающие) конструкции с константной переменной.

+ [x] const int var;
+ [x] const int a = 5; int b = a;
+ [x] long const lg = 10;
+ [x] const short sh = 100;
+ [ ] char const cnst_ch; cnst_ch = 12;
+ [ ] const char ch_cnst; ch_cnst = 12;

### Подвиг 4. В программе ниже объявите константную целочисленную переменную с именем total и начальным значением 5. Прочитайте из входного потока total целых чисел, записанных в одну строчку через пробел, в массив целых чисел с именем marks и длиной 100 элементов. Выведите в консоль прочитанные значения в обратном порядке в одну строчку через пробел.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/5.4.4

```c
#include <stdio.h>

int main(void) {
    const int total = 5;
    int marks[100];

    for (int i = 0; i < total; i++) {
        scanf("%d", marks + i);
    }
    for (int i = total - 1; i >= 0; i--) {
        printf("%d ", *(marks + i));
    }

    return 0;
}
```

### Подвиг 5. Продолжите программу. Необходимо из входного потока читать целые числа (по одному), пока не встретится число 78. Все прочитанные числа по порядку заносить в массив ar, используя указатель ptr_ar (кроме последнего числа 78). Вывести в консоль прочитанные значения из массива ar в одну строчку через пробел в порядке их чтения.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/5.4.5

```c
#include <stdio.h>

int main(void) {
    int ar[100], count = 0, value;
    int* const ptr_ar = ar;

    while (scanf("%d", &value) == 1 && value != 78) {
        ptr_ar[count] = value;
        printf("%d ", ptr_ar[count++]);
    }

    return 0;
}
```

### Подвиг 6 (на повторение). Выберите все верные утверждения для следующего фрагмента программы:

```c
#include <stdio.h>

#define MUL(X, Y) X* Y
#define ADD(X, Y) ((X) + (Y))
#define T_ADD(X, Y) "Adding two values " #X " and " #Y
#define RES_N(RES) res_##RES

int main(void) {
    int a = 2, b = 5;
    int res_1 = MUL(7, b);
    int res_2 = MUL(a + 2, b - 1);
    int res_3 = ADD(7, b * 2);
    printf(T_ADD(i, j) "\n");
    printf("%d %d %d", RES_N(1), RES_N(2), RES_N(3));

    return 0;
}
```

+ [x] действие макроопределений распространяется только на текущий модуль
+ [x] операция ## служит для склейки двух лексем в одну
+ [x] вызов макро-функции ADD(X, Y) всегда будет давать корректные результаты сложения двух числовых выражений
+ [x] операция # возвращает текстовое представление лексемы X
+ [x] макрос-функция T_ADD(i <> 2, j == 3) вернет строку "Adding two values i <> 2 and j == 3"
+ [x] вызов макро-функции MUL(a + 2, b - 1) приведет к не верным результатам вычисления произведения (a+2) * (b-1)
+ [ ] вызов макро-функции MUL(7, b) приведет к не верным результатам вычисления произведения 7 * b
+ [ ] вызов макрос-функции T_ADD(i <> 2, j == 3) приведет к синтаксической ошибке

### Подвиг 7 (на повторение). Выберите все верные утверждения, касающиеся следующего фрагмента программы:

```c
#include <stdio.h>

#define CELL_N(N) cell_##N

int main(void) {
    short cell_1 = 1, cell_2 = 2, cell_3 = 3;
    int n = 2;

    int res_1 = CELL_N(1) + 10;
    int res_2 = CELL_N(n) * 2;
    int res_3 = CELL_N(1 + 2) * 3;

    return 0;
}
```

+ [x] в место вызова CELL_N(1) препроцессор подставляет лексему cell_1
+ [ ] значение переменной res_3 равно 9
+ [x] в место вызова CELL_N(1+2) препроцессор подставляет лексему cell_1+2
+ [x] значение переменной res_1 равно 11
+ [x] значение переменной res_3 равно 7
+ [ ] в место вызова CELL_N(n) препроцессор подставляет лексему cell_2
+ [x] вызов CELL_N(n) приводит к ошибке
+ [ ] в место вызова CELL_N(1+2) препроцессор подставляет лексему cell_3

# 5.5 Операции с массивами: копирование, вставка, удаление, сортировка

## Операции с массивами

Это занятие будет посвящено операциям, которые часто выполняются над массивами при разработке различных приложений.

Первая операция – это копирование данных из одного массива в другой. Давайте представим, что в функции `main()` объявлены два одномерных массива разной длины с начальной инициализацией первого массива:

```c
#include <stdio.h>

int main(void) {
    float func_1[100] = {2.4, -3.8, 0, 10.2, 11.78, -5.43};
    float func_2[50];

    return 0;
}
```

Наша задача скопировать данные из первого массива `func_1` во второй `func_2`. Как это можно сделать? Начинающие программисты первым делом пробуют применить очевидную для них операцию присваивания:

```
func_2 = func_1;
```

И здесь их ждет жестокое разочарование. При компиляции в этой строчке появляется ошибка, что выполнять присваивание одного массива другому нельзя. 

Действительно, такая операция в языке Си запрещена. 

Это еще раз нам говорит о том, что массивы в Си – это не полноценная структура данных, а все лишь способ хранения значений в непрерывной области памяти, не более того. 

Как же тогда решить поставленную задачу? Самый очевидный способ – это перебрать элементы первого массива и поэлементно присвоить их другому массиву. Например, это можно сделать так:

```c
#include <stdio.h>

int main(void) {
    float func_1[100] = {2.4, -3.8, 0, 10.2, 11.78, -5.43};
    float func_2[50];

    int size_1 = sizeof(func_1) / sizeof(func_1[0]);
    int size_2 = sizeof(func_2) / sizeof(func_2[0]);
    int size = (size_1 < size_2) ? size_1 : size_2;

    for (int i = 0; i < size; ++i) func_2[i] = func_1[i];

    return 0;
}
```

Смотрите, вначале мы определяем длины обоих массивов и, затем, выбираем наименьшую, так как при копировании мы должны быть уверены, что не выйдем за пределы диапазона индексов. 

После этого запускается цикл для копирования ровно `size` элементов (наименьшего количества). Внутри цикла на каждой итерации происходит присваивание i-му элементу второго массива i-го элемента первого массива.

По аналогии копируются любые одномерные массивы, даже если типы элементов у них разные. Например, программа будет корректно работать и для таких массивов:

```c
float func_1[100] = {2.4, -3.8, 0, 10.2, 11.78, -5.43};
double func_2[50];
```

А вот если вместо `double` прописать целочисленный тип `int`:

```c
int func_2[50];
```

то внутри цикла в момент присваивания:

```c
func_2[i] = func_1[i];
```

будет происходить потеря данных. В подобных случаях рекомендуется явно прописывать операцию приведения типов:

```c
func_2[i] = (int)func_1[i];
```

Так мы говорим компилятору, что понимаем что делаем и нам нужно вещественные числа представить в виде целых с последующим присвоением результата.

### Вставка значения в произвольный элемент массива

Следующая частая операция – это вставка нового значения в произвольный элемент массива. 

О чем здесь идет речь? 

Давайте представим, что имеется массив marks для хранения оценок учащегося и в нем уже присутствуют первые три оценки:

```c
#include <stdio.h>

#define TOTAL_MARKS 10

int main(void) {
    char marks[TOTAL_MARKS] = {3, 2, 5};

    for (int i = 0; i < TOTAL_MARKS; ++i) printf("%d ", marks[i]);

    return 0;
}
```

Но, потом оказалось, что учитель забыл поставить одну четверку после двойки, а потому, нам нужно вставить это число `4` после числа `2` с сохранением всех остальных последующих оценок (до конца массива). Это и есть пример операции вставки нового значения.

Как ее можно реализовать? В общем случае нам нужно пройти с конца массива и последовательно скопировать все элементы, стоящие справа от вставляемого:

```
3, 2, x, 5, 0, 0, 0, 0, 0, 0
```

А, затем, записать новое значение в нужный элемент:

```
3, 2, 4, 5, 0, 0, 0, 0, 0, 0
```

На уровне программы это можно сделать следующим образом:

```c
#include <stdio.h>

#define TOTAL_MARKS 10

int main(void) {
    char marks[TOTAL_MARKS] = {3, 2, 5};
    int insert_indx = 2;

    for (int i = TOTAL_MARKS - 1; i > insert_indx; --i) {
        printf("marks[%d] = marks[%d]\n", i, i - 1);
        marks[i] = marks[i - 1];
    }

    marks[insert_indx] = 4;

    for (int i = 0; i < TOTAL_MARKS; ++i) printf("%d ", marks[i]);

    return 0;
}
```

Здесь дополнительно отображаются операции присваивания при сдвигах значений элементов массива. В результате, массив `marks` будет принимать значения:

```
3 2 4 5 0 0 0 0 0 0
```

Как видим, число `4` было вставлено после числа `2`, как это и требовалось. 

При этом все остальные числа после вставляемого были сдвинуты на одну позицию вправо. 

В этом и заключается суть операции вставки значения в произвольный элемент массива. По аналогии можно выполнять вставки и в другие позиции.

### Удаление значения из произвольной позиции массива

Следующий алгоритм выполняет противоположную операцию удаления значения из произвольного элемента массива. Делается это похожим образом, только здесь значения массива, стоящие после удаляемого, нужно сдвинуть на одну позицию влево.

Сделать это можно следующим образом:

```c
#include <stdio.h>

#define TOTAL_MARKS 10

int main(void) {
    char marks[TOTAL_MARKS] = {3, 2, 4, 5, 2, 4};
    int del_indx = 3;

    for (int i = del_indx; i < TOTAL_MARKS - 1; ++i) {
        printf("marks[%d] = marks[%d]\n", i, i + 1);
        marks[i] = marks[i + 1];
    }

    for (int i = 0; i < TOTAL_MARKS; ++i) printf("%d ", marks[i]);

    return 0;
}
```

Здесь вначале определен массив из 10 элементов со значениями:

```
3, 2, 4, 5, 2, 4, 0, 0, 0, 0
```

Затем, в переменной `del_indx` указывается индекс удаляемого элемента. В данном случае – это элемент с индексом `3`, который соответствует числу `5`. 

После этого запускается цикл, в котором выполняется смещение всех последующих элементов (после удаляемого) на одну позицию влево. В результате получаем массив:

```
3, 2, 4, 2, 4, 0, 0, 0, 0, 0
```

Это общий принцип удаления значения из произвольного элемента массива с сохранением всех остальных значений, а также их последовательности без каких-либо пропусков данных.

### Сортировка выбором элементов массива

Последний алгоритм, который мы разберем на этом занятии – это сортировка значений элементов массива. Что это такое? Давайте представим, что имеется массив, содержащий следующие целые числа:

```c
int a[] = {-3, 5, 0, -8, 1, 10};
```

Требуется все значения в нем выстроить по возрастанию (точнее, по не убыванию):

```
-8, -3, 0, 1, 5, 10
```

Это довольно частая и типовая задача, встречающаяся в практике программирования. И алгоритмов сортировки массивов большое количество. Мы рассмотрим один из них в качестве примера. Не самый быстрый, но наиболее понятный в своей работе, который носит название сортировки выбором.

Суть его работы очень проста. Сначала мы проходим по всем элементам массива и находим минимальное значение. Затем меняем местами это минимальное значение с первым элементом. Получаем массив:

```
1-й проход: -8, 5, 0, -3, 1, 10
```

Здесь первый элемент уже отсортирован. Далее, повторяем эту же операцию с оставшимися элементами массива, имеем:

```
2-й проход: -8, -3, 0, 5, 1, 10
3-й проход: -8, -3, 0, 5, 1, 10
4-й проход: -8, -3, 0, 1, 5, 10
5-й проход: -8, -3, 0, 1, 5, 10
```

Как видите, после пяти проходов массив a оказывается отсортированным по возрастанию (не убыванию).

Реализация этой идеи на языке Си может выглядеть следующим образом:

```c
#include <stdio.h>

int main(void) {
    char a[] = {-3, 5, 0, -8, 1, 10};
    int size = sizeof(a) / sizeof(a[0]);
    int pos;
    for (int i = 0; i < size - 1; ++i) {
        pos = i;
        for (int j = i + 1; j < size; ++j) {
            if (a[pos] > a[j]) pos = j;
        }
        if (pos != i) {
            int t = a[i];
            a[i] = a[pos];
            a[pos] = t;
        }
    }

    for (int i = 0; i < size; ++i) printf("%d ", a[i]);

    return 0;
}
```

После выполнения этой программы увидим на экране результат обработки элементов массива:

```
-8 -3 0 1 5 10
```

Кстати, если требуется сортировка по убыванию (не возрастанию), то в операторе `if(min > a[j])` достаточно поменять знак больше на меньше. 

Получим:

```
10 5 1 0 -3 -8
```

Вот примеры того, как можно обрабатывать значения элементов в массивах: для копирования, вставки, удаления и сортировки.

### Подвиг 1. Продолжите программу. Необходимо из массива ar в обратном порядке (идя от последнего записанного значения к первому) скопировать прочитанные данные в массив marks (копирование выполнять от первого элемента к последнему), не выходя за пределы массива marks. То есть, в случае достижения последнего элемента массива marks, останавливать процедуру копирования. Вывести в консоль значения массива marks (от первого до последнего скопированного элемента) в одну строчку через пробел.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/5.5.1

```c
#include <stdio.h>

int main(void) {
    short ar[10], marks[5];
    size_t count = 0;
    size_t sz_ar = sizeof(ar) / sizeof(*ar);
    size_t sz_marks = sizeof(marks) / sizeof(*marks);

    while (count < sz_ar && scanf("%hd", &ar[count]) == 1) {
        count++;
    }
    for (size_t i = 0; i < (sz_marks < count ? sz_marks : count); i++) {
        marks[i] = ar[count - i - 1];
        printf("%d ", marks[i]);
    }

    return 0;
}
```

### Подвиг 2. Продолжите программу. Необходимо в массиве buffer поменять местами первую половину прочитанных данных со второй половиной. Обратите внимание, что число прочитанных данных определяется переменной count. Причем, если count четное, то первая половина меняется со второй целиком, а если count нечетное, то центральный элемент должен оставаться на своем месте без изменений. Выведите в консоль в одну строчку через пробел первые count элементов полученного массива buffer.

P. S. Дополнительных массивов в программе не создавать.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/5.5.2

```c
#include <stdio.h>

#define SIZE_BUFFER 128

int main(void) {
    int buffer[SIZE_BUFFER];
    size_t count = 0;
    size_t sz_ar = sizeof(buffer) / sizeof(*buffer);

    while (count < sz_ar && scanf("%d", &buffer[count]) == 1) {
        count++;
    }

    size_t half_counter = count / 2;
    int shift = (count) % 2;

    for (size_t i = 0; i < half_counter; i++) {
        int tmp = buffer[i];
        buffer[i] = buffer[half_counter + i + shift];
        buffer[half_counter + i + shift] = tmp;
    }

    for (size_t i = 0; i < count; i++) {
        printf("%d ", buffer[i]);
    }
    return 0;
}
```

### Подвиг 3. Продолжите программу. Необходимо после первого найденного элемента со значением 5 массива digs вставить новое значение -5. Обратите внимание, что при вставке нового значения, последний элемент массива digs может теряться (если длина массива не позволяет хранить все значения). Также следует учитывать, что элемент со значением 5 может отсутствовать в массиве digs (тогда ничего вставлять не нужно). Выведите в консоль по порядку значения всех прочитанных + добавленных элементов массива digs в одну строчку через пробел.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/5.5.3

```c
#include <stdio.h>

#define TOTAL 10
#define DIGIT 5
#define INSERT_DIGIT -5

int main(void) {
    int digs[TOTAL] = {0}, flag = 1;
    size_t count = 0;
    size_t sz_ar = sizeof(digs) / sizeof(*digs);

    while (count < sz_ar && scanf("%d", &digs[count]) == 1) {
        if (digs[count] == DIGIT && flag) {
            digs[++count] = INSERT_DIGIT;
            flag = 0;
        }
        count++;
    }
    for (size_t i = 0; i < count; i++) {
        printf("%d ", digs[i]);
    }

    return 0;
}
```

### Подвиг 4. Продолжите программу. Необходимо после каждого элемента со значением 5 массива digs вставлять новые элементы со значениями: -1 - после первой найденной пятерки; -2 - после второй пятерки и т.д. Обратите внимание, что при вставке новых значений, последние элементы массива digs могут теряться. Также следует учитывать, что элемент со значением 5 может отсутствовать в массиве digs (тогда ничего вставлять не нужно). Выведите в консоль по порядку значения всех прочитанных + добавленных элементов массива digs в одну строчку через пробел.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/5.5.4

```c
#include <stdio.h>

#define TOTAL 10
#define DIGIT 5
#define INSERT_DIGIT -1

int main(void) {
    int digs[TOTAL] = {0}, ins = INSERT_DIGIT;
    size_t count = 0;
    size_t sz_ar = sizeof(digs) / sizeof(*digs);

    while (count < sz_ar && scanf("%d", &digs[count]) == 1) {
        if (digs[count] == DIGIT) {
            digs[++count] = ins--;
        }
        count++;
    }
    for (size_t i = 0; i < count; i++) {
        printf("%d ", digs[i]);
    }

    return 0;
}
```

### Подвиг 5. Продолжите программу. Из массива pows необходимо удалить элемент с первым найденным четным значением. Если такой элемент не был найден, то, соответственно, ничего удалять не нужно. Выведите в консоль по порядку в одну строчку через пробел полученные значения оставшихся элементов массива pows.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/5.5.5

```c
#include <stdio.h>

#define TOTAL 20

int main(void) {
    short pows[TOTAL] = {0};
    size_t count = 0;
    size_t sz_ar = sizeof(pows) / sizeof(*pows);
    char flag = 0;

    while (count < sz_ar && scanf("%hd", &pows[count]) == 1) count++;

    for (size_t i = 0; i < count - flag; i++) {
        if (flag) pows[i - flag] = pows[i];
        if (pows[i] % 2 == 0) flag = 1;
    }
    for (size_t i = 0; i < count - flag; i++) {
        printf("%d ", pows[i]);
    }

    return 0;
}
```

### Подвиг 6. Продолжите программу. Из массива pows необходимо удалить все элементы кратные 3 (делятся нацело на 3). Если таких элементов нет, то ничего удалять не нужно. Выведите в консоль по порядку в одну строчку через пробел полученные значения оставшихся элементов массива pows.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/5.5.6

```c
#include <stdio.h>

#define TOTAL 20

int main(void) {
    short pows[TOTAL] = {0};
    size_t count = 0;
    size_t sz_ar = sizeof(pows) / sizeof(*pows);
    char flag = 0;

    while (count < sz_ar && scanf("%hd", &pows[count]) == 1) count++;

    for (size_t i = 0; i < count; i++) {
        if (flag) pows[i - flag] = pows[i];
        if (pows[i] % 3 == 0) flag++;
    }
    for (size_t i = 0; i < count - flag; i++) {
        printf("%d ", pows[i]);
    }

    return 0;
}
```

### Подвиг 7. Продолжите программу. Выполните сортировку массива ws по возрастанию (неубыванию), используя метод сортировки выбором. Сортировать нужно только первые count элементов. Выведите в консоль значения отсортированного массива ws (первые count элементов) в одну строчку через пробел с точностью до сотых.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/5.5.7

```c
#include <stdio.h>

#define TOTAL 20

int main(void) {
    float ws[TOTAL] = {0.0f};
    size_t count = 0;
    size_t sz_ar = sizeof(ws) / sizeof(*ws);

    while (count < sz_ar && scanf("%f", &ws[count]) == 1) count++;

    for (size_t i = 0; i < count; i++) {
        float min = ws[i];
        size_t min_index = i;
        for (size_t j = i; j < count; j++) {
            if (ws[j] < min) {
                min_index = j;
                min = ws[j];
            }
        }
        float tmp = ws[i];
        ws[i] = ws[min_index];
        ws[min_index] = tmp;
    }

    for (size_t i = 0; i < count; i++) {
        printf("%.2f ", ws[i]);
    }

    return 0;
}
```

### Подвиг 8. Продолжите программу. Выполните сортировку второй половины массива ws по убыванию (невозрастанию), используя метод сортировки выбором. То есть, сортировать нужно элементы с индексами от count/2 до count-1 включительно. Выведите в консоль все полученные значения массива ws (первые count элементов) в одну строчку через пробел с точностью до сотых.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/5.5.8

```c
#include <stdio.h>

#define TOTAL 20

int main(void) {
    float ws[TOTAL] = {0.0f};
    size_t count = 0;
    size_t sz_ar = sizeof(ws) / sizeof(*ws);

    while (count < sz_ar && scanf("%f", &ws[count]) == 1) count++;

    for (size_t i = count / 2; i < count; i++) {
        float max = ws[i];
        size_t max_index = i;
        for (size_t j = i; j < count; j++) {
            if (ws[j] > max) {
                max_index = j;
                max = ws[j];
            }
        }
        float tmp = ws[i];
        ws[i] = ws[max_index];
        ws[max_index] = tmp;
    }

    for (size_t i = 0; i < count; i++) {
        printf("%.2f ", ws[i]);
    }

    return 0;
}
```

### Подвиг 9 (на повторение). Выберите все верные утверждения, касающиеся следующей программы.

```c
#include <stdio.h>

int main(void) {
    short var = 7;
    short* ptr_var;

    ptr_var = &var;
    *ptr_var = 8;

    printf("%d\n", *ptr_var);

    return 0;
}
```


+ [x] если перед указателем не ставится *, то ему присваивается адрес области памяти
+ [x] если перед указателем записан символ *, то в область памяти, хранимой в указателе, заносится или считывается то или иное значение
+ [ ] если перед указателем не ставится *, то в область памяти, хранимой в указателе, заносится или считывается то или иное значение
+ [ ] если перед указателем записан символ *, то ему присваивается адрес области памяти
+ [ ] операция &, записанная перед именем переменной, возвращает значение переменной
+ [x] объявляется указатель ptr_var для работы с данными типа short
+ [x] операция &, записанная перед именем переменной, возвращает ее адрес

### Подвиг 10 (на повторение). Какую роль играет непосредственно компилятор при транслировании программы на языке Си в машинный код?

+ [x] отдельные файлы с текстами программы преобразует в машинный код, формируя объектные файлы
+ [ ] отдельные файлы с текстами программы преобразует в машинный код, формируя конечный исполняемый файл
+ [ ] выполняет сборку объектных модулей программы в единый исполняемый файл
+ [ ] объединяет все файлы с текстами программы текущего проекта в единую программу и переводит ее в машинный код

# 5.6 Двумерные и многомерные массивы. Указатели на двумерные массивы

## Двумерные и многомерные массивы.

До сих пор мы с вами в программах объявляли одномерные массивы, то есть, массивы, у которых была одна размерность, один набор индексов:

```c
short digits[10];
```

И по каждому индексу получали определенное числовое значение элемента:

```c
short x = digits[2];
```

Такая организация подходит для хранения последовательных данных, например, значений функций в отдельных дискретных отсчетах:

![05](/Good_good_C_C++/img/05_05.png)

Однако такое представление данных не всегда бывает удобным. Например, при хранении пикселей изображений, где есть строки и столбцы, или клеток игрового поля и многих других подобных многомерных данных.

![05](/Good_good_C_C++/img/05_06.png)

Здесь напрашивается два набора индексов: один для строк, другой для столбцов. Это приводит нас к идее двумерных массивов, которые можно объявлять в программах на языке Си следующим образом:

```c
<тип элементов> <имя массива>[число строк][число столбцов];
```

Например, для представления игрового поля игры «Крестики-нолики» в программе можно объявить такой двумерный массив:

```c
char game_pole[3][3];
```

Интерпретировать его можно следующим образом. По первому индексу `game_pole[i]` мы получаем одномерные массивы, описывающие строки игрового поля. А второй индекс `game_pole[i][j]` перебирает элементы соответствующего одномерного массива:

![05](/Good_good_C_C++/img/05_07.png)

В памяти устройства такой двумерный массив организован так же, как и одномерный, только друг за другом следуют не конкретные числовые значения, а соответствующие одномерные массивы:

![05](/Good_good_C_C++/img/05_08.png)

И отсюда хорошо видно, что двумерный массив – это всего лишь некоторая абстракция. На уровне машинных кодов – это все тот же одномерный массив. Поэтому, строго говоря, любой одномерный массив относительно просто может быть интерпретирован как двумерный. Например, это же игровое поле в программе мы могли бы описать и так:

```c
#define N  3
char pole_2[N * N];
```

Получили бы те же 9 байт в непрерывной области памяти, а доступ к элементам можно было бы организовать также по двум индексам `i` и `j` следующим образом:

```c
char x = pole_2[i * N + j];
```

Формула, записанная в квадратных скобках, позволяет воспринимать наш одномерный массив как двумерный. По сути, то же самое происходит при объявлении двумерного массива:

```c
char game_pole[3][3];
```

При обращении к его отдельным элементам по двум индексам:

```c
char y = game_pole[i][j];
```

внутри выполняются аналогичные вычисления индекса одномерного массива.

Хотя, все же определение двумерного и одномерного массивов на уровне языка Си – это разные сущности и воспринимать их как одно и то же было бы неверно. Единство возникает только на уровне представления данных в памяти и не более того.

## Инициализация двумерных массивов

Подтверждение этого можно увидеть в особенностях работы инициализаторов двумерных массивов. Начальные значения игрового поля `game_pole` можно задать следующим образом:

```c
char game_pole[3][3] = {1, 2, 3, 4};
```

В этом случае массив `game_pole` инициализатором будет рассматриваться как одномерный и в первые четыре элемента записаны значения 1, 2, 3, 4:

![05](/Good_good_C_C++/img/05_09.png)

Давайте выведем элементы массива game_pole в консоль и убедимся, что данные организованы именно так:

```c
#include <stdio.h>

int main(void) {
    char game_pole[3][3] = {1, 2, 3, 4};

    for (int i = 0; i < 3; ++i) {
        for (int j = 0; j < 3; ++j) printf("%d ", game_pole[i][j]);
        printf("\n");
    }

    return 0;
}
```

Обратите внимание, вложенные циклы очень удобны для перебора элементов двумерных массивов. В этом качестве они очень часто используются в программах.

После выполнения программы увидим:

```
1 2 3
4 0 0
0 0 0
```

Однако инициализатор можно прописать конкретно и для двумерных массивов следующим образом:

```c
char game_pole[3][3] = {{1, 2}, {3, 4}};
```

Тогда в первую строку (первый одномерный массив) будут занесены числа 1 и 2, а во вторую строку – числа 3 и 4:

![05](/Good_good_C_C++/img/05_10.png)

После выполнения программы увидим результат:

```
1 2 0
3 4 0
0 0 0
```

## Многомерные массивы
Я, думаю, в целом понятна идея организации и объявления двумерных массивов в языке Си, а также способы их начальной инициализации. По аналогии мы можем объявлять не только двумерные, но и трех, четырех и вообще N-мерные массивы:

```c
double ar_3D[3][4][5];
short ar_4D[5][2][10][3];
```

Их инициализация выполняется аналогично инициализации двумерных массивов, а для доступа к отдельным элементам нужно указывать уже три или четыре индекса:

```
double val = ar_3D[1][0][1];
short res = ar_4D[0][1][5][2];
```

Разумеется, в памяти они по-прежнему представлены в виде непрерывной последовательности ячеек, следующих друг за другом.

Вообще, в практике программирования обычно используют одномерные и реже двумерные массивы. 

Массивы больших размерностей встречаются крайне редко. И это не случайно. 

Большое количество индексов может легко запутать программиста при чтении программы. Поэтому всегда лучше продумывать логику работы так, чтобы избегать использования многомерных массивов.

## Операция sizeof с многомерными массивами

В заключение этого занятия посмотрим, как с помощью операции `sizeof` можно вычислять размеры многомерных массивов. Предположим, имеется следующий двумерный массив:

```c
int game_pole[5][3];
```

И нам бы хотелось узнать, сколько у него строк и столбцов. Если применить операцию `sizeof` ко всему массиву, то получим число байт, которые он занимает в памяти:

```c
size_t bytes = sizeof(game_pole);
```

В данном случае переменная `bytes` будет принимать значение 60:

$5 \cdot 3 \cdot 4 = 60$ байт.

Если же эту операцию применить к первому индексу:

```c
size_t bytes_row = sizeof(game_pole[0]);
```

то получим значение 12:

$3 \cdot 4 = 12$ байт.

Следовательно, чтобы получить число строк нужно величину `bytes` разделить на `bytes_row`. Это можно записать в виде следующей операции:

```c
size_t rows = sizeof(game_pole) / sizeof(game_pole[0]);
```

Ну а для подсчета числа столбцов добавляем в это выражение второй индекс:

```c
size_t cols = sizeof(game_pole[0]) / sizeof(game_pole[0][0]);
```

Вот так, относительно просто и очевидно можно вычислять размерности многомерных массивов.

## Указатели на двумерные массивы

И, последнее, что отмечу на этом занятии – это способ объявления указателей на двумерные и вообще на многомерные массивы. Как мы с вами уже знаем, имя массива – это указатель, который хранит адрес начала области памяти, в которой располагаются элементы массива. Причем, например, двумерный массив:

```c
char game_pole[3][3] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
```

по первому индексу возвращает указатель на соответствующий одномерный массив. Значит, мы можем присвоить этот указатель другому указателю с тем же типом `char` следующим образом:

```c
char *p_row = game_pole[1];
```

В итоге, `p_row` будет указывать на второй массив из трех элементов:

![05](/Good_good_C_C++/img/05_11.png)

Давайте в этом убедимся. Выведем значение элемента, на который он ссылается:

```c
printf("%d\n", *p_row);
```

После запуска программы увидим значение `4`. Соответственно, если смещать адрес, то будет получать другие значения этого массива. Например:

```c
printf("%d\n", *(p_row-2));
```

увидим значение 2. То есть, указатель `p_row` позволяет работать с этим двумерным массивом, как с одномерным.

Но как нам определить указатель именно на двумерный массив и работать с ним как с двумерным? Не вдаваясь в длительные разъяснения, сразу приведу синтаксис объявления таких указателей:

```c
<тип данных> (* <имя указателя>)[вторая размерность];
```

В нашем случае указатель на двумерный массив можно объявить следующим образом:

```c
char (*p_ar)[3] = game_pole;
```

Обратите внимание на круглые скобки. Они здесь обязательны, так как приоритет операции `[]` выше, чем операции `*`. Если бы мы прописали без круглых скобок:

```c
char *ptr[3];
```

то это был бы массив из трех указателей. Но с круглыми скобками получаем уже указатель на двумерный массив, у которого вторая размерность равна трем.

Пользоваться указателем `p_ar` можно также, как и указателем `game_pole`. Изначально `p_ar` ссылается на первый одномерный массив из трех элементов. Поэтому команда:

```c
char x = p_ar[0][1];
```

вернет второй элемент первого массива, то есть, число 2. Для перехода к следующей строке, достаточно увеличить первый индекс, например, так:

```c
char x = p_ar[1][2];
```

прочитаем третье значение второго массива из трех элементов, то есть, число 6. И так далее.

Надо сказать, что в практике программирования очень редко прибегают к указателям на двумерные массивы. Они несколько неудобны, т.к. нам приходится явно указывать вторую размерность. Гораздо удобнее и универсальнее пользоваться указателями на одномерные массивы, которые достаточно просто можно воспринимать и как двумерные и даже как многомерные.

Видео по теме [#34. Двумерные и многомерные массивы. Указатели на двумерные массивы](https://www.youtube.com/watch?v=xyI7bMqfZNo&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные варианты объявления многомерных массивов.

+ [x] short ar_3[4][8][6][7];
+ [x] float ar_1[5][4];
+ [ ] int ar_5[30, 22, 4];
+ [x] int ar_2[11][12][5];
+ [ ] long ar_4[6, 7];
+ [ ] short ar_6[4][5, 2];

### Подвиг 2. Выберите все верные варианты инициализации двумерных массивов.

+ [ ] long ar_5[2][] = {{1, 2, 3}, {4, 5, 6}};
+ [x] float ar_4[][3] = {1, 2, 3, 4, 5, 6};
+ [x] short ar_1[2][3] = {{1, 2, 3}, {3, 4, 6}};
+ [ ] int ar_6[2][3] = {{1, 2}, {3, 4}, {5, 6}};
+ [x] int ar_7[3][3] = {{1, 2}, {3, 4}};
+ [x] short ar_2[2][3] = {1, 2, 3, 4, 5, 6};
+ [x] int ar_3[][3] = {{1, 2, 3}, {4, 5, 6}};

### Подвиг 3. Пусть в программе объявлен следующий многомерный массив с применением к нему операции sizeof:

```
short ar[3][5][2];
size_t sz_ar = sizeof(ar);
```

Чему равно значение переменной `sz_ar`, если тип `short` в памяти компьютера занимает 16 бит?

$3 \cdot 5 \cdot 2 \cdot 16 / 8 = 60$

### Подвиг 4. Пусть в программе объявлен следующий многомерный массив с применением к нему операции sizeof:

```c
short ar[3][5][2];
size_t sz_ar_1 = sizeof(ar[1]);
```

Чему равно значение переменной `sz_ar_1`, если тип `short` в памяти компьютера занимает 16 бит?

$5 \cdot 2 \cdot 16 / 8 = 20$

### Подвиг 5. Продолжите программу, которая читает из входного потока 9 целых чисел, записанных в одну строчку через пробел, и помещает их по порядку в двумерный целочисленный массив ar_2D размерностью 3 x 3. В тестах гарантируется наличие минимум 9 целых чисел.

P. S. В консоль ничего выводить не нужно.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/5.6.5

```c
#include <stdio.h>
#define ROWS 3
#define COLS 3

int main(void) {
    int ar_2D[ROWS][COLS];

    for (size_t i = 0; i < ROWS; i++) {
        for (size_t j = 0; j < COLS; j++) {
            scanf("%d", &ar_2D[i][j]);
        }
    }

    return 0;
}
```

### Подвиг 6. Продолжите программу, которая читает из входного потока 12 целых чисел, записанных в одну строчку через пробел, и помещает их по порядку в двумерный массив ar_2D размерностью 4 x 3 (4 - строки; 3 - столбцы). Выведите в консоль в одну строчку через пробел целочисленные значения массива ar_2D по столбцам (сначала числа первого столбца, затем - второго и так до последнего). Пробелов в конце строк быть не должно.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/5.6.6

Sample Input:

```
1 2 3 4 5 6 7 8 9 10 11 12
```

Sample Output:

```
1 4 7 10
2 5 8 11
3 6 9 12
```

```c
#include <stdio.h>
#define ROWS 4
#define COLS 3

int main(void) {
    int ar_2D[ROWS][COLS];

    for (size_t i = 0; i < ROWS; i++) {
        for (size_t j = 0; j < COLS; j++) {
            scanf("%d", &ar_2D[i][j]);
        }
    }

    for (size_t j = 0; j < COLS; j++) {
        for (size_t i = 0; i < ROWS; i++) {
            printf("%d%s", ar_2D[i][j], i != ROWS - 1 ? " " : "");
        }
        printf("%s", j != COLS - 1 ? "\n" : "");
    }

    return 0;
}
```

### Подвиг 7. В программе ниже выполняется считывание целочисленных значений из входного потока с их последовательной записью в массив vls размерностью 3 x 5 (3 строки и 5 столбцов). Необходимо объявить еще один массив с именем mean типа double и размерностью 3 элемента. В элементы массива mean следует записать среднее арифметическое каждой строки массива vls. Выведите в консоль значения элементов массива mean (по порядку) в одну строчку через пробел с точностью до сотых.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/5.6.7

```c
#include <stdio.h>

#define ROWS 3
#define COLS 5

int main(void) {
    short vls[ROWS][COLS] = {0};
    short *ptr_vls = &vls[0][0];

    short x;
    for (int i = 0; i < ROWS * COLS && scanf("%hd", &x) == 1; ++i) *ptr_vls++ = x;

    double mean[3] = {0};

    for (size_t i = 0; i < ROWS; i++) {
        for (size_t j = 0; j < COLS; j++) {
            mean[i] += vls[i][j];
        }
        mean[i] /= COLS;
        printf("%.2f ", mean[i]);
    }

    return 0;
}
```

### Подвиг 8. Продолжите программу, в которой из консоли считываются целочисленные значения в два массива с именами a и b, каждый размерностью 3 x 4. Объявите еще один целочисленный двумерный массив res той же размерности, значения каждого элемента которого должны быть равны сумме соответствующих элементов массивов a и b, то есть, по следующей формуле:

res[i][j] = a[i][j] + b[i][j]
Выведите в консоль полученный массив res в виде таблицы целых чисел из 3 строк и 4 столбцов. В каждой строке числа должны быть записаны через пробел. В начале и конце строк пробелов быть не должно.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/5.6.8

```c
#include <stdio.h>

#define ROWS 3
#define COLS 4

int main(void) {
    int a[ROWS][COLS] = {0};
    int b[ROWS][COLS] = {0};
    int res[ROWS][COLS] = {0};
    int *ptr_a = &a[0][0];
    int *ptr_b = &b[0][0];
    int *ptr_res = &res[0][0];

    int x;
    for (int i = 0; i < ROWS * COLS && scanf("%d", &x) == 1; ++i) *ptr_a++ = x;
    for (int i = 0; i < ROWS * COLS && scanf("%d", &x) == 1; ++i) *ptr_b++ = x;
    ptr_a -= ROWS * COLS;
    ptr_b -= ROWS * COLS;
    for (int i = 0; i < ROWS * COLS; ++i) *ptr_res++ = *ptr_a++ + *ptr_b++;

    for (size_t i = 0; i < ROWS; i++) {
        for (size_t j = 0; j < COLS; j++) {
            printf("%d%s", res[i][j], j != COLS - 1 ? " " : "");
        }
        printf("%s", i != ROWS - 1 ? "\n" : "");
    }

    return 0;
}
```

### Подвиг 9* (классический). Напишите программу в которой на двумерное игровое поле размерностью 10 x 10 случайным образом размещаются 12 "мин" так, чтобы они не соприкасались друг с другом (вокруг клетки с миной не должно быть других мин). Игровое поле должно быть представлено двумерным массивом с именем pg, типом char и размерностью 10 х 10. Пустые клетки (без мин) должны принимать значение 0, а клетки с минами помечаются символом '*'.

P. S. В консоль ничего выводить не нужно.

```c
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define SIZE 10
#define MINES 12

// корректируем координаты точек

int correctX(int x) {
    if (x < 0) return 0;
    if (x >= SIZE) return SIZE - 1;
    return x;
}

int correctY(int y) {
    if (y < 0) return 0;
    if (y >= SIZE) return SIZE - 1;
    return y;
}

int main(void) {
    // char pg[SIZE][SIZE] = {
    //     "0000000000", "0000000000", "0000000000", "0000000000", "0000000000",
    //     "0000000000", "0000000000", "0000000000", "0000000000",
    //     "0000000000"};

    char pg[SIZE][SIZE] = {0};

    int m_count = 0, counter = 0;

    srand(time(NULL));

    while (m_count < MINES && counter < 10000) {
        int row = rand() % SIZE;
        int col = rand() % SIZE;
        if (pg[row][col] != '*') {
            int count = 0;
            // проверяем соседей
            for (int phi = 0; phi < 360; phi += 45) {
                int x, y;
                x = round(cos(phi * 3.14159265 / 180));
                y = round(sin(phi * 3.14159265 / 180));

                if (pg[correctX(row + x)][correctY(col + y)] == '*') {
                    count += 1;
                }
            }
            if (count == 0) {
                pg[row][col] = '*';
                m_count++;
            }
        }
        counter++;
    }
    // printf("%d %d \n", m_count, counter);

    // for (size_t i = 0; i < SIZE; i++) {
    //     for (size_t j = 0; j < SIZE; j++) {
    //         printf("%c%s", pg[i][j], j != SIZE - 1 ? " " : "");
    //     }
    //     printf("%s", i != SIZE - 1 ? "\n" : "");
    // }
    __assert_verify_pg(pg);  // для тестирования (не убирать и должна идти
                             // непосредственно перед return 0)
    return 0;
}
```

### Подвиг 10 (на повторение). Выберите все верные утверждения, касающиеся переменных языка Си.

+ [ ] обычные переменные в языке Си представляют собой ссылки на данные, хранящиеся в памяти устройства
+ [x] порядковый номер ячейки в памяти, начиная с которой переменная хранится в памяти, называется адресом переменной
+ [x] максимальная длина имени переменной внутри модуля, учитываемое компилятором, составляет 63 символа
+ [x] переменные в языке Си представляют собой непосредственные хранилища данных в памяти устройства
+ [x] переменные в языке Си объявляются согласно синтаксису: <тип переменной> <имя переменной>;
+ [ ] переменные в языке Си объявляются согласно синтаксису: <имя переменной> <тип переменной>;
+ [x] максимальная длина имени внешней переменной (за пределами модуля), учитываемое компилятором, составляет 31 символ

# 5.7 Строки. Способы объявления, escape-последовательности

## Строки.

После знакомства с массивами в целом пришло время узнать, как в языке Си представлять строки и обрабатывать их. Сразу отмечу, что в Си нет строкового типа данных. Поэтому для хранения последовательности символов, как правило, используют массивы типа ё. Например, так:

```c
#include <stdio.h>

int main(void) {
    char str[] = {'B', 'a', 'l', 'a', 'k', 'i', 'r', 'e', 'v', '\0'};

    return 0;
}
```

В итоге, в памяти устройства выделяется непрерывная область размером 10 байт, каждая ячейка которого содержит соответствующий символ строки:

![05](/Good_good_C_C++/img/05_12.png)

Обратите внимание на последний символ `\0`. Он совпадает с числом `0`. 

Это маркер (метка) конца строки. Его часто называют символом конца строки. Каждая корректная строка в языке Си должна иметь такой символ. Иначе, строка считается некорректной. 

Поэтому длина строки всегда на один больше общего числа «видимых» символов. Маркер конца строки не отображается стандартными функциями работы со строками, а лишь учитывается ими для определения конца строки.

Вы заметили, как неудобно инициализировать массив отдельными символами? Поэтому для массивов типа `char` можно прописывать инициализатор в виде строкового литерала следующим образом:

```c
char s[] = "Sergey Balakirev";
```

Символ конца строки здесь добавляется автоматически. Явно указывать его не надо.

![05](/Good_good_C_C++/img/05_13.png)

Чаще всего именно так на практике делают инициализацию массива строкой. Разумеется, при необходимости, в квадратных скобках можно указывать размер массива. Например, так:

```c
char buffer[512] = "Hello, World";
```

Тогда общий размер массива будет составлять 512 байт, а строка записана в первые 13 байт:

![05](/Good_good_C_C++/img/05_14.jpg)

И вот здесь хорошо видна роль символа конца строки. 

Если бы его не было, то как бы мы поняли, что строка заканчивается на символе `d`? 

А не идет дальше, возможно, вплоть до конца массива? 

Но символ `\0` нам четко и определенно указывает, где следует останавливаться. 

Разумеется, сама строка всегда начинается с самого первого элемента массива. Таким образом, для корректной строки мы всегда знаем, где она начинается и где заканчивается вне зависимости от общего размера массива типа `char`.

Ту же самую строку в программе можно определить и несколькими литералами, записанных через пробельные символы:

```c
char b[] = "Hel" "lo" 
         ", World";
```

Все эти фрагменты компилятор сначала соединит в один строковый литерал `Hello, World`, а затем, при инициализации, занесет все эти символы в массив `b`. Или можно сделать так:

```c
char sp[] = "Hello, \
World";
```

Обратный слеш, за которым сразу следует символ переноса строки, компилятор воспринимает как продолжение описания строки. 

Соответственно, такое объявление сначала также будет представлено в виде строкового литерала `Hello, World` (обратите внимание, без переноса строки), а затем, им проинициализирован массив `sp`.

Все эти варианты введены в язык Си исключительно для удобства оформления текста программы. Поэтому используйте тот, который внесет большую ясность при чтении программы.

И еще раз подчеркну, что строки в языке Си объявляются исключительно в двойных кавычках. А элементы строк – символы – в одинарных кавычках. Например:

```c
char string[] = "a";   // строка из двух символов a0
char symbol = 'a';     // один символ буквы a
```

Когда мы прописываем литерал в двойных кавычках, то компилятор формирует байтовый массив и в конец всегда автоматически добавляет символ конца строки `\0`. А когда прописываем одинарные кавычки, то это воспринимается как один символ (число с кодом указанного символа). Эти две записи нужно очень хорошо запомнить и правильно понимать.

## Представление строковых литералов в памяти

Возможно, глядя на все эти вариации объявления строк, некоторые из вас задаются вопросом, а где и как все эти строковые литералы хранятся в процессе работы программы? 

В действительности, все что определено в двойных кавычках, представляется на уровне последовательности байт (условно, массива типа `char`) и физически сохраняется в выходном исполняемом файле. 

Затем, в момент загрузки, все эти строки размещаются в неизменяемой области памяти, как правило, в сегменте кода секции `.text`:

![05](/Good_good_C_C++/img/05_15.png)

В результате, у каждого строкового литерала появляется свой уникальный адрес, который может быть использован при работе с соответствующей строкой. Именно так происходит при инициализации байтовых массивов:

```c
int main(void) {
    char s[] = "Sergey Balakirev";
    char buffer[512] = "Hello, World";

    return 0;
}
```

Компилятор передает в инициализатор адрес начала строки и в массив `s` выполняется копирование соответствующих символов, включая символ конца строки. 

То есть, области памяти, занимаемые массивом и строковым литералом, разные. 

Строка находится в неизменяемой области (ее нельзя менять в процессе работы программы), а массив размещается в стековом фрейме. Память под массив автоматически выделяется в момент вызова функции `main()`. 

Подробнее о стековом фрейме и других классах памяти мы с вами еще будем говорить. Но сразу отмечу, что несколько иная ситуация, когда мы задаем строку в глобальной области (вне функций), например, так:

```c
char buffer[512] = "Hello, World";

int main(void) {
    char s[] = "Sergey Balakirev";

    return 0;
}
```

Тогда все начальные данные для соответствующих перемененных сохраняются в секции `.data`, затем, в момент загрузки программы сразу выделяется память под массив `buffer` и в эту область загружается строка `Hello, World`.

![05](/Good_good_C_C++/img/05_16.png)

Зачем я вам рассказываю все эти детали? 

Не все ли равно, где и как хранятся строковые литералы? 

Главное, чтобы мы могли их использовать в программе и достаточно! 

В большинстве случаев, так оно и есть. Но бывают ситуации, когда важно все это понимать. Например, что нам мешает объявить строку через указатель следующим образом:

```c
int main(void) {
    char* str = "Balakirev";
    char s[] = "Balakirev";

    return 0;
}
```

Чем будут отличаться эти два объявления? 

Сейчас, когда вы знаете, что строковые литералы размещаются в неизменяемой области памяти, а массивы – в стековом фрейме и лишь инициализируются строкой, можете догадаться, что через указатель `str` мы только можем читать символы строки, но не менять, а через массив `s` выполнять любые операции: и чтения и записи.

Давайте проверим, так ли это? Попробуем изменить строковый литерал "Balakirev" через указатель `str`:

```c
str[0] = 'A';
```

После запуска программа завершается с ненулевым кодом, то есть, аварийно. Это, как раз, произошло из-за попытки внести изменения в неизменяемую область памяти. А вот с массивом `s` у нас такой проблемы не будет:

```c
s[0] = 'A';
```

Видим код завершения `0`.

По этой причине указатели на строковые литералы рекомендуется объявлять с ключевым словом `const` следующим образом:

```c
const char* str = "Balakirev";
```

Тогда уже на этапе компиляции будет выдана ошибка, при попытке изменения строки `Balakirev`. 

А это гораздо лучше, чем потом гадать, почему программа вылетает. Кстати, в современных стандартах языка Си/С++ при объявлении таких указателей требуется прописывать ключевое слово `const`.

## Экранирование и спецсимволы

Давайте снова вернемся к вопросу определения строк и представим ситуацию, когда нужно объявить строковый литерал вида:

```
I like programming in "C" language.
```

Сложность в том, что здесь внутри строки фигурируют двойные кавычки. Очевидно, прописать их просто так не получится. Попытка это сделать:

```c
char s[] = "I like programming in "C" language.";
```

очевидно, приведет к синтаксической ошибке. Как же быть? Для этих целей предусмотрен механизм экранирования символов. Нам достаточно в строке перед каждой кавычкой прописать обратный слеш:

```c
char s[] = "I like programming in \"C\" language.";
```

Обратный слеш указывает компилятору рассматривать символ двойной кавычки не как элемент синтаксиса языка, а именно как символ строки. В результате программа скомпилируется без ошибок, и массив `s` будет содержать нужную нам информацию.

Вообще обратный слеш с разными символами ведет себя по-разному. Вот таблица наиболее употребительных сочетаний (`escape`-последовательностей):

escape-последовательность | Код в таблице ASCII | Описание
-|-|-
`\n` | 0x0A | перевод на новую строку
`\r` | 0x0D | возврат каретки
`\t` | 0x09 | символ табуляции
`\'` | 0x27 | экранирование апострофа (одинарная кавычка)
`\"` | 0x22 | экранирование двойной кавычки
`\?` | 0x3F | экранирование вопросительного знака
`\\` | 0x5C | экранирование обратного слеша
`\0` | 0x00 | символ конца строки (число 0)
`\x<число>` | | символ с указанным шестнадцатеричным значением 
`\uxxxx` | | символ с кодом xxxx в кодировке UNICODE (добавлено в стандарте C99)

Три символа из этой таблицы мы с вами уже использовали. Это `\n`, `\"` и `\0`. 

Остальные прописываются в строках аналогичным образом. Приведу лишь дополнительный пример с указанием символа в виде шестнадцатеричного кода:

```c
char str[] = "\x61 \x4f";
```

Это эквивалентно строке «a O».

На этом мы завершим первое знакомство со строками. На следующем занятии продолжим эту тему и посмотрим, какие существуют встроенные средства для ввода/вывода строк из стандартных потоков.

Видео по теме [#35. Строки. Способы объявления, escape-последовательности](https://www.youtube.com/watch?v=whRGTUExD9E&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные варианты объявления строк.


+ [ ] char s_7 = "Balakirev";
+ [ ] char s_5[100] = {"Balakirev", 'S', 'e', 'r', 'g', 'e', 'i', '\0'};
+ [x] char s_2[20] = {'B', 'a', 'l', 'a', 'k', 'i', 'r', 'e', 'v', '\0'};
+ [x] char s_6[100] = "Sergey " "Balakirev";
+ [x] char s_3[] = "Balakirev";
+ [x] char s_1[] = {'B', 'a', 'l', 'a', 'k', 'i', 'r', 'e', 'v', '\0'};
+ [x] char s_4[100] = "Balakirev";
+ [x] const char* s_8 = "Balakirev";

### Подвиг 2. Выберите все верные утверждения, касающиеся строк языка Си.

+ [ ] конец строки определяется числовым значением 10 (символом '\n')
+ [x] строка в языке Си задается массивом символов (типа char)
+ [x] каждая корректная строка в языке Си должна завершаться числом 0 (символ '\0')
+ [x] конец строки определяется числовым значением 0 (символом '\0')
+ [x] строковые литералы загружаются вместе с программой и располагаются в неизменяемой области памяти
+ [x] у строкового литерала (например, "hello C") автоматически добавляется символ конца строки '\0'

### Подвиг 3. Выберите все верные утверждения, касающиеся двух следующих определений:

```c
char s[] = "Balakirev";
char* ptr_s = "Balakirev";
```

+ [x] массив s инициализируется строковым литералом, то есть, содержимое строки копируется в массив s
+ [x] указатель ptr_s ссылается на начало строки, которая располагается в неизменяемой области памяти
+ [ ] в массиве s символы строки изменить нельзя
+ [x] через указатель ptr_s строковый литерал изменить нельзя
+ [x] в массиве s можно менять символы строки
+ [ ] указатель ptr_s ссылается на начало строки, которую можно менять через этот указатель

### Подвиг 4. Продолжите программу, в которой объявляется строка с именем str и максимальной длиной 100 символов (включая символ конца строки). Инициализируйте str строковым литералом "Best string!". Замените символ '!' на символ '.' (точка).

P. S. В консоль ничего выводить не нужно.

```c
#include <stdio.h>
#define MAX 100

int main(void) {
    char str[MAX] = "Best string!";

    for (size_t i = 0; i < MAX; i++) {
        if (str[i] == '!') {
            str[i] = '.';
            break;
        }
    }

    // __ASSERT_TESTS__
    /*макроопределение для тестирования
    (не убирать и должно идти непосредственно перед
    return 0)*/

    return 0;
}
```

### Подвиг 5. Продолжите программу, в которой объявляется массив text из трех указателей, проиницализированные на строковые литералы:

1-й указатель: "language C"<br>
2-й указатель: "language C++"<br>
3-й указатель: "language Python"<br>

P. S. В консоль ничего выводить не нужно.

```c
#include <stdio.h>
#define MAX 100

int main(void) {
    char* text[] = {"language C", "language C++", "language Python"};

    for (size_t i = 0; i < 3; i++) {
        printf("%s\n", text[i]);
    }

    // __ASSERT_TESTS__
    /*макроопределение для тестирования
    (не убирать и должно идти непосредственно перед
    return 0)*/

    return 0;
}
```

```c
#include <stdio.h>

int main(void) {
   
    char *a = "language C";
    char *b = "language C++";
    char *c = "language Python";
   
   const char *text[3] = {a, b, c};
    

    __ASSERT_TESTS__ // макроопределение для тестирования (не убирать и должно идти непосредственно перед return 0)
    return 0;
}
```

### Подвиг 6. Продолжите программу, в которой объявляется строка с именем str и максимальной длиной 100 символов (включая символ конца строки). Инициализируйте str строковым литералом "Best string!". Затем, удалите из строки все символы 's'.

P. S. В консоль ничего выводить не нужно.

```c
#include <stdio.h>
#define MAX 100

int main(void) {
    char str[MAX] = "Best string!";
    // char str[MAX] = "Besssssst string!";

    size_t shift = 0;
    char ch = 's';

    for (size_t i = 0; i < MAX; i++) {
        if (shift) str[i - shift] = str[i];
        if (str[i] == ch) shift++;
        if (str[i] == '\0') break;
    }

    // printf("%s", str);

    // __ASSERT_TESTS__
    /*макроопределение для тестирования
    (не убирать и должно идти непосредственно перед
    return 0)*/

    return 0;
}
```

```c
#include <stdio.h>

int main(void)
{
    char str[100] = "Best string!", *a = str, *b = a;
    
    for(;;){
        while(*b == 's') b++; 
        *a = *b;
        // if(!*a) break;
        if(*a = '\0') break;
        a++; 
        b++; 
    }
    
    printf("%s", str);

    __ASSERT_TESTS__
    return 0;
}
```

### Подвиг 7. Продолжите программу, в которой объявляется строка с именем str и максимальной длиной 50 символов (включая символ конца строки). Инициализируйте str строковым литералом "best string!". Затем, вставьте в начало массива str фрагмент "The ", чтобы получилось "The best string!".

P. S. В консоль ничего выводить не нужно.

```c
#include <stdio.h>
#define MAX 50

int main(void) {
    char str[MAX] = "best string!", *a = str;
    char ins[MAX] = "The ";
    int ins_len = 0;
    
    //посчитаем длину вставки
    while (ins[ins_len++])
        ;
    
    //добавим к вставке исходную строку
    for (; *a != '\0'; ins_len++, a++) {
        ins[ins_len - 1] = *a;
    }

    // скопируем полученную строку в исходную
    for (char *b = ins, *c = str; *b != '\0';) {
        *c++ = *b++;
    }

    // printf("%s", ins);
    // printf("%s", str);
    // __ASSERT_TESTS__
    return 0;
}
```

### Подвиг 8. Установите соответствия между спецсимволами и их описаниями.

![05](/Good_good_C_C++/img/05_17.PNG)

### Подвиг 9. Продолжите программу, в которой объявляется строка с именем str и максимальной длиной 50 символов (включая символ конца строки). Инициализируйте str строкой:

Best   language  "C"

(Обратите внимание на несколько подряд идущих пробелов, они должны все присутствовать в строке.) Затем, все группы подряд идущих символов пробелов заменить на символ переноса строки. (Каждая группа пробелов заменяется одним символом переноса строки.)

P. S. В консоль ничего выводить не нужно.

```c
#include <stdio.h>
#define MAX 50

int main(void) {
    char str[MAX] = "Best   language  \"C\"";
    char ch = ' ';
    char shift = 0;

    for (size_t i = 0; i < MAX; i++) {
        if (shift) str[i - shift] = str[i];
        if (str[i] == ch) {
            str[i - shift] = '\n';
            if (str[i + 1] == ch) shift++;
        }
        if (str[i] == '\0') break;
    }

    // printf("%s", str);
    // __ASSERT_TESTS__
    return 0;
}
```

# 5.8 Ввод/вывод строк в стандартные потоки

Теперь, когда мы узнали, как они задаются и инициализируются, давайте рассмотрим работу функций ввода/вывода строк в стандартные потоки. И начнем с функций вывода.

## Функция printf()

Когда мы с вами говорили о функции `printf()`, то отмечали спецификатор `%s` для вывода строк. Собственно, с его помощью строки и выводятся. Например:

```c
#include <stdio.h>

int main(void) {
    char sp[] = "Hello, World";
    printf("sp = %s\n", sp);

    return 0;
}
```

Будет выведена ранее объявленная строка `sp` в консоль, следующим образом:

```c
sp = Hello, World
```

Давайте детальнее разберемся, как это работает. 

Вначале функция `printf()` анализирует форматную строку и встречает в ней спецификатор `%s`. 

На это место должна быть подставлена строка. 

Значит, следующим аргументом должен фигурировать указатель, содержащий адрес строки. Именно его мы и передаем при вызове функции `printf()`. 

Как мы помним, имя массива – это указатель на его начало. В данном случае, на начало строки. Затем, внутри функции `printf()` отрабатывает алгоритм, который перебирает последовательно все символы строки и подставляет их на место спецификатора `%s`, пока не дойдет до символа конца строки. 

Как только встречается символ `\0`, формирование выходной строки завершается и она выводится в выходной поток `stdout` и, в нашем случае, с последующим выводом на экран.

Аналогичным образом все работает и при указании строкового литерала в функции `printf()`. Например:

```c
printf("name: %s\n", "Balakirev");
```
Строка `"Balakirev"` размещается в виде байтового массива в памяти компьютера при загрузке программы, а при вызове функции `printf()` передается лишь ее адрес. Дальше все происходит ровно так, как и с обычным массивом.

## Функция puts()

Функция `printf()` обычно используется для форматного вывода информации в стандартный поток `stdout`. 

Однако в практике программирования часто нужно просто вывести строку без какого-либо форматирования, так как она есть. 

Для этого лучше воспользоваться функцией `puts()`, которая определена в заголовочном файле `stdio.h`. 

Этой функции не нужно анализировать форматную строку, поэтому она работает несколько быстрее функции `printf()`. Пользоваться функцией `puts()` очень просто, например:

```c
char str[] = {'B', 'a', 'l', 'a', 'k', 'i', 'r', 'e', 'v', '\0'};
puts(str);
puts("Hello!");
```

После запуска программы увидим результат вывода:

```
Balakirev
Hello!
```

Обратите внимание, после каждого вывода функция `puts()` автоматически добавляет символ переноса строки `\n`, так как строки обычно нужно выводить каждую с новой позиции.

## Функция scanf() для считывания строк

В целом функции `printf()` и `puts()` безопасны для вывода строк. Если строка является корректной, то никаких неожиданностей не возникает. 

Если же в конце строки по какой-то причине отсутствует символ `\0`, то худшее, что может произойти – это вывод в выходной поток stdout различного шума, записанного в последующих ячейках памяти, пока в какой-нибудь из них не встретится значение `0`.

Гораздо хуже в языке Си обстоят дела с функциями чтения строк из стандартного входного потока `stdin`. 

Одна такая функция нам уже известна и называется `scanf()`. Для считывания строк используется все тот же спецификатор `%s` следующим образом:

```c
#include <stdio.h>

int main(void) {
    char bf[10];
    scanf("%s", bf);

    return 0;
}
```

Давайте в деталях разберемся, как здесь будет работать функция `scanf()`. Первое, что обращает на себя – это отсутствие амперсанда `&` перед именем переменной `bf`. До этого, мы всегда его прописывали, когда указывали переменные базовых типов (`int`, `short`, `char`, `double`, …). Я, думаю, вы уже догадались, с чем это связано? 

Да, в качестве параметров после форматной строки функции `scanf()` нужно передавать адреса переменных, а не их значения. 

Амперсанд перед именем переменной, как раз, возвращает ее адрес. 

Как мы теперь знаем, имея этот адрес, значение переменной достаточно просто изменить, записав в нее, таким образом, прочитанные данные из входного потока. 

То же самое и с массивом. Нам нужно передать его адрес. И, так как имя массива – это и есть указатель на него, то никакого амперсанда дополнительно прописывать не нужно.

Теперь, как непосредственно происходит считывание строки по спецификатору `%s`. Предположим, мы введи с клавиатуры строку:

```
Hello World
```

Эта строка попала в буфер входного потока `stdin`. Затем, используя указатель на переданный массив символов, функция `scanf()` побайтно читает данные из входного потока и заносит по порядку в элементы массива. 

И делает это до тех пор, пока не встретится пробельный символ (это, собственно, пробел, а также символы табуляции и переноса строки). 

В конце функция `scanf()` дописывает ноль, чтобы строка была корректной с позиции языка Си.

В результате здесь имеем две проблемы.
+ Первая. Строка читается не целиком, а лишь до пробельного символа. И это поведение никак нельзя изменить.
+ Вторая проблема связана с тем, что если бы не было пробела после слова «Hello», то чтение из потока `stdin` продолжилось бы и функция `scanf()` стала бы заносить данные в ячейки памяти, не отведенные под массив `bf`. 

Ни к чему хорошему такое поведение не приводит. Программа, в лучшем случае, завершится аварийно, а в худшем – функция `scanf()` станет источником уязвимости программы.

К счастью, эту вторую проблему можно относительно просто решить, если у спецификатора `%s` дополнительно прописать максимальную ширину чтения данных, например, так:

```c
char bf[10];
scanf("%9s", bf);
puts(bf);
```

В этом случае максимум будет прочитано 9 символов, а в следующий последний 10-й функция `scanf()` автоматически записывает символ конца строки `\0`. 

Об этом символе всегда следует помнить, указывая максимальную длину. В нашем примере массив `bf` содержит всего 10 элементов, значит, только в первые 9 можно заносить символы строки, а на место 10-го – символ конца строки. 

Конечно, если пробельный символ будет встречен раньше 9-й позиции, то считывание остановится на нем. Ширина здесь никак на это не влияет.

Указание максимальной ширины чтения данных, на самом деле, не очень удобно с практической точки зрения. 

Мы здесь явно вынуждены прописывать конкретные числовые значения, исходя из длины массива. Использовать переменные в записи спецификатора не получится. 

Конечно, из этой ситуации тоже можно выйти, формируя форматную строку на программном уровне и подставляя, затем, в функцию `scanf()`. Но это дополнительные неудобства. 

Поэтому, в целом, использование `scanf()` для считывания строк не самый лучший подход.

## Функция gets() – источник уязвимостей

Начинающие программисты, впервые столкнувшись с задачей чтения строк, начинают искать другие подобные стандартные библиотечные функции. 

И, конечно же, наталкиваются на функцию `gets()`, которая читает строку целиком в массив по переданному адресу `buf` вместе с пробельными символами, пока не встретится символ переноса строки:

```c
char* gets(char* buf);
```

В конце эта функция также дописывает символ нуля для формирования корректной строки.

Казалось бы, эврика! 

Вот она заветная функция для чтения произвольных строк. 

Бери и используй в своих программах. Вначале так и делали. 

Пока не произошло событие, поставившее крест на этой и подобных ей функциях. 

Было замечено, что ранние коды программы ОС Unix применяют функцию `gets()`. 

Недолго думая, «плохие» парни решили воспользоваться этой уязвимостью и создали вредоносную программу в виде «червя». 

Такая программа могла легко распространяться по компьютерам, задавая длинную последовательность символов. 

Эти символы читались функцией `gets()` и затирали часть кода самой ОС, пробивая в ней брешь. 

Конечно, с тех пор ОС Unix была неоднократно переписана и теперь такой уязвимости в ней нет. 

А вот от функции `gets()` с тех пор совсем отказались. 

Ее не рекомендуется использовать даже в своих приложениях, чтобы потом, по привычке, не дай бог использовать в коммерческом проекте. 

Лучше забудьте, что такая функция вообще существует. Именно по этой причине мы не будем ее рассматривать даже на простых примерах.

## Безопасные способы чтения строк из стандартного потока stdin

Получается, что функции `scanf()` и `gets()` не обеспечивают нас необходимым и безопасным функционалом для чтения строк.

Какую же функцию нам тогда взять? 

На самом деле язык Си стандарта C99 и более ранних не имеет подходящих функций чтения строк из стандартного входного потока. Как же нам тогда быть? Как вариант, можно воспользоваться функцией:

```c
char* fgets(char* buf, int max_len, FILE* stream);
```

которая предназначена для чтения строки из произвольных потоков, как правило, из файлов. 

Ее плюс в том, что здесь помимо адреса массива (буфера) указывается максимальная длина `max_len`  для чтения данных из потока `stream`. Благодаря этому мы можем гарантировать запись данных только в пределах массива. Например, этой функцией можно воспользоваться так:

```c
char bf[10];
fgets(bf, sizeof(bf), stdin);
```

Здесь последним аргументом указан стандартный входной поток в виде макроимени `stdin`, определенное в заголовочном файле `stdio.h`. 

Сама же функция `fgets()` читает максимум `max_len-1` символ.

Чтение останавливается, когда будет встречен символ перевода строки `\n`, либо конец файла `EOF`, либо прочитано `max_len-1` символов из потока `stdin`. 

При этом функция `fgets()` формирует корректную строку, то есть, автоматически добавляет символ конца строки после последнего прочитанного символа. 

Главным ее неудобством при чтении строк из стандартного потока `stdin` является то, что она оставляет символ перевода строки `\n` и нам его приходится убирать самостоятельно.

Другой подход заключается в использовании функции:

```c
int getchar(void);
```

о которой мы с вами уже говорили. Она позволяет посимвольно читать данные из входного потока `stdin`. Например, с ее помощью можно в цикле читать символы, пока не дойдем до переноса строки, конца файла или максимальной длины:

```c
#include <stdio.h>

int main(void) {
    char bf[10];

    int max_len = sizeof(bf), i = 0;
    char *ptr = bf, ch;

    while ((ch = getchar()) != '\n' && ch != EOF && i < max_len - 1) {
        ptr[i++] = ch;
    }

    ptr[i] = '\0';

    puts(bf);

    return 0;
}
```

Обратите внимание, что в конце мы прописываем символ конца строки `\0`, чтобы строка в массиве `bf` была корректной. 

Именно поэтому из входного потока максимум читается `max_len-1` символ (последним обязательно должен быть `\0`).

Надо сказать, что в современном языке С++ эта проблема решена введением новых функций вида:

```c
scanf_s(), gets_s()
```

в которых дополнительно можно задавать максимальный размер читаемых данных. Но если вы пишите программу на языке Си, ориентированную на стандарт C99, то выход только один: в создании своих собственных вариантов функций для чтения строк из стандартного входного потока.

Видео по теме [#36. Ввод/вывод строк в стандартные потоки](https://www.youtube.com/watch?v=G7bbL0TWbz8&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, касающиеся следующего фрагмента программы:

```c
char str[50];
char *ptr;

scanf("%s", str);
scanf("%s", ptr);
```

+ [x] оба приведенных вызова функции scanf() могут приводить к аварийному завершению программы
+ [x] команда scanf("%s", str); таит потенциальную угрозу в случае ввода более 50 символов из входного потока
+ [x] команда scanf("%s", ptr); помещает символы из входного потока в произвольную область памяти устройства
+ [ ] команда scanf("%50s", str); будет безопасной для считывания данных в массив str
+ [x] команда scanf("%49s", str); будет безопасной для считывания данных в массив str
+ [ ] команда scanf("%s", str); будет читать данные из входного потока максимум длиной 50 символов (по длине массива str)

### Подвиг 2. Установите соответствия между функциями и их описаниями.

![05](/Good_good_C_C++/img/05_18.PNG)

### Подвиг 3. Напишите программу, которая читает из входного потока слова в массив:

```c
char data[5][10];
```

Всего пять слов записанных через пробел. Чтение должно выполняться с помощью функции `scanf()` с учетом максимальной длины хранимого слова (10 символов, включая символ конца строки). После чтения пяти фрагментов (функция `scanf()` должна сработать ровно пять раз), вывести прочитанные данные в консоль в формате:

[строка 1]
[строка 2]
...
[строка 5]

(Прочитанные строки выводятся каждая с новой строки в квадратных скобках.)

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/5.8.3

```c
#include <stdio.h>
#define WORDS 5
#define CHARS 10

int main(void) {
    char str[WORDS][CHARS];

    for (size_t i = 0; i < WORDS; i++) {
        scanf("%9s", str[i]);
    }
    for (size_t i = 0; i < WORDS; i++) {
        printf("[%s]\n", str[i]);
    }
    return 0;
}
```

### Подвиг 4. Напишите программу, которая читает из входного потока в массив data названия шести городов, записанных в одну строчку через пробел. Считать, что максимальная длина названия города не превышает 20 символов. Вывести в консоль прочитанные города в обратном порядке в одну строчку через пробел.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/5.8.4

```c
#include <stdio.h>
#define WORDS 6
#define CHARS 20

int main(void) {
    char str[WORDS][CHARS];

    for (size_t i = 0; i < WORDS; i++) {
        scanf("%19s", str[i]);
    }
    for (size_t i = 0; i < WORDS; i++) {
        printf("%s ", str[WORDS - i - 1]);
    }
    return 0;
}
```

### Подвиг 5. Напишите программу, которая читает из входного потока в массив data названия шести стран, записанных в одну строчку через пробел. Считать, что максимальная длина названия страны не превышает 30 символов. Вывести в консоль страны, начинающиеся на букву 'G', в одну строчку через пробел в том же порядке, что и во входном потоке. Если таких стран нет, то ничего выводить не нужно.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/5.8.5

```c
#include <stdio.h>
#define WORDS 6
#define CHARS 30
#define FIRST_CHAR 'G'

int main(void) {
    char str[WORDS][CHARS], ch = FIRST_CHAR;

    for (size_t i = 0; i < WORDS; i++) {
        scanf("%29s", str[i]);
    }
    for (size_t i = 0; i < WORDS; i++) {
        if (str[i][0] == ch) {
            printf("%s ", str[i]);
        }
    }
    return 0;
}
```

### Подвиг 6. Продолжите программу, которая читает из входного потока строку целиком с помощью функции fgets(). На выходе формируется корректная Си строка. Удалите из прочитанной строки все латинские символы 'e' и выведите в консоль полученную строку.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/5.8.6

```c
#include <stdio.h>
#define CHAR_TO_DEL 'e'

void strip_string(char* str, int max_len) {
    int count = 0;
    while (*str++ != '\0' && count++ < max_len)
        ;

    if (count > 0) {
        str -= 2;
        if (*str == '\n') *str = '\0';
    }
}

void char_deleting(char* str, int max_len, char ch) {
    int count = 0;
    char* ptr = str;
    while (*str != '\0' && count++ < max_len) {
        while (*ptr == ch) ptr++;
        *str++ = *ptr++;
    }
}

int main(void) {
    char str[100];
    fgets(str, sizeof(str), stdin);
    strip_string(str, sizeof(str));

    char_deleting(str, sizeof(str), CHAR_TO_DEL);

    puts(str);

    return 0;
}
```

### Подвиг 7. Продолжите программу, которая читает из входного потока строку целиком с помощью функции fgets(). На выходе формируется корректная Си строка. Вычислите количество слов в строке (слова разделяются одним или несколькими пробелами) и выведите в консоль полученное целое число.

P. S. Пробелы могут быть в начале и в конце строки.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/5.8.7

```c
#include <stdio.h>

void strip_string(char* str, int max_len) {
    int count = 0;
    while (*str++ != '\0' && count++ < max_len)
        ;

    if (count > 0) {
        str -= 2;
        if (*str == '\n') *str = '\0';
    }
}

int words_counter(char* str, int max_len) {
    int count = 0, res = 0;
    while (*str != '\0' && count++ < max_len) {
        if (*str != ' ' && (*(str + 1) == ' ' || *(str + 1) == '\0')) res++;
        str++;
    }
    return res;
}

int main(void) {
    char str[100];
    fgets(str, sizeof(str), stdin);
    strip_string(str, sizeof(str));

    int res = words_counter(str, sizeof(str));

    printf("%d", res);

    return 0;
}
```

### Подвиг 8. Продолжите программу, которая читает из входного потока строку целиком с помощью функции fgets(). На выходе формируется корректная Си строка. Выделите из строки второе слово (слова разделяются одним или несколькими пробелами) и выведите его в консоль. Пробелов до и после выделенного слова быть не должно. Если строка состоит из одного слова, то в консоль вывести "no".

P. S. Пробелы могут быть в начале и в конце строки.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/5.8.8

```c
#include <stdio.h>

void strip_string(char* str, int max_len) {
    int count = 0;
    while (*str++ != '\0' && count++ < max_len)
        ;

    if (count > 0) {
        str -= 2;
        if (*str == '\n') *str = '\0';
    }
}

int words_counter(char* str, int max_len) {
    int count = 0, res = 0;
    while (*str != '\0' && count++ < max_len) {
        if (*str != ' ' && (*(str + 1) == ' ' || *(str + 1) == '\0')) res++;
        str++;
    }
    return res;
}

void str_norm(char* str, int max_len) {
    char ch = ' ';
    char shift = 0;
    char start = 1;

    for (int i = 0; i < max_len; i++) {
        if (start && str[i] == ch) shift++;
        if (start && str[i] != ch) start--;

        if (!start && shift) str[i - shift] = str[i];
        if (!start && str[i] == ch) {
            str[i - shift] = '_';
            if (str[i + 1] == ch) shift++;
        }
        if (str[i] == '\0') break;
    }
}

int main(void) {
    char str[100];
    fgets(str, sizeof(str), stdin);
    strip_string(str, sizeof(str));

    int res = words_counter(str, sizeof(str));

    if (res < 2) {
        printf("no");
        return 0;
    }

    str_norm(str, sizeof(str));

    int flag = 0;
    for (size_t i = 0; i < sizeof(str); i++) {
        if (flag) printf("%c", str[i]);
        if (str[i] == '_') flag = 1;
        if (flag && (str[i + 1] == '_' || str[i + 1] == '\0')) break;
    }

    return 0;
}
```

```c
#include <stdio.h>

void strip_string(char* str, int max_len)
{
    int count = 0;
    while(*str++ != '\0' && count++ < max_len);

    if(count > 0) {
        str -= 2;
        if(*str == '\n')
            *str = '\0';
    }
}

int main(void)
{
    char str[100];
    fgets(str, sizeof(str), stdin);
    strip_string(str, sizeof(str));

    int i = 0;
    //пропускаем все пробелы в начале строки
    while(str[i] == ' ' && str[i] != '\0')
        i++;
    
    //пропускаем первое слово
    while(str[i] != ' ' && str[i] != '\0')
        i++;
    
    //пропускаем пробелы после 1 слова
    while(str[i] == ' ' && str[i] != '\0')
        i++;
    
    int flag = 0;
    while(str[i] != ' ' && str[i] != '\0'){
        printf("%c", str[i]);
        i++;
        flag = 1;
    }
    
    if(flag == 0)
        printf("no");
    
    return 0;
}
```

### Подвиг 9 (на повторение). Установите соответствия между директивами условной компиляции и их описаниями.

![05](/Good_good_C_C++/img/05_19.PNG)

### Подвиг 10 (на повторение). Установите соответствия между математическими функциями округления и их описаниями.

![05](/Good_good_C_C++/img/05_20.PNG)

# 5.9 Строковые функции strlen(), strcpy(), strncpy(), strcat()

С этого занятия мы начнем рассмотрение основных функций для работы со строками. Первое, с чем приходится иметь дело – это копирование одной строки в другую, а, точнее, из одного массива в другой. Давайте посмотрим, как это можно сделать.

Пусть у нас объявлены две строки (два байтовых массива) разного размера:

```c
#include <stdio.h>

int main(void) {
    char source[100] = "Source string";
    char destination[10];

    return 0;
}
```

Наша задача скопировать содержимое строки `source` (источник) в строку `destination` (назначение). Первое, что, почему то пробуют делать начинающие кодеры, это просто присвоить один массив другому:

```c
destination = source;   // ошибка
```

Но мы уже знаем, что массивы так нельзя присваивать, т.к. это неизменяемые указатели на области памяти. 

Единственный вариант – это перебрать элементы первого массива и посимвольно скопировать во второй. Для этого, очевидно, нужно воспользоваться оператором цикла. Я реализую этот алгоритм с помощью цикла `while` следующим образом:

```c
#include <stdio.h>

int main(void) {
    char source[100] = "Source string";
    char destination[10];

    const char* src = source;
    char* dst = destination;
    int max_len_copy = sizeof(destination);

    while (*src != '\0' && max_len_copy-- > 1) *dst++ = *src++;
    *dst = '\0';

    puts(destination);

    return 0;
}
```

Вначале идет объявление вспомогательных указателей `src` и `dst`, причем указатель `src` определен с ключевым словом `const`, показывающий, что исходная строка изменена через указатель `src` не будет. Далее, объявлена переменная `max_len_copy` со значением размера массива `destination`, в который будет выполняться копирование строки. В цикле мы будем копировать символы, пока либо не дойдем до конца строки `source`, либо не скопируем `max_len_copy-1` символ, чтобы не выйти за пределы массива `destination`. После цикла в конец копируемой строки необходимо прописать символ ее конца ‘\0’.

После выполнения программы увидим фрагмент строки из 9 символов:

```
Source st
```

Если же размер массива `destination` увеличить до 20 символов:

```c
char destination[10];
```

то будет скопирована вся строка:

```
Source string
```

## Функция `strcpy()`

Конечно, каждый раз писать цикл, чтобы скопировать одну строку в другую, очень неудобно. Поэтому в языке Си уже есть стандартные функции, которые выполняют эту операцию:

```c
char* strcpy(char* dest, const char* src);
char* strncpy(char* dest, const char* src, int max_len);
```

Обе они определены в заголовочном файле `string.h` и возвращают указатели `dest`. Первая функция `strcpy()` в `dest` копирует все символы строки из `src`, пока не встретится символ конца строки (он тоже копируется). Вторая функция делает то же самое, но дополнительно еще проверяет, чтобы максимальное количество копируемых символов не превышало значения `max_len`. Такой подход считается более безопасным.

Давайте на примерах посмотрим, как их можно использовать:

```c
#include <stdio.h>
#include <string.h>

int main(void) {
    char s_1[100] = "Source string";
    char d_1[10], d_2[20];

    strcpy(d_1, s_1);
    strcpy(d_2, s_1);

    puts(d_1);
    puts(d_2);

    return 0;
}
```
Смотрите, здесь длина массива `d_1` недостаточна для хранения строки `s_1`. Поэтому после запуска программы получаем неожиданный результат содержимое массивов `d_1` и `d_2`:

```
Source string
ing
```

Если же массив `d_1` увеличить, например, до 20 элементов, то проблема исчезнет, и мы получим корректный результат копирования:

```
Source string
Source string
```

Как раз для контроля за этой уязвимостью, лучше использовать вторую функцию `strncpy()` следующим образом:

```c
#include <stdio.h>
#include <string.h>

int main(void) {
    char s_1[100] = "Source string";
    char d_1[10], d_2[20];

    int max_len = sizeof(d_1) - 1;
    strncpy(d_1, s_1, max_len);
    d_1[max_len] = 0;
    strncpy(d_2, "Balakirev", 5);
    d_2[5] = 0;

    puts(d_1);
    puts(d_2);

    return 0;
}
```

Обратите внимание, функция `strncpy()` не добавляет автоматически символ `\0` при окончании процесса копирования. 

Если в строке встретился этот символ, то он будет записан в новую строку, но если мы достигли предела `max_len` и символа `\0` при этом не было, то новой строке его также не будет. Именно поэтому, для гарантии, мы его прописываем в последнюю позицию. 

Также в качестве копируемой строки можно прописывать строковый литерал. При выполнении функции `strncpy()` вместо него будет подставлен адрес строки "Balakirev" и далее процесс копирования будет происходить так же, как и в случае с массивами.

## Функция strlen() определения длины строки
Следующая часто используемая операция – это определение длины строки, то есть, числа символов. О чем здесь речь? Давайте предположим, что в программе объявлена строка:

```c
char str[100] = "Length of the string";
```

Спрашивается, чему равна ее длина? Правильный ответ будет 20 – число символов до символа конца строки:

![05](/Good_good_C_C++/img/05_21.png)

Не нужно путать длину строки с числом элементов массива. В данном примере, массив `str` содержит 100 элементов, но длина строки равна 20.

Как же вычислить эту длину? Здесь опять же следует воспользоваться циклом, например, так:

```c
#include <stdio.h>

int main(void) {
    char str[100] = "Length of the string";

    const char *buf = str;
    size_t length = 0;
    while (*buf++) length++;

    printf("length = %zu\n", length);

    return 0;
}
```

Мы здесь объявили вспомогательный указатель `buf` на строку `str` и переменную `length` типа `size_t` – целый беззнаковый тип. 

Затем, идет цикл `while`, который будет выполняться пока истинно условие, то есть, пока код текущего символа не равен нулю. А ноль, как мы знаем, это маркер конца строки. 

В цикле на каждой итерации происходит увеличение переменной `length` на единицу. В результате, когда встретится число `0`, переменная `length` будет содержать значение длины строки.

Опять же, каждый раз прописывать цикл для определения длины строки, было бы очень неудобно. Поэтому в заголовочном файле `string.h` имеется определение следующей функции:

```c
size_t strlen(const char* buf);
```

которая на входе принимает указатель на строку и возвращает ее длину.

Функция `strlen()` перебирает ячейки памяти, начиная с указанного адреса, пока не будет встречено значение 0. Если переданная строка корректна, то есть, содержит символ конца строки, то проблем с вычислением длины не возникает. Например:

```c
size_t len = strlen(str);
```

Однако если в конце строки по каким-либо причинам не будет символа `\0`, то цикл пойдет дальше по ячейкам памяти, вполне может выйти за пределы массива и остановиться в произвольной позиции. Программа от этого аварийно не завершится, т.к. данные лишь читаются из ячеек памяти, но возвращенное значение длины явно будет неверным. Чтобы такой ситуации не возникало, передавайте в функцию `strlen()` только корректные строки.

## Функции strcat() и strncat() объединения двух строк

Следующие две полезные функции – это объединение двух строк, а точнее, добавление к первой строке `dest` второй `src`:

```c
char* strcat(char* dest, const char* src);
char* strncat(char* dest, const char* src, int max_add);
```

Первая функция добавляет все символы строки `src` к концу строки `dest` (включая символ конца строки), а вторая делает то же самое, но с дополнительным ограничением добавляемых символов не более `max_add`. 

Возвращают обе функции указатель на первую строку (результат объединения).

Вот пример использования этих функций:

```c
#include <stdio.h>
#include <string.h>

int main(void) {
    char str_cat[100] = "Sergey";
    char str[15] = "Balalkirev";

    strcat(str_cat, str);
    printf("%s", str_cat);

    printf("\n");

    size_t max_add = sizeof(str) - strlen(str) - 1;
    strncat(str, str_cat, max_add);
    str[sizeof(str) - 1] = '\0';
    printf("%s", str);

    return 0;
}
```

Первая функция `strcat()` добавляет в конец строки `str_cat` строку `str`, а вторая `strncat()`, наоборот, ко второй строке `str` первую `str_cat` с максимальным ограничением в `max_add` элементов (символов).

После запуска программы увидим следующий результат их работы:

```
SergeyBalalkirev
BalalkirevSerg
```

Как видим, обе функции сформировали корректный результат. Причем, для второй функции максимальное число добавляемых символов было вычислено как разница между всеми элементами массива и числом уже занятых элементов минус один:

```c
size_t max_add = sizeof(str) - strlen(str) - 1;
```

Этот минус один нужен, чтобы сформировать корректную строку, если при объединении строк будет достигнут рубеж в `max_add` символов. Функция `strncat()` не добавляет автоматом символ конца строки, поэтому мы это должны сделать сами.

Конечно, на практике предпочтение следует отдавать второй функции `strncat()`, так как она более безопасна в использовании и позволяет контролировать выход за пределы массива, куда выполняется добавление новых значений. А первую функцию `strcat()` удобно применять при добавлении к строке какого-либо строкового литерала, где мы легко можем контролировать итоговую длину объединенной строки.

Видео по теме [#37. Строковые функции strlen(), strcpy(), strncpy(), strcat(), strncat()](https://www.youtube.com/watch?v=Nk3Jary7ji0&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Установите соответствия между названиями функций и их описаниями.

![05](/Good_good_C_C++/img/05_22.PNG)

### Подвиг 2. Напишите программу, которая в массив строк cities читает из входного потока названия шести городов, записанных в одну строчку через пробел. Максимальная длина названия города не превышает 50 символов. Из всех названий выбрать наибольшее по длине и вывести в консоль.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/5.9.2

```c
#include <stdio.h>
#include <string.h>

#define CITIES 6
#define CHARS 50

int main(void) {
    char cities[CITIES][CHARS];
    int index = 0, max_len = 0;

    for (int i = 0; i < CITIES; i++) {
        scanf("%49s", cities[i]);
        int size = strlen(cities[i]);
        if (max_len < size) {
            max_len = size;
            index = i;
        }
    }

    puts(cities[index]);

    return 0;
}
```

### Подвиг 3. Напишите программу, которая в массив строк cities читает из входного потока названия шести городов, записанных в одну строчку через пробел. Максимальная длина названия города не превышает 50 символов. Из всех названий выбрать два наибольших по длине и вывести в консоль в одну строчку через пробел.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/5.9.3

```c
#include <stdio.h>
#include <string.h>

#define CITIES 6
#define CHARS 50

int main(void) {
    char cities[CITIES][CHARS];
    int index_max = 0, index_pre_max = 0, max_len = 0, pre_max_len = 0;

    for (int i = 0; i < CITIES; i++) {
        scanf("%49s", cities[i]);
        int size = strlen(cities[i]);
        if (max_len < size) {
            pre_max_len = max_len;
            max_len = size;
            index_pre_max = index_max;
            index_max = i;
        }
        if (size < max_len && pre_max_len < size) {
            pre_max_len = size;
            index_pre_max = i;
        }
    }

    printf("%s %s", cities[index_max], cities[index_pre_max]);

    return 0;
}
```

### Подвиг 4. Продолжите программу, которая читает из входного потока строку целиком с помощью функции fgets() в массив str. На выходе формируется корректная Си строка. Добавьте к строке res_str строку str. При объединении строк необходимо контролировать выход за пределы массива res_str. То есть, из строки str можно максимум скопировать до 99-го индекса строки res_str. В конце строки res_str обязательно должен стоять символ '\0'. Выведите полученную строку res_str в консоль.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/5.9.4

```c
#include <stdio.h>
#include <string.h>

void strip_string(char* str, int max_len) {
    int count = 0;
    while (*str++ != '\0' && count++ < max_len)
        ;

    if (count > 0) {
        str -= 2;
        if (*str == '\n') *str = '\0';
    }
}

int main(void) {
    char str[100], res_str[100] = "I love language C ";
    fgets(str, sizeof(str), stdin);
    strip_string(str, sizeof(str));

    size_t max_add = sizeof(res_str) - strlen(res_str) - 1;

    strncat(res_str, str, max_add);

    puts(res_str);

    return 0;
}
```

### Подвиг 5. Продолжите программу, которая в массив строк ps (двумерный массив 7 x 50) читает из входного потока фамилии семи сотрудников, записанных в одну строчку через пробел. Считать, что максимальная длина фамилии не превышает 50 символов. Сформировать еще одну строку ps_res, в которую через пробел скопировать фамилии сотрудников (в порядке их считывания). В конце последней фамилии пробела быть не должно, сразу стоять символ '\0'. Вывести строку ps_res в консоль.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/5.9.5

```c
#include <stdio.h>
#include <string.h>
#define MEN 7
#define CHARS 50

int main(void) {
    char ps[MEN][CHARS], ps_res[MEN * CHARS];
    char* ptr = ps_res;
    for (size_t i = 0; i < MEN; i++) {
        scanf("%s", ps[i]);
        for (size_t j = 0; j < strlen(ps[i]); j++) {
            *ptr++ = ps[i][j];
        }
        *ptr++ = ' ';
    }
    *(ptr - 1) = '\0';

    puts(ps_res);

    // __ASSERT_TESTS__  // макроопределение для тестирования (не убирать и должно идти непосредственно перед
    // return 0)

    return 0;
}
```

```c
#include <stdio.h>
#include <string.h>

int main(void)
{
    // здесь продолжайте программу
    char ps[7][50] = {0};
    char ps_res[357] = {0};
    for(int i = 0; i < 7; ++i)
    {
        scanf("%s", ps[i]);
        strcat(ps_res, ps[i]);
        strcat(ps_res, (i == 6) ? "\0" : " ");
    }
    puts(ps_res);
    
    //__ASSERT_TESTS__ 
    // макроопределение для тестирования (не убирать и должно идти непосредственно перед return 0)
    return 0;
}
```

### Подвиг 6. Продолжите программу, которая в массив строк ps (размерностью 7 x 50) читает из входного потока фамилии семи сотрудников, записанных в одну строчку через пробел. Считать, что максимальная длина фамилии не превышает 50 символов. Сформировать еще одну строку ps_res, в которую через пробел скопировать фамилии сотрудников (в порядке их считывания), которые имеют четную длину. В конце последней фамилии пробела быть не должно, сразу стоять символ '\0'. Если фамилий счетными длинами нет, то формируется пустая строка. Вывести строку ps_res в консоль.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/5.9.6

```c
#include <stdio.h>
#include <string.h>
#define MEN 7
#define CHARS 50

int main(void) {
    char ps[MEN][CHARS], ps_res[MEN * CHARS];
    char* ptr = ps_res;
    for (size_t i = 0; i < MEN; i++) {
        scanf("%s", ps[i]);
        size_t len = strlen(ps[i]);
        if (len % 2 == 0) {
            for (size_t j = 0; j < len; j++) {
                *ptr++ = ps[i][j];
            }
            *ptr++ = ' ';
        }
    }
    *(ptr - 1) = '\0';

    puts(ps_res);

    // __ASSERT_TESTS__  // макроопределение для тестирования (не убирать и должно идти непосредственно перед
    // return 0)

    return 0;
}
```

### Подвиг 7* (с повторением). Продолжите программу, которая в массив строк ps (двумерный массив 7 x 50) читает из входного потока фамилии семи сотрудников, записанных в одну строчку через пробел. Считать, что максимальная длина фамилии не превышает 50 символов. Сформировать еще одну строку ps_sort, в которую через пробел скопировать фамилии сотрудников по возрастанию их длин. В конце последней фамилии пробела быть не должно, сразу стоять символ '\0'. Вывести строку ps_sort в консоль.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/5.9.7

```c
#include <stdio.h>
#include <string.h>
#define MEN 7
#define CHARS 51

int main(void) {
    char ps[MEN][CHARS], ps_sort[MEN * CHARS];
    char* ptr = ps_sort;
    for (size_t i = 0; i < MEN; i++) {
        scanf("%50s", ps[i]);
    }

    for (size_t i = 0; i < MEN; i++) {
        for (size_t j = i; j < MEN; j++) {
            if (strlen(ps[i]) > strlen(ps[j])) {
                char tmp[CHARS];
                strcpy(tmp, ps[i]);
                strcpy(ps[i], ps[j]);
                strcpy(ps[j], tmp);
            }
        }
    }

    for (size_t i = 0; i < MEN; i++) {
        size_t len = strlen(ps[i]);

        for (size_t j = 0; j < len; j++) {
            *ptr++ = ps[i][j];
        }
        *ptr++ = ' ';
    }
    *(ptr - 1) = '\0';

    puts(ps_sort);

    // __ASSERT_TESTS__  // макроопределение для тестирования (не убирать и должно идти непосредственно перед
    // return 0)

    return 0;
}
```

### Подвиг 8 (на повторение). Выберите все верные утверждения, касающиеся операции sizeof.

+ [x] операция sizeof применительно к массиву возвращает число байт, которые он занимает в памяти устройства
+ [x] операция sizeof для массива с именем ar может быть записана в виде: sizeof(ar);
+ [x] операцию sizeof можно применить к типам данных, например, так: sizeof(short);
+ [ ] операцию sizeof можно применить к типам данных, например, так: sizeof short;
+ [x] операция sizeof для массива с именем ar может быть записана в виде: sizeof ar;

### Подвиг 9 (на повторение). Выберите все верные варианты инициализации массивов.


+ [x] double ar_d[7] = {[2]=0.5, 0.8, [6]=0.01};
+ [x] char str[100] = {1, 2, 3, 10};
+ [ ] int ar_i[5] = {0, 1, 2, 3, 4, 5};
+ [x] short zeros[64] = {0};
+ [x] int row[32] = {};
+ [x] long long pows[4] = {1, 2, 4, 8};
+ [x] short buf[] = {0, 0, 1, 1, 2, 2};

# 5.10 Строковые функции сравнения, поиска символов и фрагментов

Мы продолжаем изучение основных функций работы со строками. Следующая важная операция – это сравнение на равенство двух строк между собой. При этом строки считаются равными, если равны их длины и все соответствующие символы:

![05](/Good_good_C_C++/img/05_23.png)

Например, следующие две строки считаются равными:

```c
char s1[12] = "Hello";
char s2[10] = "Hello";
```

Обратите внимание, строки равны, хотя длины массивов отличаются. Но для нас важно равенство длин именно строк, а не массивов. Очевидно, здесь длины строк совпадают и все соответствующие символы в этих строках. Поэтому приведенные строки равны.

А вот примеры неравных строк:

```c
"Hello" != "hello";  "Hell" != "Hello";   "HELLO" != "hello"
```

Алгоритм сравнения на равенство можно реализовать следующим образом:

```c
#include <stdio.h>

int main(void) {
    char s1[12] = "Hello";
    char s2[10] = "Hello";

    const char *str1 = s1;
    const char *str2 = s2;

    int i = 0;
    for (; str1[i] != '\0' && str2[i] != 0; ++i)
        if (str1[i] != str2[i]) {
            puts("Strings are not equal!");
            return 0;
        }

    if (str1[i] != str2[i]) {
        puts("String lengths are not equal!");
        return 0;
    }

    puts("Strings are equal!");

    return 0;
}
```

Цикл `for` выполняется до тех пор, пока не будет достигнут конец или первой или второй строки. В теле цикла записана проверка на равенство символов с индексом `i`. Если соответствующие символы не равны, то строки считаются различными и алгоритм сравнения завершается. Если же был достигнут конец хотя бы одной из двух строк, то делается проверка, что у другой строки конец не достигнут, а значит, строки имеют разные длины. А иначе, делаем вывод, что строки равны.

Конечно, это лишь один из вариантов реализации алгоритма сравнения строк. Его можно запрограммировать и по-другому. В качестве практики попробуйте придумать свою реализацию. Ну а библиотечный код, который выполняет ту же задачу, реализован с помощью следующих двух функций:

```c
int strcmp(const char* str1, const char* str2);
int strncmp(const char* str1, const char* str2, size_t max_len);
```

Обе возвращают `0`, если строки равны, отрицательное значение, если первая строка `str1` меньше второй `str2` и положительное значение, если первая строка `str1` больше второй `str2`. 

Больше и меньше здесь связано не столько с длинами строк, сколько с символами, из которых они состоят. 

Например, если встречается символ первой строки, который имеет код меньше соответствующего символа второй строки, то функции вернут отрицательное значение. И, наоборот. Но сейчас для нас важно лишь то, что они возвращают `0` для равных строк, а иначе не `0`. Кроме того, вторая функция позволяет задавать сравнение только первых `max_len` символов в обеих строках, а остальные игнорировать. Давайте посмотрим, как их можно использовать в программе.

```c
#include <stdio.h>
#include <string.h>

int main(void) {
    char s1[12] = "Hello";
    char s2[10] = "Hello";

    int res = strcmp(s1, s2);
    if (res == 0)
        puts("Strings are equal!");
    else
        puts("Strings are not equal!");

    return 0;
}
```

Функции `strcmp()` передаются указатели на начало строк, а результат их сравнения сохраняется в переменной `res`. Затем, мы проверяем, если значение `res` равно нулю, то строки равны, а иначе – не равны.

Конечно, в приведенной программе переменная `res` не играет какой-то особой роли, поэтому вызов функции `strcmp()` можно прописать непосредственно в условном операторе следующим образом:

```c
if(strcmp(s1, s2) == 0)
    puts("Strings are equal!");
else
    puts("Strings are not equal!");

```
И это довольно частый вариант записи.

Давайте теперь воспользуемся второй функцией `strncmp()` и с ее помощью выберем все строки, которые начинаются с фрагмента «`Sh`»:

```c
#include <stdio.h>
#include <string.h>

int main(void) {
    const char* strings[] = {"Ship", "Shopping", "Shematic", "Super", "Car", "Sherif"};

    for (int i = 0; i < sizeof(strings) / sizeof(*strings); ++i)
        if (strncmp(strings[i], "Sh", 2) == 0) puts(strings[i]);

    return 0;
}
```

Обратите внимание, как в программе объявлен массив из нескольких строк. В действительности, это обычный массив из указателей и каждый из них содержит адрес начала соответствующей строки. Причем, строки в памяти занимают ровно столько места, сколько требуется для представления корректной строки:

![05](/Good_good_C_C++/img/05_24.png)

Не нужно путать эту конструкцию с двумерным массивом. Это обычный одномерный массив, но состоящий из указателей. Так удобно делать, когда нужно определить несколько строковых литералов и работать с ними, как с единым целым. Причем, все указатели объявлены с ключевым словом `const`, так как строковые литералы, как мы с вами уже знаем, сохраняются в неизменяемой области памяти. Данные из них можно только читать, но не менять.

После определения строк, идет цикл `for`, который перебирает все указатели массива `strings`. В теле цикла на каждой итерации происходит проверка, содержит ли текущая строка (с индексом `i`) первые два символа `Sh`. И если это так, то на экран выводится строка.

После запуска этой программы на экране увидим следующий результат:

```c
Ship
Shopping
Shematic
Sherif
```

Как видите, функция `strncmp()` полезна, когда нам нужно сравнивать не строки целиком, а лишь определенные фрагменты.

## Функции поиска символов и подстрок

Во второй части этого занятия познакомимся с несколькими функциями, которые позволяет находить заданный символ и заданный фрагмент в строке:

```c
char* strchr(const char* str, int val);
// выполняет поиск символа слева-направо с кодом val в строке str;
char* strrchr(const char* str, int val);
// выполняет поиск символа справа-налево с кодом val в строке str;
char* strstr(const char* str, const char* find);
// выполняет поиск слева-направо подстроки find в строке str;
char* strpbrk(const char* str, const char* find);
//выполняет поиск слева-направо любого символа из подстроки find в строке str.
```

Все эти функции возвращаю указатель на ячейку памяти, где был найден символ или фрагмент подстроки, либо значение `NULL`, если поиск не увенчался успехом.

Пользоваться всеми этими функциями достаточно просто и очевидно. Например:

```c
#include <stdio.h>
#include <string.h>

int main(void) {
    char str[] = "Abrakadabra";
    char *ptr = strchr(str, 'a');

    printf("str = %p\nptr = %p\n", str, ptr);
    if (ptr != NULL) printf("*ptr = %c\n", *ptr);

    return 0;
}
```

Здесь функция `strchr()` возвращает указатель на 4-й символ буквы ‘a’ в строке "`Abrakadabra`". После запуска программы увидим следующий результат:

```
str = 0062ff10
ptr = 0062ff13
*ptr = a
```

Если же вместо `strchr()` записать функцию `strrchr()`, то поиск символа будет осуществляться с конца строки:

```c
char *ptr = strrchr(str, 'a');
//с результатом работы:
```

```
str = 0062ff10
ptr = 0062ff1a
*ptr = a
```

Если указать не существующий символ, например, буквы `s`:

```c
char *ptr = strrchr(str, 's');
///то функция вернет нулевой указатель:
```
```
str = 0062ff10
ptr = 00000000
```

Следующие две функции работают похожим образом. Если нам нужно определить, входит ли фрагмент «ra» в строку `Abrakadabra`, то сделать это можно так:

```c
#include <stdio.h>
#include <string.h>

int main(void) {
    char str[] = "Abrakadabra";
    char *ptr = strstr(str, "ra");

    printf("str = %p\nptr = %p\n", str, ptr);
    if (ptr != NULL) printf("ptr: %s\n", ptr);

    return 0;
}
```

После запуска программы увидим результат:

```
str = 0062ff10
ptr = 0062ff12
ptr: rakadabra
```

Наконец, последняя функция `strpbrk()` позволяет проверить, содержится ли в строке хотя бы один из символов подстроки. Это бывает полезно, когда, например, мы хотим проверить, есть ли во введенном пароле хотя бы один из символов `"@!#$^&?"`:

```c
#include <stdio.h>
#include <string.h>

int main(void) {
    char pass[] = "dfdfg90!#$$A";
    char *ptr = strpbrk(pass, "@!#$^&?");

    printf("pass = %p\nptr = %p\n", pass, ptr);
    if (ptr != NULL) printf("ptr: %s\n", ptr);

    return 0;
}
```

После запуска программы увидим результат:

```
pass = 0062ff0f
ptr = 0062ff16
ptr: !#$$A
```

На этом мы завершим текущее занятие по строкам. На следующем продолжим эту тему и поговорим о функциях преобразования произвольной числовой информации в строки и из строк в числа.

Видео по теме [#38. Строковые функции сравнения, поиска символов и фрагментов](https://www.youtube.com/watch?v=ILJWkCfvvjc&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Установите соответствия между строковыми функциями и их описаниями.

![05](/Good_good_C_C++/img/05_25.PNG)

### Подвиг 2. Продолжите программу. В строке str необходимо найти последний символ '\n' и если он найден, то заменить на символ '\0'. Вывести в консоль полученную строку str в квадратных скобках.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/5.10.2

```c
#include <stdio.h>
#include <string.h>
#define CHAR_TO_FIND '\n'
#define CHAR_TO_CHANGE '\0'

int main(void) {
    char str[100] = {0};
    fgets(str, sizeof(str) - 1, stdin);

    char* ptr = strrchr(str, CHAR_TO_FIND);

    if (ptr != NULL) *ptr = CHAR_TO_CHANGE;

    printf("[%s]", str);

    return 0;
}
```

### Подвиг 3. Продолжите программу. Определите в строке str количество фрагментов 'is' и выведите в консоль полученное целое число.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/5.10.3

```c
#include <stdio.h>
#include <string.h>

#define STRING_TO_FIND "is"

int main(void) {
    char str[100] = {0};
    fgets(str, sizeof(str) - 1, stdin);
    char* ptr_n = strrchr(str, '\n');
    if (ptr_n != NULL) *ptr_n = '\0';

    char *ptr_str = str, res = 0;

    while (ptr_str != NULL) {
        ptr_str = strstr(ptr_str, STRING_TO_FIND);
        if (ptr_str != NULL) {
            // printf("%s", ptr_str);
            ptr_str++;
            res++;
        }
    }
    printf("%d", res);
    return 0;
}
```

```c
#include <stdio.h>
#include <string.h>

int main(void)
{
    char str[100] = {0};
    fgets(str, sizeof(str)-1, stdin);
    char* ptr_n = strrchr(str, '\n');
    if(ptr_n != NULL)
        *ptr_n = '\0';

    // здесь продолжайте программу
    char* ptr = str;
    int cnt = 0;
    while ((ptr = strstr(ptr, "is")) != NULL){
        cnt++;
        ptr++;
    }
    
    printf("%d", cnt);

    return 0;
}
```

### Подвиг 4. Продолжите программу. Замените в строке str все дефисы (-) фрагментом "-+-". Выведите полученную строку в консоль.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/5.10.4

```c
#include <stdio.h>
#include <string.h>
#define CHAR_TO_CHANGE '-'

int main(void) {
    char str[100] = {0};

    fgets(str, sizeof(str) - 1, stdin);

    char* ptr_n = strrchr(str, '\n');
    if (ptr_n != NULL) *ptr_n = '\0';

    char res[300];
    char shift = 0;

    for (size_t i = 0; i <= strlen(str); i++) {
        res[i + shift] = str[i];
        if (str[i] == CHAR_TO_CHANGE) {
            res[i + 1 + shift] = '+';
            res[i + 2 + shift] = '-';
            shift += 2;
        }
    }

    puts(res);

    return 0;
}
```

```c
#include <stdio.h>
#include <string.h>

int main(void)
{
    char str[100] = {0};
    fgets(str, sizeof(str)-1, stdin);
    char* ptr_n = strrchr(str, '\n');
    if(ptr_n != NULL)
        *ptr_n = '\0';

    // здесь продолжайте программу
    ptr_n = str;

    while (ptr_n != NULL)
    {
        ptr_n = strchr(ptr_n, '-');

        if (ptr_n != NULL)
        {
            char str_temp[100] = {0};
            size_t max_add = strlen(str) - strlen(ptr_n);
            strncpy(str_temp, str, max_add);
            strcat(str_temp, "-+-");
            strcat(str_temp, ++ptr_n);
            strcpy(str, str_temp);
            ptr_n += 2;
        }
    }
    
    puts(str);

    return 0;
}
```

### Подвиг 5. Продолжите программу. В строке str необходимо заменить все подряд идущие дефисы (например: --, ---, ---- и т.д.) на один дефис (-). Выведите в консоль полученную строку.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/5.10.5

```c
#include <stdio.h>
#include <string.h>

int main(void) {
    char str[100] = {0};
    fgets(str, sizeof(str) - 1, stdin);
    char* ptr_n = strrchr(str, '\n');
    if (ptr_n != NULL) *ptr_n = '\0';

    char *ptr = str, shift = 0;

    while (*ptr != '\0') {
        *(ptr - shift) = *ptr;
        if (*ptr == '-' && *(ptr + 1) == '-') shift++;
        ptr++;
    }
    *(ptr - shift) = '\0';
    puts(str);
    return 0;
}
```

```c
#include <stdio.h>
#include <string.h>

int main(void)
{
    char str[100] = {0};
    fgets(str, sizeof(str)-1, stdin);
    char* ptr_n = strrchr(str, '\n');
    if(ptr_n != NULL)
        *ptr_n = '\0';
    
    ptr_n = str;
    
    while((ptr_n = strchr(ptr_n, '-')) != NULL) {
        while (ptr_n[1] == '-')
            for(char *ptr = ptr_n; *ptr; ptr++)
               ptr[0]= ptr[1];
        ptr_n++;
    }
            

    printf("%s", str);

    return 0;
}
```

### Подвиг 6. С каждой новой строки вводятся названия городов. Напишите программу, которая читает эти строки, кроме пустых (пустая строка должна быть проигнорирована). Программа должна завершаться после чтения максимум 10 городов. Максимальная длина названия каждого города не превышает 50 символов. Сформировать строку, в которой названия городов идут по порядку (считывания) через пробел, кроме тех, что содержат фрагмент "на". Вывести сформированную строку в консоль.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/5.10.6

```c
#include <stdio.h>
#include <string.h>

#define CITIES 10
#define CHARS 50
#define STRING_TO_FIND "на"

int main(void) {
    char cities[CITIES][CHARS];

    for (int i = 0; i < CITIES; i++) {
        scanf("%49s", cities[i]);
    }
    for (int i = 0; i < CITIES; i++) {
        if (strstr(cities[i], STRING_TO_FIND) != NULL)
            continue;
        else
            printf("%s ", cities[i]);
    }

    return 0;
}
```

### Подвиг 7. Напишите программу, в которой с каждой новой строки вводятся названия городов. Пустая строка должна быть проигнорирована. Максимум может быть введено 10 городов. Максимальная длина названия не превышает 50 символов. Сформировать строку, в которой названия городов идут по порядку (считывания) через пробел без дублирования, то есть, повторяющиеся названия отбрасывать. Вывести сформированную строку в консоль.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/5.10.7

```c
#include <stdio.h>
#include <string.h>

#define CITIES 10
#define CHARS 50

int main(void) {
    char cities[CITIES][CHARS];

    for (int i = 0; i < CITIES; i++) {
        scanf("%49s", cities[i]);
    }
    for (size_t i = 0; i < CITIES; i++) {
        char res = 1;
        for (size_t j = 1; j < i; j++) {
            res *= strcmp(cities[i], cities[j]);
        }

        if (res == 0)
            continue;
        else
            printf("%s ", cities[i]);
    }

    return 0;
}
```

### Подвиг 8. Напишите программу, которая читает из входного потока время, представленное в виде строки формата:

hh:mm:ss

где hh - часы; mm - минуты; ss - секунды. Например:

12:06:30

Необходимо преобразовать эту строку и представить время в формате:

ss:mm:hh

Полученную строку вывести в консоль.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/5.10.8

```c
#include <stdio.h>

int main(void) {
    int h, m, s;

    scanf("%d:%d:%d", &h, &m, &s);

    printf("%02d:%02d:%02d", s, m, h);

    return 0;
}
```

### Подвиг 9*. Продолжите программу. В переменной str содержится E-mail адрес. Необходимо проверить его корректность. Для этого в str должен присутствовать один символ '@', а после него (не сразу) - символ '.'. Также в самом E-mail адресе допустимы только символы: a-z, A-Z, 0-9, '.', '_', '-'. Если строка str содержит корректный E-mail адрес, то в консоль вывести 1, иначе 0.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/5.10.9

```c
#include <stdio.h>
#include <string.h>

int main(void) {
    char str[100] = {0};
    fgets(str, sizeof(str) - 1, stdin);
    char* ptr_n = strrchr(str, '\n');
    if (ptr_n != NULL) *ptr_n = '\0';
    size_t len = strlen(str);
    char res = 1;
    char dog_count = 0, dog_index = -1;
    char dot_count = 0, dot_index = -1;

    // посчитаем @ и сохраним его индекс
    for (size_t i = 0; i < len; i++) {
        if (str[i] == '@') {
            dog_count++;
            dog_index = i;
        }
    }
    if (dog_count != 1) {
        res = 0;
        // puts("@");
    }

    // посчитаем точки после @

    for (size_t i = dog_index; i < len; i++) {
        if (str[i] == '.') {
            dot_count++;
            dot_index = i;
        }
    }
    if (dot_count != 1 || dot_index == dog_index + 1) {
        res = 0;
        // puts(".");
    }

    printf("%d", res);

    return 0;
}
```

### Подвиг 10 (на повторение). Установите соответствия между названиями функций и их описаниями.

![05](/Good_good_C_C++/img/05_26.PNG)

# 5.11 Строковые функции sprintf(), atoi(), atol(), atoll() и atof()

## sprintf()

Это занятие начнем с рассмотрения довольно популярной функции:

```c
int sprintf(char* buffer, const char* format, ...);
```

которая определена в заголовочном файле `stdio.h`. Эта функция работает также как и известная нам функция `printf()`, только результат заносит не в выходной поток `stdout`, а в указанную строку `buffer`. И, как вы понимаете, с ее помощью очень удобно формировать строки по заданному шаблону. Например, имеются габаритные размеры `(width, height, depth)` и нам нужно их представить в формате:

`(width x height x depth)`

Вот пример программы, которая это делает:

```c
#include <stdio.h>

int main(void) {
    double width = 2.4, height = 0.76, depth = 3.14;
    char info[100];
    const char format[] = "(%.2f x %.2f x %.2f)";

    sprintf(info, format, width, height, depth);
    puts(info);

    return 0;
}
```

После ее запуска на экран будет выведена строка:

```
(2.40 x 0.76 x 3.14)
```

Как видите, все достаточно просто и удобно. Единственный важный нюанс – это размер массива `info`. Его должно быть достаточно, чтобы целиком помещалась сформированная строка. В представленном примере довольно просто определить максимальную длину итоговой строки. Соответственно, можно заранее объявить массив нужного размера. Но так бывает не всегда. Если форматная строка предполагает вставку других строк, то итоговый размер строки может быть сколь угодно большим. Например:

```c
#include <stdio.h>

int main(void) {
    double width = 2.4, height = 0.76, depth = 3.14;
    char name[] = "Chair";
    char info[100];

    sprintf(info, "(%s: %.2f x %.2f x %.2f)", name, width, height, depth);
    puts(info);

    return 0;
}
```

Здесь в шаблон вывода добавлено название предмета. И, теоретически, максимальная длина имени может быть очень большой, больше размера массива `info`. В результате приходим к проблеме выхода за пределы массива и записи данных в произвольные ячейки памяти. Выходом из этой ситуации может стать указание максимального числа символов в подставляемой строке. Например, так:

```c
sprintf(info, "(%.3s: %.2f x %.2f x %.2f)", name, width, height, depth);
```

В итоге из массива name будут взяты только первые 3 символа. Так мы снова сможем контролировать максимальную длину, но при этом некоторые данные могут быть представлены в усеченном виде, а это не всегда допустимо.

Другой выход из этой ситуации, вычислить длины подставляемых строк и сформировать массив нужной длины. Сделать это лучше всего с использованием функций `malloc()` и `free()`, о которых речь пойдет в будущих занятиях. При этом не стоит для решения такой задачи использовать массивы переменной длины, то есть, массивы, объявленные через переменные, например, так:

```c
const size_t size = strlen(name) + 100;
char info[size];   // плохое решение
```

Как я уже отмечал, программа, использующая массивы переменной длины, может неэффективно переводиться в машинные коды.  Забегая вперед, приемлемое решение выглядит следующим образом:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(void) {
    double width = 2.4, height = 0.76, depth = 3.14;
    char name[] = "Chair";
    const size_t size = strlen(name) + 100;
    char* info = (char*)malloc(size);

    sprintf(info, "(%.30s: %.2f x %.2f x %.2f)", name, width, height, depth);
    puts(info);

    free(info);

    return 0;
}
```

Функция `malloc()` выделяет `size+100` байт в памяти, в нее заносится строка и в конце программы выделенная память освобождается с помощью функции `free()`. Фактически, получили тот же массив переменной длины, но лучшим способом.

## Преобразование чисел в строки

Довольно часто функцию `sprintf()` используют для преобразования чисел в строки. Например, у нас имеется целочисленная переменная `var_i` со значением `-123`:

```c
int var_i = -123;
```

и нам бы хотелось получить ее строковое представление в массиве:

```
char str_var[10];
```

в виде пяти символов:

![05](/Good_good_C_C++/img/05_27.png)

Как вы уже догадались, сделать это можно следующим образом:

```c
sprintf(str_var, "%d", var_i);
```

с последующим выводом результата на экран:

```c
puts(str_var);
```

Довольно удобная и универсальная конструкция. Так можно выполнять преобразование любой числовой информации в текстовый вид. Например, для вещественного значения можно записать функцию `sprint()` следующим образом:

```c
double var_d = 35.7895;
sprintf(str_var, "%.2f", var_d);
```

Получим число в строке с точностью до сотых «35.79». И так далее.

## Преобразование из строк в числа
Конечно, в практике нередко приходится выполнять и обратные задачи: преобразовывать числовые значения из строк в соответствующий числовой тип данных. Для этого в заголовочном файле `stdlib.h` имеется набор следующих функций:

```c
int atoi(const char* str);
// для преобразования целых чисел из строк в тип int;
long atol(const char* str);
// для преобразования целых чисел из строк в тип long;
long long atoll(const char* str);
// для преобразования целых чисел из строк в тип long long;
double atof(const char* str);
// для преобразования вещественных чисел из строк в тип double.
```

Использовать их достаточно просто и очевидно. Например:

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    int a = atoi("123");
    long b = atol("234235354");
    long long c = atoll("23423535456456");
    double d = atof("4564.4545");

    printf("a = %d\nb = %ld\nc = %lld\nd = %f\n", a, b, c, d);

    return 0;
}
```

После запуска программы увидим результат:

```
a = 123
b = 234235354
c = 23423535456456
d = 4564.454500
```

Единственный нюанс работы этих функций, связан с неверным представлением числовой информации в строке или переполнением. Например, если прописать следующие строки в функциях `atoi()`, a`tol()`, `atoll()` и `atof()`:

```c
int a = atoi("1a23");
long b = atol("-234235354564564564");
long long c = atoll("234d23535456456");
double d = atof("f4564.4545");
```

то получим следующие результаты:

```
a = 1
b = -1588106836
c = 234
d = 0.000000
```

Отсюда хорошо видно, что преобразование выполняется либо до первого нечислового символа, либо выдается 0, если строка изначально не может быть интерпретирована как число. Также некорректный результат может получаться, если число не умещается в типе данных, к которому оно приводится.

На этом мы завершим рассмотрение основных функций работы со строками. Конечно, их гораздо больше того, что мы охватили на последних занятиях. Но этой информации вам будет вполне достаточно, чтобы сделать первые шаги в работе со строками языка Си.

Видео по теме [#39. Строковые функции sprintf(), atoi(), atol(), atoll() и atof()](https://www.youtube.com/watch?v=Ej-EMdWOy74&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Установите соответствия между названиями функций работы со строками и их описаниями.

![05](/Good_good_C_C++/img/05_28.PNG)

### Подвиг 2. Напишите программу, которая читает из входного потока три целых числа, записанных в одну строчку через пробел, в переменные h, m, s. Здесь h - часы; m - минуты; s - секунды. На основе этих значений сформировать строку в формате:

hh:mm:ss

Если значение переменных h, m, s выходит за допустимый диапазон (h: [0; 23], m: [0; 59], s: [0; 59]), то вместо соответствующего значения прописать два символа дефиса '--'. Выведите сформированную строку в консоль.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/5.11.2

```c
#include <stdio.h>

int main(void) {
    int h, m, s;

    scanf("%d %d %d", &h, &m, &s);

    if (h < 0 || h > 24)
        printf("--:");
    else
        printf("%02d:", h);
    if (m < 0 || m > 59)
        printf("--:");
    else
        printf("%02d:", m);
    if (s < 0 || s > 59)
        printf("--");
    else
        printf("%02d", s);

    return 0;
}
```

```c
#include <stdio.h>

int main(void) 
{
    int h, m, s;
    scanf("%d %d %d", &h, &m, &s);
    char hh[3] = "--", mm[3] = "--", ss[3] = "--";
    if (h >= 0 && h < 24) sprintf(hh, "%02d", h);
    if (m >= 0 && m < 60) sprintf(mm, "%02d", m);
    if (s >= 0 && s < 60) sprintf(ss, "%02d", s);
    printf("%s:%s:%s", hh, mm, ss);  
    return 0;
}
```

### Подвиг 3. Продолжите программу. В переменную str считывается строка в формате:

<наименование товара>: <высота> x <ширина> x <длина>.

(Символ x - латинская буква.) Значения высоты, ширины и глубины представлены целыми числами. Необходимо выделить их из строки и сохранить в целочисленные переменные: h (высота), w (ширина), d (длина).

P. S. В консоль ничего выводить не нужно. Строка str меняться не должна.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/5.11.3

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(void) {
    char str[100] = {0};
    fgets(str, sizeof(str) - 1, stdin);
    char* ptr_n = strrchr(str, '\n');
    if (ptr_n != NULL) *ptr_n = '\0';

    int h = 0, w = 0, d = 0;
    char* ptr = strchr(str, ':') + 1;
    h = atoi(ptr);
    ptr = strchr(ptr, 'x') + 1;
    w = atoi(ptr);
    d = atoi((strchr(ptr, 'x') + 1));

    printf("%d %d %d", h, w, d);

    // __ASSERT_TESTS__
    // макроопределение для тестирования (не убирать и должно идти непосредственно перед return 0)
    return 0;
}
```

### Подвиг 4. Продолжите программу. В переменную str считывается строка в формате:

csv: <число 1>; <число 2>; <число 3>; ...; <число N>

(после точки с запятой может быть любое число пробелов от 0 и выше).

Числа представлены вещественными значениями, а их общее количество может быть любым, но не менее 1 и не более 50. Необходимо выделить из строки все числа и сохранить их в массиве csv типа double в порядке записи в строке.

P. S. В консоль ничего выводить не нужно. Строка str меняться не должна.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/5.11.4

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(void) {
    char str[200] = {0};
    fgets(str, sizeof(str) - 1, stdin);
    char* ptr_n = strrchr(str, '\n');
    if (ptr_n != NULL) *ptr_n = '\0';

    double csv[50];
    char* ptr = strchr(str, ':');
    int count = 0;

    csv[count++] = atof(++ptr);

    while (strpbrk(ptr, ";")) {
        ptr = strchr(ptr, ';');
        csv[count++] = atof(++ptr);
    }
    for (int i = 0; i < count; i++) {
        printf("%.2lf ", csv[i]);
    }

    // __ASSERT_TESTS__
    // макроопределение для тестирования (не убирать и должно идти непосредственно перед return 0)
    return 0;
}
```

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

int main(void)
{
    char str[200] = {0};
    fgets(str, sizeof(str)-1, stdin);
    char* ptr_n = strrchr(str, '\n');
    if(ptr_n != NULL)
        *ptr_n = '\0';

    double csv[50];
    double *ptr_csv = csv;
    char *ptr = str;
    
    while (strpbrk(ptr, ":;") != NULL ) {
            ptr = strpbrk(ptr, ":;");
            *ptr_csv = atof(++ptr);
            ptr_csv++;
    }
    
    __ASSERT_TESTS__ // макроопределение для тестирования (не убирать и должно идти непосредственно перед return 0)
    return 0;
}
```

### Подвиг 5. Продолжите программу. В массиве строк str хранится информация о count товарах, каждый представлен в формате:

<наименование товара>: <идентификатор>; <цена>; <вес>

Здесь идентификатор - целое число; цена - вещественное число; вес - вещественное число. 

Необходимо удалить из массива str все товары с ценой равной 12300. Выведите в консоль в одну строчку через пробел оставшиеся наименования товаров в массиве str в порядке их следования.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/5.11.5

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define TOTAL 10

typedef struct {
    char name[20];
    double price;
} data;

int main(void) {
    char str[TOTAL][50];
    int count = 0;
    while (count < TOTAL && fgets(str[count], sizeof(str) - 1, stdin)) {
        char* ptr_n = strrchr(str[count], '\n');
        if (ptr_n != NULL) *ptr_n = '\0';
        count++;
    }
    data data[TOTAL];
    for (int i = 0; i < count; i++) {
        char* ptr = str[i];
        char* name = data[i].name;
        while (1) {
            *name++ = *ptr++;
            if (*ptr == ':') {
                *name = '\0';
                break;
            }
        }

        ptr = strchr(ptr, ';') + 1;

        data[i].price = atof(ptr);
        if (data[i].price != 12300.0) {
            printf("%s %lf ", data[i].name, data[i].price);
        }
    }

    return 0;
}
```

### Подвиг 6. Напишите программу, которая читает строку, представленную в формате:

<имя студента>: <оценка 1>, <оценка 2>, ..., <оценка N>

Все оценки представлены целыми числами. Количество оценок может быть разным у разных студентов, но не более 20.

Необходимо вычислить среднее арифметическое оценок и полученное вещественное число вывести в консоль с точностью до тысячных.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/5.11.6

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define TOTAL 20

int main(void) {
    char str[100] = {0};
    fgets(str, sizeof(str) - 1, stdin);
    char* ptr_n = strrchr(str, '\n');
    if (ptr_n != NULL) *ptr_n = '\0';

    double res = 0, count = 0;

    char* ptr = str;
    while (strpbrk(ptr, ":,")) {
        ptr = strpbrk(ptr, ":,") + 1;
        res += atof(ptr);
        count++;
    }
    printf("%.3lf ", res / count);

    return 0;
}
```

```c
#include <stdio.h>

int main()
{
    char name[50];
    scanf("%[^:]:", name);
    int k, count = 0;
    double ans = 0;
    while(scanf("%d,", &k) == 1) {
        ans += k;
        count++;
    }
    printf("%.3f", ans / count);
    return 0;
}
```

### Подвиг 7. Напишите программу, которая читает из входного потока слово (имя студента), а затем, целые числа. Все записано в одну строчку через пробел. Максимальное количество чисел не более 20. Затем, представьте эти числа в виде строки формата:

<имя студента>: <оценка 1>, <оценка 2>, ..., <оценка N>

Оценки должны следовать в порядке их считывания. Выведите полученную строку в консоль.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/5.11.7

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define TOTAL 20

int main(void) {
    char str[100] = {0};
    fgets(str, sizeof(str) - 1, stdin);
    char* ptr_n = strrchr(str, '\n');
    if (ptr_n != NULL) *ptr_n = '\0';

    int count = 0;

    char student[20];
    char* ptr = str;
    char* name = student;
    while (1) {
        *name++ = *ptr++;
        if (*ptr == ' ') {
            *name = '\0';
            break;
        }
    }

    int nums[20];

    ptr = str;
    while (strpbrk(ptr, " ")) {
        ptr = strpbrk(ptr, " ") + 1;
        nums[count++] = atof(ptr);
    }

    printf("%s: ", student);

    for (int i = 0; i < count; i++) {
        printf("%d%s", nums[i], i == count - 1 ? "" : ", ");
    }

    return 0;
}
```

### Подвиг 8* (с повторением). Продолжите программу. В массиве строк str хранится информация о count товарах, каждый представлен в формате:

<наименование товара>: <идентификатор>; <цена>; <вес>

Здесь идентификатор - целое число; цена - целое число; вес - вещественное число. 

Необходимо массив указателей p_sort сформировать так, чтобы они ссылались на отсортированные строки по убыванию веса товара. (Сортировку лучше выполнять непосредственно массива p_sort.) Выведите в консоль в одну строчку через пробел наименования товаров, отсортированные по убыванию веса товара.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/5.11.8

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define TOTAL 10

int main(void) {
    char str[TOTAL][50], *p_sort[TOTAL];
    int count = 0;
    while (count < TOTAL && fgets(str[count], sizeof(str) - 1, stdin)) {
        char* ptr_n = strrchr(str[count], '\n');
        if (ptr_n != NULL) *ptr_n = '\0';
        count++;
    }

    char tmp[50];
            

    for (int i = 0; i < count; i++) {
        for (int j = i; j < count; j++) {
            if ( atof(strrchr(str[i], ';') + 1) < atof(strrchr(str[j], ';') + 1)) {
                strcpy(tmp, str[i]);
                strcpy(str[i], str[j]);
                strcpy(str[j], tmp);
            }
        }
    }
    for (int i = 0; i < count; i++) {
        char * ptr = strchr(str[i], ':');
        *ptr = '\0';
        
        printf("%s ", str[i]);
    }

    return 0;
}
```

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define TOTAL   10

/// Меняет местами строчки
void swap_items( char *st1, char *st2 )
{  char tmp[ 50 ];
     strcpy( tmp, st1 );
     strcpy( st1, st2 );
     strcpy( st2, tmp );
}

/// возвращает вес товара
double get_weight( char *str ) 
{
    return atof( strrchr( str, ';' ) + 2 );
}

/// возвращает индекс самого легкого товара 
char* get_min( char str[][ 50 ], int size )
{
    int idx = 0; 
    double min = get_weight( str[ 0 ] );
    for( int i = 1; i < size; i++ ) {
        if( min < get_weight( str[i] ) ) {
            idx = i;
            min = get_weight( str[i] );
        }
    }
    return str[ idx ];
}

/// Возвращает строку с названием товара.
char *get_name( char *src_str, char *dst_str ) 
{
    int offset = strchr( src_str, ':' ) - src_str;
    memcpy( dst_str, src_str, offset );
    dst_str[ offset ] = ' ';
    dst_str[ offset + 1 ] = 0;
    return dst_str;        
}

int main(void)
{
    char str[TOTAL][50], *p_sort[TOTAL];
    char str3[TOTAL][50];
    int count = 0;
    while(count < TOTAL && fgets(str[count], sizeof(str)-1, stdin)) {
        char* ptr_n = strrchr(str[count], '\n');
        if(ptr_n != NULL)
            *ptr_n = '\0';
        count++;
    }
    char name[ 50 ];
    /// сортируем
    for( int i = 0; i < count; i++ ) {
        /// меняем i-тый элемент с самым маленьким в оставшемся массиве.
       swap_items( str[ i ], get_min( str + i, count - i ) );     
    }
    /// выводим
    for( int i = 0; i < count; i++ ) {
        printf( get_name( str[ i ], name ) );  
    }

    return 0;
}
```

### Подвиг 9 (на повторение). Установите соответствия между строковыми функциями и их описаниями.

![05](/Good_good_C_C++/img/05_29.PNG)

### Подвиг 10 (на повторение). Выберите все верные варианты инициализации двумерных массивов.


+ [x] short ar_1[2][3] = {{1, 2, 3}, {3, 4, 6}};
+ [x] int ar_7[3][3] = {{1, 2}, {3, 4}};
+ [ ] long ar_5[2][] = {{1, 2, 3}, {4, 5, 6}};
+ [ ] int ar_6[2][3] = {{1, 2}, {3, 4}, {5, 6}};
+ [x] int ar_3[][3] = {{1, 2, 3}, {4, 5, 6}};
+ [x] float ar_4[][3] = {1, 2, 3, 4, 5, 6};
+ [x] short ar_2[2][3] = {1, 2, 3, 4, 5, 6};