# 6  Функции

# 6.1 Объявление и вызов функций

## Объявление и вызов функций

Мы начинаем большую и ключевую тему языка Си, посвященную функциям. До сих пор у нас в программах объявлялась только одна функция с именем `main`, из которой вызывались другие стандартные функции:

```c
#include <stdio.h>

int main(void) {
    int x;
    if (scanf("%d", &x) == 1)
        puts("Correct input!");
    else
        puts("Incorrect input!");

    return 0;
}
```

Спрашивается, что же такое функции и зачем они нужны? 

Вы уже знаете, что функция выполняет набор операторов, заключенных в ней. 

Благодаря этому в них можно выносить многократно повторяющиеся фрагменты кода, и, затем, вызывать функции в нужных местах программы. 

Например, код вывода строк в стандартный поток целесообразно вынести в отдельную функцию, т.к. эта операция довольно часто повторяется. В нашем примере, как раз, фигурирует два вызова функции `puts()`. В результате исключается дублирование кода, который в программировании кратко называется:

```
DRY – Don’t Repeat Yourself
```

Вообще, как только в программе появляется повторение (дублирование) кода, то, скорее всего, архитектура и структура программы выстроена неверно и ее следует пересмотреть. 

Дублирование – это очень грубая ошибка при проектировании программ. И функции, как раз, один из самых действенных методов этого избежать. В результате программа становится более модульной, проще воспринимается и редактируется.

## Объявление и вызов функций

Конечно, стандартных функций, поставляемых с компилятором языка Си, недостаточно. Они покрывают лишь базовые потребности. Но мы легко можем объявить свои собственные и использовать их в своих программах. Общий синтаксис объявления функции имеет следующий вид:

```
<тип данных> <имя функции>([набор параметров])
{
        оператор_1;
        ...
        оператор_N;
}
```

Здесь первая строчка соответствует заголовку функции, а операторные фигурные скобки – телу функции. Тип данных перед именем функции определяет возвращаемый функцией тип значений. В самом простом случае это могут быть базовые типы:

```c
int, char, double, short, ...
```

Если же функция ничего не возвращает, то перед ней прописывается тип:

```c
void
```

Имя функции придумывается самим программистом, подобно именам переменных. Но, если переменные, как правило, определяются существительными, то имена функций рекомендуется задавать глаголами, так как они связаны с определенными действиями. Например:

```c
get_coord, show_x, is_digit, и т.п.
```

После имени функции обязательно должны идти круглые скобки, в которых могут быть указаны параметры функции. 

Что такое параметры и зачем они нужны, мы подробнее разберем позже. 

А здесь отмечу, что если функция не принимает никаких параметров, то принято при ее объявлении в круглых скобках прописывать ключевое слово `void`. Тем самым мы подчеркиваем факт отсутствия параметров.

После определения заголовка функции, с новой строки записывается открывающаяся фигурная скобка. 

Обратите внимание, с новой строки, а не на текущей! 

Это общепринятая запись оформления функций на языке Си. 

Фигурные скобки тела функции пишутся в отдельных строчках. 

Почему так? 

Потому что заголовок функции – это отдельная синтаксическая конструкция, которая может быть определена без тела функции. 

Об этом мы с вами еще будем говорить.

Давайте в качестве примера объявим функцию, которая выводит приветственное сообщение:

```c
#include <stdio.h>

void print_hi(void) { 
    puts("Hello! I'm Sergey Balakirev!"); 
}

int main(void) {
    return 0; 
}
```

Здесь имя функции `print_hi` мы придумываем сами, возвращаемый тип `void`, т.к. функция ничего не возвращает. В качестве аргументов также указано ключевое слово `void`. Это простейший пример объявления функции в программе.

Обратите внимание, функция `print_hi()` объявлена до функции `main()`, после директив (если они присутствуют) и вне каких-либо других функций. 

То есть, прежде чем использовать какую-либо функцию, она должна быть прежде объявлена. Также как и с переменными: мы можем их использовать только после объявления.

Итак, если сейчас запустить программу, то никакого вывода на экран не увидим. 

Почему? 

Потому что функция всего лишь объявлена, но нигде не была вызвана (не запущена). Давайте сделаем вызов нашей функции в `main()` следующим образом:

```c
int main(void) {
    print_hi();
    return 0;
}
```

Обратите внимание на круглые скобки после имени функции `print_hi`. Это операция вызова функции. Если их убрать, то программа выполнится, но функция `print_hi()` запущена не будет. Круглые скобки строго обязательны для запуска функции.

Если прописать еще два вызова этой же функции:

```c
int main(void) {
    print_hi();
    print_hi();
    print_hi();
    return 0;
}
```

то при выполнении программы увидим три строчки приветствия:

```
Hello! I'm Sergey Balakirev!
Hello! I'm Sergey Balakirev!
Hello! I'm Sergey Balakirev!
```

Этот пример показывает, что мы можем многократно вызывать функции в любом месте программы и выполнять операторы, записанные в теле вызываемой функции.


## Объявление и вызов функций с параметрами
Приведенная функция `print_hi()`, по большому счету, бесполезна. Она не дает нам ничего существенно нового. И это не удивительно, так как она ничего не принимает и ничего не возвращает. Давайте усложним пример и объявим функцию для вычисления периметра прямоугольника. Что нам для этого нужно? Очевидно, функция должна иметь информацию о длине и ширине прямоугольника, иначе периметр не вычислить. И, кроме того, должна вернуть вычисленное значение, чтобы мы его могли использовать дальше по программе.

![06](/Good_good_C_C++/img/06_01.png)

Пусть функция называется `get_per`, а ширина и длина прямоугольника определяются целочисленными переменными:

```c
int width, int height
```

Тогда объявить эту функцию можно следующим образом:

```c
int get_per(int width, int height) {
    int p = 2 * (width + height);
    return p;
}
```

Обратите внимание, параметры функции записываются как переменные через запятую. Собственно, это и есть обычные переменные. Причем, перед каждым параметром обязательно нужно указывать тип данных, даже при одинаковых типах. Объявление вида:

```c
int get_per(int width, height)       // ошибка
```

будет неверным. Хотя, при объявлении нескольких целочисленных переменных в теле функции мы можем использовать такой синтаксис. Но не при описании параметров.

Возвращаемый тип здесь также указан как `int`, так как функция возвращает целочисленное значение периметра прямоугольника. 

Сам периметр вычисляется в теле функции и сохраняется во временную переменную `p`. Затем, с помощью оператора `return` мы указываем, что именно будет возвращать данная функция. Так как нужно вернуть периметр, то записываем переменную `p` после ключевого слова `return`.

Кстати, тело функции в данном случае можно было бы записать в одну строчку, не создавая промежуточную переменную `p`:

```c
int get_per(int width, int height) {
    return 2 * (width + height);
}
```

Результат будет абсолютно таким же. Мало того, современные компиляторы обе функции преобразуют в машинные коды одинаковым образом. Поэтому какой вид записи использовать, решать только вам. Главное, чтобы программа была понятной для восприятия.

Забегая вперед отмечу, что все обычные параметры и переменные, объявленные внутри функции, создаются в момент вызова этой функции и исчезают при ее завершении. 

То есть, параметры `width`, `height` и переменная p доступны только внутри функции `get_per()` и не существуют за ее пределами. Более подробно мы с вами об этом еще будем говорить.

Давайте теперь посмотрим, на способы вызова функции `get_per()`:

```c
int main(void) {
    int w = 2, h = 5;

    get_per(w, h);
    int per_1 = get_per(w + 1, h - 4);
    int per_2 = get_per(w, 3);
    int per_3 = get_per(1, 3);

    return 0;
}
```

Смотрите, в первом случае мы вызвали `get_per(w, h)` и не сохраняли возвращаемое ею значение. 

Так вполне можно делать, если не важно, что именно при вызове вернет функция. 

В этом случае говорят, что функция была вызвана ради побочного эффекта. 

То есть, не ради того, чтобы получить возвращаемое значение, а только ради выполнения операторов тела функции. Например, так часто поступают при вызове функции `printf()`:

```c
printf("get_per\n");
```

Она возвращает число байт, помещенных в выходной поток `stdout`, но нас это значение не интересует, так как обычно с выводом данных проблем не возникает.

Если же возвращаемое значение важно, то его можно сохранить с помощью операции присваивания в переменной соответствующего типа.

Далее, при каждом вызове функции `get_per()` в круглых скобках указываются значения, которые ей передаются. 

Эти значения называются аргументами и их должно быть ровно столько, сколько прописано параметров при объявлении функции. 

Каждое переданное значение копируется в соответствующий параметр: первый аргумент копируется в параметр `width`, а второй – в параметр `height`.

Обратите внимание, данные именно копируются, то есть, создается их копия в переменных функции `width` и `height`. 

Соответственно, при первом вызове `get_per()` в параметры `width` и `height` записываются значения `2` и `5`; при втором – значения `2+1 = 3` и `5-4 = 1`; при третьем – `2` и `3`; при четвертом – `1` и `3`.

Если в момент вызова функции `get_per()` указать неверное число аргументов, например:

```c
int per_3 = get_per(1);
```

то при компиляции возникнет ошибка. Число аргументов в нашем примере должно совпадать с числом параметров функции.

На этом мы завершим наше первое знакомство с функциями. Из этого занятия вы должны хорошо себе представлять, как объявляются и вызываются функции.

Видео по теме [#40. Объявление и вызов функций](https://www.youtube.com/watch?v=nlVj5rOtLVw&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, касающиеся объявления и использования функций языка Си.

+ [x] функция может быть вызвана в любом (допустимом) месте программы произвольное число раз
+ [x] оператор вызова функции - это круглые скобки, стоящие после ее имени
+ [x] в качестве имен функций следует использовать глаголы
+ [x] объявление функций выполняется согласно синтаксису: <тип данных> <имя функции>([набор параметров]) {[операторы тела функции]}
+ [x] перед каждым параметром функции обязательно указывать его тип данных
+ [x] если функция не возвращает никаких значений, то у нее прописывается тип void
+ [ ] если функция не возвращает никаких значений, то тип данных у нее не прописывается
+ [x] часто в функции выносят многократно повторяющиеся (используемые) фрагменты программного кода

## Подвиг 2. В программе ниже объявите функцию с именем show_info без параметров и без возвращаемого значения. Функция show_info должна выводить в консоль строку (без кавычек и с символом переноса на следующую строку):

"It's my first function"

В функции main вызовите функцию show_info.

```c
#include <stdio.h>

void show_info(void) { puts("It's my first function"); }

int main(void) {
    show_info();

    return 0;
}
```

### Подвиг 3. В программе ниже объявите функцию с именем fact, которая вычисляет факториал, переданного ей целого числа, и возвращает вычисленное значение. Напомню, что факториал любого целого положительного числа n вычисляется по формуле:

$n!=1⋅2⋅...⋅n$

Если n = 0, то по правилам математики 0! = 1. Для отрицательных чисел функция fact должна возвращать число -1.

Вызовите в функции main функцию fact для вычисления факториала числа 6 и выведите результат в консоль в виде целого числа.

```c
#include <stdio.h>

int fact(int n) {
    if (n < 0) return -1;
    int res = 1;
    for (int i = 1; i <= n; i++) {
        res *= i;
    }
    return res;
}

int main(void) {
    int res = fact(6);
    printf("%d", res);
    return 0;
}
```

### Подвиг 4. В программе ниже объявите функцию с именем pow_n, которая принимает два целочисленных значения n, m (m >= 0) и вычисляет 

$n^m$. Напомню, что любое число в степени 0 равно 1. 

Вычисленное значение возвращается функцией. 

Вызовите в функции main функцию pow_n с аргументами 2 и 4. 

Выведите результат в консоль в виде целого числа.

```c
#include <stdio.h>

int pow_n(int n, int m) {
    int res = 1;

    for (int i = 1; i <= m; i++) {
        res *= n;
    }
    return res;
}

int main(void) {
    int res = pow_n(2, 4);
    printf("%d", res);
    return 0;
}
```

### Подвиг 5. В программе ниже объявите функцию с именем get_volume, которая принимает три целочисленных значения h, w, d и вычисляет объем h * w * d. Вычисленное значение возвращается функцией. Прочитайте из входного потока три целых числа, записанных в одну строчку через пробел в переменные height, width, depth. Вызовите в функции main функцию get_volume с аргументами height, width, depth. Результат сохраните в переменной и выведите ее значение в консоль как одно целое число.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/6.1.5

```c
#include <stdio.h>

int get_volume(int h, int w, int d) {
    int res = h * w * d;
    return res;
}

int main(void) {
    int height, width, depth;
    scanf("%d %d %d", &height, &width, &depth);
    int res = get_volume(height, width, depth);
    printf("%d", res);
    return 0;
}
```

### Подвиг 6. В программе ниже объявите функцию с именем is_triangle, которая принимает три целочисленных значения a, b, c и определяет, могут ли длины a, b, c образовывать стороны треугольника. Функция возвращает 1, если a, b, c могут быть длинами треугольника, и 0 - в противном случае. Прочитайте из входного потока три целых числа, записанных в одну строчку через пробел в переменные a, b, c. Вызовите в функции main функцию is_triangle с аргументами a, b, c. Результат сохраните в переменной и выведите ее значение в консоль как одно целое число.

Напомню, что числа a, b, c могут образовывать длины сторон треугольника, если каждое из них меньше суммы двух остальных.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/6.1.6

```c
#include <stdio.h>

int is_triangle(int a, int b, int c) {
    int res = (a < b + c) * (b < a + c) * (c < a + b);
    return res;
}

int main(void) {
    int a, b, c;
    scanf("%d %d %d", &a, &b, &c);
    int res = is_triangle(a, b, c);
    printf("%d", res);
    return 0;
}
```

### Подвиг 7 (на повторение). Выберите все верные варианты объявления указателей.

+ [x] double* a;
+ [ ] int* u, v, c; // u, v, c - указатели
+ [ ] unsigned * char ptr_byte;
+ [x] float *a, *b, *c; // a, b, c - указатели
+ [ ] unsigned * short ptr_hd;
+ [x] long * ptr_var;

### Подвиг 8 (на повторение). Пусть в программе объявлены следующие переменные и указатели:

```c
int a = 5, b = 7;
double d = 2.0;
int* ptr_a = &a, *ptr_b = &b;
```

Выберите все верные (рабочие) варианты изменения значения адреса указателей `ptr_a` и `ptr_b`.

+ [x] ptr_b - ptr_a;
+ [x] ptr_a += 3;
+ [ ] ptr_b -= ptr_a;
+ [ ] ptr_a -= d;
+ [ ] ptr_a *= a;
+ [ ] ptr_b + ptr_a;
+ [ ] ptr_b += ptr_a;
+ [x] ptr_b++;
+ [ ] ptr_a /= b;
+ [x] ptr_a += b * 5;
+ [x] --ptr_a;

# 6.2 Оператор return. Вызов функций в аргументах

## Оператор return.

На этом занятии подробнее ознакомимся с работой оператора `return`.

Давайте предположим, что нам нужно объявить функцию, которая бы вычисляла корень четвертой степени от переданного значения `x`. Ее можно записать и вызвать следующим образом:

```c
#include <math.h>
#include <stdio.h>

double sq4_x(double x) {
    double res = (x < 0) ? NAN : pow(x, 0.25);
    return res;
}

int main(void) {
    printf("%f\n", sq4_x(16));
    return 0;
}
```
Функция `sq4_x()` имеет возвращаемый тип `double` и один параметр этого же типа. Затем, во временную переменную `res` заносится значение `nan` (сокращение от `Not a Number` – не число) если переменная `x` меньше нуля, а иначе корень четвертой степени. Далее, записан оператор `return` с указанием возвращаемого значения – переменной `res`. Ниже, в функции `main()`, вызывается функция `sq4_x()` с аргументом `16` и значение выводится на экран. После запуска программы увидим результат:

```
2.000000
```

Очевидно, это число `2.0` было возвращено функцией `sq4_x()` благодаря оператору `return`. Если этот оператор убрать, то функция будет возвращать неопределенные значения. Однако в современных стандартах языка Си/С++ оператор `return` строго обязателен, если тип функции отличен от `void`. Поэтому следует придерживаться правила: если функция возвращает какой-либо определенный тип данных (не `void`), то в ней следует прописывать оператор `return`.

В действительности, этот оператор делает две вещи:
+ собственно, возвращает указанные значения;
+ и завершает выполнение функции. 

Вот этот второй момент не следует упускать из виду. Например, если после оператора `return` прописать еще какой-либо оператор, например:

```c
double sq4_x(double x) {
    double res = (x < 0) ? NAN : pow(x, 0.25);
    return res;
    puts("sq4_x");
}
```

то он выполнен не будет, так как выполнение функции завершится на операторе `return`.

Это свойство часто используют для досрочного завершения функций. Например, в нашем примере, мы это могли бы использовать так:

```c
double sq4_x(double x) {
    if (x < 0) return NAN;

    return pow(x, 0.25);
}
```

Вначале проверяем, если `x` меньше нуля, то сразу завершаем выполнение функции с возвращением специального значения `nan`. Иначе, при ложности условия, выполнение тела функции дойдет до второго оператора `return` и будет вычислен корень четвертой степени.

## Оператор return в функции типа void

Если при объявлении функции возвращаемый тип указан как `void`, то оператор `return` в ней прописывать не обязательно. Например, функция, которая выводит на экран значение переданной переменной, если она четная:

```c
void print_even_x(int x) {
    if (x % 2 == 0) printf("x = %d\n", x);
}
```
Здесь нет никакого оператора `return`. Функция просто выводит значение для четных чисел. Ниже в функции `main()` мы можем ее вызвать следующим образом:

```c
int main(void) {
    printf("%f\n", sq4_x(-16));
    print_even_x(4);

    return 0;
}
```
Программа скомпилируется и успешно запустится. Однако эту же функцию `print_even_x()` можно записать и с оператором `return`, например, так:

```c
void print_even_x(int x) {
    if (x % 2 != 0) return;

    printf("x = %d\n", x);
}
```

Он будет срабатывать при нечетных x и, соответственно, досрочно завершать выполнение функции. Обратите внимание, после `return` сразу ставится точка с запятой без указания возвращаемого значения. Когда функция имеет тип `void`, она ничего не возвращает, а значит, после оператора `return` не нужно ничего прописывать.

## Функции, как отдельные, независимые модули программы

Вообще, правильно раскладывать программу на наборы функций – это, в некотором смысле, искусство – искусство программирования. 

На первых порах начинающие кодеры суют в функции все подряд. В результате, они получаются громоздкими, корявыми, неудобными для дальнейшего применения. 

Чтобы избежать такой участи, следует на начальных этапах придерживаться нескольких простых правил:
+ функции следует выполнять только свою узко поставленную задачу;
+ для решения поставленной задачи, функции следует использовать только переданные ей параметры;
+ если тело функции становится слишком большим – это повод задуматься над правильностью организации логики программы; возможно, подзадачу следует раздробить на более мелкие подзадачи;
+ в 99% случаях функции ничего не считывают с клавиатуры (из потока `stdin`) и ничего не выводят на экран (в поток `stdout`); если ваша функция делает это, убедитесь, что это действительно необходимо.

## Вызов функций в аргументах

Давайте я покажу на конкретном примере красоту решения задачи с использованием функций. Предположим, перед нами ставится задача объявления функций для поиска минимального числового значения из двух и из трех возможных. Вначале определим функцию для нахождения минимального среди двух значений, например, так:

```c
double min_2(double a, double b) {
    return (a < b) ? a : b;
}
```

А, затем, на основе этой функции, определим вторую – для нахождения минимального среди трех чисел:

```c
double min_3(double a, double b, double c) {
    double min_ab = min_2(a, b);
    return (min_ab < c) ? min_ab : c;
}
```

Видите, как красиво можно подойти к решению этой задачи, если действовать не в лоб, а разбивать задачу на более простые, а потом, объединять их, получая конечный, более сложный результат.

Давайте теперь посмотрим, как можно использовать эти функции:

```c
int main(void) {
    int x = 1, y = -2, z = 10;

    double res_1 = min_2(x, y);
    double res_2 = min_3(x, y, z);
    double res_3 = min_2(min_2(x, y), z);
    double res_4 = min_2(x, min_2(y, z));

    printf("res_1 = %.2f, res_2 = %.2f, res_3 = %.2f, res_4 = %.2f\n", res_1, res_2, res_3, res_4);

    return 0;
}
```

Первые два вызова очевидны, мы просто передаем значения и получаем минимальное из них. А во вторых двух вызовах в качестве аргумента записан еще один вызов функции `min_2()`. Так тоже вполне можно делать. В результате, сначала отработает функция `min_2(x, y)`, будет получено минимальное среди этих двух значений, а затем, оно передается как аргумент первой функции `min_2()`. В итоге, с помощью `min_2()` мы находим минимальное для трех чисел. По аналогии отрабатывает и следующая строчка программы.

Как вы понимаете, мы можем пойти еще дальше и использовать функции `min_2()` и `min_3()` следующим образом:

```c
double r4 = min_2(min_2(-2, 3), min_2(x, y));
double r5 = min_2(min_2(-2, 3), min_3(x, y, z));
```

В итоге получим минимальное среди четырех и пяти чисел. Видите, какое многообразие решений дают эти две функции, при условии их правильного проектирования. 

Но здесь возникает вопрос, в каком порядке будут вызваны функции, записанные в аргументах? Например, при нахождении минимального среди пяти чисел, что будет вызвано вначале `min_2()` или `min_3()`? 

В действительности, стандартом языка Си этот момент не определен. 

Поэтому разные компиляторы могут транслировать программу так, что сначала `min_3()` вызовется, а затем, `min_2()`, или наоборот. 

Гарантии никакой нет. Однако точно можно сказать, что вначале отрабатывают функции, стоящие в аргументах, и только после этого основная функция. В этом мы можем быть уверены.

На первый взгляд может показаться, что нет особой разницы, в каком порядке срабатывают функции в аргументах. Но это не всегда так. Пусть, например, мы задумали использовать операцию инкремента при вызове функции `min_2()`:

```c
double res_1 = min_2(++x, x);
printf("res_1 = %.2f\n", res_1);
```

И думаем, ага, вначале отработает первый аргумент и переменная x увеличится на 1, а затем, второй. В результате, минимальное будет равно 2. Но после запуска программы видим другое значение 1. А вот если в моем случае записать инкремент у второго аргумента:

```c
double res_1 = min_2(x, ++x);
```

то получаем значение 2. То есть, порядок иногда имеет значение, но, так как мы его не знаем, то полагаться на подобные конструкции не стоит. Можно использовать инкремент или декремент, только если такая же переменная не стоит в других аргументах, например, так:

```c
double res_1 = min_2(y, ++x);
```

В этом случае порядок для нас не важен. И, обратите внимание, операция инкремента у переменной `x` записана в префиксной форме. Почему именно так? 

Очевидно, в этом случае значение второго параметра b функции `min_2()` будет принимать значение:

```c
b = ++x;
```

То есть, значение `x` будет увеличено на `1` и только после этого присвоено переменной `b`. Если же при вызове функции `min_2()` использовать постфиксную форму записи:

```c
double res_1 = min_2(y, x++);
```

то это будет эквивалентно присваиванию:

```
b = x++;
```

Соответственно, значение параметра `b` будет равно прежнему значению `x` без увеличения на единицу. Вот этот момент нужно хорошо себе представлять.

Видео по теме [#41. Оператор return. Вызов функций в аргументах](https://www.youtube.com/watch?v=63eFhyLVTBk&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, касающиеся функций языка Си.

+ [x] оператор return завершает текущее выполнение функции
+ [x] оператор return обязателен, если тип функции отличен от void
+ [x] вызов одной функции можно прописывать в аргументах при вызове другой функции
+ [x] для решения поставленной задачи, функции следует использовать только переданные ей параметры
+ [x] большинство функций ничего не считывают с клавиатуры (из потока stdin) и ничего не выводят на экран (в поток stdout)
+ [x] оператор return определяет возвращаемое функцией значение
+ [x] функции должны выполнять строго поставленную задачу и ничего более

### Подвиг 2. Выберите все верные утверждения, касающиеся следующего фрагмента программы.

```c
int get_square(int x) { return x * x; }

int main(void) {
    int a = 7, b = 7, c = 7;
    int res_1 = get_square(a);
    int res_2 = get_square(b++);
    int res_3 = get_square(--c);

    return 0;
}
```

+ [x] переменная res_3 принимает значение 36
+ [ ] переменная res_2 принимает значение 64
+ [x] функция get_square возвращает квадрат переданного ей целого числа
+ [x] переменная res_2 принимает значение 49
+ [ ] переменная res_3 принимает значение 49
+ [x] переменная res_1 принимает значение 49

### Подвиг 3. Выберите все верные утверждения, касающиеся следующего фрагмента программы.

```c
int sum_two(int a, int b) { return a + b; }

int main(void) {
    int a = 3, b = 2;
    int res_1 = sum_two(++a, a);
    a = 3;
    b = 2;
    int res_2 = sum_two(++a, b);
    a = 3;
    b = 2;
    int res_3 = sum_two(a, b++);

    return 0;
}
```

+ [x] значение переменной res_2 равно 6
+ [ ] значение переменной res_1 равно 7
+ [ ] значение переменной res_2 равно 5
+ [x] значение переменной res_3 равно 5
+ [x] значение переменной res_1 неопределенно, т.к. в стандарте языка Си порядок вычисления аргументов функции не определен
+ [ ] значение переменной res_1 равно 8
+ [ ] значение переменной res_3 равно 6

### Подвиг 4. Напишите программу, которая читает из входного потока два целых числа, записанных в одну строчку через пробел, и вычисляет их среднее арифметическое с помощью функции get_mean2. Эта функция должна принимать два целых числа, а возвращать - вещественное число (среднее арифметическое). Вызовите функцию get_mean2 для прочитанных целых чисел и выведите результат ее работы в консоль в виде вещественного числа с точностью до десятых.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/6.2.4

```c
#include <stdio.h>

double get_mean2(int a, int b) {
    double result = (a + b) / 2.0;
    return result;
}

int main(void) {
    int a, b;

    scanf("%d %d", &a, &b);

    double res = get_mean2(a, b);

    printf("%.1lf", res);

    return 0;
}
```

### Подвиг 5. Напишите программу, которая читает из входного потока три целых числа, записанных в одну строчку через пробел, и вычисляет их сумму с помощью функции get_sum2. Эта функция должна принимать два целых числа, а возвращать - одно целое число (сумму от двух переданных чисел). Функцию get_sum2 необходимо вызвать (возможно несколько раз) для вычисления суммы трех прочитанных целых чисел. Выведите результат итогового вычисления в консоль в виде целого числа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/6.2.5

```c
#include <stdio.h>

int get_sum2(int a, int b) {
    int result = a + b;
    return result;
}

int main(void) {
    int a, b, c;

    scanf("%d %d %d", &a, &b, &c);

    int res = get_sum2(c, get_sum2(a, b));

    printf("%.d", res);

    return 0;
}
```

### Подвиг 6. Продолжите программу, которая последовательно читает из входного потока целые числа в переменную x. Необходимо объявить функцию с именем is_even, которая принимает целое значение и проверяет его на четность. Если число четное, то функция is_even возвращает 1, а иначе 0. В записанном цикле while вызовите функцию is_even для каждого прочитанного числа и выведите в консоль в одну строчку через пробел только четные числа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/6.2.6

```c
#include <stdio.h>

int is_even(int a) {
    int res = a % 2 ? 0 : 1;
    return res;
}

int main(void) {
    int x;
    while (scanf("%d", &x) == 1) {
        if (is_even(x)) {
            printf("%d ", x);
        }
    }
    return 0;
}
```

### Подвиг 7. Продолжите программу, которая последовательно читает из входного потока вещественные числа в переменную x. Необходимо объявить функцию с именем is_range со следующей сигнатурой:

```c
int is_range(double x, double a, double b);
```

Функция `is_range` должна проверять попадание числа `x` в диапазон `(a; b)` не включая границы (круглые скобки). 

Если `x` принадлежит диапазону `(a; b)`, то функция возвращает `1`, иначе `0`. В записанном цикле `while` вызовите функцию `is_range` для каждого прочитанного числа и выведите в консоль в одну строчку через пробел с точностью до десятых те числа, для которых функция `is_range` с границами `(-2.5; 3.5)` выдает ложное значение.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/6.2.7

```c
#include <stdio.h>
#define A -2.5
#define B 3.5

int is_range(double x, double a, double b) {
    int res = (x > a) * (x < b);
    return res;
}

int main(void) {
    double x;
    while (scanf("%lf", &x) == 1) {
        if (!is_range(x, A, B)) {
            printf("%.1lf ", x);
        }
    }
    return 0;
}
```

### Подвиг 8. Напишите программу, которая читает из входного потока два целых числа в переменные x, y, записанных в одну строчку через пробел. Объявите функцию с именем get_length, которая возвращает длину радиус-вектора с координатами (x, y).

Напомню, что длина радиус-вектора вычисляется по формуле:

$length= \sqrt{x^2 + y^2}$

В функции `main` вызовите функцию `get_length` с прочитанными значениями `x`, `y` и выведите в консоль длину радиус-вектора с точностью до сотых.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/6.2.8

```c
#include <math.h>
#include <stdio.h>

double get_length(double x, double y) {
    double res = sqrt(x * x + y * y);
    return res;
}

int main(void) {
    double x, y;
    if (scanf("%lf %lf", &x, &y) == 2) {
        double result = get_length(x, y);
        printf("%.2lf ", result);
    }
    return 0;
}
```

Подвиг 9. Известно, что среднее арифметическое от m чисел можно вычислять рекуррентно по формуле:

$Q_{m} = \dfrac{m - 1}{m} \cdot Q_{m−1} + \dfrac{1}{m} \cdot x$
​

где
+ $Q_{m−1}$ - среднее арифметическое от предыдущих `m-1` чисел;
+ `x` - новое `m`-е значение.

В программе ниже необходимо реализовать подсчет среднего арифметического читаемых целых чисел из входного потока. Для этого объявите функцию со следующей сигнатурой:

```c
double get_qm(double qm_1, int m, int x);
```

Функция `get_qm` должна вычислять очередное значение среднего арифметического для `m` прочитанных чисел и возвращать вычисленное значение `Qm`. В записанном цикле `while` с помощью функции `get_qm` вычислите среднее арифметическое всех прочитанных целых чисел из входного потока. Выведите результат вычисления в консоль в виде вещественного числа с точностью до тысячных.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/6.2.9

```c
#include <stdio.h>

double get_qm(double qm_1, int m, int x) {
    double res = ((m - 1) / (double)m) * qm_1 + (1 / (double)m) * x;
    return res;
}

int main(void) {
    int x;
    int m = 1;
    double result = 0;

    while (scanf("%d", &x) == 1) {
        result = get_qm(result, m++, x);
    }
    printf("%.3lf ", result);
    return 0;
}
```

### Подвиг 10 (на повторение). Выберите все верные утверждения, касающиеся массивов языка Си.

+ [ ] длина массива - это число байт, которые он занимает в памяти устройства
+ [x] длина массива - это максимальное число элементов (определенного типа), которые он хранит
+ [x] массивы можно объявлять по синтаксису: <тип элементов массива> <имя массива>[<число элементов массива>];
+ [x] массивы представляют собой непрерывную область памяти, в которой друг за другом размещены данные одного типа
+ [x] индекс массива - это целое число от 0 до length-1 (length - длина массива); служит для доступа к определенному элементу массива
+ [ ] индекс массива - это целое число от 1 до length (length - длина массива); служит для доступа к определенному элементу массива

### Подвиг 11 (на повторение). Выберите все верные утверждения, касающиеся инициализации массивов языка Си стандарта C99.

+ [x] если при инициализации указано меньше значений, чем длина массива, то оставшиеся элементы массива принимают произвольные значения
+ [x] операция инициализации массивов не влияет на скорость выполнения программы
+ [x] число значений в инициализаторе должно быть меньшее или равно длине массива
+ [x] при инициализации массивов в глобальной области можно использовать только выражения времени компиляции программы
+ [x] если при инициализации указано меньше значений, чем длина массива, то оставшиеся элементы массива принимают значение 0
+ [x] операция инициализации массивов увеличивает объем вычислений (при выполнении программы) и тем больше, чем длиннее массив
+ [x] при инициализации массивов в функции main() можно использовать переменные

# 6.3 Прототипы функций

На прошлых занятиях мы целиком задавали функции до основной функции `main()`. Однако довольно часто бывают ситуации, когда нужно лишь объявить заголовок функции, а ее реализацию определить позже или даже прописать в другом модуле программы. Например, пусть у нас имеется все та же функция вычисления периметра прямоугольника:

```c
#include <stdio.h>

double per_sq(double w, double h) {
    if (w < 0 || h < 0) return 0;

    return 2 * (w + h);
}

int main(void) {
    printf("per = %.2f\n", per_sq(2.5, 3.5));
    return 0;
}
```

Так вот, чтобы мы могли ее вызывать в функции `main()` достаточно прописать лишь заголовок этой функции, а реализацию указать позже. Например, так:

```c
#include <stdio.h>

double per_sq(double w, double h);

int main(void) {
    printf("per = %.2f\n", per_sq(2.5, 3.5));
    return 0;
}

double per_sq(double w, double h) {
    if (w < 0 || h < 0) return 0;

    return 2 * (w + h);
}
```

Программа по-прежнему компилируется и запускается. Такой заголовок еще называют прототипом функции. Для формирования объектного файла текущего модуля, то есть, для преобразования текста программы в машинный код, компилятору достаточно иметь описание заголовка функции. На основе этой информации он сможет сформировать корректный вызов функции в программе, а позже для этого вызова подставит адрес с телом вызываемой функции на этапе сборки всего проекта. В частности, это означает, что конкретную реализацию функции можно прописывать в любом другом модуле проекта, или даже выносить ее в заранее скомпилированные объектные файлы, которые, затем, следует указывать при линковке (сборке) проекта.

Давайте в этом убедимся. Создадим в рабочем каталоге еще один файл с именем `func.c` и пропишем в нем целиком функцию `per_sq()`:

```c
double per_sq(double w, double h) {
    if (w < 0 || h < 0) return 0;

    return 2 * (w + h);
}
```
А из файла с функцией `main()` реализацию функции `per_sq()` удалим. Если прямо сейчас попробовать скомпилировать программу, то получим ошибку на этапе линковки проекта, что отсутствует реализация для функции `per_sq()`.

Это из-за того, что второй файл `func.c` не был включен в проект для совместной компиляции его с основным файлом программы. Давайте его добавим. Для этого перейдем в настройки (файл `settings.json`) и для компиляции Си-программ явно пропишем два файла (`lessons.c`  и `func.c`):

```bash
gcc -std=c99 lessons.c func.c -o lessons
```

Теперь второй файл `func.c` также будет скомпилирован и реализация функции `per_sq()` будет взята из него.

Как видите, прототипы функций предоставляют нам удобный инструмент оформления программы в нескольких файлах. Этим очень часто пользуются на практике и, наверное, не существует ни одного серьезного проекта, который бы не включал в себя множество файлов с программой. Скорее, наоборот, использование одного файла – это исключение, чаще всего, при обучении.

Итак, мы с вами увидели, как можно объявлять заголовок (прототип) функции и узнали, где это используется. Отмечу лишь, что в прототипе имена переменных можно опускать, компилятор их все равно не учитывает:

```c
double per_sq(double, double);
```

Для него главная информация – это возвращаемый тип, имя функции и количество параметров с их типами. Больше ничего ему не нужно для формирования вызова функции на уровне машинных кодов.

## Прототипы функций в заголовочном файле
Полученный текст программы, описанный в двух модулях, имеет один существенный недостаток. Если модулей станет больше и определение функции в файле `func.c` изменится, то его придется менять во всех прототипах других модулей. Поэтому поступают следующим образом. Все общие прототипы выносятся в заголовочные файлы, например, в файл `func.h`:

```c
#ifndef __FUNC_H__
#define __FUNC_H__
 
double per_sq(double, double);
 
#endif
```

А в модулях, где используется функция `per_sq()` подключается этот файл с помощью директивы `#include:`

```c
#include <stdio.h>

#include "func.h"

int main(void) {
    printf("per = %.2f\n", per_sq(2.5, 3.5));
    return 0;
}
```

Теперь, при изменении сигнатуры функции ее достаточно будет изменить в заголовочном файле `func.h` и изменение автоматически коснется всех модулей, где этот файл подключается.

Обратите также внимание на оформление файла `func.h`. В нем прописаны директивы препроцессора `#ifndef`, `#define` и `#endif`. Они необходимы, чтобы при повторном подключении этого заголовочного файла в один и тот же модуль дважды не попадало содержимое этого файла. Подробно об этом мы с вами уже говорили, когда рассматривали условные директивы препроцессора.

Самих же прототипов различных функций в программе может быть сколько угодно. Например, в файле func.c можно объявить еще несколько функций:

```c
int abs_int(int x) {
    return (x < 0) ? -x : x;
}
 
int sq_to_int(double x) {
    return (int )(x * x);
}
```

Прописать их прототипы в файле `func.h`:

```c
#ifndef __FUNC_H__
#define __FUNC_H__
 
double per_sq(double, double);
int abs_int(int);
int sq_to_int(double);
 
#endif
```

И тогда все они станут доступны во всех модулях, где подключен файл `func.h`.

Видео по теме [#42. Прототипы функций](https://www.youtube.com/watch?v=PL3cPFvQNUk&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, касающиеся функций языка Си.

+ [ ] в заголовочных файлах, как правило, прописаны реализации функций (вместе с телом)
+ [x] прототип функции - это ее заголовок, например: int abs(int x);
+ [x] в заголовочных файлах, как правило, записаны прототипы функций
+ [x] прототипы удобны, когда нужно разделить объявление функции от ее реализации
+ [ ] прототип функции - это ее заголовок вместе с телом функции, например: int abs(int x) {...}
+ [x] для использования функции в программе достаточно объявить ее прототип

### Подвиг 2. Выберите правильную реализацию защиты от возможного множественного включения содержимого заголовочного файла в тексте программы.

A:
```c
#ifdef __MODULE_MATH_H__
#define __MODULE_MATH_H__
// подключаемое содержимое 
#endif
```

B: (Верное исполнение)
```c
#ifndef __MODULE_MATH_H__
#define __MODULE_MATH_H__
// подключаемое содержимое 
#endif
```

C:
```c
#if defined(__MODULE_MATH_H__)
#define __MODULE_MATH_H__
// подключаемое содержимое 
#endif
```

D:
```c
#define __MODULE_MATH_H__
#ifndef __MODULE_MATH_H__
// подключаемое содержимое 
#endif
```

__B__

### Подвиг 3. Продолжите программу. Перед функцией main объявите прототип функции с именем get_geom, которая принимает два целочисленных параметра, вычисляет их среднее геометрическое по формуле:

$g = \sqrt{a⋅b}$
​
и возвращает вычисленное значение `g`. Реализацию функции `get_geom` пропишите после функции `main`. В функции `main` вызовите функцию `get_geom` для переменных `a` и `b`. Вычисленное значение выведите в консоль в виде вещественного числа с точностью до сотых.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/6.3.3

```c
#include <math.h>
#include <stdio.h>

double get_geom(int a, int b);

int main(void) {
    int a, b;
    scanf("%d, %d", &a, &b);

    double result = get_geom(a, b);

    printf("%.2lf", result);

    return 0;
}

double get_geom(int a, int b) {
    double res = sqrt(a * b);
    return res;
}
```

### Подвиг 4. Продолжите программу. Перед функцией main объявите прототип функции с именем calc_rect, которая имеет три целочисленных параметра: w, h - ширина и длина прямоугольника; type - тип вычисления. Функция calc_rect должна вычислять и возвращать площадь прямоугольника со сторонами w, h, если type равен 1 и периметр - в противном случае. Возвращаемое значение должно быть целочисленным. 

Реализацию функции calc_rect пропишите после функции main. В функции main вызовите функцию calc_rect для переменных a,  b и t. Вычисленное значение выведите в консоль в виде целого числа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/6.3.4

```c
#include <stdio.h>

int calc_rect(int w, int h, int t);

int main(void) {
    int a, b, t;
    scanf("%d, %d, %d", &a, &b, &t);

    int result = calc_rect(a, b, t);

    printf("%d", result);

    return 0;
}

int calc_rect(int w, int h, int t) {
    int res;
    if (t == 1) {
        res = w * h;
    } else
        res = 2 * (w + h);
    return res;
}
```

### Подвиг 5. Продолжите программу. Перед функцией main объявите два прототипа функций:

get_max: для вычисления максимального из двух переданных целых чисел (возвращается целое число);
get_min: для вычисления минимального из двух переданных целых чисел (возвращается целое число).
Реализации функций пропишите после функции main. В функции main вызовите функцию get_max для переменных a и b, если значение переменной t равно 1. Иначе должна вызываться функция get_min для тех же переменных a и b. Выведите в консоль вычисленное значение в виде целого числа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/6.3.5

```c
#include <stdio.h>

int get_max(int a, int b);
int get_min(int a, int b);

int main(void) {
    int a, b, t;
    scanf("%d, %d, %d", &a, &b, &t);
    int result;
    if (t == 1)
        result = get_max(a, b);
    else
        result = get_min(a, b);

    printf("%d", result);

    return 0;
}

int get_max(int a, int b) {
    if (a > b)
        return a;
    else
        return b;
}

int get_min(int a, int b) {
    if (a > b)
        return b;
    else
        return a;
}
```

### Подвиг 6. Напишите программу, которая читает из входного потока радиус круга в виде вещественного числа. До функции main объявите прототип функции с именем circle_len, которая должна принимать радиус круга, вычислять его длину по формуле:

$L=2⋅π⋅R$

и возвращать вычисленное значение L. Значение π определить через директиву #define в виде макроопределения PI и взять равным 3.1415. Реализацию функции circle_len пропишите после функции main. В функции main вызовите функцию circle_len и выведите в консоль вычисленное значение длины круга в виде вещественного числа с точностью до сотых.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/6.3.6

```c
#include <stdio.h>
#define PI 3.1415

double circle_len(double radius);

int main(void) {
    double r;
    scanf("%lf", &r);

    double result = circle_len(r);

    printf("%.2lf", result);

    return 0;
}

double circle_len(double radius) {
    double res = radius * 2 * PI;
    return res;
}
```

### Подвиг 7 (на повторение). Выберите все верные варианты объявления строк.


+ [x] char s_1[] = {'B', 'a', 'l', 'a', 'k', 'i', 'r', 'e', 'v', '\0'};
+ [x] char s_3[] = "Balakirev";
+ [ ] char s_5[100] = {"Balakirev", 'S', 'e', 'r', 'g', 'e', 'i', '\0'};
+ [x] char s_2[20] = {'B', 'a', 'l', 'a', 'k', 'i', 'r', 'e', 'v', '\0'};
+ [ ] char s_7 = "Balakirev";
+ [x] const char* s_8 = "Balakirev";
+ [x] char s_4[100] = "Balakirev";
+ [x] char s_6[100] = "Sergey " "Balakirev";

### Подвиг 8 (на повторение). Установите соответствия между функциями и их описаниями.

![06](/Good_good_C_C++/img/06_02.PNG)

# 6.4 Указатели как параметры. Передача массивов в функции

## Указатели как параметры.

Это занятие начнем с рассмотрения указателей в качестве параметров функции.

До этого момента мы с вами объявляли и использовали указатели в рамках одной функции `main()` для изменения значений переменных. Например, так:

```c
#include <stdio.h>

int main(void) {
    short var_a = 10;
    short* ptr = &var_a;
    *ptr = 5;

    return 0;
}
```

Однако особого практического смысла от такой операции не было. Но теперь, когда мы имеем дело с функциями, указатели становятся одним из ключевых элементов. Давайте представим, что нам нужна функция, которая бы меняла значения между двумя переменными. Без указателей решение этой задачи было бы очень корявое. А вот с ними получаем вполне красивое решение:

```c
void swap_2(int* a, int* b) {
    int t = *a;
    *a = *b;
    *b = t;
}

int main(void) {
    int x = 5, y = 10;
    swap_2(&x, &y);

    return 0;
}
```

Как это работает? Вначале в функции `main()` выполняется вызов функции `swap_2()` с передачей адресов переменных `x` и `y`. В результате, указатель `*a` ссылается на переменную `x`, а указатель `*b` – на переменную `y`. Затем, в самой функции `swap_2()` происходит обмен значениями между указанными областями памяти, и, как следствие, меняются значения переменных `x` и `y`.

![06](/Good_good_C_C++/img/06_03.png)

Почему это решение можно считать красивым?
+ Во-первых, такая функция может менять значения между любыми целочисленными переменными типа `int`, где бы эти переменные ни были бы определены.<br>
Например, в приведенной программе, переменные `x` и `y` доступны только в пределах функции `main()` и недоступны (по их именам) за пределами этой функции. Поэтому напрямую получить к ним доступ в функции `swap_2()` не получится.<br>
Но через указатели это вполне можно сделать.
+ Во-вторых, использование указателей позволяет нам определять функции, которые могут менять и возвращать более одного значения. Как вы помните, после оператора `return` можно указывать только одно значение (выражение), которое будет возвращено функцией. Прописывать несколько нельзя. Поэтому с возвратом множества значений возникают определенные трудности, которые, хотя, можно преодолеть, например, с помощью структур, о которых мы с вами еще будем говорить. Однако через указатели решить задачу с возвратом множества значений все же куда проще.

## Передача массивов через параметры функции
Помимо изменения значений, указатели в параметрах используют с целью передачи массивов функциям. Как я ранее уже отмечал, в языке Си нет специального типа (структуры данных) для массивов. Их следует воспринимать, как непрерывную область памяти, в которой последовательно друг за другом расположены элементы массива:

```c
short ar[5];
```

![06](/Good_good_C_C++/img/06_04.png)

При этом имя массива `ar` можно воспринимать, как указатель на начало этой области. А раз так, то любой одномерный массив можно передать в функцию, используя указатели. Например, следующим образом:

```c
#include <stdio.h>

int sum_ar(const short* arr, int length) {
    int res = 0;
    for (int i = 0; i < length; ++i) res += arr[i];

    return res;
}

int main(void) {
    short ar[] = {1, 2, 3, 4, 5};
    int res = sum_ar(ar, sizeof(ar) / sizeof(*ar));

    printf("res = %d\n", res);

    return 0;
}
```

При вызове функции `sum_ar()` параметр `arr` будет ссылаться на первый элемент массива `ar`, а второй параметр `length` содержать число элементов массива. Затем, используя операцию квадратные скобки, мы через указатель `arr` перебираем элементы массива `ar` и подсчитываем их сумму, которая возвращается функцией `sum_ar()`. 

Ключевое слово `const` говорит о том, что значения массива внутри функции меняться не будут. 

Так принято делать, если данные по указателям только читаются и не меняются. 

Своего рода, правило хорошего тона при объявлении параметров-указателей.

Как видите, передать массив в функцию достаточно просто. 

Но здесь у вас может возникнуть вопрос, а зачем определять второй параметр `length`?

Разве нельзя вычислить размер массива непосредственно в функции `sum_ar()`? 

Увы, нет. 

Указатель `arr` – это уже обычный указатель на ячейки памяти, а не на массив, поэтому операция `sizeof()` для него вернет размер указателя, а не области памяти, который занимает массив. 

Определить число элементов массива мы можем только, используя имя массива `ar`, но не указатель на него. Об этом ранее мы с вами уже говорили.

Если мы еще раз посмотрим на объявление функции `sum_ar()`, то первый параметр `arr` можно интерпретировать и как указатель на массив и как указатель на переменную типа `short`. Так вот, чтобы подчеркнуть, что `arr` ссылается именно на массив, допустимо этот указатель описывать следующим образом:

```c
int sum_ar(const short arr[], int length) {...}
```

На уровне машинных кодов оба варианта абсолютно равнозначны. Это все тот же указатель `arr`, только синтаксис подсказывает программисту, что через `ar` в функции `sum_ar()` предполагается работать с непрерывной областью памяти, как с массивом. Не более того.

Также, при необходимости, функция может возвращать константные значения. Для этого достаточно в типе прописать ключевое слово `const` следующим образом:

```c
const char* find_space(const char* buf) {
    while (*buf != '\0') {
        if (*buf == ' ') return buf;
        buf++;
    }
}
```

Обычно `const` прописывают при возвращении константного указателя, так как в других ситуациях особого смысла в `const` нет. В данном примере, функция находит первый пробел в переданной строке и возвращает указатель на него. Если пробел не был найден, то возвращается значение `NULL`.

## Передача многомерных массивов через параметры функции

Крайне редко, но все же бывают ситуации, когда нам нужно передать не одномерный, а многомерный массив в функцию. Для этого, как вы уже догадались, нужно использовать специальный тип указателя на соответствующий многомерный массив. Например, пусть у нас объявлен двумерный массив с некоторым числом строк и тремя столбцами:

```c
short ar[][3] = {{1, 2, 3}, {4, 5, 6}};
```

Чтобы его передать через параметр в функцию, следует сделать следующее объявление:

```c
void show_ar2D(const short (*ar)[3], int rows) {
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < 3; ++j) printf("%d ", ar[i][j]);
        printf("\n");
    }
}
```

Эта функция принимает указатель на двумерный массив с произвольным числом строк `rows`, но обязательно тремя столбцами. И, затем, отображает его на экране в виде таблицы.

Использовать такую функцию можно следующим образом:

```c
int main(void) {
    short ar[][3] = {{1, 2, 3}, {4, 5, 6}};
    show_ar2D(ar, sizeof(ar) / sizeof(*ar));

    return 0;
}
```

Мы по-прежнему передаем указатель на массив и число строк вторым аргументом. После запуска программы увидим результат:

```
1 2 3
4 5 6
```

Как вы понимаете, недостатком использования и передачи многомерных массивов в функцию является необходимость указания точных размеров, кроме первого. В нашем случае, при объявлении функции, необходимо указывать число столбцов, равное трем. И если это значение изменится, то придется вносить правки во все места, где оно используется. Из этой ситуации есть, по крайней мере, два выхода. Первый очевидный. С помощью директивы `define` определить число столбцов и использовать макроимя в тексте программы:

```c
#include <stdio.h>

#define COLS 3

void show_ar2D(const short (*ar)[COLS], int rows) {
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < COLS; ++j) printf("%d ", ar[i][j]);
        printf("\n");
    }
}

int main(void) {
    short ar[][COLS] = {{1, 2, 3}, {4, 5, 6}};
    show_ar2D(ar, sizeof(ar) / sizeof(*ar));

    return 0;
}
```

Во втором случае определить одномерный массив и работать с ним, как с многомерным. Например, для получения аналога двумерного массива в `COLS` столбцов, можно использовать следующую формулу:

```c
short ar[] = {1, 2, 3, 4, 5, 6};
short res_ij = ar[i * COLS + j];  // i – индекс строк; j – индекс столбцов
```

Какой именно вариант использовать на практике зависит от конкретной решаемой задачи и предпочтений программиста.

Видео по теме [#43. Указатели как параметры. Передача массивов в функции](https://www.youtube.com/watch?v=D3K70nL1K_E&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, касающиеся указателей в параметрах функций языка Си.


+ [x] посредством указателей в параметрах можно получить доступ к локальным переменным, объявленным в других функциях
+ [ ] через указатели в функции можно передавать только обычные переменные базовых типов, исключая массивы
+ [ ] через указатели в функции можно передавать только одномерные массивы (не многомерные)
+ [x] посредством указателей в параметрах функция получает возможность менять сразу несколько внешних переменных
+ [x] через указатели в функции можно передавать массивы и строки

### Подвиг 2. Напишите программу, которая читает из входного потока в массив типа int десять целочисленных значений, записанных в одну строчку через пробел. Объявите функцию с именем sum_ar и следующими параметрами (порядок параметров должен соблюдаться):
+ целочисленный массив (тип int);
+ длина массива (число обрабатываемых элементов).

Функция sum_ar должна вычислять сумму элементов переданного массива и возвращать вычисленное значение в виде целого числа.

В функции main вызовите функцию sum_ar для чисел, прочитанных из входного потока. Возвращенное функцией sum_ar значение выведите в консоль в виде целого числа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/6.4.2

```c
#include <stdio.h>

#define MAX 10

int sum_ar(int *ar, int len) {
    int res = 0;
    for (int i = 0; i < len; i++) {
        res += ar[i];
    }
    return res;
}

int main(void) {
    int ar[MAX] = {0};
    for (int i = 0; i < MAX; i++) {
        scanf("%d", &ar[i]);
    }

    int *ptr = ar;
    int result = sum_ar(ptr, sizeof(ar) / sizeof(*ar));

    printf("%d", result);

    return 0;
}
```

### Подвиг 3. Напишите программу, которая читает из входного потока в массив несколько целочисленных значений (не менее одного и не более 20), записанных в одну строчку через пробел. Объявите функцию с именем prod_ar и следующими параметрами (порядок параметров должен соблюдаться):

целочисленный массив;
длина массива (число обрабатываемых элементов).
Функция prod_ar должна вычислять произведение элементов переданного массива и возвращать вычисленное значение в виде целого числа.

В функции main вызовите функцию prod_ar для чисел, прочитанных из входного потока. Возвращенное функцией prod_ar значение выведите в консоль в виде целого числа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/6.4.3

```c
#include <stdio.h>

#define MAX 20

int prod_ar(const int *ar, int len) {
    int res = 1;
    for (int i = 0; i < len; i++) {
        res *= ar[i];
    }
    return res;
}

int main(void) {
    int ar[MAX] = {0}, count = 0;
    for (int i = 0; i < MAX; i++) {
        if (scanf("%d", &ar[i]) == 1)
            count++;
        else
            break;
    }

    int *ptr = ar;
    int result = prod_ar(ptr, count);

    printf("%d", result);

    return 0;
}
```

### Подвиг 4. Напишите программу, которая читает из входного потока в массив несколько вещественных значений (не менее одного и не более 20), записанных в одну строчку через пробел. Объявите функцию с именем to_csv и следующими параметрами (порядок параметров должен соблюдаться):
+ указатель на массив символов (строку);
+ максимальная длина строки (неотрицательное целое число);
+ массив вещественных чисел (тип double);
+ длина массива (неотрицательное целое число).

Функция to_csv должна из переданного ей массива вещественных чисел сформировать строку в формате:

```
"csv: <число 1>; <число 2>; ...; <число N>"
```

Точность вещественных чисел должна быть два знака после запятой (точки), то есть, до сотых. Например:

```
"csv: 0.56; -65.43; 0.10; 11.00"
```

Полагается, что длины строки в 100 символов достаточно для хранения сформированной строки из чисел.

Функция to_csv должна возвращать количество (целое число) записанных в строку вещественных чисел.

В функции main вызвать функцию to_csv для вещественных чисел, прочитанных из входного потока и вывести в консоль сформированную строку.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/6.4.4

```c
#include <stdio.h>
#include <string.h>

#define NUMBERS 20
#define STR_LEN 100

int to_csv(char *str, unsigned int str_len, const double *ar, const int ar_len) {
    int res = 0;
    strcpy(str, "csv:");
    for (int i = 0; i < ar_len; i++) {
        char buff[8];
        sprintf(buff, " %.2lf%s", ar[i], i == ar_len - 1 ? "" : ";");
        strcat(str, buff);
        res++;
    }
    if (strlen(str) < str_len) str[strlen(str)] = '\0';

    return res;
}

int main(void) {
    double ar[NUMBERS] = {0};
    int count = 0;
    char str[STR_LEN];

    for (int i = 0; i < NUMBERS; i++) {
        if (scanf("%lf", &ar[i]) == 1)
            count++;
        else
            break;
    }

    const double *ar_ptr = ar;
    char *str_ptr = str;
    to_csv(str_ptr, STR_LEN, ar_ptr, count);

    printf("%s", str);

    return 0;
}
```

### Подвиг 5. Допишите программу. Объявите функцию с именем get_data_csv со следующими параметрами (порядок параметров должен соблюдаться):
+ массив вещественных чисел (double);
+ максимальная длина массива (неотрицательное целое число);
+ указатель на корректную Си-строку.

Функция get_data_csv должна из переданной ей строки выделять и сохранять в переданный массив вещественные числа, которые записаны в формате:

"csv: <число 1>; <число 2>; ...; <число N>"

Например:

"csv: 0.56; -65.43; 0.1; 11.0"

Необходимо выделенные числа сохранять в переданном массиве в количестве не превышающем длину массива 20 элементов. Функция get_data_csv должна возвращать количество (целое число) записанных в массив вещественных чисел.

В функции main вызвать функцию get_data_csv для строки str и вывести в консоль выделенные в массив вещественные числа в одну строчку через пробел с точностью до сотых.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/6.4.5

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define NUMBERS 20

int get_data_csv(double ar[], int len, char* str) {
    int count = 0;
    while (strpbrk(str, ":;")) {
        str = strpbrk(str, ":;");
        ar[count++] = atof(++str);
        if (count == len - 1) return len;
    }
    return count;
}

int main(void) {
    char str[100] = {0};
    fgets(str, sizeof(str) - 1, stdin);
    char* ptr_n = strrchr(str, '\n');
    if (ptr_n != NULL) *ptr_n = '\0';
    ptr_n = str;
    double ar[NUMBERS];

    int result = get_data_csv(ar, NUMBERS, ptr_n);

    for (int i = 0; i < result; i++) {
        printf("%.2lf ", ar[i]);
    }

    return 0;
}
```

### Подвиг 6. Продолжите программу. Необходимо объявить функцию с именем transpose, которой передается двумерный массив размером SIZE x SIZE из чисел типа short. Функция transpose должна строки заменять на соответствующие столбцы (транспонирование) переданного массива. В функции main вызовите функцию transpose для массива matrix. Выведите полученный транспонированный массив matrix в консоль в виде таблицы целых чисел SIZE x SIZE элементов.

(Обратите внимание, что между числами в строках должен быть один пробел, а в конце строк - ни одного.) 

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/6.4.6

```c
#include <stdio.h>

#define SIZE 4

void transpose(short (*matrix)[SIZE]);
void print_matrix(short (*matrix)[SIZE]);
void copy_matrix(short (*copy)[SIZE], short (*matrix)[SIZE]);

int main(void) {
    short matrix[SIZE][SIZE] = {0};
    short* ptr = &matrix[0][0];
    int count = 0;
    while (count < SIZE * SIZE && scanf("%hd", ptr) == 1) {
        ptr++;
        count++;
    }

    transpose(matrix);
    print_matrix(matrix);

    return 0;
}

void transpose(short (*matrix)[SIZE]) {
    short copy[SIZE][SIZE];

    copy_matrix(copy, matrix);

    for (int i = 0; i < SIZE; i++) {
        for (int j = 0; j < SIZE; j++) {
            matrix[j][i] = copy[i][j];
        }
    }
}

void copy_matrix(short (*copy)[SIZE], short (*matrix)[SIZE]) {
    short* matrix_ptr = &matrix[0][0];
    short* copy_ptr = &copy[0][0];
    int count = 0;
    while (count < SIZE * SIZE) {
        *copy_ptr++ = *matrix_ptr++;
        count++;
    }
}

void print_matrix(short (*matrix)[SIZE]) {
    for (int i = 0; i < SIZE; i++) {
        for (int j = 0; j < SIZE; j++) {
            printf("%d%s", matrix[i][j], j == SIZE - 1 ? "\n" : " ");
        }
    }
}
```

### Подвиг 7. Продолжите программу. Объявите функцию с именем show_pole, которой передается двумерный массив типа char размером SIZE x SIZE элементов. Она должна отобразить в консоли этот двумерный массив в виде таблицы размером SIZE x SIZE по следующей схеме:
* * *
* * *
* * *
То есть, в три строки и три столбца. Причем, между символами в строках должен быть один пробел. В конце строк пробела быть не должно.

Вместо символа '*'' необходимо вывести символ, который хранится в элементах переданного массива, либо символ '#', если значение элемента равно 0 (целое число).

В функции main вызывать функцию show_pole для массива pole.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/6.4.7

```c
#include <stdio.h>

#define SIZE 3

void print_matrix(char (*matrix)[SIZE]);

int main(void) {
    char pole[SIZE][SIZE] = {0};
    char* ptr_p = &pole[0][0];
    int count = 0;
    while (count < SIZE * SIZE && scanf("%d", ptr_p) == 1) {
        *ptr_p = (*ptr_p == 1) ? 'x' : (*ptr_p == 2) ? 'o' : *ptr_p;
        ptr_p++;
        count++;
    }

    print_matrix(pole);

    return 0;
}

void print_matrix(char (*matrix)[SIZE]) {
    for (int i = 0; i < SIZE; i++) {
        for (int j = 0; j < SIZE; j++) {
            char ch = matrix[i][j] == 0 ? '#' : matrix[i][j];
            printf("%c%s", ch, j == SIZE - 1 ? "\n" : " ");
        }
    }
}
```

### Подвиг 8. Продолжите программу. Объявите функцию с именем is_win, которой передается двумерный массив типа char размером SIZE x SIZE элементов. Функция is_win должна проверять и возвращать статус переданного игрового поля игры "Крестики-нолики" в виде целого числа:

0 - игра не окончена;
1 - выиграли "крестики";
2 - выиграли "нолики";
3 - ничья.

Каждый элемент переданного двумерного массива хранит либо символ 'x', либо символ 'o', либо целое число 0, если клетка свободна.

В функции main вызовите функцию is_win для массива pole. Выведите в консоль вычисленный статус игрового поля в виде целого числа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/6.4.8

```c
#include <stdio.h>

#define SIZE 3

int is_win(char (*matrix)[SIZE]);
int ch_to_int(char ch);

int main(void) {
    char pole[SIZE][SIZE] = {0};
    char* ptr_p = &pole[0][0];
    int count = 0;
    while (count < SIZE * SIZE && scanf("%d", ptr_p) == 1) {
        *ptr_p = (*ptr_p == 1) ? 'x' : (*ptr_p == 2) ? 'o' : *ptr_p;
        ptr_p++;
        count++;
    }

    int result = is_win(pole);

    printf("%d", result);

    return 0;
}

int ch_to_int(char ch) {
    if (ch == 'x') return 1;
    if (ch == 'o') return 2;
    return 0;
}

int is_win(char (*matrix)[SIZE]) {
    // проверим строки
    for (int i = 0; i < SIZE; i++) {
        int row_count = 0;
        int nulls = 1;
        for (int j = 0; j < SIZE; j++) {
            if (matrix[i][j] == 0) {
                nulls = 0;
                break;
            }
            row_count += ch_to_int(matrix[i][j]);
        }
        if (nulls && row_count == 3) return 1;
        if (nulls && row_count == 6) return 2;
    }

    // проверим столбцы
    for (int i = 0; i < SIZE; i++) {
        int cell_count = 0;
        int nulls = 1;
        for (int j = 0; j < SIZE; j++) {
            if (matrix[j][i] == 0) {
                nulls = 0;
                break;
            }
            cell_count += ch_to_int(matrix[j][i]);
        }
        if (nulls && cell_count == 3) return 1;
        if (nulls && cell_count == 6) return 2;
    }

    // проверим диагонали
    int diag1_sum = 0;
    int diag2_sum = 0;
    int nulls = 1;
    for (int i = 0; i < SIZE; i++) {
        if (matrix[i][i] == 0) {
            nulls = 0;
            break;
        }
        diag1_sum += ch_to_int(matrix[i][i]);
        diag2_sum += ch_to_int(matrix[i][SIZE - i - 1]);
    }
    if (nulls && diag1_sum == 3) return 1;
    if (nulls && diag2_sum == 3) return 1;
    if (nulls && diag1_sum == 6) return 2;
    if (nulls && diag2_sum == 6) return 2;

    // проверим нули
    for (int i = 0; i < SIZE; i++) {
        for (int j = 0; j < SIZE; j++) {
            if (matrix[i][j] == 0) {
                return 0;
            }
        }
    }
    return 3;
}
```

### Подвиг 9 (на повторение). Установите соответствия между строковыми функциями и их описаниями.

![06](/Good_good_C_C++/img/06_05.PNG)

### Подвиг 10 (на повторение). Установите соответствия между названиями функций работы со строками и их описаниями.

![06](/Good_good_C_C++/img/06_06.PNG)

# 6.5 Указатели на функцию. Функция как параметр (callback)

