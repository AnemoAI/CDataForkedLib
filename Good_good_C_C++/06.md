# 6  Функции

# 6.1 Объявление и вызов функций

## Объявление и вызов функций

Мы начинаем большую и ключевую тему языка Си, посвященную функциям. До сих пор у нас в программах объявлялась только одна функция с именем `main`, из которой вызывались другие стандартные функции:

```c
#include <stdio.h>

int main(void) {
    int x;
    if (scanf("%d", &x) == 1)
        puts("Correct input!");
    else
        puts("Incorrect input!");

    return 0;
}
```

Спрашивается, что же такое функции и зачем они нужны? 

Вы уже знаете, что функция выполняет набор операторов, заключенных в ней. 

Благодаря этому в них можно выносить многократно повторяющиеся фрагменты кода, и, затем, вызывать функции в нужных местах программы. 

Например, код вывода строк в стандартный поток целесообразно вынести в отдельную функцию, т.к. эта операция довольно часто повторяется. В нашем примере, как раз, фигурирует два вызова функции `puts()`. В результате исключается дублирование кода, который в программировании кратко называется:

```
DRY – Don’t Repeat Yourself
```

Вообще, как только в программе появляется повторение (дублирование) кода, то, скорее всего, архитектура и структура программы выстроена неверно и ее следует пересмотреть. 

Дублирование – это очень грубая ошибка при проектировании программ. И функции, как раз, один из самых действенных методов этого избежать. В результате программа становится более модульной, проще воспринимается и редактируется.

## Объявление и вызов функций

Конечно, стандартных функций, поставляемых с компилятором языка Си, недостаточно. Они покрывают лишь базовые потребности. Но мы легко можем объявить свои собственные и использовать их в своих программах. Общий синтаксис объявления функции имеет следующий вид:

```
<тип данных> <имя функции>([набор параметров])
{
        оператор_1;
        ...
        оператор_N;
}
```

Здесь первая строчка соответствует заголовку функции, а операторные фигурные скобки – телу функции. Тип данных перед именем функции определяет возвращаемый функцией тип значений. В самом простом случае это могут быть базовые типы:

```c
int, char, double, short, ...
```

Если же функция ничего не возвращает, то перед ней прописывается тип:

```c
void
```

Имя функции придумывается самим программистом, подобно именам переменных. Но, если переменные, как правило, определяются существительными, то имена функций рекомендуется задавать глаголами, так как они связаны с определенными действиями. Например:

```c
get_coord, show_x, is_digit, и т.п.
```

После имени функции обязательно должны идти круглые скобки, в которых могут быть указаны параметры функции. 

Что такое параметры и зачем они нужны, мы подробнее разберем позже. 

А здесь отмечу, что если функция не принимает никаких параметров, то принято при ее объявлении в круглых скобках прописывать ключевое слово `void`. Тем самым мы подчеркиваем факт отсутствия параметров.

После определения заголовка функции, с новой строки записывается открывающаяся фигурная скобка. 

Обратите внимание, с новой строки, а не на текущей! 

Это общепринятая запись оформления функций на языке Си. 

Фигурные скобки тела функции пишутся в отдельных строчках. 

Почему так? 

Потому что заголовок функции – это отдельная синтаксическая конструкция, которая может быть определена без тела функции. 

Об этом мы с вами еще будем говорить.

Давайте в качестве примера объявим функцию, которая выводит приветственное сообщение:

```c
#include <stdio.h>

void print_hi(void) { 
    puts("Hello! I'm Sergey Balakirev!"); 
}

int main(void) {
    return 0; 
}
```

Здесь имя функции `print_hi` мы придумываем сами, возвращаемый тип `void`, т.к. функция ничего не возвращает. В качестве аргументов также указано ключевое слово `void`. Это простейший пример объявления функции в программе.

Обратите внимание, функция `print_hi()` объявлена до функции `main()`, после директив (если они присутствуют) и вне каких-либо других функций. 

То есть, прежде чем использовать какую-либо функцию, она должна быть прежде объявлена. Также как и с переменными: мы можем их использовать только после объявления.

Итак, если сейчас запустить программу, то никакого вывода на экран не увидим. 

Почему? 

Потому что функция всего лишь объявлена, но нигде не была вызвана (не запущена). Давайте сделаем вызов нашей функции в `main()` следующим образом:

```c
int main(void) {
    print_hi();
    return 0;
}
```

Обратите внимание на круглые скобки после имени функции `print_hi`. Это операция вызова функции. Если их убрать, то программа выполнится, но функция `print_hi()` запущена не будет. Круглые скобки строго обязательны для запуска функции.

Если прописать еще два вызова этой же функции:

```c
int main(void) {
    print_hi();
    print_hi();
    print_hi();
    return 0;
}
```

то при выполнении программы увидим три строчки приветствия:

```
Hello! I'm Sergey Balakirev!
Hello! I'm Sergey Balakirev!
Hello! I'm Sergey Balakirev!
```

Этот пример показывает, что мы можем многократно вызывать функции в любом месте программы и выполнять операторы, записанные в теле вызываемой функции.


## Объявление и вызов функций с параметрами
Приведенная функция `print_hi()`, по большому счету, бесполезна. Она не дает нам ничего существенно нового. И это не удивительно, так как она ничего не принимает и ничего не возвращает. Давайте усложним пример и объявим функцию для вычисления периметра прямоугольника. Что нам для этого нужно? Очевидно, функция должна иметь информацию о длине и ширине прямоугольника, иначе периметр не вычислить. И, кроме того, должна вернуть вычисленное значение, чтобы мы его могли использовать дальше по программе.

![06](/Good_good_C_C++/img/06_01.png)

Пусть функция называется `get_per`, а ширина и длина прямоугольника определяются целочисленными переменными:

```c
int width, int height
```

Тогда объявить эту функцию можно следующим образом:

```c
int get_per(int width, int height) {
    int p = 2 * (width + height);
    return p;
}
```

Обратите внимание, параметры функции записываются как переменные через запятую. Собственно, это и есть обычные переменные. Причем, перед каждым параметром обязательно нужно указывать тип данных, даже при одинаковых типах. Объявление вида:

```c
int get_per(int width, height)       // ошибка
```

будет неверным. Хотя, при объявлении нескольких целочисленных переменных в теле функции мы можем использовать такой синтаксис. Но не при описании параметров.

Возвращаемый тип здесь также указан как `int`, так как функция возвращает целочисленное значение периметра прямоугольника. 

Сам периметр вычисляется в теле функции и сохраняется во временную переменную `p`. Затем, с помощью оператора `return` мы указываем, что именно будет возвращать данная функция. Так как нужно вернуть периметр, то записываем переменную `p` после ключевого слова `return`.

Кстати, тело функции в данном случае можно было бы записать в одну строчку, не создавая промежуточную переменную `p`:

```c
int get_per(int width, int height) {
    return 2 * (width + height);
}
```

Результат будет абсолютно таким же. Мало того, современные компиляторы обе функции преобразуют в машинные коды одинаковым образом. Поэтому какой вид записи использовать, решать только вам. Главное, чтобы программа была понятной для восприятия.

Забегая вперед отмечу, что все обычные параметры и переменные, объявленные внутри функции, создаются в момент вызова этой функции и исчезают при ее завершении. 

То есть, параметры `width`, `height` и переменная p доступны только внутри функции `get_per()` и не существуют за ее пределами. Более подробно мы с вами об этом еще будем говорить.

Давайте теперь посмотрим, на способы вызова функции `get_per()`:

```c
int main(void) {
    int w = 2, h = 5;

    get_per(w, h);
    int per_1 = get_per(w + 1, h - 4);
    int per_2 = get_per(w, 3);
    int per_3 = get_per(1, 3);

    return 0;
}
```

Смотрите, в первом случае мы вызвали `get_per(w, h)` и не сохраняли возвращаемое ею значение. 

Так вполне можно делать, если не важно, что именно при вызове вернет функция. 

В этом случае говорят, что функция была вызвана ради побочного эффекта. 

То есть, не ради того, чтобы получить возвращаемое значение, а только ради выполнения операторов тела функции. Например, так часто поступают при вызове функции `printf()`:

```c
printf("get_per\n");
```

Она возвращает число байт, помещенных в выходной поток `stdout`, но нас это значение не интересует, так как обычно с выводом данных проблем не возникает.

Если же возвращаемое значение важно, то его можно сохранить с помощью операции присваивания в переменной соответствующего типа.

Далее, при каждом вызове функции `get_per()` в круглых скобках указываются значения, которые ей передаются. 

Эти значения называются аргументами и их должно быть ровно столько, сколько прописано параметров при объявлении функции. 

Каждое переданное значение копируется в соответствующий параметр: первый аргумент копируется в параметр `width`, а второй – в параметр `height`.

Обратите внимание, данные именно копируются, то есть, создается их копия в переменных функции `width` и `height`. 

Соответственно, при первом вызове `get_per()` в параметры `width` и `height` записываются значения `2` и `5`; при втором – значения `2+1 = 3` и `5-4 = 1`; при третьем – `2` и `3`; при четвертом – `1` и `3`.

Если в момент вызова функции `get_per()` указать неверное число аргументов, например:

```c
int per_3 = get_per(1);
```

то при компиляции возникнет ошибка. Число аргументов в нашем примере должно совпадать с числом параметров функции.

На этом мы завершим наше первое знакомство с функциями. Из этого занятия вы должны хорошо себе представлять, как объявляются и вызываются функции.

Видео по теме [#40. Объявление и вызов функций](https://www.youtube.com/watch?v=nlVj5rOtLVw&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, касающиеся объявления и использования функций языка Си.

+ [x] функция может быть вызвана в любом (допустимом) месте программы произвольное число раз
+ [x] оператор вызова функции - это круглые скобки, стоящие после ее имени
+ [x] в качестве имен функций следует использовать глаголы
+ [x] объявление функций выполняется согласно синтаксису: <тип данных> <имя функции>([набор параметров]) {[операторы тела функции]}
+ [x] перед каждым параметром функции обязательно указывать его тип данных
+ [x] если функция не возвращает никаких значений, то у нее прописывается тип void
+ [ ] если функция не возвращает никаких значений, то тип данных у нее не прописывается
+ [x] часто в функции выносят многократно повторяющиеся (используемые) фрагменты программного кода

## Подвиг 2. В программе ниже объявите функцию с именем show_info без параметров и без возвращаемого значения. Функция show_info должна выводить в консоль строку (без кавычек и с символом переноса на следующую строку):

"It's my first function"

В функции main вызовите функцию show_info.

```c
#include <stdio.h>

void show_info(void) { puts("It's my first function"); }

int main(void) {
    show_info();

    return 0;
}
```

### Подвиг 3. В программе ниже объявите функцию с именем fact, которая вычисляет факториал, переданного ей целого числа, и возвращает вычисленное значение. Напомню, что факториал любого целого положительного числа n вычисляется по формуле:

$n!=1⋅2⋅...⋅n$

Если n = 0, то по правилам математики 0! = 1. Для отрицательных чисел функция fact должна возвращать число -1.

Вызовите в функции main функцию fact для вычисления факториала числа 6 и выведите результат в консоль в виде целого числа.

```c
#include <stdio.h>

int fact(int n) {
    if (n < 0) return -1;
    int res = 1;
    for (int i = 1; i <= n; i++) {
        res *= i;
    }
    return res;
}

int main(void) {
    int res = fact(6);
    printf("%d", res);
    return 0;
}
```

### Подвиг 4. В программе ниже объявите функцию с именем pow_n, которая принимает два целочисленных значения n, m (m >= 0) и вычисляет 

$n^m$. Напомню, что любое число в степени 0 равно 1. 

Вычисленное значение возвращается функцией. 

Вызовите в функции main функцию pow_n с аргументами 2 и 4. 

Выведите результат в консоль в виде целого числа.

```c
#include <stdio.h>

int pow_n(int n, int m) {
    int res = 1;

    for (int i = 1; i <= m; i++) {
        res *= n;
    }
    return res;
}

int main(void) {
    int res = pow_n(2, 4);
    printf("%d", res);
    return 0;
}
```

### Подвиг 5. В программе ниже объявите функцию с именем get_volume, которая принимает три целочисленных значения h, w, d и вычисляет объем h * w * d. Вычисленное значение возвращается функцией. Прочитайте из входного потока три целых числа, записанных в одну строчку через пробел в переменные height, width, depth. Вызовите в функции main функцию get_volume с аргументами height, width, depth. Результат сохраните в переменной и выведите ее значение в консоль как одно целое число.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/6.1.5

```c
#include <stdio.h>

int get_volume(int h, int w, int d) {
    int res = h * w * d;
    return res;
}

int main(void) {
    int height, width, depth;
    scanf("%d %d %d", &height, &width, &depth);
    int res = get_volume(height, width, depth);
    printf("%d", res);
    return 0;
}
```

### Подвиг 6. В программе ниже объявите функцию с именем is_triangle, которая принимает три целочисленных значения a, b, c и определяет, могут ли длины a, b, c образовывать стороны треугольника. Функция возвращает 1, если a, b, c могут быть длинами треугольника, и 0 - в противном случае. Прочитайте из входного потока три целых числа, записанных в одну строчку через пробел в переменные a, b, c. Вызовите в функции main функцию is_triangle с аргументами a, b, c. Результат сохраните в переменной и выведите ее значение в консоль как одно целое число.

Напомню, что числа a, b, c могут образовывать длины сторон треугольника, если каждое из них меньше суммы двух остальных.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/6.1.6

```c
#include <stdio.h>

int is_triangle(int a, int b, int c) {
    int res = (a < b + c) * (b < a + c) * (c < a + b);
    return res;
}

int main(void) {
    int a, b, c;
    scanf("%d %d %d", &a, &b, &c);
    int res = is_triangle(a, b, c);
    printf("%d", res);
    return 0;
}
```

### Подвиг 7 (на повторение). Выберите все верные варианты объявления указателей.

+ [x] double* a;
+ [ ] int* u, v, c; // u, v, c - указатели
+ [ ] unsigned * char ptr_byte;
+ [x] float *a, *b, *c; // a, b, c - указатели
+ [ ] unsigned * short ptr_hd;
+ [x] long * ptr_var;

### Подвиг 8 (на повторение). Пусть в программе объявлены следующие переменные и указатели:

```c
int a = 5, b = 7;
double d = 2.0;
int* ptr_a = &a, *ptr_b = &b;
```

Выберите все верные (рабочие) варианты изменения значения адреса указателей `ptr_a` и `ptr_b`.

+ [x] ptr_b - ptr_a;
+ [x] ptr_a += 3;
+ [ ] ptr_b -= ptr_a;
+ [ ] ptr_a -= d;
+ [ ] ptr_a *= a;
+ [ ] ptr_b + ptr_a;
+ [ ] ptr_b += ptr_a;
+ [x] ptr_b++;
+ [ ] ptr_a /= b;
+ [x] ptr_a += b * 5;
+ [x] --ptr_a;

# 6.2 Оператор return. Вызов функций в аргументах

## Оператор return.

На этом занятии подробнее ознакомимся с работой оператора `return`.

Давайте предположим, что нам нужно объявить функцию, которая бы вычисляла корень четвертой степени от переданного значения `x`. Ее можно записать и вызвать следующим образом:

```c
#include <math.h>
#include <stdio.h>

double sq4_x(double x) {
    double res = (x < 0) ? NAN : pow(x, 0.25);
    return res;
}

int main(void) {
    printf("%f\n", sq4_x(16));
    return 0;
}
```
Функция `sq4_x()` имеет возвращаемый тип `double` и один параметр этого же типа. Затем, во временную переменную `res` заносится значение `nan` (сокращение от `Not a Number` – не число) если переменная `x` меньше нуля, а иначе корень четвертой степени. Далее, записан оператор `return` с указанием возвращаемого значения – переменной `res`. Ниже, в функции `main()`, вызывается функция `sq4_x()` с аргументом `16` и значение выводится на экран. После запуска программы увидим результат:

```
2.000000
```

Очевидно, это число `2.0` было возвращено функцией `sq4_x()` благодаря оператору `return`. Если этот оператор убрать, то функция будет возвращать неопределенные значения. Однако в современных стандартах языка Си/С++ оператор `return` строго обязателен, если тип функции отличен от `void`. Поэтому следует придерживаться правила: если функция возвращает какой-либо определенный тип данных (не `void`), то в ней следует прописывать оператор `return`.

В действительности, этот оператор делает две вещи:
+ собственно, возвращает указанные значения;
+ и завершает выполнение функции. 

Вот этот второй момент не следует упускать из виду. Например, если после оператора `return` прописать еще какой-либо оператор, например:

```c
double sq4_x(double x) {
    double res = (x < 0) ? NAN : pow(x, 0.25);
    return res;
    puts("sq4_x");
}
```

то он выполнен не будет, так как выполнение функции завершится на операторе `return`.

Это свойство часто используют для досрочного завершения функций. Например, в нашем примере, мы это могли бы использовать так:

```c
double sq4_x(double x) {
    if (x < 0) return NAN;

    return pow(x, 0.25);
}
```

Вначале проверяем, если `x` меньше нуля, то сразу завершаем выполнение функции с возвращением специального значения `nan`. Иначе, при ложности условия, выполнение тела функции дойдет до второго оператора `return` и будет вычислен корень четвертой степени.

## Оператор return в функции типа void

Если при объявлении функции возвращаемый тип указан как `void`, то оператор `return` в ней прописывать не обязательно. Например, функция, которая выводит на экран значение переданной переменной, если она четная:

```c
void print_even_x(int x) {
    if (x % 2 == 0) printf("x = %d\n", x);
}
```
Здесь нет никакого оператора `return`. Функция просто выводит значение для четных чисел. Ниже в функции `main()` мы можем ее вызвать следующим образом:

```c
int main(void) {
    printf("%f\n", sq4_x(-16));
    print_even_x(4);

    return 0;
}
```
Программа скомпилируется и успешно запустится. Однако эту же функцию `print_even_x()` можно записать и с оператором `return`, например, так:

```c
void print_even_x(int x) {
    if (x % 2 != 0) return;

    printf("x = %d\n", x);
}
```

Он будет срабатывать при нечетных x и, соответственно, досрочно завершать выполнение функции. Обратите внимание, после `return` сразу ставится точка с запятой без указания возвращаемого значения. Когда функция имеет тип `void`, она ничего не возвращает, а значит, после оператора `return` не нужно ничего прописывать.

## Функции, как отдельные, независимые модули программы

Вообще, правильно раскладывать программу на наборы функций – это, в некотором смысле, искусство – искусство программирования. 

На первых порах начинающие кодеры суют в функции все подряд. В результате, они получаются громоздкими, корявыми, неудобными для дальнейшего применения. 

Чтобы избежать такой участи, следует на начальных этапах придерживаться нескольких простых правил:
+ функции следует выполнять только свою узко поставленную задачу;
+ для решения поставленной задачи, функции следует использовать только переданные ей параметры;
+ если тело функции становится слишком большим – это повод задуматься над правильностью организации логики программы; возможно, подзадачу следует раздробить на более мелкие подзадачи;
+ в 99% случаях функции ничего не считывают с клавиатуры (из потока `stdin`) и ничего не выводят на экран (в поток `stdout`); если ваша функция делает это, убедитесь, что это действительно необходимо.

## Вызов функций в аргументах

Давайте я покажу на конкретном примере красоту решения задачи с использованием функций. Предположим, перед нами ставится задача объявления функций для поиска минимального числового значения из двух и из трех возможных. Вначале определим функцию для нахождения минимального среди двух значений, например, так:

```c
double min_2(double a, double b) {
    return (a < b) ? a : b;
}
```

А, затем, на основе этой функции, определим вторую – для нахождения минимального среди трех чисел:

```c
double min_3(double a, double b, double c) {
    double min_ab = min_2(a, b);
    return (min_ab < c) ? min_ab : c;
}
```

Видите, как красиво можно подойти к решению этой задачи, если действовать не в лоб, а разбивать задачу на более простые, а потом, объединять их, получая конечный, более сложный результат.

Давайте теперь посмотрим, как можно использовать эти функции:

```c
int main(void) {
    int x = 1, y = -2, z = 10;

    double res_1 = min_2(x, y);
    double res_2 = min_3(x, y, z);
    double res_3 = min_2(min_2(x, y), z);
    double res_4 = min_2(x, min_2(y, z));

    printf("res_1 = %.2f, res_2 = %.2f, res_3 = %.2f, res_4 = %.2f\n", res_1, res_2, res_3, res_4);

    return 0;
}
```

Первые два вызова очевидны, мы просто передаем значения и получаем минимальное из них. А во вторых двух вызовах в качестве аргумента записан еще один вызов функции `min_2()`. Так тоже вполне можно делать. В результате, сначала отработает функция `min_2(x, y)`, будет получено минимальное среди этих двух значений, а затем, оно передается как аргумент первой функции `min_2()`. В итоге, с помощью `min_2()` мы находим минимальное для трех чисел. По аналогии отрабатывает и следующая строчка программы.

Как вы понимаете, мы можем пойти еще дальше и использовать функции `min_2()` и `min_3()` следующим образом:

```c
double r4 = min_2(min_2(-2, 3), min_2(x, y));
double r5 = min_2(min_2(-2, 3), min_3(x, y, z));
```

В итоге получим минимальное среди четырех и пяти чисел. Видите, какое многообразие решений дают эти две функции, при условии их правильного проектирования. 

Но здесь возникает вопрос, в каком порядке будут вызваны функции, записанные в аргументах? Например, при нахождении минимального среди пяти чисел, что будет вызвано вначале `min_2()` или `min_3()`? 

В действительности, стандартом языка Си этот момент не определен. 

Поэтому разные компиляторы могут транслировать программу так, что сначала `min_3()` вызовется, а затем, `min_2()`, или наоборот. 

Гарантии никакой нет. Однако точно можно сказать, что вначале отрабатывают функции, стоящие в аргументах, и только после этого основная функция. В этом мы можем быть уверены.

На первый взгляд может показаться, что нет особой разницы, в каком порядке срабатывают функции в аргументах. Но это не всегда так. Пусть, например, мы задумали использовать операцию инкремента при вызове функции `min_2()`:

```c
double res_1 = min_2(++x, x);
printf("res_1 = %.2f\n", res_1);
```

И думаем, ага, вначале отработает первый аргумент и переменная x увеличится на 1, а затем, второй. В результате, минимальное будет равно 2. Но после запуска программы видим другое значение 1. А вот если в моем случае записать инкремент у второго аргумента:

```c
double res_1 = min_2(x, ++x);
```

то получаем значение 2. То есть, порядок иногда имеет значение, но, так как мы его не знаем, то полагаться на подобные конструкции не стоит. Можно использовать инкремент или декремент, только если такая же переменная не стоит в других аргументах, например, так:

```c
double res_1 = min_2(y, ++x);
```

В этом случае порядок для нас не важен. И, обратите внимание, операция инкремента у переменной `x` записана в префиксной форме. Почему именно так? 

Очевидно, в этом случае значение второго параметра b функции `min_2()` будет принимать значение:

```c
b = ++x;
```

То есть, значение `x` будет увеличено на `1` и только после этого присвоено переменной `b`. Если же при вызове функции `min_2()` использовать постфиксную форму записи:

```c
double res_1 = min_2(y, x++);
```

то это будет эквивалентно присваиванию:

```
b = x++;
```

Соответственно, значение параметра `b` будет равно прежнему значению `x` без увеличения на единицу. Вот этот момент нужно хорошо себе представлять.

Видео по теме [#41. Оператор return. Вызов функций в аргументах](https://www.youtube.com/watch?v=63eFhyLVTBk&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, касающиеся функций языка Си.

+ [x] оператор return завершает текущее выполнение функции
+ [x] оператор return обязателен, если тип функции отличен от void
+ [x] вызов одной функции можно прописывать в аргументах при вызове другой функции
+ [x] для решения поставленной задачи, функции следует использовать только переданные ей параметры
+ [x] большинство функций ничего не считывают с клавиатуры (из потока stdin) и ничего не выводят на экран (в поток stdout)
+ [x] оператор return определяет возвращаемое функцией значение
+ [x] функции должны выполнять строго поставленную задачу и ничего более

### Подвиг 2. Выберите все верные утверждения, касающиеся следующего фрагмента программы.

```c
int get_square(int x) { return x * x; }

int main(void) {
    int a = 7, b = 7, c = 7;
    int res_1 = get_square(a);
    int res_2 = get_square(b++);
    int res_3 = get_square(--c);

    return 0;
}
```

+ [x] переменная res_3 принимает значение 36
+ [ ] переменная res_2 принимает значение 64
+ [x] функция get_square возвращает квадрат переданного ей целого числа
+ [x] переменная res_2 принимает значение 49
+ [ ] переменная res_3 принимает значение 49
+ [x] переменная res_1 принимает значение 49

### Подвиг 3. Выберите все верные утверждения, касающиеся следующего фрагмента программы.

```c
int sum_two(int a, int b) { return a + b; }

int main(void) {
    int a = 3, b = 2;
    int res_1 = sum_two(++a, a);
    a = 3;
    b = 2;
    int res_2 = sum_two(++a, b);
    a = 3;
    b = 2;
    int res_3 = sum_two(a, b++);

    return 0;
}
```

+ [x] значение переменной res_2 равно 6
+ [ ] значение переменной res_1 равно 7
+ [ ] значение переменной res_2 равно 5
+ [x] значение переменной res_3 равно 5
+ [x] значение переменной res_1 неопределенно, т.к. в стандарте языка Си порядок вычисления аргументов функции не определен
+ [ ] значение переменной res_1 равно 8
+ [ ] значение переменной res_3 равно 6

### Подвиг 4. Напишите программу, которая читает из входного потока два целых числа, записанных в одну строчку через пробел, и вычисляет их среднее арифметическое с помощью функции get_mean2. Эта функция должна принимать два целых числа, а возвращать - вещественное число (среднее арифметическое). Вызовите функцию get_mean2 для прочитанных целых чисел и выведите результат ее работы в консоль в виде вещественного числа с точностью до десятых.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/6.2.4

```c
#include <stdio.h>

double get_mean2(int a, int b) {
    double result = (a + b) / 2.0;
    return result;
}

int main(void) {
    int a, b;

    scanf("%d %d", &a, &b);

    double res = get_mean2(a, b);

    printf("%.1lf", res);

    return 0;
}
```

### Подвиг 5. Напишите программу, которая читает из входного потока три целых числа, записанных в одну строчку через пробел, и вычисляет их сумму с помощью функции get_sum2. Эта функция должна принимать два целых числа, а возвращать - одно целое число (сумму от двух переданных чисел). Функцию get_sum2 необходимо вызвать (возможно несколько раз) для вычисления суммы трех прочитанных целых чисел. Выведите результат итогового вычисления в консоль в виде целого числа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/6.2.5

```c
#include <stdio.h>

int get_sum2(int a, int b) {
    int result = a + b;
    return result;
}

int main(void) {
    int a, b, c;

    scanf("%d %d %d", &a, &b, &c);

    int res = get_sum2(c, get_sum2(a, b));

    printf("%.d", res);

    return 0;
}
```

### Подвиг 6. Продолжите программу, которая последовательно читает из входного потока целые числа в переменную x. Необходимо объявить функцию с именем is_even, которая принимает целое значение и проверяет его на четность. Если число четное, то функция is_even возвращает 1, а иначе 0. В записанном цикле while вызовите функцию is_even для каждого прочитанного числа и выведите в консоль в одну строчку через пробел только четные числа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/6.2.6

```c
#include <stdio.h>

int is_even(int a) {
    int res = a % 2 ? 0 : 1;
    return res;
}

int main(void) {
    int x;
    while (scanf("%d", &x) == 1) {
        if (is_even(x)) {
            printf("%d ", x);
        }
    }
    return 0;
}
```

### Подвиг 7. Продолжите программу, которая последовательно читает из входного потока вещественные числа в переменную x. Необходимо объявить функцию с именем is_range со следующей сигнатурой:

```c
int is_range(double x, double a, double b);
```

Функция `is_range` должна проверять попадание числа `x` в диапазон `(a; b)` не включая границы (круглые скобки). 

Если `x` принадлежит диапазону `(a; b)`, то функция возвращает `1`, иначе `0`. В записанном цикле `while` вызовите функцию `is_range` для каждого прочитанного числа и выведите в консоль в одну строчку через пробел с точностью до десятых те числа, для которых функция `is_range` с границами `(-2.5; 3.5)` выдает ложное значение.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/6.2.7

```c
#include <stdio.h>
#define A -2.5
#define B 3.5

int is_range(double x, double a, double b) {
    int res = (x > a) * (x < b);
    return res;
}

int main(void) {
    double x;
    while (scanf("%lf", &x) == 1) {
        if (!is_range(x, A, B)) {
            printf("%.1lf ", x);
        }
    }
    return 0;
}
```

### Подвиг 8. Напишите программу, которая читает из входного потока два целых числа в переменные x, y, записанных в одну строчку через пробел. Объявите функцию с именем get_length, которая возвращает длину радиус-вектора с координатами (x, y).

Напомню, что длина радиус-вектора вычисляется по формуле:

$length= \sqrt{x^2 + y^2}$

В функции `main` вызовите функцию `get_length` с прочитанными значениями `x`, `y` и выведите в консоль длину радиус-вектора с точностью до сотых.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/6.2.8

```c
#include <math.h>
#include <stdio.h>

double get_length(double x, double y) {
    double res = sqrt(x * x + y * y);
    return res;
}

int main(void) {
    double x, y;
    if (scanf("%lf %lf", &x, &y) == 2) {
        double result = get_length(x, y);
        printf("%.2lf ", result);
    }
    return 0;
}
```

Подвиг 9. Известно, что среднее арифметическое от m чисел можно вычислять рекуррентно по формуле:

$Q_{m} = \dfrac{m - 1}{m} \cdot Q_{m−1} + \dfrac{1}{m} \cdot x$
​

где
+ $Q_{m−1}$ - среднее арифметическое от предыдущих `m-1` чисел;
+ `x` - новое `m`-е значение.

В программе ниже необходимо реализовать подсчет среднего арифметического читаемых целых чисел из входного потока. Для этого объявите функцию со следующей сигнатурой:

```c
double get_qm(double qm_1, int m, int x);
```

Функция `get_qm` должна вычислять очередное значение среднего арифметического для `m` прочитанных чисел и возвращать вычисленное значение `Qm`. В записанном цикле `while` с помощью функции `get_qm` вычислите среднее арифметическое всех прочитанных целых чисел из входного потока. Выведите результат вычисления в консоль в виде вещественного числа с точностью до тысячных.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/6.2.9

```c
#include <stdio.h>

double get_qm(double qm_1, int m, int x) {
    double res = ((m - 1) / (double)m) * qm_1 + (1 / (double)m) * x;
    return res;
}

int main(void) {
    int x;
    int m = 1;
    double result = 0;

    while (scanf("%d", &x) == 1) {
        result = get_qm(result, m++, x);
    }
    printf("%.3lf ", result);
    return 0;
}
```

### Подвиг 10 (на повторение). Выберите все верные утверждения, касающиеся массивов языка Си.

+ [ ] длина массива - это число байт, которые он занимает в памяти устройства
+ [x] длина массива - это максимальное число элементов (определенного типа), которые он хранит
+ [x] массивы можно объявлять по синтаксису: <тип элементов массива> <имя массива>[<число элементов массива>];
+ [x] массивы представляют собой непрерывную область памяти, в которой друг за другом размещены данные одного типа
+ [x] индекс массива - это целое число от 0 до length-1 (length - длина массива); служит для доступа к определенному элементу массива
+ [ ] индекс массива - это целое число от 1 до length (length - длина массива); служит для доступа к определенному элементу массива

### Подвиг 11 (на повторение). Выберите все верные утверждения, касающиеся инициализации массивов языка Си стандарта C99.

+ [x] если при инициализации указано меньше значений, чем длина массива, то оставшиеся элементы массива принимают произвольные значения
+ [x] операция инициализации массивов не влияет на скорость выполнения программы
+ [x] число значений в инициализаторе должно быть меньшее или равно длине массива
+ [x] при инициализации массивов в глобальной области можно использовать только выражения времени компиляции программы
+ [x] если при инициализации указано меньше значений, чем длина массива, то оставшиеся элементы массива принимают значение 0
+ [x] операция инициализации массивов увеличивает объем вычислений (при выполнении программы) и тем больше, чем длиннее массив
+ [x] при инициализации массивов в функции main() можно использовать переменные

# 6.3 Прототипы функций

На прошлых занятиях мы целиком задавали функции до основной функции `main()`. Однако довольно часто бывают ситуации, когда нужно лишь объявить заголовок функции, а ее реализацию определить позже или даже прописать в другом модуле программы. Например, пусть у нас имеется все та же функция вычисления периметра прямоугольника:

```c
#include <stdio.h>

double per_sq(double w, double h) {
    if (w < 0 || h < 0) return 0;

    return 2 * (w + h);
}

int main(void) {
    printf("per = %.2f\n", per_sq(2.5, 3.5));
    return 0;
}
```

Так вот, чтобы мы могли ее вызывать в функции `main()` достаточно прописать лишь заголовок этой функции, а реализацию указать позже. Например, так:

```c
#include <stdio.h>

double per_sq(double w, double h);

int main(void) {
    printf("per = %.2f\n", per_sq(2.5, 3.5));
    return 0;
}

double per_sq(double w, double h) {
    if (w < 0 || h < 0) return 0;

    return 2 * (w + h);
}
```

Программа по-прежнему компилируется и запускается. Такой заголовок еще называют прототипом функции. Для формирования объектного файла текущего модуля, то есть, для преобразования текста программы в машинный код, компилятору достаточно иметь описание заголовка функции. На основе этой информации он сможет сформировать корректный вызов функции в программе, а позже для этого вызова подставит адрес с телом вызываемой функции на этапе сборки всего проекта. В частности, это означает, что конкретную реализацию функции можно прописывать в любом другом модуле проекта, или даже выносить ее в заранее скомпилированные объектные файлы, которые, затем, следует указывать при линковке (сборке) проекта.

Давайте в этом убедимся. Создадим в рабочем каталоге еще один файл с именем `func.c` и пропишем в нем целиком функцию `per_sq()`:

```c
double per_sq(double w, double h) {
    if (w < 0 || h < 0) return 0;

    return 2 * (w + h);
}
```
А из файла с функцией `main()` реализацию функции `per_sq()` удалим. Если прямо сейчас попробовать скомпилировать программу, то получим ошибку на этапе линковки проекта, что отсутствует реализация для функции `per_sq()`.

Это из-за того, что второй файл `func.c` не был включен в проект для совместной компиляции его с основным файлом программы. Давайте его добавим. Для этого перейдем в настройки (файл `settings.json`) и для компиляции Си-программ явно пропишем два файла (`lessons.c`  и `func.c`):

```bash
gcc -std=c99 lessons.c func.c -o lessons
```

Теперь второй файл `func.c` также будет скомпилирован и реализация функции `per_sq()` будет взята из него.

Как видите, прототипы функций предоставляют нам удобный инструмент оформления программы в нескольких файлах. Этим очень часто пользуются на практике и, наверное, не существует ни одного серьезного проекта, который бы не включал в себя множество файлов с программой. Скорее, наоборот, использование одного файла – это исключение, чаще всего, при обучении.

Итак, мы с вами увидели, как можно объявлять заголовок (прототип) функции и узнали, где это используется. Отмечу лишь, что в прототипе имена переменных можно опускать, компилятор их все равно не учитывает:

```c
double per_sq(double, double);
```

Для него главная информация – это возвращаемый тип, имя функции и количество параметров с их типами. Больше ничего ему не нужно для формирования вызова функции на уровне машинных кодов.

## Прототипы функций в заголовочном файле
Полученный текст программы, описанный в двух модулях, имеет один существенный недостаток. Если модулей станет больше и определение функции в файле `func.c` изменится, то его придется менять во всех прототипах других модулей. Поэтому поступают следующим образом. Все общие прототипы выносятся в заголовочные файлы, например, в файл `func.h`:

```c
#ifndef __FUNC_H__
#define __FUNC_H__
 
double per_sq(double, double);
 
#endif
```

А в модулях, где используется функция `per_sq()` подключается этот файл с помощью директивы `#include:`

```c
#include <stdio.h>

#include "func.h"

int main(void) {
    printf("per = %.2f\n", per_sq(2.5, 3.5));
    return 0;
}
```

Теперь, при изменении сигнатуры функции ее достаточно будет изменить в заголовочном файле `func.h` и изменение автоматически коснется всех модулей, где этот файл подключается.

Обратите также внимание на оформление файла `func.h`. В нем прописаны директивы препроцессора `#ifndef`, `#define` и `#endif`. Они необходимы, чтобы при повторном подключении этого заголовочного файла в один и тот же модуль дважды не попадало содержимое этого файла. Подробно об этом мы с вами уже говорили, когда рассматривали условные директивы препроцессора.

Самих же прототипов различных функций в программе может быть сколько угодно. Например, в файле func.c можно объявить еще несколько функций:

```c
int abs_int(int x) {
    return (x < 0) ? -x : x;
}
 
int sq_to_int(double x) {
    return (int )(x * x);
}
```

Прописать их прототипы в файле `func.h`:

```c
#ifndef __FUNC_H__
#define __FUNC_H__
 
double per_sq(double, double);
int abs_int(int);
int sq_to_int(double);
 
#endif
```

И тогда все они станут доступны во всех модулях, где подключен файл `func.h`.

Видео по теме [#42. Прототипы функций](https://www.youtube.com/watch?v=PL3cPFvQNUk&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, касающиеся функций языка Си.

+ [ ] в заголовочных файлах, как правило, прописаны реализации функций (вместе с телом)
+ [x] прототип функции - это ее заголовок, например: int abs(int x);
+ [x] в заголовочных файлах, как правило, записаны прототипы функций
+ [x] прототипы удобны, когда нужно разделить объявление функции от ее реализации
+ [ ] прототип функции - это ее заголовок вместе с телом функции, например: int abs(int x) {...}
+ [x] для использования функции в программе достаточно объявить ее прототип

### Подвиг 2. Выберите правильную реализацию защиты от возможного множественного включения содержимого заголовочного файла в тексте программы.

A:
```c
#ifdef __MODULE_MATH_H__
#define __MODULE_MATH_H__
// подключаемое содержимое 
#endif
```

B: (Верное исполнение)
```c
#ifndef __MODULE_MATH_H__
#define __MODULE_MATH_H__
// подключаемое содержимое 
#endif
```

C:
```c
#if defined(__MODULE_MATH_H__)
#define __MODULE_MATH_H__
// подключаемое содержимое 
#endif
```

D:
```c
#define __MODULE_MATH_H__
#ifndef __MODULE_MATH_H__
// подключаемое содержимое 
#endif
```

__B__

### Подвиг 3. Продолжите программу. Перед функцией main объявите прототип функции с именем get_geom, которая принимает два целочисленных параметра, вычисляет их среднее геометрическое по формуле:

$g = \sqrt{a⋅b}$
​
и возвращает вычисленное значение `g`. Реализацию функции `get_geom` пропишите после функции `main`. В функции `main` вызовите функцию `get_geom` для переменных `a` и `b`. Вычисленное значение выведите в консоль в виде вещественного числа с точностью до сотых.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/6.3.3

```c
#include <math.h>
#include <stdio.h>

double get_geom(int a, int b);

int main(void) {
    int a, b;
    scanf("%d, %d", &a, &b);

    double result = get_geom(a, b);

    printf("%.2lf", result);

    return 0;
}

double get_geom(int a, int b) {
    double res = sqrt(a * b);
    return res;
}
```

### Подвиг 4. Продолжите программу. Перед функцией main объявите прототип функции с именем calc_rect, которая имеет три целочисленных параметра: w, h - ширина и длина прямоугольника; type - тип вычисления. Функция calc_rect должна вычислять и возвращать площадь прямоугольника со сторонами w, h, если type равен 1 и периметр - в противном случае. Возвращаемое значение должно быть целочисленным. 

Реализацию функции calc_rect пропишите после функции main. В функции main вызовите функцию calc_rect для переменных a,  b и t. Вычисленное значение выведите в консоль в виде целого числа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/6.3.4

```c
#include <stdio.h>

int calc_rect(int w, int h, int t);

int main(void) {
    int a, b, t;
    scanf("%d, %d, %d", &a, &b, &t);

    int result = calc_rect(a, b, t);

    printf("%d", result);

    return 0;
}

int calc_rect(int w, int h, int t) {
    int res;
    if (t == 1) {
        res = w * h;
    } else
        res = 2 * (w + h);
    return res;
}
```

### Подвиг 5. Продолжите программу. Перед функцией main объявите два прототипа функций:

get_max: для вычисления максимального из двух переданных целых чисел (возвращается целое число);
get_min: для вычисления минимального из двух переданных целых чисел (возвращается целое число).
Реализации функций пропишите после функции main. В функции main вызовите функцию get_max для переменных a и b, если значение переменной t равно 1. Иначе должна вызываться функция get_min для тех же переменных a и b. Выведите в консоль вычисленное значение в виде целого числа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/6.3.5

```c
#include <stdio.h>

int get_max(int a, int b);
int get_min(int a, int b);

int main(void) {
    int a, b, t;
    scanf("%d, %d, %d", &a, &b, &t);
    int result;
    if (t == 1)
        result = get_max(a, b);
    else
        result = get_min(a, b);

    printf("%d", result);

    return 0;
}

int get_max(int a, int b) {
    if (a > b)
        return a;
    else
        return b;
}

int get_min(int a, int b) {
    if (a > b)
        return b;
    else
        return a;
}
```

### Подвиг 6. Напишите программу, которая читает из входного потока радиус круга в виде вещественного числа. До функции main объявите прототип функции с именем circle_len, которая должна принимать радиус круга, вычислять его длину по формуле:

$L=2⋅π⋅R$

и возвращать вычисленное значение L. Значение π определить через директиву #define в виде макроопределения PI и взять равным 3.1415. Реализацию функции circle_len пропишите после функции main. В функции main вызовите функцию circle_len и выведите в консоль вычисленное значение длины круга в виде вещественного числа с точностью до сотых.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/6.3.6

```c
#include <stdio.h>
#define PI 3.1415

double circle_len(double radius);

int main(void) {
    double r;
    scanf("%lf", &r);

    double result = circle_len(r);

    printf("%.2lf", result);

    return 0;
}

double circle_len(double radius) {
    double res = radius * 2 * PI;
    return res;
}
```

### Подвиг 7 (на повторение). Выберите все верные варианты объявления строк.


+ [x] char s_1[] = {'B', 'a', 'l', 'a', 'k', 'i', 'r', 'e', 'v', '\0'};
+ [x] char s_3[] = "Balakirev";
+ [ ] char s_5[100] = {"Balakirev", 'S', 'e', 'r', 'g', 'e', 'i', '\0'};
+ [x] char s_2[20] = {'B', 'a', 'l', 'a', 'k', 'i', 'r', 'e', 'v', '\0'};
+ [ ] char s_7 = "Balakirev";
+ [x] const char* s_8 = "Balakirev";
+ [x] char s_4[100] = "Balakirev";
+ [x] char s_6[100] = "Sergey " "Balakirev";

### Подвиг 8 (на повторение). Установите соответствия между функциями и их описаниями.

![06](/Good_good_C_C++/img/06_02.PNG)

# 6.4 Указатели как параметры. Передача массивов в функции

## Указатели как параметры.

Это занятие начнем с рассмотрения указателей в качестве параметров функции.

До этого момента мы с вами объявляли и использовали указатели в рамках одной функции `main()` для изменения значений переменных. Например, так:

```c
#include <stdio.h>

int main(void) {
    short var_a = 10;
    short* ptr = &var_a;
    *ptr = 5;

    return 0;
}
```

Однако особого практического смысла от такой операции не было. Но теперь, когда мы имеем дело с функциями, указатели становятся одним из ключевых элементов. Давайте представим, что нам нужна функция, которая бы меняла значения между двумя переменными. Без указателей решение этой задачи было бы очень корявое. А вот с ними получаем вполне красивое решение:

```c
void swap_2(int* a, int* b) {
    int t = *a;
    *a = *b;
    *b = t;
}

int main(void) {
    int x = 5, y = 10;
    swap_2(&x, &y);

    return 0;
}
```

Как это работает? Вначале в функции `main()` выполняется вызов функции `swap_2()` с передачей адресов переменных `x` и `y`. В результате, указатель `*a` ссылается на переменную `x`, а указатель `*b` – на переменную `y`. Затем, в самой функции `swap_2()` происходит обмен значениями между указанными областями памяти, и, как следствие, меняются значения переменных `x` и `y`.

![06](/Good_good_C_C++/img/06_03.png)

Почему это решение можно считать красивым?
+ Во-первых, такая функция может менять значения между любыми целочисленными переменными типа `int`, где бы эти переменные ни были бы определены.<br>
Например, в приведенной программе, переменные `x` и `y` доступны только в пределах функции `main()` и недоступны (по их именам) за пределами этой функции. Поэтому напрямую получить к ним доступ в функции `swap_2()` не получится.<br>
Но через указатели это вполне можно сделать.
+ Во-вторых, использование указателей позволяет нам определять функции, которые могут менять и возвращать более одного значения. Как вы помните, после оператора `return` можно указывать только одно значение (выражение), которое будет возвращено функцией. Прописывать несколько нельзя. Поэтому с возвратом множества значений возникают определенные трудности, которые, хотя, можно преодолеть, например, с помощью структур, о которых мы с вами еще будем говорить. Однако через указатели решить задачу с возвратом множества значений все же куда проще.

## Передача массивов через параметры функции
Помимо изменения значений, указатели в параметрах используют с целью передачи массивов функциям. Как я ранее уже отмечал, в языке Си нет специального типа (структуры данных) для массивов. Их следует воспринимать, как непрерывную область памяти, в которой последовательно друг за другом расположены элементы массива:

```c
short ar[5];
```

![06](/Good_good_C_C++/img/06_04.png)

При этом имя массива `ar` можно воспринимать, как указатель на начало этой области. А раз так, то любой одномерный массив можно передать в функцию, используя указатели. Например, следующим образом:

```c
#include <stdio.h>

int sum_ar(const short* arr, int length) {
    int res = 0;
    for (int i = 0; i < length; ++i) res += arr[i];

    return res;
}

int main(void) {
    short ar[] = {1, 2, 3, 4, 5};
    int res = sum_ar(ar, sizeof(ar) / sizeof(*ar));

    printf("res = %d\n", res);

    return 0;
}
```

При вызове функции `sum_ar()` параметр `arr` будет ссылаться на первый элемент массива `ar`, а второй параметр `length` содержать число элементов массива. Затем, используя операцию квадратные скобки, мы через указатель `arr` перебираем элементы массива `ar` и подсчитываем их сумму, которая возвращается функцией `sum_ar()`. 

Ключевое слово `const` говорит о том, что значения массива внутри функции меняться не будут. 

Так принято делать, если данные по указателям только читаются и не меняются. 

Своего рода, правило хорошего тона при объявлении параметров-указателей.

Как видите, передать массив в функцию достаточно просто. 

Но здесь у вас может возникнуть вопрос, а зачем определять второй параметр `length`?

Разве нельзя вычислить размер массива непосредственно в функции `sum_ar()`? 

Увы, нет. 

Указатель `arr` – это уже обычный указатель на ячейки памяти, а не на массив, поэтому операция `sizeof()` для него вернет размер указателя, а не области памяти, который занимает массив. 

Определить число элементов массива мы можем только, используя имя массива `ar`, но не указатель на него. Об этом ранее мы с вами уже говорили.

Если мы еще раз посмотрим на объявление функции `sum_ar()`, то первый параметр `arr` можно интерпретировать и как указатель на массив и как указатель на переменную типа `short`. Так вот, чтобы подчеркнуть, что `arr` ссылается именно на массив, допустимо этот указатель описывать следующим образом:

```c
int sum_ar(const short arr[], int length) {...}
```

На уровне машинных кодов оба варианта абсолютно равнозначны. Это все тот же указатель `arr`, только синтаксис подсказывает программисту, что через `ar` в функции `sum_ar()` предполагается работать с непрерывной областью памяти, как с массивом. Не более того.

Также, при необходимости, функция может возвращать константные значения. Для этого достаточно в типе прописать ключевое слово `const` следующим образом:

```c
const char* find_space(const char* buf) {
    while (*buf != '\0') {
        if (*buf == ' ') return buf;
        buf++;
    }
}
```

Обычно `const` прописывают при возвращении константного указателя, так как в других ситуациях особого смысла в `const` нет. В данном примере, функция находит первый пробел в переданной строке и возвращает указатель на него. Если пробел не был найден, то возвращается значение `NULL`.

## Передача многомерных массивов через параметры функции

Крайне редко, но все же бывают ситуации, когда нам нужно передать не одномерный, а многомерный массив в функцию. Для этого, как вы уже догадались, нужно использовать специальный тип указателя на соответствующий многомерный массив. Например, пусть у нас объявлен двумерный массив с некоторым числом строк и тремя столбцами:

```c
short ar[][3] = {{1, 2, 3}, {4, 5, 6}};
```

Чтобы его передать через параметр в функцию, следует сделать следующее объявление:

```c
void show_ar2D(const short (*ar)[3], int rows) {
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < 3; ++j) printf("%d ", ar[i][j]);
        printf("\n");
    }
}
```

Эта функция принимает указатель на двумерный массив с произвольным числом строк `rows`, но обязательно тремя столбцами. И, затем, отображает его на экране в виде таблицы.

Использовать такую функцию можно следующим образом:

```c
int main(void) {
    short ar[][3] = {{1, 2, 3}, {4, 5, 6}};
    show_ar2D(ar, sizeof(ar) / sizeof(*ar));

    return 0;
}
```

Мы по-прежнему передаем указатель на массив и число строк вторым аргументом. После запуска программы увидим результат:

```
1 2 3
4 5 6
```

Как вы понимаете, недостатком использования и передачи многомерных массивов в функцию является необходимость указания точных размеров, кроме первого. В нашем случае, при объявлении функции, необходимо указывать число столбцов, равное трем. И если это значение изменится, то придется вносить правки во все места, где оно используется. Из этой ситуации есть, по крайней мере, два выхода. Первый очевидный. С помощью директивы `define` определить число столбцов и использовать макроимя в тексте программы:

```c
#include <stdio.h>

#define COLS 3

void show_ar2D(const short (*ar)[COLS], int rows) {
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < COLS; ++j) printf("%d ", ar[i][j]);
        printf("\n");
    }
}

int main(void) {
    short ar[][COLS] = {{1, 2, 3}, {4, 5, 6}};
    show_ar2D(ar, sizeof(ar) / sizeof(*ar));

    return 0;
}
```

Во втором случае определить одномерный массив и работать с ним, как с многомерным. Например, для получения аналога двумерного массива в `COLS` столбцов, можно использовать следующую формулу:

```c
short ar[] = {1, 2, 3, 4, 5, 6};
short res_ij = ar[i * COLS + j];  // i – индекс строк; j – индекс столбцов
```

Какой именно вариант использовать на практике зависит от конкретной решаемой задачи и предпочтений программиста.

Видео по теме [#43. Указатели как параметры. Передача массивов в функции](https://www.youtube.com/watch?v=D3K70nL1K_E&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, касающиеся указателей в параметрах функций языка Си.


+ [x] посредством указателей в параметрах можно получить доступ к локальным переменным, объявленным в других функциях
+ [ ] через указатели в функции можно передавать только обычные переменные базовых типов, исключая массивы
+ [ ] через указатели в функции можно передавать только одномерные массивы (не многомерные)
+ [x] посредством указателей в параметрах функция получает возможность менять сразу несколько внешних переменных
+ [x] через указатели в функции можно передавать массивы и строки

### Подвиг 2. Напишите программу, которая читает из входного потока в массив типа int десять целочисленных значений, записанных в одну строчку через пробел. Объявите функцию с именем sum_ar и следующими параметрами (порядок параметров должен соблюдаться):
+ целочисленный массив (тип int);
+ длина массива (число обрабатываемых элементов).

Функция sum_ar должна вычислять сумму элементов переданного массива и возвращать вычисленное значение в виде целого числа.

В функции main вызовите функцию sum_ar для чисел, прочитанных из входного потока. Возвращенное функцией sum_ar значение выведите в консоль в виде целого числа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/6.4.2

```c
#include <stdio.h>

#define MAX 10

int sum_ar(int *ar, int len) {
    int res = 0;
    for (int i = 0; i < len; i++) {
        res += ar[i];
    }
    return res;
}

int main(void) {
    int ar[MAX] = {0};
    for (int i = 0; i < MAX; i++) {
        scanf("%d", &ar[i]);
    }

    int *ptr = ar;
    int result = sum_ar(ptr, sizeof(ar) / sizeof(*ar));

    printf("%d", result);

    return 0;
}
```

### Подвиг 3. Напишите программу, которая читает из входного потока в массив несколько целочисленных значений (не менее одного и не более 20), записанных в одну строчку через пробел. Объявите функцию с именем prod_ar и следующими параметрами (порядок параметров должен соблюдаться):

целочисленный массив;
длина массива (число обрабатываемых элементов).
Функция prod_ar должна вычислять произведение элементов переданного массива и возвращать вычисленное значение в виде целого числа.

В функции main вызовите функцию prod_ar для чисел, прочитанных из входного потока. Возвращенное функцией prod_ar значение выведите в консоль в виде целого числа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/6.4.3

```c
#include <stdio.h>

#define MAX 20

int prod_ar(const int *ar, int len) {
    int res = 1;
    for (int i = 0; i < len; i++) {
        res *= ar[i];
    }
    return res;
}

int main(void) {
    int ar[MAX] = {0}, count = 0;
    for (int i = 0; i < MAX; i++) {
        if (scanf("%d", &ar[i]) == 1)
            count++;
        else
            break;
    }

    int *ptr = ar;
    int result = prod_ar(ptr, count);

    printf("%d", result);

    return 0;
}
```

### Подвиг 4. Напишите программу, которая читает из входного потока в массив несколько вещественных значений (не менее одного и не более 20), записанных в одну строчку через пробел. Объявите функцию с именем to_csv и следующими параметрами (порядок параметров должен соблюдаться):
+ указатель на массив символов (строку);
+ максимальная длина строки (неотрицательное целое число);
+ массив вещественных чисел (тип double);
+ длина массива (неотрицательное целое число).

Функция to_csv должна из переданного ей массива вещественных чисел сформировать строку в формате:

```
"csv: <число 1>; <число 2>; ...; <число N>"
```

Точность вещественных чисел должна быть два знака после запятой (точки), то есть, до сотых. Например:

```
"csv: 0.56; -65.43; 0.10; 11.00"
```

Полагается, что длины строки в 100 символов достаточно для хранения сформированной строки из чисел.

Функция to_csv должна возвращать количество (целое число) записанных в строку вещественных чисел.

В функции main вызвать функцию to_csv для вещественных чисел, прочитанных из входного потока и вывести в консоль сформированную строку.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/6.4.4

```c
#include <stdio.h>
#include <string.h>

#define NUMBERS 20
#define STR_LEN 100

int to_csv(char *str, unsigned int str_len, const double *ar, const int ar_len) {
    int res = 0;
    strcpy(str, "csv:");
    for (int i = 0; i < ar_len; i++) {
        char buff[8];
        sprintf(buff, " %.2lf%s", ar[i], i == ar_len - 1 ? "" : ";");
        strcat(str, buff);
        res++;
    }
    if (strlen(str) < str_len) str[strlen(str)] = '\0';

    return res;
}

int main(void) {
    double ar[NUMBERS] = {0};
    int count = 0;
    char str[STR_LEN];

    for (int i = 0; i < NUMBERS; i++) {
        if (scanf("%lf", &ar[i]) == 1)
            count++;
        else
            break;
    }

    const double *ar_ptr = ar;
    char *str_ptr = str;
    to_csv(str_ptr, STR_LEN, ar_ptr, count);

    printf("%s", str);

    return 0;
}
```

### Подвиг 5. Допишите программу. Объявите функцию с именем get_data_csv со следующими параметрами (порядок параметров должен соблюдаться):
+ массив вещественных чисел (double);
+ максимальная длина массива (неотрицательное целое число);
+ указатель на корректную Си-строку.

Функция get_data_csv должна из переданной ей строки выделять и сохранять в переданный массив вещественные числа, которые записаны в формате:

"csv: <число 1>; <число 2>; ...; <число N>"

Например:

"csv: 0.56; -65.43; 0.1; 11.0"

Необходимо выделенные числа сохранять в переданном массиве в количестве не превышающем длину массива 20 элементов. Функция get_data_csv должна возвращать количество (целое число) записанных в массив вещественных чисел.

В функции main вызвать функцию get_data_csv для строки str и вывести в консоль выделенные в массив вещественные числа в одну строчку через пробел с точностью до сотых.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/6.4.5

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define NUMBERS 20

int get_data_csv(double ar[], int len, char* str) {
    int count = 0;
    while (strpbrk(str, ":;")) {
        str = strpbrk(str, ":;");
        ar[count++] = atof(++str);
        if (count == len - 1) return len;
    }
    return count;
}

int main(void) {
    char str[100] = {0};
    fgets(str, sizeof(str) - 1, stdin);
    char* ptr_n = strrchr(str, '\n');
    if (ptr_n != NULL) *ptr_n = '\0';
    ptr_n = str;
    double ar[NUMBERS];

    int result = get_data_csv(ar, NUMBERS, ptr_n);

    for (int i = 0; i < result; i++) {
        printf("%.2lf ", ar[i]);
    }

    return 0;
}
```

### Подвиг 6. Продолжите программу. Необходимо объявить функцию с именем transpose, которой передается двумерный массив размером SIZE x SIZE из чисел типа short. Функция transpose должна строки заменять на соответствующие столбцы (транспонирование) переданного массива. В функции main вызовите функцию transpose для массива matrix. Выведите полученный транспонированный массив matrix в консоль в виде таблицы целых чисел SIZE x SIZE элементов.

(Обратите внимание, что между числами в строках должен быть один пробел, а в конце строк - ни одного.) 

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/6.4.6

```c
#include <stdio.h>

#define SIZE 4

void transpose(short (*matrix)[SIZE]);
void print_matrix(short (*matrix)[SIZE]);
void copy_matrix(short (*copy)[SIZE], short (*matrix)[SIZE]);

int main(void) {
    short matrix[SIZE][SIZE] = {0};
    short* ptr = &matrix[0][0];
    int count = 0;
    while (count < SIZE * SIZE && scanf("%hd", ptr) == 1) {
        ptr++;
        count++;
    }

    transpose(matrix);
    print_matrix(matrix);

    return 0;
}

void transpose(short (*matrix)[SIZE]) {
    short copy[SIZE][SIZE];

    copy_matrix(copy, matrix);

    for (int i = 0; i < SIZE; i++) {
        for (int j = 0; j < SIZE; j++) {
            matrix[j][i] = copy[i][j];
        }
    }
}

void copy_matrix(short (*copy)[SIZE], short (*matrix)[SIZE]) {
    short* matrix_ptr = &matrix[0][0];
    short* copy_ptr = &copy[0][0];
    int count = 0;
    while (count < SIZE * SIZE) {
        *copy_ptr++ = *matrix_ptr++;
        count++;
    }
}

void print_matrix(short (*matrix)[SIZE]) {
    for (int i = 0; i < SIZE; i++) {
        for (int j = 0; j < SIZE; j++) {
            printf("%d%s", matrix[i][j], j == SIZE - 1 ? "\n" : " ");
        }
    }
}
```

### Подвиг 7. Продолжите программу. Объявите функцию с именем show_pole, которой передается двумерный массив типа char размером SIZE x SIZE элементов. Она должна отобразить в консоли этот двумерный массив в виде таблицы размером SIZE x SIZE по следующей схеме:
* * *
* * *
* * *
То есть, в три строки и три столбца. Причем, между символами в строках должен быть один пробел. В конце строк пробела быть не должно.

Вместо символа '*'' необходимо вывести символ, который хранится в элементах переданного массива, либо символ '#', если значение элемента равно 0 (целое число).

В функции main вызывать функцию show_pole для массива pole.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/6.4.7

```c
#include <stdio.h>

#define SIZE 3

void print_matrix(char (*matrix)[SIZE]);

int main(void) {
    char pole[SIZE][SIZE] = {0};
    char* ptr_p = &pole[0][0];
    int count = 0;
    while (count < SIZE * SIZE && scanf("%d", ptr_p) == 1) {
        *ptr_p = (*ptr_p == 1) ? 'x' : (*ptr_p == 2) ? 'o' : *ptr_p;
        ptr_p++;
        count++;
    }

    print_matrix(pole);

    return 0;
}

void print_matrix(char (*matrix)[SIZE]) {
    for (int i = 0; i < SIZE; i++) {
        for (int j = 0; j < SIZE; j++) {
            char ch = matrix[i][j] == 0 ? '#' : matrix[i][j];
            printf("%c%s", ch, j == SIZE - 1 ? "\n" : " ");
        }
    }
}
```

### Подвиг 8. Продолжите программу. Объявите функцию с именем is_win, которой передается двумерный массив типа char размером SIZE x SIZE элементов. Функция is_win должна проверять и возвращать статус переданного игрового поля игры "Крестики-нолики" в виде целого числа:

0 - игра не окончена;
1 - выиграли "крестики";
2 - выиграли "нолики";
3 - ничья.

Каждый элемент переданного двумерного массива хранит либо символ 'x', либо символ 'o', либо целое число 0, если клетка свободна.

В функции main вызовите функцию is_win для массива pole. Выведите в консоль вычисленный статус игрового поля в виде целого числа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/6.4.8

```c
#include <stdio.h>

#define SIZE 3

int is_win(char (*matrix)[SIZE]);
int ch_to_int(char ch);

int main(void) {
    char pole[SIZE][SIZE] = {0};
    char* ptr_p = &pole[0][0];
    int count = 0;
    while (count < SIZE * SIZE && scanf("%d", ptr_p) == 1) {
        *ptr_p = (*ptr_p == 1) ? 'x' : (*ptr_p == 2) ? 'o' : *ptr_p;
        ptr_p++;
        count++;
    }

    int result = is_win(pole);

    printf("%d", result);

    return 0;
}

int ch_to_int(char ch) {
    if (ch == 'x') return 1;
    if (ch == 'o') return 2;
    return 0;
}

int is_win(char (*matrix)[SIZE]) {
    // проверим строки
    for (int i = 0; i < SIZE; i++) {
        int row_count = 0;
        int nulls = 1;
        for (int j = 0; j < SIZE; j++) {
            if (matrix[i][j] == 0) {
                nulls = 0;
                break;
            }
            row_count += ch_to_int(matrix[i][j]);
        }
        if (nulls && row_count == 3) return 1;
        if (nulls && row_count == 6) return 2;
    }

    // проверим столбцы
    for (int i = 0; i < SIZE; i++) {
        int cell_count = 0;
        int nulls = 1;
        for (int j = 0; j < SIZE; j++) {
            if (matrix[j][i] == 0) {
                nulls = 0;
                break;
            }
            cell_count += ch_to_int(matrix[j][i]);
        }
        if (nulls && cell_count == 3) return 1;
        if (nulls && cell_count == 6) return 2;
    }

    // проверим диагонали
    int diag1_sum = 0;
    int diag2_sum = 0;
    int nulls = 1;
    for (int i = 0; i < SIZE; i++) {
        if (matrix[i][i] == 0) {
            nulls = 0;
            break;
        }
        diag1_sum += ch_to_int(matrix[i][i]);
        diag2_sum += ch_to_int(matrix[i][SIZE - i - 1]);
    }
    if (nulls && diag1_sum == 3) return 1;
    if (nulls && diag2_sum == 3) return 1;
    if (nulls && diag1_sum == 6) return 2;
    if (nulls && diag2_sum == 6) return 2;

    // проверим нули
    for (int i = 0; i < SIZE; i++) {
        for (int j = 0; j < SIZE; j++) {
            if (matrix[i][j] == 0) {
                return 0;
            }
        }
    }
    return 3;
}
```

### Подвиг 9 (на повторение). Установите соответствия между строковыми функциями и их описаниями.

![06](/Good_good_C_C++/img/06_05.PNG)

### Подвиг 10 (на повторение). Установите соответствия между названиями функций работы со строками и их описаниями.

![06](/Good_good_C_C++/img/06_06.PNG)

# 6.5 Указатели на функцию. Функция как параметр (callback)

## Указатели на функцию.

На этом занятии речь пойдет об указателях на функции. Да, в языке Си можно определять указатели не только на переменные (данные), но и на функции, используя следующий синтаксис:

```
<тип> (*<имя указателя>) (<типы параметров>);
```

Например, пусть в программе объявлена функция, которая принимает два целочисленных параметра и возвращает площадь прямоугольника в виде целого значения:

```c
int sq_rect(int width, int height) {
    return width * height;
}
```

Имя функции `sq_rect` здесь есть не что иное, как указатель на функцию. Мы в этом можем легко убедиться, если выведем на экран значение этого указателя:

```c
int main(void) {
    printf("sq_rect = %p\n", sq_rect);
    return 0;
}
```

После запуска увидим строку:

```
sq_rect = 00401439
```

То есть, функция в данном случае располагается по адресу `0x00401439`. Но раз `sq_rect` – это указатель, значит, можно объявить еще один указатель на эту функцию и присвоить ему адрес `sq_rect`. Согласно приведенному синтаксису, такой указатель можно объявить следующим образом:

```c
int (*ptr_func) (int, int);
```

Здесь первый `int` – это возвращаемый тип функции `sq_rect`, далее в круглых скобках прописываем имя указателя (придумываем сами) и, затем, в круглых скобках через запятую типы параметров функции. Получаем указатель с именем `ptr_func` на любую функцию, которая возвращает целое значение и принимает два целочисленных параметра.

Давайте проиницализируем этот указатель на функцию `sq_rect`:

```c
ptr_func = sq_rect;
```

и вызовем функцию через `ptr_func`, передав два аргумента:

```c
int res = ptr_func(2, 3);
printf("ptr_func(2, 3) = %d\n", res);
```

Увидим результат ее работы:

```
ptr_func(2, 3) = 6
```

Причем, как я только что сказал, указатель `ptr_func` может ссылаться на любую функцию с описанной сигнатурой. Например, объявим еще одну подобную функцию в нашей программе:

```c
int per_rect(int width, int height) {
    return 2 * (width + height);
}
```

Тогда `ptr_rect` можно инициализировать на нее:

```
ptr_func = per_rect;
```

и также вызвать с двумя аргументами:

```c
int res = ptr_func(2, 3);
```

Видите, какой универсальный механизм у нас с вами вырисовывается. Один и тот же указатель может быть связан с разными функциями одинаковой сигнатуры и вызывать нужную из них.

В качестве примера, давайте посмотрим, что будет, если сигнатура функции будет отличаться от определения указателя. Например, объявим в программе еще одну функцию:

```c
void print_hi(void) {
    puts("Hi!");
}
```

Тогда при попытке инициализации указателя `ptr_func` такой функцией:

```
ptr_func = print_hi;
```

получим предупреждение о несовпадении типов. Другие версии компиляторов могут здесь выдавать ошибку и останавливать процесс трансляции программы. Очень важно, чтобы тип указателя на функцию и сама функция совпадали. Иначе, это может привести к серьезным ошибкам в процессе выполнения программы. Поэтому делать такие присваивания недопустимо.

Для функции `print_hi` указатель следует объявить следующим образом:

```c
void (*ptr_hi) (void);
ptr_hi = print_hi;
ptr_hi();
```

## Параметры как указатели на функции

Теперь, когда мы разобрались, как объявлять указатели на функции и как их использовать, давайте посмотрим на примеры, где это может быть использовано.

Предположим, нам необходимо определить функцию, которая бы отбирала из одного массива в другой только те элементы, которые удовлетворяют некоторому критерию. Причем, критерий определяется другой независимой функцией. Реализовать эту задачу можно, например, следующим образом:

```c
#include <stdio.h>

#define SIZE 10

void filter(int dst[], size_t size_dst, const int src[], size_t size_src, int (*is_correct)(int)) {
    for (int i = 0; i < size_dst; ++i) dst[i] = 0;

    for (int i = 0, j = 0; i < size_src; ++i)
        if (is_correct(src[i])) dst[j++] = src[i];
}

int is_even(int x) { return x % 2 == 0; }

int main(void) {
    int digits[] = {-3, 4, 10, 11, -5, 3};
    int result[SIZE];

    filter(result, SIZE, digits, sizeof(digits) / sizeof(*digits), is_even);

    for (int i = 0; i < SIZE; ++i) printf("%d ", result[i]);

    return 0;
}
```

Вначале объявлена функция `filter()`, которая принимает два массива с их размерами и ссылку на функцию. Затем, массив `dst`, в который заносится результат, обнуляется и в следующем цикле выполняется копирование только тех значений из второго массива `src`, для которых функция `is_correct()` возвращает не нулевое значение. То есть, указатель `is_correct` определяет критерий отбора значений.

После функции `filter()` объявлена еще одна функция `is_even()`, которая будет использоваться в качестве критерия отбора: для четных значений она возвращает единицу, а для нечетных – ноль.

В функции `main()` объявляются два массива и, затем, вызывается функция `filter()`, в которую передаются указатели на эти массивы, их длины и указатель на функцию `is_even()`. То есть, параметр `is_correct` будет ссылаться на функцию `is_even()`.

После запуска программы увидим следующий результат:

```c
4 10 0 0 0 0 0 0 0 0
```

Как видите, в массив `result` попали только четные значения из массива `digits`.

Уникальность функции `filter()` в том, что мы легко можем изменить критерий отбора, не меняя саму функцию `filter()`. Например, нам ставится задача выбрать все положительные числа. Нет ничего проще. Объявляем еще одну функцию для нового критерия отбора:

```c
int is_positive(int x) {
    return x > 0;
}
```

И указываем ее при вызове функции `filter()`:

```c
filter(result, SIZE, digits, sizeof(digits) / sizeof(*digits), is_positive);
```

Запускаем программу, получаем результат:

```
4 10 11 3 0 0 0 0 0 0
```

Видите, какие красивые конструкции можно формировать, используя указатели на функции?

## Массивы из указателей на функции

Можно пойти еще дальше и определить массив из указателей на функции. Общий синтаксис здесь следующий:

```c
<тип> (*<имя массива>[<размер>]) (<параметры>)
```

Давайте объявим в программе еще одну функцию для выделения нечетных значений:

```c
int is_odd(int x) {
    return x % 2 != 0;
}
```

И сформируем массив из указателей на эти критерильные функции:

```c
int (*criterials[]) (int) = {is_even, is_odd, is_positive};
```

Теперь в `filter()` можно передавать одну из этих функций, просто указывая нужный индекс массива `criterials`:

```c
filter(result, SIZE, digits, sizeof(digits) / sizeof(*digits), criterials[1]);
```

Это может быть полезно, когда у пользователя запрашивается критерий отбора, например, в виде меню:
1. Четные значения.
2. Нечетные значения.
3. Положительные значения.

И выбранный номер `select_id` просто преобразуется в индекс `indx = select_id - 1` массива `criterials`.

Видео по теме [#44. Указатели на функцию. Функция как параметр (callback)](https://www.youtube.com/watch?v=_st6VD2v4Fc&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Запишите объявление указателя с именем ptr_func на функции, имеющих следующую сигнатуру:

```c
double <имя функции>(int, int);
```
P. S. Указатель ptr_func следует объявлять в глобальной области видимости и без какой-либо инициализации. Кроме объявления указателя в программе больше ничего делать не нужно.

```c
#include <stdio.h>

double (*ptr_func)(int, int);

int main(void) {

    return 0;
}
```

### Подвиг 2. Продолжите программу. В функции main объявите указатель с именем ptr_max_2 на функцию max_2 и вызовите функцию через этот указатель с переменными a и b. Выведите в консоль возвращенное вещественное число с точностью до десятых.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/6.5.2

```c
#include <stdio.h>

double max_2(double a, double b) { return (a > b) ? a : b; }

int main(void) {
    double a, b;
    scanf("%lf, %lf", &a, &b);

    double (*ptr_max_2)(double, double);
    ptr_max_2 = max_2;

    double result = ptr_max_2(a, b);

    printf("%.1lf", result);
    //__ASSERT_TESTS__
    // макроопределение для тестирования (не убирать и должно идти непосредственно перед return 0)
    return 0;
}
```

### Подвиг 3. Продолжите программу. Необходимо дописать функцию copy_string, которая копирует строку из src в dst с учетом ее максимального размера. Последним параметром функции copy_string должен быть указатель на функцию с сигнатурой:

```c
int <имя функции>(const char);
```

Эта дополнительная функция должна возвращать `1`, если символ `char` следует копировать в строку `dst`, и `0` в противном случае. Объявите в любом допустимом месте программы такую функцию, которая запрещает копирование всех латинских символов:

```
a-z и A-Z.
```

В функции `copy_string` реализовать копирование строки из `src` в `dst` с проверкой допустимости копирования символов. Если символ копировать запрещено, то он пропускается. Строка `dst` должна быть корректной Си-строкой (в конце всегда должен быть символ `'\0'`).

Вызовите функцию `copy_string` для копирования строки `str` в строку `str2` с запретом копирования любых символов латинского алфавита. Выведите полученную строку `str2` в консоль.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/6.5.3

```c
#include <stdio.h>
#include <string.h>

void copy_string(char* dst, size_t max_len_dst, const char* src, int (*to_copy)(const char)) {
    size_t counter = 0;
    int index = 0, shift = 0;
    char* dst_ptr = dst;
    while (src[index] != '\0' && counter < max_len_dst) {
        if (to_copy(src[index])) {
            if (((int)src[index]) < 0) shift++;
            // printf("%c ", src[index]);
            *dst_ptr++ = src[index];
            counter++;
        }

        index++;
    }

    // printf("\n%d %d\n", counter, shift);

    dst[max_len_dst - 1] = '\0';
}

int is_al(const char ch) {
    int res = 1;
    if ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z')) {
        res = 0;
    }
    return res;
}

int (*to_copy)(const char) = is_al;

int main(void) {
    char str[100] = {0}, str2[20];
    fgets(str, sizeof(str) - 1, stdin);
    char* ptr_n = strrchr(str, '\n');
    if (ptr_n != NULL) *ptr_n = '\0';

    copy_string(str2, 20, str, to_copy);

    printf("%s", str2);

    return 0;
}
```

### Подвиг 4. Продолжите программу. В функции main из стандартного входного потока читаются целые числа. Необходимо все их сохранять в массиве marks (не более 20). То есть, чисел может быть и больше 20, но сохранять только первые 20 в порядке их считывания. 

Допишите функцию sum_ar, которая бы вычисляла сумму чисел переданного ей массива ar. Складывать следует только те числа, для которых переданная функция (через указатель) возвращает истину (не нулевое значение). Полученная сумма должна возвращаться функцией sum_ar.

Указатель на функцию должен инициализироваться любой функцией с сигнатурой:

int <имя функции>(int);
В функции main вызовите функцию sum_ar для массива marks, складывая только четные числа (проверка на четность выполняется дополнительной, вспомогательной функцией, которая, затем, передается последним аргументом в функцию sum_ar). Выведите в консоль целое значение, которое вернула функция sum_ar.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/6.5.4

```c
#include <stdio.h>
#define MAX 20

int sum_ar(const int *ar, size_t len_ar, int (*request)(int)) {
    int res = 0;
    for (size_t i = 0; i < len_ar; i++) {
        if (request(ar[i])) res += ar[i];
    }
    return res;
}

int is_even(int num) {
    int res = 1;
    if (num % 2) res = 0;
    return res;
}

int (*request)(int) = is_even;

int main(void) {
    int marks[MAX] = {0};
    int x;
    size_t count = 0;
    while (scanf("%d", &x) == 1 && count < MAX) {
        marks[count++] = x;
    }

    int result = sum_ar(marks, count, request);

    printf("%d", result);

    return 0;
}
```

### Подвиг 5. Продолжите программу. Необходимо объявить четыре критериальных функции для отбора целочисленных значений при суммировании в функции sum_ar. Все критериальные функции должны иметь сигнатуру:
```c
int <имя функции>(int );
```
и быть следующими:
+ `is_odd`: возвращает `1` для нечетных значений и `0` для четных;
+ `is_positive`: возвращает `1` для неотрицательных значений и `0` для отрицательных;
+ `is_negative`: возвращает `1` для отрицательных значений и `0` для неотрицательных;
+ `deflt`: возвращает `1` для любых значений.

В функции `sum_ar` реализовать подсчет целых чисел переданного массива `ar`, для которых критериальная функция (переданная через указатель) возвращает истину (не нулевое значение). Функция `sum_ar` должна возвращать вычисленную сумму.

В функции `main` объявить массив указателей с именем `funcs` на объявленные критериальные функции (в порядке их перечисления в задании). Затем, сформировать массив `marks` из прочитанных целочисленных значений в количестве не более `20` (необходима проверка на максимальное количество записываемых данных). После этого в операторе `switch` выполнить подсчет суммы с указанием соответствующей критериальной функции из массива `funcs`.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/6.5.5

```c
#include <stdio.h>

int is_odd(int num) {
    int res = 0;
    if (num % 2) res = 1;
    return res;
}

int is_positive(int num) {
    int res = 0;
    if (num >= 0) res = 1;
    return res;
}

int is_negative(int num) {
    int res = 1;
    if (num >= 0) res = 0;
    return res;
}

int deflt(int num) {
    int res = num * 0 + 1;
    return res;
}

int sum_ar(const int *ar, size_t len_ar, int (*func)(int)) {
    int res = 0;
    for (size_t i = 0; i < len_ar; i++) {
        if (func(ar[i])) res += ar[i];
    }
    return res;
}

int main(void) {
    // здесь массив указателей funcs на критериальные функции
    int marks[20] = {0};

    int item = 0;
    scanf("%d", &item);  // выбор критерия суммирования

    int x;
    size_t count = 0, len = sizeof(marks) / sizeof(marks[0]);
    while (scanf("%d", &x) == 1 && count < len) {
        marks[count++] = x;
    }

    int (*funcs[4])(int) = {is_odd, is_positive, is_negative, deflt};

    int sum = 0;  // переменная для хранения суммы
    switch (item) {
        case 1:
            sum = sum_ar(marks, len, funcs[item - 1]);
            break;
        case 2:
            sum = sum_ar(marks, len, funcs[item - 1]);
            break;
        case 3:
            sum = sum_ar(marks, len, funcs[item - 1]);
            break;
        default:
            sum = sum_ar(marks, len, funcs[item - 1]);
    }

    printf("%d", sum);

    return 0;
}
```

### Подвиг 6* (с повторением). Продолжите программу. Необходимо дописать функцию sort_string, которая бы выполняла сортировку символов переданной строки str (только символов строки, а не всех символов массива) по их возрастанию (неубыванию). Критерий возрастания (какой символ считать большим, а какой меньшим) задается дополнительной функцией с сигнатурой:

```c
int match_ab(const char a, const char b);
```

Данная функция должна возвращать `1`, если `a < b`, и `0` в противном случае. И, кроме того, все цифровые символы ('0', ..., '9') должны быть "меньше" любых других символов. То есть, при сортировке сначала в строке будут идти цифровые символы (по возрастанию), а затем все остальные (по возрастанию).

Вызовите функцию `sort_string` для строки `str` и с функцией сравнения `match_ab`. Выведите полученную строку `str` в консоль.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/6.5.6

```c
#include <stdio.h>
#include <string.h>

int is_digit(const char a) {
    int res = 0;
    if (a >= '0' && a <= '9') res = 1;
    return res;
}

int match_ab(const char a, const char b) {
    int a_is_digit = is_digit(a);
    int b_is_digit = is_digit(b);

    if (a_is_digit == b_is_digit) return a < b;
    if (a_is_digit > b_is_digit)
        return 1;
    else
        return 0;
}

void swap(char* a, char* b) {
    char tmp = *a;
    *a = *b;
    *b = tmp;
}

void sort_string(char* str, size_t max_len, int (*match_ab)(const char, const char)) {
    max_len = strlen(str);
    for (size_t i = 0; i < max_len; i++) {
        for (size_t j = i; j < max_len; j++) {
            if (!match_ab(str[i], str[j])) swap(&str[i], &str[j]);
        }
    }
}

int main(void) {
    char str[100] = {0};
    fgets(str, sizeof(str) - 1, stdin);
    char* ptr_n = strrchr(str, '\n');
    if (ptr_n != NULL) *ptr_n = '\0';

    sort_string(str, strlen(str) - 1, match_ab);

    puts(str);

    return 0;
}
```

XOR - надо запомнить!

```c
#include <stdio.h>
#include <string.h>

int is_digit(const char x) 
{
    return x >= '0' && x <= '9';
}

int match_ab(const char a, const char b)
{
    if (is_digit(a) ^ is_digit(b))
        return (is_digit(a)) ? 1 : 0;
    return a < b;
}

void sort_string(char *str, size_t max_len, int (*sort_func)(const char, const char))
{
    int k = 0;
    while (*(str + k)) k++;
    
    for (int i = k - 1; i >= 0; i--) {
        for (int j = 0; j < i; j++) {
            if (!sort_func(str[j], str[j+1])) {
                char tmp = str[j];
                str[j] = str[j+1];
                str[j+1] = tmp;
            }
        }
    }
}

int main(void)
{
    char str[100] = {0};
    fgets(str, sizeof(str)-1, stdin);
    char* ptr_n = strrchr(str, '\n');
    if(ptr_n != NULL)
        *ptr_n = '\0';

    sort_string(str, sizeof(str) / sizeof(*str), match_ab);
    printf("%s", str);

    return 0;
}
```

### Подвиг 7 (релакс). Напишите программу, которая читает четыре целых числа из входного потока, записанных в одну строчку через пробел. Объявите функцию с сигнатурой:

```c
int sum_big2(int a, int b, int c, int d);
```

Эта функция должна складывать два наибольших числа из четырех переданных и возвращать значение суммы. Вызовите функцию `sum_big2` в функции main для прочитанных чисел из входного потока. Выведите в консоль полученное значение суммы в виде одного целого числа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/6.5.7

```c
#include <stdio.h>
#define MAX 4

void swap(int* a, int* b) {
    int tmp = *a;
    *a = *b;
    *b = tmp;
}

int match_ab(const int a, const int b) { return a < b; }

int sum_big2(int a, int b, int c, int d) {
    int nums[MAX] = {a, b, c, d};
    for (size_t i = 0; i < MAX; i++) {
        for (size_t j = i; j < MAX; j++) {
            if (match_ab(nums[i], nums[j])) swap(&nums[i], &nums[j]);
        }
    }
    return nums[0] + nums[1];
}

int main(void) {
    int a, b, c, d;
    scanf("%d %d %d %d", &a, &b, &c, &d);

    int result = sum_big2(a, b, c, d);

    printf("%d", result);

    return 0;
}
```

### Подвиг 8 (на повторение). Какую роль играет функция main() в тексте программы на языке Си?

+ [x] это функция, которая автоматически запускается при запуске исполняемого файла
+ [ ] если функция main() возвращает не нулевое значение, значит, программа была выполнена успешно (без ошибок)
+ [x] если функция main() возвращает 0, значит, программа была выполнена успешно (без ошибок)
+ [x] как только функция main() завершает свою работу, завершается выполнение всей программы
+ [ ] функция main() служит для начальной инициализации переменных в программе (и только для этого)
+ [x] если функция main() отсутствует в тексте программы (проекта), то при компиляции возникает ошибка

### Подвиг 9 (на повторение). Двоичная запись неотрицательного числа имеет вид:

$00011100_2 = 28_{10}$

Переведите его в десятичную форму и запишите ответ.

### Подвиг 10 (на повторение). Шестнадцатеричная запись числа имеет вид:

$2F3C_{16} = 2 \cdot 16^3 + 15 \cdot 16^2 + 3 \cdot 16^1 + 12 = 8192 + 3840 + 48 + 12 = 12092$

Переведите его в десятичную беззнаковую форму и запишите ответ.

# 6.6 Стековый фрейм. Автоматические переменные

Прежде чем двигаться дальше, нам нужно глубже познакомиться с механизмом вызова функций, заглянуть за кулису этого процесса, раскрыть некоторые важные детали его работы.

Когда запускается какая-либо программа, то происходит загрузка данных и программного кода в память устройства и, кроме того, автоматически выделяется область памяти под стек вызова функций. 

Его еще называют стековым фреймом. 

Я напомню, что стек – это такая структура, когда новые данные помещаются наверх и извлекаются тоже сверху. Это вроде того, как мы в стакан кладем некие предметы, а затем, вынимаем их тоже сверху. 

![06](/Good_good_C_C++/img/06_07.PNG)

Получаем очередь, работающую по принципу:

```
LIFO (Last In, First Out) – последний вошел, первый вышел.
```

Зачем в программе понадобился такой стек? 

Давайте предположим, что объявлены две функции:
+ `max2()` – для поиска максимального из двух значений;
+ `main()` – основная функция, точка входа в программу:

```c
int max2(int a, int b) { return (a > b) ? a : b; }

int main(void) {
    int x = 1, y = 2;
    int res = max2(x, y);

    return 0;
}
```

Каждая функция имеет свои собственные переменные, необходимые для ее работы. 

Например, в функции `main()` – это переменные `x`, `y`, `res`, а в функции `max2()` – это параметры `a` и `b`. 

Так вот, переменные, связанные с той или иной функцией автоматически создаются в момент вызова этой функции и становятся недоступными после ее завершения. 

А размещаются переменные, как раз в стековом фрейме. 

В нашем примере сначала будет вызвана функция `main()`. В стеке появится блок данных для этой функции. Затем, функция `main()` вызывает функцию `max2()` и в стеке появляется еще один блок данных для работы этой второй функции. 

![06](/Good_good_C_C++/img/06_08.png)

После завершения функции `max2()` блок с данными для нее в стековом фрейме перестает быть актуальным и более не учитывается. 

Соответственно, параметры `a` и `b` становятся недоступными после завершения этой функции. 

То же самое происходит при завершении функции `main()`. Все ее данные в стековом фрейме как бы перестают существовать, в том числе и локальные переменные `x`, `y`, `res`.

Получается, что обычные переменные, объявленные внутри функции, автоматически создаются в момент ее вызова и пропадают после ее завершения.

Именно поэтому такие переменные получили название автоматические. 

А область их видимости (то есть, существования) ограничивается телом функции. Подробнее об областях видимости и классах памяти мы еще будем говорить.

Давайте теперь в деталях посмотрим, как происходит вызов этих функций.

Вначале, когда вызывается функция `main()`, вызывающая программа копирует в стек аргументы функции (если они есть), резервирует память под возвращаемое значение и сохраняет адрес возврата, то есть, адрес машинной команды, которую нужно будет выполнить после завершения вызова текущей функции.

Указатель стека `ESP`, как правило, указывает на позицию в стековом фрейме, где располагается этот адрес. 

Затем, срабатывает команда `call` с указанием адреса перехода к подпрограмме, то есть, к первой ячейке памяти, где хранятся команды функции `main()`. 

Это и есть непосредственно процесс вызова функции. 

Сама функция в момент вызова резервирует в стеке память для хранения всех локальных переменных, объявленных внутри нее. 

В нашем примере – это переменные `x`, `y`, `res`. 

И дополнительно прописывается еще некоторая служебная информация. 

После этого начинает отрабатывать логика функции `main()`. 

В данном случае вызывать следующую функцию `max2(x, y)`. 

Соответственно, процесс вызова повторяется. Сначала в стек вызывающая функция, то есть `main()` добавляет параметры `a`, `b`, причем в обратном порядке: сначала `b`, затем `a`. 

Записывает адрес возврата из функции `max2()` и перемещает указатель стека `ESP` на этот новый адрес. Далее, срабатывает все та же команда `call` с адресом подпрограммы функции `max2()`. 

Функция начинает свою работу и первым делом размешает в стеке свои локальные переменные. 

Но их нет, поэтому там появляется только служебная информация. После выполнения всех команд подпрограмма функции `max2()` доходит до команды `ret` с переходом на сохраненный адрес возврата. 

![06](/Good_good_C_C++/img/06_09.PNG)

Мы снова попадаем в функцию `main()` и ее выполнение продолжается. 

В частности, восстанавливается прежнее значение указателя стека `ESP`. В результате, все данные, относящиеся к функции `max2()`, становятся неактуальными и эта область памяти может быть использована при вызове других функций. 

Поэтому продолжать работу с локальными переменными `a` и `b` уже нельзя. 

Собственно, на уровне языка Си они недоступны за пределами тела функции именно по этой причине – они, как бы перестают существовать. 

Функция `main()` также завершается, выполняется команда `ret` с переходом по сохраненному адресу, и мы попадаем в начальный программный блок. 

Здесь указатель `ESP` устанавливается на самый низ фреймового стека и программа завершается.

Вот такие манипуляции происходят каждый раз при вызове функций. И мы теперь знаем, что все обычные локальные переменные и параметры размещаются в стековом фрейме при очередном вызове функции. 

При этом память под переменные просто резервируется и не более того. Это значит, что локальные переменные могут принимать произвольные начальные значения, так как в ячейках памяти, которые они занимают, могут находиться любые величины, так называемый шум. 

Давайте в этом убедимся. 

Создадим в функции `main()` целочисленную переменную с именем var и выведем ее на экран:

```c
int var;
printf("var = %d\n", var);
```

В моем случае получилось значение:

```
var = 4199120
```

У вас будет какое-то другое. То есть, начальные значения в локальных автоматических переменных непредсказуемы. Это нужно учитывать при составлении программы.

Другой важный вывод связан с тем, что стековый фрейм, как правило, имеет весьма ограниченный размер (несколько мегабайт). 

Это, во-первых, означает, что мы не можем вызывать бесконечно длинную цепочку функций (одну из другой), так как стек просто заполнится, и при очередном вызове получим ошибку:

```
Stack Overflow (переполнение стека)
```

И, во-вторых, не следует внутри функций определять автоматические локальные переменные, которые занимают большой объем памяти. Например, массивы из большого числа элементов. Допустим, такой:

```c
int main(void) {
    double big_ar[1000000];
    return 0;
}
```

В этом случае памяти стекового фрейма просто не хватит для его хранения и программа завершится аварийно. А вот если объявить вне функций, то никаких проблем не будет.

Забегая вперед отмечу, что данные больших размеров, которые нужно динамически создавать в момент вызова функций, лучше размещать в основной области памяти, так называемой, куче. Делается это с помощью вызова функций `malloc()` и `free()`, о которых мы с вами еще будем говорить.

На этом мы завершим знакомство с механизмом вызова функций. Думаю, вы теперь хорошо представляете себе особенности и ограничения, связанные с локальными переменными и параметрами функций.

Видео по теме [#45. Стековый фрейм. Автоматические переменные](https://www.youtube.com/watch?v=F0xlilZzwCs&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, касающиеся стека вызова функций языка Си.

+ [x] область памяти под стек вызова выделяется в момент запуска программы и освобождается при ее завершении
+ [x] если области памяти стека вызова недостаточно (при очередном вызове функции), то генерируется ошибка Stack Overflow
+ [x] стек вызова работает по принципу очереди LIFO (последним зашел, первым вышел)
+ [ ] стек вызова работает по принципу очереди FIFO (первым зашел, первым вышел)
+ [x] при каждом вызове функции ее данные (в том числе и аргументы) помещаются в стек вызова
+ [ ] переменные, хранящиеся в стековом фрейме, называются автоматическими и принимают нулевые начальные значения
+ [x] переменные, хранящиеся в стековом фрейме, называются автоматическими и принимают неопределенные начальные значения

### Подвиг 2. Выберите все верные утверждения, касающиеся следующего фрагмента программы:

```c
float global_ar[1000000];

int main(void) {
    double ar[1000000];
    return 0;
}
```

+ [ ] массив global_ar располагается в стековом фрейме
+ [x] если размера стекового фрейма недостаточно для хранения массива ar, то возникает ошибка Stack Overflow
+ [x] массив global_ar располагается вне стекового фрейма
+ [x] массив ar располагается в стековом фрейме в момент вызова функции main
+ [ ] если размера стекового фрейма недостаточно для хранения массива ar, то часть данных массива ar теряется (неопределенное поведение)
+ [ ] массив ar располагается в стековом фрейме в момент загрузки программы (до вызова функции main)

### Подвиг 3. Объявите функцию со следующей сигнатурой:

```c
double norm(int a, int b);
```
которая генерирует псевдослучайное число по формуле:

$y= \dfrac{1}{N} \cdot \displaystyle\sum_{i=1}^{N}x_i$ 
   
где $x_i$ - псевдослучайные числа в диапазоне `[a; b]`. Число `N` объявите внутри функции `norm` со значением `100`.

В функции `main` вызовите функцию `norm` с аргументами `-2, 10` и сохраните возвращенное значение в вещественной переменной `y` (игрек).

P. S. В консоль ничего выводить не нужно.

```c
#include <stdio.h>
#include <stdlib.h>
#define N 100

double norm(int a, int b) {
    double res = 0;
    size_t count = N;
    for (size_t i = 0; i < count; i++) {
        res += a + rand() % (b - a + 1);
    }
    return res / N;
}

int main(void) {
    double y = norm(-2, 10);

    printf("%.2lf", y);
    //__ASSERT_TESTS__
    // макроопределение для тестирования (не убирать и должно идти непосредственно перед return 0)
    return 0;
}
```

### Подвиг 4 (продолжение подвига 3). Дополнительно к функции norm из предыдущего подвига объявите еще одну функцию с сигнатурой:

```c
double reley(double x1, double x2);
```

которая генерирует псевдослучайное число по формуле:

$y = \sqrt{x_1^2 + x_2^2}$ где $x_1$, $x_2$ - псевдослучайные числа, вычисленные (сгенерированные) функцией `norm`.

В функции `main` вызовите функцию `reley` и в аргументах запишите вызов функции `norm` c аргументами `0, 5`. Сохраните возвращенное значение функцией `reley` в вещественной переменной y (игрек).

P. S. В консоль ничего выводить не нужно.

```c
#include <math.h>
#include <stdio.h>
#include <stdlib.h>

#define N 100

double norm(int a, int b) {
    double res = 0;
    size_t count = N;
    for (size_t i = 0; i < count; i++) {
        res += a + rand() % (b - a + 1);
    }
    return res / N;
}

double reley(double x1, double x2) {
    double res = sqrt(x1 * x1 + x2 * x2);
    return res;
}

int main(void) {
    double y = reley(norm(0, 5), norm(0, 5));

    printf("%.2lf", y);
    //__ASSERT_TESTS__
    // макроопределение для тестирования (не убирать и должно идти непосредственно перед return 0)
    return 0;
}
```

### Подвиг 5. Продолжите программу. Объявите функцию с именем reverse, которая имеет два параметра (порядок важен):
+ указатель на обрабатываемый массив типа `short`;
+ число обрабатываемых элементов массива.

Функция `reverse` должна "переворачивать" переданный массив, то есть, значения должны идти в обратном порядке: от последнего к первому.

Вызовите функцию `reverse` в функции `main` для массива `digs`. Выведите в консоль первые `count` значений массива `digs` в одну строчку через пробел.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/6.6.5

```c
#include <stdio.h>
#define MAX_SIZE 20

void swap(short* a, short* b) {
    short tmp = *a;
    *a = *b;
    *b = tmp;
}

void print_array(short array[], short size) {
    for (int i = 0; i < size; i++) {
        printf("%d%s", array[i], i == size - 1 ? "" : " ");
    }
}

void reverse(short* array, short size) {
    for (int i = 0; i < size / 2; i++) {
        swap((array + i), (array + size - i - 1));
    }
}

int main(void) {
    short digs[MAX_SIZE];
    int count = 0;
    while (count < MAX_SIZE && scanf("%hd", &digs[count]) == 1) count++;

    reverse(digs, count);

    print_array(digs, count);

    return 0;
}
```

### Подвиг 6. Продолжите программу. Объявите функцию с именем strip_str, которая имеет следующие параметры (порядок важен):
+ указатель на обрабатываемую корректную Си-строку;
+ указатель на строку с удаляемыми символами.

Функция `strip_str` должна из переданной ей строки удалить все символы, указанные в последнем параметре (строке с удаляемыми символами). Например, если указана строка `"!? &@"`, то все эти символы, где бы они в строке ни находились и в каком бы порядке ни шли, следует удалить.

В функции `main` вызовите функцию `strip_str` для строки `str` и укажите удалить из нее символы `".,-!?"`. Выведите полученную строку в консоль.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/6.6.6

```c
#include <stdio.h>
#include <string.h>

void strip_str(char* str, const char* strip) {
    char *ptr = str, shift = 0;
    while (*ptr != '\0') {
        *(ptr - shift) = *ptr;
        if (strchr(strip, *ptr) != NULL) shift++;
        ptr++;
    }
    *(ptr - shift) = '\0';
    return;
}

int main(void) {
    char str[100] = {0}, str2[20] = ".,-!?";
    fgets(str, sizeof(str) - 1, stdin);
    char* ptr_n = strrchr(str, '\n');
    if (ptr_n != NULL) *ptr_n = '\0';

    char* str_ptr = str;
    const char* str2_ptr = str2;

    strip_str(str_ptr, str2_ptr);

    puts(str);

    return 0;
}
```

```c
#include <stdio.h>
#include <string.h>

// void strip_str(char* str, const char* strip) {
//     char *ptr = str, shift = 0;
//     while (*ptr != '\0') {
//         *(ptr - shift) = *ptr;
//         if (strchr(strip, *ptr) != NULL) shift++;
//         ptr++;
//     }
//     *(ptr - shift) = '\0';
//     return;
// }

void strip_str(const char* str, const char* find) {
    char* ptr = strpbrk(str, find);
    while (ptr) {
        strcpy(ptr, ptr + 1);
        ptr = strpbrk(str, find);
    }

    return;
}

int main(void) {
    char str[100] = {0}, str2[20] = ".,-!?";
    fgets(str, sizeof(str) - 1, stdin);
    char* ptr_n = strrchr(str, '\n');
    if (ptr_n != NULL) *ptr_n = '\0';

    const char* str_ptr = str;
    const char* str2_ptr = str2;

    strip_str(str_ptr, str2_ptr);

    puts(str);

    return 0;
}
```

### Подвиг 7 (на повторение). Установите соответствия между спецификаторами функции printf() и их описаниями.

![06](/Good_good_C_C++/img/06_10.PNG)

### Подвиг 8 (на повторение). Установите соответствия между операторами и их описаниями.

![06](/Good_good_C_C++/img/06_11.PNG)

# 6.7 Рекурсивные функции

На прошлом занятии мы увидели, что локальные переменные и значения аргументов функции при ее вызове помещаются в стековый фрейм. 

Благодаря такой организации данных у нас автоматически появляется довольно интересная возможность вызывать функции из самих себя с разными входными данными. 

Это называется рекурсией. А функции, которые это выполняют, рекурсивными.

Давайте посмотрим на работу очень простой рекурсивной функции:

```c
#include <stdio.h>

void rcs(int x) {
    printf("Down: x = %d\n", x);

    if (x > 1) rcs(x - 1);

    printf("Up: x = %d\n", x);
}

int main(void) {
    rcs(4);

    return 0;
}
```

Здесь функция `rcs()` пока значение параметра `x` больше единицы вызывает саму себя с аргументом `x-1`, то есть, на единицу меньше. 

Что в итоге будет происходить? 

При первом вызове в стек помещается значение параметра `x=4` вместе с адресом возврата. Затем, отрабатывает первая функция `printf()` и на экране отображается строка:

```
Down: x = 4
```

После проверки условия снова вызывается функция `rcs(3)` с аргументом `3`. В стек помещается новое значение параметра `x=3` и выполнение начинается с самого начала функции. Снова отрабатывает `printf()` с выводом на экран следующей строчки:

```
Down: x = 3
```

И так далее. Для `rcs(2)` увидим строку:

```
Down: x = 2
```

а для `rcs(1)` строчку:

```
Down: x = 1
```

После этого переходим на проверку условия. Оно оказывается ложным, поэтому попадаем на вторую функцию `printf()`, которая выводит сообщение:

```
Up: x = 1
```

Что происходит дальше? Из стека извлекается адрес возврата на вторую функцию `printf()`, указатель стека перемещается на предыдущий блок данных, в которых параметр `x` равен `2`. Поэтому функция `printf()` отрабатывает с этим значением `x=2`. Видим на экране строку:

```
Up: x = 2
```

На этом выполнение функции завершается. Снова берется из стека адрес возврата на вторую функцию `printf()`, указатель стека перемещается на блок с данными предыдущего вызова, в котором `x = 3`. Получаем строку:

```
Up: x = 3
```

И также с последним вызовом:

```
Up: x = 4
```

Условно рекурсивный вызов функции `rcs()` можно изобразить следующим образом:

![06](/Good_good_C_C++/img/06_12.jpg)

Сначала срабатывает `rcs(3)`, затем, она вызывает функцию `rcs(2)`, а та, в свою очередь, функцию `rcs(1)`. Последняя функция не продолжает рекурсию, так как условие становится ложным. Сразу отрабатывает вторая функция `printf()` и текущий вызов завершает свою работу. Осуществляется переход (возврат) к вызывающей функции `rcs(2)`. Она продолжает свое выполнение со второй функции `printf()`. Затем, также завершает свою работу и мы переходим к функции `rcs(3)`.

Вот принцип работы рекурсии. 

При этом, когда движение идет вглубь, то имеем прямой ход рекурсии, а при возврате – обратный ход. Максимальное число вызовов рекурсивной функции называют глубиной рекурсии.

## Пример использования рекурсивной функции

Надеюсь, общий принцип работы рекурсивных функций вам понятен. 

И, возможно, остается один важный вопрос, зачем они нужны и где имеет смысл их применять? 

Давайте для этого рассмотрим реальную практическую задачу. 

Предположим, у нас есть некоторое игровое поле `pole` размером 5х5 клеток и в каждой клетке может быть число от `0` до `255`.

Что это за числа и какую роль они несут сейчас совершенно неважно. 

Изначально все клетки поля закрыты от игрока. 

Эту информацию мы будем хранить во втором массиве `ppole` также размером 5х5. И будем полагать, если клетка `ppole` имеет значение `0`, значит, она закрыта, а иначе открыта. 

Когда игрок открывает какую-либо клетку со значением `0` на игровом поле `pole`, то должны автоматически открываться все соседние клетки с нулевыми значениями, стоящие по горизонтали и вертикали. Открытые клетки мы будем помечать значением `1` в массиве `ppole`. Соответственно, при открытии центральной клетки должны получать следующую картину:

![06](/Good_good_C_C++/img/06_13.jpg)

Эту задачу достаточно просто можно реализовать с помощью рекурсивной функции, например, так:

```c
#include <stdio.h>

#define N 5

void show_pole(const char (*p)[N]) {
    for (int i = 0; i < N; ++i) {
        for (int j = 0; j < N; ++j) printf("%c ", (p[i][j] == 0) ? '#' : '0');
        putchar('\n');
    }
}

void open_zeros(const char (*p)[N], char (*pp)[N], int i, int j) {
    if (p[i][j] != 0 || pp[i][j] == 1) return;

    pp[i][j] = 1;  // открываем клетку

    if (i - 1 >= 0 && p[i - 1][j] == 0) open_zeros(p, pp, i - 1, j);
    if (i + 1 < N && p[i + 1][j] == 0) open_zeros(p, pp, i + 1, j);
    if (j - 1 >= 0 && p[i][j - 1] == 0) open_zeros(p, pp, i, j - 1);
    if (j + 1 < N && p[i][j + 1] == 0) open_zeros(p, pp, i, j + 1);
}

int main(void) {
    char pole[N][N] = {
        {1, 1, 1, 1, 1}, 
        {1, 1, 0, 1, 1}, 
        {0, 0, 0, 0, 1}, 
        {1, 1, 0, 0, 0}, 
        {1, 1, 0, 1, 1},
    };

    char ppole[N][N] = {0};

    show_pole(ppole);
    open_zeros(pole, ppole, 2, 2);

    puts("--------------------");
    show_pole(ppole);

    return 0;
}
```
Здесь функция `show_pole()` отображает клетки игрового поля. А рекурсивная функция `open_zeros()` открывает все соседние клетки с нулевыми значениями.

Работает она очень просто. Вначале мы передаем ей оба массива и индексы начальной открываемой клетки. 

Если текущая клетка игрового поля содержит 0, то она открывается и запускается рекурсия во все соседние клетки:

![06](/Good_good_C_C++/img/06_14.png)

Если в соседних клетках также будет число `0`, то она откроется, и рекурсия от нее продолжится дальше. И так, пока вся группа связанных нулевых клеток не будет открыта.

После запуска программы увидим следующий результат:

```
# # # # #
# # 0 # #
0 0 0 0 #
# # 0 0 0
# # 0 # #
```

Как видите, все нужные клетки были открыты.

Вообще рекурсивные функции очень удобны, когда нам нужно перебрать некие иерархические данные, которые имеют сложную структуру, и обычными циклами их проходить было бы затруднительно. 

В частности, рекурсия используется для переборов вершин бинарных деревьев – довольно распространенной структуры данных следующего вида:

![06](/Good_good_C_C++/img/06_15.png)

Или для перебора каталогов и файлов:

![06](/Good_good_C_C++/img/06_16.png)

И так далее. Везде, где присутствует иерархичность можно подумать об использовании рекурсивных функций. Но нужно всегда помнить и об их недостатках. Они следующие:
+ рекурсивные вызовы работаю медленнее, чем итерации операторов циклов, поэтому, если задачу относительно просто можно реализовать через циклы, то именно их и следует применять;
+ рекурсия не может идти до бесконечности;
+ программа аварийно завершится, когда фреймовый стек будет полностью заполнен, поэтому если в задаче сложно оценить максимальную глубину рекурсии, то от использования рекурсивных функций лучше отказаться.

Видео по теме [#46. Рекурсивные функции](https://www.youtube.com/watch?v=GyMBhLnCE70&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, касающиеся рекурсивных функций языка Си.

+ [ ] рекурсивная функция - это та, которая использует рекурсивные вычисления
+ [x] параметры каждого вызова рекурсивной функции независимы между собой
+ [x] рекурсивная функция - это та, которая вызывает саму себя
+ [x] с помощью рекурсивных функций удобно делать иерархические (древовидные) переборы (например, файлов и каталогов на диске)
+ [x] вызов рекурсивной функции легко может привести к переполнению стека вызова функций

### Подвиг 2. Продолжите программу. Необходимо объявить рекурсивную функцию с именем recursive и одним целочисленным параметром, которая бы выводила в консоль в одну строчку через пробел целые числа в диапазоне от MAX_RECURSION до 1 (включительно).

P. S. В теле функции `recursive` не использовать какие-либо операторы циклов.

```c
#include <stdio.h>
#define MAX_RECURSION 4

void recursive(int num) {
    if (num > MAX_RECURSION) return;

    recursive(num + 1);

    printf("%d ", num);
    return;
}

int main(void) {
    recursive(1);

    return 0;
}
```

### Подвиг 3. Продолжите программу. Необходимо объявить рекурсивную функцию со следующей сигнатурой:

```c
size_t range_to_ar(int* ptr_a, size_t max_len, int from, int to, size_t count);
```

Эта функция должна последовательно заносить в переданный массив (через указатель `ptr_a`) целые числа в диапазоне `[from; to]` (включая границы) с шагом 1, не превышая длину массива `max_len`. Функция `range_to_ar` возвращает число `count` - записанных в массив значений (не более `max_len`).

В функции `main` выведите в консоль в одну строчку через пробел первые cnt значений массива ar.

P. S. В теле функции `range_to_ar` не использовать какие-либо операторы циклов.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/6.7.3

```c
#include <stdio.h>
#define MAX_LENGTH 20

size_t range_to_ar(int* ptr_a, size_t max_len, int from, int to, size_t count) {
    if (from > to || count >= max_len)
        return (size_t)(to - from + 1) > (size_t)max_len ? max_len : (size_t)(to - from + 1);

    ptr_a[count] = from;
    // printf("UP:%d %d\n", from, count);

    range_to_ar(ptr_a, max_len, from + 1, to, count + 1);

    // printf("DOWN:%d %d\n", from, count);

    return (size_t)(to - from + 1) > (size_t)max_len ? max_len : (size_t)(to - from + 1);
}

int main(void) {
    int max_rec;
    int ar[MAX_LENGTH];
    scanf("%d", &max_rec);

    size_t cnt = range_to_ar(ar, MAX_LENGTH, 1, max_rec, 0);

    // printf("%d\n", cnt);

    for (size_t i = 0; i < cnt; i++) {
        printf("%d ", ar[i]);
    }

    return 0;
}
```

```c
size_t range_to_ar(int* ptr_a, size_t max_len, int from, int to, size_t count) {
    if (from > to || count == max_len) {
        return count;
    }

    *(ptr_a + count) = from;
    return range_to_ar(ptr_a, max_len, ++from, to, ++count);
}
```


### Подвиг 4. Продолжите программу. Объявите рекурсивную функцию со следующей сигнатурой:

```c
int sum_ar(const short* ar, size_t len, size_t indx);
```

которая вычисляет сумму значений элементов переданного массива `ar` и возвращает вычисленное значение.

Вспомогательный параметр `indx` (с начальным значением `0`) служит для перебора элементов массива `ar` при рекурсивном вызове функции `sum_ar`.

В функции main вызовите функцию `sum_ar` и выведите в консоль возвращенной ей значение в виде целого числа.

P. S. В теле функции `sum_ar` не использовать какие-либо операторы циклов.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/6.7.4

```c
#include <stdio.h>
#define MAX_LENGTH 20

int sum_ar(const short* ar, size_t len, size_t indx) {
    if (indx == len) return 0;
    // printf("%d ", ar[indx]);
    return ar[indx] + sum_ar(ar, len, indx + 1);
}

int main(void) {
    short ar[MAX_LENGTH];
    int count = 0;
    while (count < MAX_LENGTH && scanf("%hd", &ar[count]) != EOF) count++;
    // printf("%d ", count);
    int sum = sum_ar(ar, count, 0);

    printf("%d ", sum);

    return 0;
}
```

### Подвиг 5*. Продолжите программу. Необходимо дописать рекурсивную функцию to_flat, которая в одномерный массив v по порядку заносит целые числа из таблицы чисел table. Таблица представляет собой массив указателей на целочисленные массивы:

![06](/Good_good_C_C++/img/06_17.png)

В конце каждого одномерного массива всегда стоит число `0` - маркер конца данных. Максимальное число записываемых в массив `v` данных составляет `max_len_v` (превышать это значение нельзя). На выходе функция `to_flat` возвращает количество записанных в массив v числовых значений.

Например, для следующих данных:

```c
short ar_1[] = {1, 2, 3, 0};
short ar_2[] = {4, 5, 6, 7, 8, 0};
short ar_3[] = {-1, -2, 0};
short ar_4[] = {-3, -4, -5, 0};
short * table[] = {ar_1, ar_4, ar_3, ar_2};
```
Функция `to_flat` в массив v должна занести числовые значения:

```
1 2 3 -3 -4 -5 -1 -2 4 5 6 7 8
```

P. S. Рекурсивная функция `to_flat` ничего в консоль выводить не должна. Также в теле функции `to_flat` недопустимо использовать какие-либо операторы циклов.

```c
#include <stdio.h>
#define MAX_LENGTH 20

size_t to_flat(short* v,         /* массив, в который заносятся значения */
               size_t max_len_v, /* максимальная длина массива v */
               short* table[], /* массив на массив, из которого читаются значения */
               size_t len,     /* длина массива table (первая размерность) */
               size_t count_v, /* число записанных в массив v значений (начальное значение 0) */
               size_t indx_t, /* индекс для перебора указателей (первой размерности) массива table
               (начальное
                                 значение 0) */
               size_t indx) /* индекс для перебора элементов массивов (условно, вторая размерность),
                               на которые ссылается текущий указатель table[indx_t] (начальное значение
                               0)*/
{
    // for (indx_t = 0; indx_t < len; indx_t++) {
    //     for (indx = 0; table[indx_t][indx] != 0; indx++) {
    //         v[count_v] = table[indx_t][indx];
    //         // printf("%d = %d ", count_v, v[count_v]);
    //         if (++count_v == max_len_v) return count_v;
    //     }
    // }

    // return count_v;

    if (indx_t < len && count_v < max_len_v) {
        if (table[indx_t][indx]) {
            v[count_v++] = table[indx_t][indx++];
        } else {
            indx_t++;
            indx = 0;
        }
    } else {
        return count_v;
    }

    return to_flat(v, max_len_v, table, len, count_v, indx_t, indx);
}

int main(void) {
    short ar_1[] = {-4, 2, 3, 7, 0};
    short ar_2[] = {11, 6, 10, 8, 13, 98, -5, 0};
    short ar_3[] = {-47, 0};
    short ar_4[] = {8, 11, 56, -3, -2, 0};

    short* table[] = {ar_1, ar_4, ar_3, ar_2};

    short flat[MAX_LENGTH];
    size_t cnt = to_flat(flat, MAX_LENGTH, table, sizeof(table) / sizeof(*table), 0, 0, 0);

    // printf("\n%d\n", (int)cnt);

    for (size_t i = 0; i < cnt; i++) {
        printf("%d ", flat[i]);
    }
    return 0;
}
```

### Подвиг 6* (на повторение). Напишите программу, которая читает строку из входного потока (строку целиком до символа переноса строки). Необходимо ее закодировать азбукой Морзе, где каждой букве ставится в соответствие код (в виде фрагмента строки) из точки и тире. После каждой закодированной буквы должен идти пробел (символ окончания кода буквы). После последнего кода пробела быть не должно (в конце строки). 

Коды азбуки Морзе приведены ниже для латинского алфавита (большие и малые буквы кодируются одинаково), цифр и символа пробела:

|||||||||
-|-|-|-|-|-|-|-
A | `.-` | J | `.---` | S | `...` | 2 | `..---`
B | `-...` | K | `-.-` | T | `-` | 3 | `...--`
C | `-.-.` | L | `.-..` | U | `..-` | 4 | `....-`
D | `-..` | M | `--` | V | `...-` | 5 | `.....`
E | `.` | N | `-.` | W | `.--` | 6 | `-....`
F | `..-.` | O | `---` | X | `-..-` | 7 | `--...`
G | `--.` | P | `.--.` | Y | `-.--` | 8 | `---..`
H | `....` | Q | `--.-` | Z | `--..` | 9 | `----.`
I | `..` | R | `.-.` | 1 | `.----` | 0 | `-----`

Пробел   `-...-`

Результат кодирования вывести в консоль виде строки.

P. S. Само кодирование лучше реализовать в виде отдельной функции, которой передается формируемая строка, исходная строка и массив азбуки Морзе.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/6.7.6

```c
#include <ctype.h>
#include <stdio.h>
#include <string.h>

char* char_to_morse(char ch) {
    char symbols[] = "AJS2BKT3CLU4DMV5ENW6FOX7GPY8HQZ9IR10 ";
    size_t len = strlen(symbols);
    char* morse[] = {".-",   ".---",  "...",  "..---", "-...",  "-.-",   "-",    "...--", "-.-.", ".-..",
                     "..-",  "....-", "-..",  "--",    "...-",  ".....", ".",    "-.",    ".--",  "-....",
                     "..-.", "---",   "-..-", "--...", "--.",   ".--.",  "-.--", "---..", "....", "--.-",
                     "--..", "----.", "..",   ".-.",   ".----", "-----", "-...-"};
    for (size_t i = 0; i < len; i++) {
        if (symbols[i] == toupper(ch)) return morse[i];
    }
    return " ";
}

void str_to_morse(char* str) {
    for (size_t i = 0; str[i] != '\0'; i++) {
        printf("%s%s", char_to_morse(str[i]), str[i + 1] == '\0' ? "" : " ");
    }
}

int main(void) {
    char str[100] = {0};
    fgets(str, sizeof(str) - 1, stdin);
    char* ptr_n = strrchr(str, '\n');
    if (ptr_n != NULL) *ptr_n = '\0';

    str_to_morse(str);

    return 0;
}
```

### Подвиг 7* (обратный подвигу 6). Напишите программу, которая читает закодированную строку с помощью азбуки Морзе. Коды разделены между собой пробелом. Необходимо ее раскодировать, используя азбуку Морзе из предыдущего занятия:

|||||||||
-|-|-|-|-|-|-|-
A | `.-` | J | `.---` | S | `...` | 2 | `..---`
B | `-...` | K | `-.-` | T | `-` | 3 | `...--`
C | `-.-.` | L | `.-..` | U | `..-` | 4 | `....-`
D | `-..` | M | `--` | V | `...-` | 5 | `.....`
E | `.` | N | `-.` | W | `.--` | 6 | `-....`
F | `..-.` | O | `---` | X | `-..-` | 7 | `--...`
G | `--.` | P | `.--.` | Y | `-.--` | 8 | `---..`
H | `....` | Q | `--.-` | Z | `--..` | 9 | `----.`
I | `..` | R | `.-.` | 1 | `.----` | 0 | `-----`

Пробел   `-...-`

Полученное сообщение (строку) вывести в консоль.

P. S. Декодирование лучше реализовать в виде отдельной функции, которой передается формируемая строка, исходная строка и массив азбуки Морзе.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/6.7.7

```c
#include <stdio.h>
#include <string.h>

char morse_to_char(const char* str) {
    const char symbols[] = "AJS2BKT3CLU4DMV5ENW6FOX7GPY8HQZ9IR10 ";
    size_t len = strlen(symbols);
    const char* morse[] = {".-",   ".---", "...",   "..---", "-...", "-.-",  "-",    "...--",
                           "-.-.", ".-..", "..-",   "....-", "-..",  "--",   "...-", ".....",
                           ".",    "-.",   ".--",   "-....", "..-.", "---",  "-..-", "--...",
                           "--.",  ".--.", "-.--",  "---..", "....", "--.-", "--..", "----.",
                           "..",   ".-.",  ".----", "-----", "-...-"};
    for (size_t i = 0; i < len; i++) {
        if (strcmp(morse[i], str) == 0) return symbols[i];
    }
    return ' ';
}

void morse_to_str(const char* str, size_t len) {
    char s[6] = {0};
    int count = 0;
    for (size_t i = 0; i <= len; i++) {
        if (str[i] == ' ' || str[i] == '\0') {
            s[count] = '\0';
            printf("%c", morse_to_char(s));
            // printf("%s", s);
            count = 0;
            continue;
        }
        s[count++] = str[i];
    }
}

int main(void) {
    char str[100] = {0};
    fgets(str, sizeof(str) - 1, stdin);
    char* ptr_n = strrchr(str, '\n');
    if (ptr_n != NULL) *ptr_n = '\0';
    size_t len = strlen(str);
    morse_to_str(str, len);

    return 0;
}
```

### Подвиг 8 (на повторение). Выберите все верные утверждения, касающиеся функций языка Си.

+ [x] для использования функции в программе достаточно объявить ее прототип
+ [x] прототип функции - это ее заголовок, например: int abs(int x);
+ [ ] прототип функции - это ее заголовок вместе с телом функции, например: int abs(int x) {...}
+ [ ] в заголовочных файлах, как правило, прописаны реализации функций (вместе с телом)
+ [x] прототипы удобны, когда нужно разделить объявление функции от ее реализации
+ [x] в заголовочных файлах, как правило, записаны прототипы функций

### Подвиг 9 (на повторение). Установите соответствия между названиями функций и их описаниями.

![06](/Good_good_C_C++/img/06_18.PNG)

# 6.8 Функции с произвольным числом параметров

На этом занятии познакомимся с еще одной возможностью языка Си – объявлять и вызывать функции с произвольным числом аргументов. Такие функции еще называют __вариадическими__.

Вначале я сразу приведу пример такой функции, которая просто вычисляет сумму, переданных ей целочисленных значений:

```c
#include <stdarg.h>
#include <stdio.h>

int sum(int count, ...) {
    int s = 0;
    va_list arg;  // указатель на параметр
    va_start(arg, count);  // получение адреса первого вариадического параметра

    for (int i = 0; i < count; ++i) {
        s += va_arg(arg, int);  // получение значение вариадического параметра
                                // и переход к следующему параметру
    }

    va_end(arg);  // завершение процедуры перебора вариадических параметров

    return s;
}

int main(void) {
    int res = sum(5, 1, 2, 3, 4, 5);
    printf("res = %d\n", res);

    return 0;
}
```

А теперь давайте детально разберемся, как работает эта программа. 

Вначале нам необходимо подключить заголовочный файл `stdarg.h`, в котором определен тип `va_list` для указателя по вариадическим параметрам функции (то есть, переменным параметрам, которые формируются при ее вызове). Кроме того, в файле `stdarg.h` определены следующие функции:

```c
va_start() // для получения указателя на первый вариадический параметр функции (тот, что идет после параметра count в нашем примере);
va_arg() // для получения значения текущего параметра и переход к следующему вариадическому параметру;
va_end() // для завершения процедуры перебора (это необходимо, если потребуется новый обход параметров, тогда нужно будет снова вызвать va_start() и va_arg() для извлечения значений).
```

После подключения всех необходимых файлов идет объявление вариадической функции с именем `sum()`.

У таких функций вначале должен быть прописан хотя бы один обычный параметр. В нашем примере – это `count`.

А уже в конце можно поставить многоточие, означающее, что функция может принимать произвольное число аргументов. 

В теле функции объявляется вспомогательная переменная `s` с начальным значением `0`, в которой будет храниться сумма значений, а далее идет объявление указателя `arg` для перебора вариадических параметров. 

С помощью функции `va_start()` выполняется инициализация этого указателя на первый вариадический параметр. 

При этом вторым аргументом мы должны указать обычный параметр, стоящий непосредственно перед многоточием при объявлении функции `sum()`. 

После этого в цикле происходит перебор `count` значений (мы полагаем, что число вариадических параметров не менее `count`, а в идеале равно ему) с помощью функции `va_arg()`. 

Этой функции передается указатель `arg` и тип текущего вариадического параметра. 

Мы полагаем, что все значения имеют тип `int`. В конце после цикла вызывается завершающая функция `va_end()`.

После запуска этой программы увидим следующий результат:

```
res = 15
```

то есть, были просуммированы переданные числа:

$1+2+3+4+5 = 15$

Обратите внимание, первый параметр у нас хранит число вариадических параметров и это значение мы прописываем сами. Например, если при вызове функции `sum()` первым аргументом указать меньшее число:

```c
int res = sum(3, 1, 2, 3, 4, 5);
```

то будут просуммированы только первые три числа (из вариадических аргументов) и получим значение:

$1+2+3 = 6$

То есть, внутри функции `sum()` мы не знаем сколько аргументов в реальности было передано и просто доверяем значению в переменной `count`. Это один из недостатков вариадических функций. 

Нам как то нужно дополнительно передавать информацию о числе вариадических параметров. 

Например, функции:

```c
int printf(const char *format, ...);
int scanf(const char *format, ...);
```

определяют это число из анализа форматной строки. 

Сколько было прописано спецификаторов, столько и выбирается вариадических параметров, даже если реально их там указано больше или меньше. В последнем случае, конечно же, возникнет ошибка.

## Вариадические функции и стековый фрейм

Вообще механизм работы вариадических функций достаточно прост. 

Я напомню, что в момент вызова какой-либо функции, все аргументы, указанные при ее вызове, автоматически копируются во фреймовый стек, начиная с последнего. Поэтому вызов функции:

```c
int res = sum(5, 1, 2, 3, 4, 5);
```
приводит к формированию следующей информации:

![06](/Good_good_C_C++/img/06_19.png)

Далее, когда выполняется функция `va_start(arg, count)`, то не составляет труда определить адрес первого вариадического параметра, на который будет ссылаться указатель `arg`. А последующие вызовы функции `va_arg(arg, int)` с указанием типа данных текущего параметра, позволяют прочитать значения из ячеек памяти, которые он занимает, правильно их интерпретировать (в виде целочисленного значения) и переместить указатель на начало следующего вариадического параметра. 

И так в цикле прочитать и перебрать все вариадические значения, указанные при вызове функции `sum()`. Вот общий принцип работы функций с произвольным числом аргументов.

## Заключение

Надо сказать, что вариадические функции очень редко используются на практике, так как они не так удобны, как обычные функции и к тому же не дают полного понимания о наборе этих вариадических параметров. 

Сторонний программист, глядя на объявление с многоточием не сразу поймет, что подается на вход такой функции и какую роль играют эти аргументы. Поэтому к ним лучше прибегать только в исключительных случаях, когда очевиден плюс от их использования.

## Дополнение для языка С++

Если вы в будущем планируете программировать на языке С++, то важно знать еще две ключевые его возможности:
+ перегрузка функций;
+ функции с параметрами по умолчанию.

Я здесь рассмотрю их кратко.

### Перегрузка функций
Перегрузка функций позволяет создавать несколько функций с одинаковыми именами, но разным набором параметров. Например, нам нужна функция для вычисления модуля числа, как для целочисленных значений, так и для вещественных. Это можно сделать на языке С++ следующим образом:

```cpp
#include <iostream>
using namespace std;

int modul(int x) {
    return (x < 0) ? -x : x; 
}

double modul(double x) {
    return (x < 0) ? -x : x; 
}

int main(void) {
    int a1 = modul(-3);
    int a2 = modul(-3.5);
    double a3 = modul(-3);
    double a4 = modul(-3.5);

    return 0;
}
```

Здесь записаны две функции `modul` с разными типами параметра `x`. Затем, в функции `main` осуществляется их вызов. 

Как вы думаете, как компилятор определяет какую из двух функций нужно вызвать? Делается это по типу входных аргументов. 

То есть, если записано `-3`, значит, будет вызвана функция `modul` с целочисленным параметром. Если же стоит вещественное число `-3.5`, то вызовется функция `modul` с вещественным параметром. 

При этом возвращаемые типы не играют никакой роли в выборе функции `modul`. Значение имеют только входные типы.

Возможно, у вас здесь возникает вопрос: зачем вообще делать перегрузку, давайте объявим одну функцию с вещественным типом, и она будет работать также и с целочисленными значениями? 

Все верно, но работать это будет дольше, так как обработка целочисленных данных как вещественных требует большего машинного времени. 

Поэтому перегрузка здесь позволяет несколько ускорить работу программы и, при этом, от программиста не требуется никаких дополнительных действий (кроме объявления нужного набора функций).

### Параметры со значениями по умолчанию

Следующий момент работы с функциями связан с параметрами со значениями по умолчанию. То есть, им сразу присваивается некоторое начальное значение, и если при вызове функции аргументы в них не будут подставлены, то эти параметры останутся с заранее прописанным значением. Например:

```cpp
#include<iostream>
using namespace std;
 
void show_args(short a=10, double b=20.0, int c=30) {
    printf("a = %d, b = %.2f, c = %d\n", a, b, c);
}
 
int main() {
    show_args();
    show_args(1);
    show_args(1, 2);
    show_args(1, 2, 3);
 
    return 0;
}
```

Смотрите, в момент объявления функции ее параметрам сразу присвоены начальные значения. Благодаря этому функцию `show_args` можно вызывать с разным набором аргументов. После запуска программы увидим результат:

```
a = 10, b = 20.00, c = 30
a = 1, b = 20.00, c = 30
a = 1, b = 2.00, c = 30
a = 1, b = 2.00, c = 3
```

Но, обратите внимание, параметры со значениями по умолчанию должны быть записаны в конце списка параметров функции. Вот примеры правильных и неправильных объявлений:

```cpp
void my_func(int a, int b = 1, int c = 1);    //правильное объявление
void my_func(int a, int b, int c = 1);          //правильное объявление
void my_func(int a=1, int b, int c = 1);      //неправильное объявление
void my_func(int a, int b = 1, int c);          //неправильное объявление
```

Теперь вы знаете все основные моменты работы с функциями в языке Си и С++.
## Подвиги

### Подвиг 1. Выберите все верные утверждения, касающиеся вариадических функций.

+ [x] вариадическая функция "не знает" о настоящем количестве вариадических параметров
+ [ ] вариадическая функция "знает" о количестве вариадических параметров
+ [x] вариадическая функция должна иметь хотя бы один явно прописанный параметр
+ [ ] вариадическая функция может быть прописана только с вариадическими параметрами
+ [x] для обработки вариадических параметров функции необходимо подключение заголовка stdarg.h
+ [x] вариадические параметры всегда располагаются последними в списке параметров функции

### Подвиг 2. Установите соответствия между определениями и функциями и их описаниями.

![06](/Good_good_C_C++/img/06_20.PNG)

### Подвиг 3. Объявите в программе вариадическую функцию со следующей сигнатурой:

```c
double mean(int total, ...);
```

Функция `mean` должна вычислять среднее арифметическое переданных ей `total` целочисленных значений типа `int` и возвращать вычисленный результат.

В функции `main` вызовите функцию `mean` для вычисления среднего арифметического чисел с аргументами:

```
7, 5, -10, 11, 0, 12, 4, 2
```

Здесь первое значение `7` - это значение переменной `total`, остальные семь чисел - вариадические для вычисления среднего арифметического.

Выведите возвращенное значение функции mean в консоль в виде вещественного числа с точностью до сотых.

```c
#include <stdarg.h>
#include <stdio.h>

double mean(int total, ...) {
    int res = 0;
    va_list arg;  // указатель на параметр
    va_start(arg, total);  // получение адреса первого вариадического параметра

    for (int i = 0; i < total; i++) {
        res += va_arg(arg, int);  // получение значение вариадического параметра
                                  // и переход к следующему параметру
    }

    va_end(arg);  // завершение процедуры перебора вариадических параметров

    return res / (double)total;
}

int main(void) {
    double res = mean(7, 5, -10, 11, 0, 12, 4, 2);
    printf("%.2lf", res);

    return 0;
}
```

### Подвиг 4. Объявите в программе вариадическую функцию с именем v_norm2, в которой должны быть определены следующие параметры (порядок важен):
+ указатель на строку (массив типа char);
+ вариадические параметры (тип double).

Функция `v_norm2` должна вычислять норму вектора по следующему правилу:
+ если в первом параметре строка "vector2", то вектор имеет две координаты;
+ если в первом параметре строка "vector3", то вектор имеет три координаты;
+ если в первом параметре строка "vector4", то вектор имеет четыре координаты;
+ если в первом параметре иная строка, то норма не вычисляется и возвращается 0.0.

Квадратичная норма вектора вычисляется по формуле:

$norm2=x^2 + y^2 +...$

где x, y, ... - координаты вектора (передаются через вариадические параметры). 

Функция `v_norm2` должна возвращать вычисленную норму в виде вещественного числа типа `double`.

В функции `main` вызовите функцию `v_norm2` для вычисления квадратичной нормы двумерного вектора с координатами `1.0` и `2.0`. Выведите результат в консоль в виде вещественного числа с точностью до десятых.

```c
#include <stdarg.h>
#include <stdio.h>
#include <string.h>

double v_norm2(char* format, ...) {
    double res = 0;
    va_list arg;
    va_start(arg, format);
    int total;
    if (strcmp(format, "vector2") == 0)
        total = 2;
    else if (strcmp(format, "vector3") == 0)
        total = 3;
    else if (strcmp(format, "vector4") == 0)
        total = 4;
    else {
        va_end(arg);
        return 0.0;
    }
    for (int i = 0; i < total; i++) {
        double coord = va_arg(arg, double);
        res += coord * coord;
    }

    va_end(arg);

    return res;
}

int main(void) {
    double res = v_norm2("vector2", 1.0, 2.0);
    printf("%.1lf", res);

    return 0;
}
```

### Подвиг 5. Продолжите программу. Объявите вариадическую функцию с именем sumf со следующей сигнатурой:

```c
double sumf(const char* format, ...);
```

Данная функция должна вычислять сумму переданных вариадических значений типа `double` в соответствии с форматной строкой `(format)`. 

Правило суммирования следующее. 

Если текущий символ форматной строки равен `'+'`, то соответствующий вариадический параметр участвует в суммировании, иначе - пропускается. Например, формат:

`"+ + +"`

определяет сумму 1-го, 3-го и 5-го значений вариадических параметров. Функция `sumf` должна возвращать вычисленное значение суммы.

P. S. Посмотрите что будет, если функцию `sumf` вызвать с целыми числами:

```c
double res = sumf("++ + +", 1, 2, 3, 4, 5, 6);
```

Объясните (себе) полученный результат.

```c
#include <stdarg.h>
#include <stdio.h>
#include <string.h>

double sumf(const char* format, ...) {
    double res = 0;
    va_list arg;
    va_start(arg, format);
    int total = strlen(format);
    for (int i = 0; i < total; i++) {
        double num = va_arg(arg, double);
        if (format[i] == '+') {
            res += num;
        }
    }
    return res;
}

int main(void) {
    double res = sumf("++ + +", 1.0, 2.0, 3.0, 4.0, 5.0, 6.0);
    printf("%.2f ", res);

    return 0;
}
```

### Подвиг 6. Объявите в программе вариадическую функцию с именем ar_fill, в которой должны быть определены следующие параметры (порядок важен):
+ указатель на массив типа `double`;
+ число записываемых в массив значений (тип `size_t`);
+ вариадические параметры (тип `double`).
Функция `ar_fill` должна в указанный массив по порядку заносить значения вариадических параметров, число которых указано во втором параметре функции. Функция `ar_fill` ничего не должна возвращать.

Вызовите функцию `ar_fill` в функции main для заполнения вещественного массива `weights` значениями:

```c
0.1, 0.2, 0.3, 0.4, 0.5
```

P. S. В консоль ничего выводить не нужно.

```c
#include <stdarg.h>
#include <stdio.h>
#define MAX 100
#define COUNT 5

void ar_fill(double* ar, size_t len, ...) {
    va_list arg;
    va_start(arg, len);  // позволяет указать, счетчик вариадических переменных
    for (size_t i = 0; i < len; i++) {
        ar[i] = va_arg(arg, double);
    }
    va_end(arg);
    return;
}

int main(void) {
    double array[MAX] = {0}, *ptr = array;
    size_t count = COUNT;
    ar_fill(ptr, count, 0.1, 0.2, 0.3, 0.4, 0.5);
    // for (int i = 0; i < COUNT; i++) {
    //     printf("%.1lf ", array[i]);
    // }

    return 0;
}
```

### Подвиг 7. Продолжите программу. Объявите вариадическую функцию с именем ar_scan, в которой должны быть определены следующие параметры (порядок важен):
+ указатель на массив типа `double`;
+ число записываемых из массива в переменные значений (тип `size_t`);
+ вариадические параметры (тип `double *`).

Функция `ar_scan` должна из переданного массива последовательно читать значения указанного числа элементов (второй параметр) и записывать их в переменные, адреса которых хранятся в вариадических параметрах. В функции `main` уже реализован вызов функции `ar_scan`.

```c

#include <stdarg.h>
#include <stdio.h>

void ar_scan(const double *ar, size_t len, ...) {
    va_list arg;
    va_start(arg, len);
    for (size_t i = 0; i < len; i++) {
        *(va_arg(arg, double *)) = ar[i];
    }
    va_end(arg);
    return;
}

int main(void) {
    const double weights[40] = {1.25, 4.34, -5.43, 0.01, -0.8};
    double w1, w2, w3;
    ar_scan(weights, 3, &w1, &w2, &w3);

    printf("%.2f %.2f %.2f", w1, w2, w3);

    return 0;
}
```

### Подвиг 8 (на повторение). Допишите программу. Объявите функцию с именем get_data_csv со следующими параметрами (порядок параметров должен соблюдаться):
+ массив вещественных чисел;
+ максимальная длина массива (неотрицательное целое число);
+ указатель на корректную Си-строку.

Функция `get_data_csv` должна из переданной ей строки выделять и сохранять в переданный массив вещественные числа, которые записаны в формате:

"csv: <число 1>; <число 2>; ...; <число N>"

Например:

"csv: 0.56; -65.43; 0.1; 11.0"

Необходимо выделенные числа сохранять в переданном массиве в количестве не превышающем длину массива 20 элементов. Функция `get_data_csv` должна возвращать количество (целое число) записанных в массив вещественных чисел.

В функции `main` вызвать функцию `get_data_csv` для строки `str` и вывести в консоль выделенные в массив вещественные числа в одну строчку через пробел с точностью до сотых.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAX 20

int get_data_csv(double arr[], size_t len, char* str) {
    char* ptr = str;
    int res = 0;
    for (size_t i = 0; i < len; i++) {
        ptr = strpbrk(ptr, ";:");
        if (ptr == NULL) break;
        // printf("%s\n", ptr);
        arr[i] = atof(++ptr);
        res++;
    }
    return res;
}

int main(void) {
    char str[100] = {0};
    fgets(str, sizeof(str) - 1, stdin);
    char* ptr_n = strrchr(str, '\n');
    if (ptr_n != NULL) *ptr_n = '\0';

    double numbers[MAX];
    ptr_n = str;
    int count = get_data_csv(numbers, MAX, ptr_n);

    for (int i = 0; i < count; i++) {
        printf("%.2lf ", numbers[i]);
    }

    return 0;
}
```

### Подвиг 9 (на повторение). Выберите все верные утверждения, касающиеся указателей в параметрах функций языка Си.


+ [x] через указатели в функции можно передавать массивы и строки
+ [ ] через указатели в функции можно передавать только одномерные массивы (не многомерные)
+ [x] посредством указателей в параметрах можно получить доступ к локальным переменным, объявленным в других функциях
+ [ ] через указатели в функции можно передавать только обычные переменные базовых типов, исключая массивы
+ [x] посредством указателей в параметрах функция получает возможность менять сразу несколько внешних переменных

