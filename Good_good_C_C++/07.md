# 7. Классы памяти. Составные типы

# 7.1 Локальные и глобальные переменные

На этом занятии поговорим об областях видимости переменных. О чем здесь речь? Смотрите. Переменные в программе можно объявлять, по сути, в двух разных местах: внутри функций (включая их параметры) и вне каких-либо функций – во внешнем блоке кода:

```c
#include <stdio.h>
/* Внешний блок кода */
char name[] = "Variables";

int main(void) {
    int var_main; /* внутренняя переменная */
    return 0;
}
```

Так вот, переменные внутри функций и вне их ведут себя по-разному. Начнем с внутренних переменных.

## Локальные переменные

Когда мы с вами рассматривали функции, то видели, что параметры и переменные, объявленные непосредственно внутри тела функции создаются в стековом фрейме в момент ее вызова. 

А при завершении функции память с блоком ее данных как бы исчезает, а значит, пропадают и все значения переменных, связанных с работой этой функции. 

То есть, получается, что параметры функции и переменные, объявленные внутри тела функции, автоматически формируются в момент ее вызова и перестают существовать после ее завершения. 

Про такие переменные говорят, что они имеют область видимости в пределах функции и являются автоматическими (автоматически создаются и уничтожаются). 

Кроме того, все переменные с ограниченной областью видимости называются локальными.

Давайте детальнее посмотрим на поведение локальных переменных. 

Предположим мы имеем объявление целочисленной локальной переменной с именем `var_main` в функции `main()`. 

Эта переменная не инициализирована никаким начальным значением. 

Спрашивается, чему она равна? 

В общем случае мы не сможем ответить на этот вопрос, так как переменная `var_main` будет размещена в некоторой области стекового фрейма и принимать значение из тех данных, которые будут находиться в ячейках этой переменной. 

Попросту говоря, значение переменной `var_main` неопределенное, случайное. 

Мы в этом с вами уже убеждались на одном из прошлых занятий, но сделаем это еще раз, выведем ее значение на экран:

```c
printf("%d\n", var_main);
```
После запуска программы высветилось значение:

```
3821568
```

И так со всеми локальными переменными, объявленными внутри тела функции. Все они размещаются в стековом фрейме и принимают неопределенное начальное значение.

Также нужно помнить, что стековый фрейм создается в момент запуска программы и, как правило, имеет фиксированный, ограниченный размер в памяти устройства. 

Это накладывает определенные ограничения на нас, как программистов: локальные переменные не должны занимать слишком много памяти. В частности, объявлять внутри функций массивы больших размеров далеко не лучшая практика. Например, так:

```c
int main(void) {
    int var_main; /* внутренняя переменная */
    double big_ar[100000];

    return 0;
}
```

Из-за массива `big_ar` размер стекового фрейма сразу сокращается на 800 000 байт! А если добавить еще один порядок к его размеру:

```c
double big_ar[1000000];
```

то стекового фрейма в моем случае будет и вовсе недостаточно для размещения такого объема данных! 

Поэтому логику программы следует продумывать так, чтобы все локальные переменные играли служебную, вспомогательную роль, а не содержали большие объемы данных, подменяя собой базы данных.

## Глобальные переменные

Несколько иная картина вырисовывается для переменных, объявленных вне каких-либо функций. Если мы перенесем наш большой массив во внешний блок кода:

```c
#include <stdio.h>
/* Внешний блок кода */
char name[] = "Variables";
double big_ar[1000000];

int main(void) {
    int var_main; /* внутренняя переменная */
    return 0;
}
```

то программа скомпилируется, запустится и завершится без каких-либо ошибок. 

С чем это связано? 

Смотрите. Все переменные из внешнего блока размещаются либо в секции `.bss`, если не инициализированы начальными значениями, либо в секции `.data`, если начальная инициализация присутствует:

![07](/Good_good_C_C++/img/07_01.jpg)

Эти секции формируются в момент загрузки программы и размещаются в оперативной памяти устройства. 

То есть, их размер ограничивается только доступной памятью компьютера и при этом они никак не связаны со стековым фреймом. 

Поэтому массив `big_ar` совершенно спокойно размещается в памяти и не мешает дальнейшей работе программы. 

В результате переменные в секциях `.bss` и `.data` формируются в момент загрузки программы и существуют на всем протяжении ее работы. 

В частности, это означает, что область видимости этих переменных не ограничена и их можно совершенно спокойно использовать в любом месте программы, как минимум, в пределах текущего файла. 

Про такие переменные говорят, что они имеют глобальную область видимости или просто глобальные.

Секция `.bss` после размещения в оперативной памяти автоматически заполняется нулями. 

В результате, все глобальные переменные, которые в нее попадают, имеют нулевые начальные значения. 

И в этом мы можем быть уверены. 

А значения переменных секции `.data` формируются в результате загрузки в нее данных из исполняемого файла. 

Да, содержимое всех переменных этой секции содержится непосредственно в файле программы, которое загружается в секцию `.data` в момент загрузки программы. 

С одной стороны это очень удобно, так как начальные значения инициализируются очень быстро, но с другой такие переменные можно инициализировать только константными величинами и соответствующими выражениями. Например, так:

```c
#include <stdio.h>
/* Внешний блок кода */
char name[] = "Variables";
int global_var_1 = 5;
int global_var_2 = 5 * 7;
int global_var_3 = sizeof(name) + 1;

int main(void) {
    int var_main; /* внутренняя переменная */
    return 0;
}
```

А вот, например, использовать переменные недопустимо:

```c
int global_var_4 = global_var_1;    // ошибка, нельзя использовать переменные
```

Хотя, если переменная будет объявлена с ключевым словом `const`, тогда компилятор поймет, что она неизменяема и подставит вместо нее соответствующее значение (ошибки не будет):

```c
const int global_var_1 = 5;
...
int global_var_4 = global_var_1;   // ok
```

Иначе обстоит дело с инициализацией локальных переменных. Так как они формируются в процессе работы программы, а не при ее загрузке, то их начальные значения можно определять любыми допустимыми выражениями языка Си. Например:

```c
#include <stdio.h>
char name[] = "Variables";
int global_var_1 = 5;
int global_var_2 = 5 * 7;
int global_var_3 = sizeof(name) + 1;

int main(void) {
    int a = 1;
    int b = a * 2 + global_var_2;
    int size = global_var_3 * 10;

    return 0;
}
```

Как видите, здесь вполне можно использовать обычные переменные, в том числе, и глобальные. 

Сразу отмечу, что использование глобальных переменных при реализации логики работы программы – это очень плохая практика. 

Связано это с тем, что значения таких переменных можно менять в любом месте программы, в любой функции текущего файла. 

Из-за этого поведение функций, использующие глобальные переменные, становится непредсказуемым. 

А ошибки, к которым они могут приводить, – трудно отслеживаемые. 

Поэтому в практике программирования на языке Си (и то же касается языка С++) глобальные переменные используются, как правило, для определения набора констант (числовых или строковых) и не более того. Очень редко имеет смысл объявлять переменную как глобальную.

Возможно, здесь у вас возникает вопрос: а как тогда нам в программе хранить данные большого размера, если для этого не стоит использовать стековый фрейм (то есть, локальные переменные) и глобальные переменные? 

На самом деле для таких целей, когда данные занимают от нескольких сот килобайт и более, лучше самостоятельно выделять нужный объем памяти и, затем, освобождать ее. Это можно сделать с помощью функций `malloc()` и `free()`, о которых мы еще будем говорить. А пока главное запомнить, что обычные переменные для представления больших данных, лучше не использовать.

Видео по теме [#48. Локальные и глобальные переменные](https://www.youtube.com/watch?v=0TeKFgaYDWg&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, касающиеся переменных языка Си.

+ [x] переменная является автоматической, если она определена внутри тела функции
+ [ ] переменная является автоматической, если она объявлена вне каких-либо блоков
+ [ ] переменная является глобальной, если она определена внутри тела функции
+ [x] переменная является локальной, если она определена внутри тела функции
+ [x] переменная является глобальной, если она объявлена вне каких-либо блоков

### Подвиг 2. Выберите все верные утверждения, касающиеся следующего фрагмента программы:

```c
#include <stdio.h>

short buff[100000000];

int main(void) {
    short buff[100000000];
    return 0;
}
```

+ [x] переменная buff, объявленная вне функции main, является глобальной
+ [x] массив buff, объявленный внутри функции main, располагается в стеке вызова функции
+ [x] элементы массива buff, объявленного внутри функции main, принимают неопределенные начальные значения
+ [ ] значения элементов глобального массива buff принимают неопределенные начальные значения
+ [x] значения элементов глобального массива buff автоматически заполняются нулями в момент запуска программы
+ [ ] элементы массива buff, объявленного внутри функции main, принимают нулевые начальные значения

### Подвиг 3. Выберите все верные утверждения, касающиеся глобальных переменных.

+ [x] глобальные переменные доступны в любом месте текущего файла (модуля), но после их объявления
+ [x] секция кода .bss автоматически заполняется нулями при загрузке программы
+ [x] глобальные переменные с начальной инициализацией располагаются в секции кода .data
+ [x] глобальные переменные без начальной инициализацией располагаются в секции кода .bss
+ [ ] глобальные переменные с начальной инициализацией располагаются в секции кода .bss
+ [ ] глобальные переменные без начальной инициализацией располагаются в секции кода .data

### Подвиг 4. Выберите все верные варианты инициализации глобальных переменных.

+ [x] double global_2 = 2 * 3.53;
+ [ ] short global_3 = 4; long global_6 = global_3 + 2;
+ [x] const int global_1 = -10;
+ [x] const int global_1 = -10; short global_3 = global_1 * 3;
+ [x] const int global_1 = -10; char global_4 = sizeof(global_1);
+ [x] char global_5[10] = "hello";

### Подвиг 5. Выберите все верные варианты инициализации автоматических переменных.

+ [x] float var_3 = 3.87f;
+ [x] int var_2[] = {1, 2, 3};
+ [x] double var_4 = var_2[0] * 0.5;
+ [x] const char* ptr_str = "C/C++";
+ [x] int var_1 = 0;

### Подвиг 6 (на повторение). Продолжите программу, которая последовательно читает из входного потока целые числа в переменную x. Необходимо объявить функцию с именем is_positive, которая принимает целое значение и проверяет его на неотрицательность. Если число неотрицательное (>= 0), то функция is_positive возвращает 1, а иначе 0. В записанном цикле while вызовите функцию is_positive для каждого прочитанного числа и выведите в консоль в одну строчку через пробел только неотрицательные числа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/7.1.6

```c
#include <stdio.h>

int is_positive(int num) {
    int res = num >= 0;
    return res;
}

int main(void) {
    int x;
    while (scanf("%d", &x) == 1) {
        if (is_positive(x)) printf("%d ", x);
    }

    return 0;
}
```

### Подвиг 7 (на повторение). Продолжите программу. В функции main из стандартного входного потока читаются целые числа. Необходимо все их сохранять в массиве marks (не более 20). То есть, чисел может быть и больше 20, но сохранять только первые 20 в порядке их считывания. 

Допишите функцию `mean_ar`, которая бы вычисляла среднее арифметическое чисел переданного ей массива `ar`. Учитывать при вычислении следует только те числа, для которых переданная функция (через указатель) с сигнатурой:

```c
int <имя функции>(int);
```

возвращает истину (не нулевое значение). Полученное значение должно возвращаться функцией `mean_ar`.

В функции `main` вызовите функцию `mean_ar` для массива `marks`, обрабатывая только числа от 1 до 5 включительно (проверка выполняется дополнительной, вспомогательной функцией, которая, затем, передается последним аргументом в функцию `mean_ar`). Выведите в консоль вещественное значение с точностью до десятых, которое вернула функция `mean_ar`.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/7.1.7

```c
#include <stdio.h>
#define RANGE_DOWN 1
#define RANGE_UP 5
#define MAX_LEN 20

double mean_ar(const int *ar, size_t len_ar, int (*in_range)(int)) {
    double res = 0;
    int count = 0;
    for (size_t i = 0; i < len_ar; i++) {
        if (in_range(ar[i])) {
            res += ar[i];
            count++;
        }
    }
    return res / count;
}

int in_range(int num) {
    int res = (num >= RANGE_DOWN) * (num <= RANGE_UP);
    return res;
}

int main(void) {
    int marks[MAX_LEN] = {0};
    int x, count = 0;
    while (scanf("%d", &x) == 1 && count < MAX_LEN) {
        marks[count++] = x;
    }
    double result = mean_ar(marks, count, in_range);

    printf("%.1lf", result);

    return 0;
}
```

### Подвиг 8 (на повторение). Выберите все верные утверждения, касающиеся размещения переменных в памяти устройства

+ [x] адресом переменной называют порядковый номер ячейки, начиная с которой переменная хранится в памяти
+ [ ] разные переменные (обычные) могут использовать одни и те же ячейки памяти
+ [x] порядковый номер ячейки памяти называется ее адресом
+ [ ] адресом переменной называют порядковый номер ячейки, которой оканчивается область памяти, отведенная под переменную
+ [x] через имя переменной на уровне языка Си осуществляется доступ к непрерывной области памяти из одной или нескольких ячеек
+ [x] разные переменные (обычные) хранятся в разных не пересекающихся ячейках памяти

# 7.2 Локальные переменные во вложенных блоках

Мы продолжаем тему областей видимости переменных. Теперь, когда мы в целом узнали, что из себя представляют локальные и глобальные переменные, давайте более детально разберем поведение локальных переменных.

В языке Си операторные фигурные скобки образуют свой собственный независимый блок данных со своим набором локальных переменных. Например, в функции `main()` можно прописать в теле функции еще одни фигурные скобки и в них объявить внутреннюю переменную `b`:

```c
#include <stdio.h>

int main(void) {
    int a = 1;

    {
        int b = 2;
        printf("a = %d, b = %d\n", a, b);
    }

    printf("a = %d\n", a);

    return 0;
}
```

Как следует воспринимать такую конструкцию? 

Смотрите, в теле функции определена локальная переменная с именем `a` и начальным значением `1`. 

При этом, в стековом фрейме только эта переменная и появляется. 

Затем, когда выполнение доходит до внутреннего блока фигурных скобок, в стековом фрейме появляется еще одна переменная `b`. 

Соответственно, обе переменных существуют и могут быть выведены на экран с помощью функции `printf()`. 

После завершения внутреннего блока, все данные связанные с ним в стековом фрейме пропадают и, следовательно, перестает существовать и переменная `b`. Поэтому вторая функция `printf()` может вывести только одну переменную `a`. После запуска программы увидим следующий результат:

```
a = 1, b = 2
a = 1
```

Если же попытаться вывести значение переменной `b` за пределами вложенного блока, например:

```c
printf("a = %d, b = %d\n", a, b);
```

то получим ошибку на этапе компиляции программы, говорящей, что переменная `b` не существует.

Такая логика работы довольно полезна, когда во внутренних блоках нужно объявить временные переменные, которые не нужны за его пределами. 

Например, в функции `main()` объявлены две локальные переменные `a` и `b` и мы бы хотели, чтобы большее значение было в переменной `a`, а меньшее – в переменной `b`. Реализовать это можно следующим образом:

```c
#include <stdio.h>

int main(void) {
    int a = 1, b = 3;

    if (a < b) {
        int t = a;
        a = b;
        b = t;
    }

    printf("a = %d, b = %d\n", a, b);

    return 0;
}
```

Здесь внутренний блок срабатывает только при истинности условия и в нем объявляется вспомогательная временная переменная `t`, которая существует только в нем и недоступна за его пределами. 

Это очень удобно, учитывая, что такая переменная вполне может быть за пределами внутреннего блока и играть свою собственную роль. Например:

```c
#include <stdio.h>

int main(void) {
    int a = 1, b = 3;
    int t = a + b;

    if (a < b) {
        int t = a;
        a = b;
        b = t;
    }

    printf("a = %d, b = %d, t = %d\n", a, b, t);

    return 0;
}
```

Смотрите, как здесь все работает. Вначале в функции `main()` определены три локальных переменных `a`, `b` и `t`. Затем, по условию отрабатывает внутренний блок, в котором объявляется переменная с тем же именем `t`. 

Однако это имя связано с совсем другой областью памяти, которая отводится в стековом фрейме. 

И изменение этой переменной никак не скажется на значении другой переменной с тем же именем `t`. 

В программировании такой эффект называется сокрытием переменной. Действительно, когда выполнение внутреннего блока завершается, все данные, связанные с ним в стековом фрейме, исчезают, а имя `t` теперь будет вести на прежнюю область памяти со значением `a+b`. Именно оно выводится функцией `printf()`:

```
a = 3, b = 1, t = 4
```

Разумеется, если бы мы не объявляли внутреннюю переменную `t`, то имя `t` вело бы к переменной из внешнего блока – из тела функции `main()`. Тогда значение этой переменной изменилось бы.

## Собственные блоки операторов if, while, for, do-while

В языке Си стандарта `C99` операторы `if`, `while`, `for`, `do-while` и некоторые другие образуют свои собственные блоки. Это можно показать на следующем примере:

```c
#include <stdio.h>

int main(void) {
    int t = 3;

    while (t-- > 0) {
        int t = 10;
        t--;
        printf("t = %d\n", t);
    }

    printf("main: t = %d\n", t);

    return 0;
}
```

Здесь в условии цикла `while` используется переменная `t` из функции `main()`, а в теле цикла – новая переменная с тем же именем `t`. В результате, цикл сработает ровно три раза и выведет строчки:

```c
t = 9
t = 9
t = 9
main: t = -1
```

Возможно, здесь все достаточно очевидно. Но вот менее очевидный пример с оператором цикла `for`:

```c
#include <stdio.h>

int main(void) {
    int t = 33;

    for (int t = 0; t < 3; ++t) {
        printf("t = %d\n", t);
    }

    printf("main: t = %d\n", t);

    return 0;
}
```

Здесь оператор `for` образует свой вложенный блок с переменной `t`, которая, затем, используется в его теле цикла. После завершения цикла на экран выводится значение прежней переменной `t` функции `main`:

```
t = 0
t = 1
t = 2
main: t = 33
```

Как видим, локальная переменная `t` не была изменена в операторе цикла `for`. Конечно, если бы мы не делали ее объявление в `for`:

```c
for(t = 0; t < 3; ++t) ...
```

то использовалась бы внешняя переменная `t` из функции `main()`. Увидели бы результат:

```
t = 0
t = 1
t = 2
main: t = 3
```

## Регистровые переменные

В заключение этого занятия отмечу еще один способ представления переменных доступный в языке Си. 

На самом первом занятии мы с вами видели, что центральный процессор компьютера сохраняет промежуточные данные в своих регистрах. 

Эти регистры физически находятся внутри процессора, а потому с ними очень быстро происходит обмен данными. 

Быстрее, чем с ячейками памяти, а значит, быстрее, чем с переменными.

![07](/Good_good_C_C++/img/07_02.jpg)

Так вот, составляя программу, мы можем попросить компилятор разместить ту или иную переменную непосредственно в одном из регистров процессора. 

Разумеется, размер этой переменной (по числу бит) не должен превышать размер регистров ЦП. Делается это с помощью ключевого слова `register`, следующим образом:

```c
#include <stdio.h>

int main(void) {
    int p = 1;
    int n = 7;

    for (register int i = 2; i <= n; ++i) p *= i;

    return 0;
}
```

Конечно, гарантии того, что переменная `i` будет соответствовать некоторому регистру ЦП, нет. Мы лишь выражаем свое желание, чтобы эта переменная стала регистровой. А поместит ли ее компилятор в регистр или нет зависит от множества факторов: от наличия свободного регистра; от типа и использования самой переменной `i` в программе. Например, если мы попытаемся получить адрес регистровой переменной, то она точно не будет в регистре, т.к. у регистров нет адреса и компилятор решит, что программист что-то напутал и сделает переменную самой обычной.

Во всем остальном регистровые переменные ведут себя, как обычные локальные автоматические, то есть, они автоматически создаются внутри блока и исчезают за пределами блока.

Видео по теме [#49. Локальные во вложенных блоках](https://www.youtube.com/watch?v=PV903MfZ4_M&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, касающиеся следующего фрагмента программы:

```c
#include <stdio.h>

int var = 0;

int main(void) {
    int var = 10;

    {
        int var = 20;
        printf("%d\n", var);
    }

    printf("%d\n", var);

    return 0;
}
```

+ [x] переменная var со значением 0 является глобальной
+ [ ] при выполнении программы в консоли увидим числа: 10 и 10
+ [ ] фигурные скобки внутри тела функции main недопустимы по синтаксису языка Си
+ [x] фигурные скобки внутри тела функции main образуют свой независимый блок видимости
+ [x] переменная var со значением 0 в функции main подменяется локальными переменными var
+ [x] при выполнении программы в консоли увидим числа: 20 и 10

### Подвиг 2. Выберите все верные утверждения, касающиеся блоков видимости.

+ [ ] тело цикла операторов while, for, do-while не образует свою локальную область видимости
+ [x] в языке Си стандарта C99 блок из фигурных скобок в любом месте программы образуют свою область видимости
+ [x] тело цикла операторов while, for, do-while образует свою локальную область видимости
+ [x] тело любой функции языка Си образует свою локальную область видимости

### Подвиг 3. Выберите все верные утверждения, касающиеся следующего фрагмента программы языка Си стандарта C99:

```c
#include <stdio.h>

int main(void) {
    int n = 10;
    for (int i = 0; i < n; ++i) printf("%d ", i + 1);

    printf("\n%d\n", i);

    return 0;
}
```

+ [ ]при выполнении программы в консоли увидим целые числа от 1 до 10 в одну строчку через пробел
+ [x]переменная i, объявленная в операторе for, существует только в пределах этого оператора
+ [x]в строчке printf("\n%d\n", i); при компиляции возникнет ошибка, т.к. переменная i за пределами цикла не существует
+ [ ]команда printf("\n%d\n", i); выведет в консоль значение 10
+ [ ]переменная i, объявленная в операторе for, существует и за пределами оператора for

### Подвиг 4. Выберите все верные утверждения, касающиеся следующего фрагмента программы языка Си стандарта C99:

```c
#include <stdio.h>

int main(void) {
    int n = 7;
    while (n-- > 0) {
        int n = 5;
        printf("%d\n", n);
        n++;
    }

    printf("%d\n", n);

    return 0;
}
```

+ [x] при выполнении программы в консоли семь раз отобразится число 5, а в конце число -1
+ [ ] цикл while будет работать "вечно", т.к. значение n на каждой итерации устанавливается равным 5
+ [ ] при выполнении программы в консоли восемь раз отобразится число 5, а в конце число 0
+ [x] цикл while сработает ровно семь раз (семь итераций)
+ [x] в теле цикла while переменная n каждый раз инициализируется значением 5
+ [ ] при выполнении программы в консоли шесть раз отобразится число 5, а в конце число -1

### Подвиг 5 (на повторение). Напишите программу, которая читает из входного потока натуральное число n. Необходимо найти все делители этого числа (то есть, натуральные числа, которые нацело делят число n, начиная с 1). Все найденные делители вывести по порядку (начиная с наименьшего) в одну строчку через пробел.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/7.2.5

```c
#include <stdio.h>

int main(void) {
    int n;

    scanf("%d", &n);
    // Выведем 1, на единицу всё делиться без остатка
    printf("%d ", 1);

    // Достаточно проверять до половины n
    for (int i = 2; i <= n / 2; i++) {
        if (n % i == 0) printf("%d ", i);
    }
    // если n = 1, то не будем печатать её второй раз
    if (n > 1) printf("%d", n);

    return 0;
}
```

### Подвиг 6 (на повторение). Напишите программу, которая читает из входного потока натуральное число n. Вычислите у этого числа все его простые множители (разложить число по простым множителям) и выведите их в порядке возрастания (неубывания) в одну строчку через пробел.

Например, число 140 = 2 * 2 * 5 * 7. В консоли должно отображаться 2 2 5 7.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/7.2.6

```c
#include <stdio.h>

int main(void) {
    int n;

    scanf("%d", &n);

    for (int i = 2; i <= n; i++) {
        while (n % i == 0) {
            printf("%d ", i);
            n /= i;
        }
    }

    return 0;
}
```

### Подвиг 7 (на повторение). Напишите программу, которая читает из входного потока два натуральных числа n, m, записанных через пробел, и вычисляет следующую сумму:

$S = \displaystyle\sum_{i=0}^{n}\sum_{j=0}^{m}i+j$

Сумма должна вычисляться до тех пор, пока слагаемое `i+j` меньше `20`. Как только `i+j` окажется больше или равно `20`, прервать подсчет суммы и вывести результат (полученную сумму) в консоль в виде одного целого числа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/7.2.7

```c
#include <stdio.h>
#define MAX 20

int main(void) {
    int n, m, result = 0;

    scanf("%d %d", &n, &m);

    for (int i = 0; i <= n; i++) {
        for (int j = 0; j <= m; j++) {
            int sum = i + j;
            if (sum == MAX) goto A;
            result += sum;
        }
    }

A:
    printf("%d", result);
    return 0;
}
```

### Подвиг 8 (на повторение). Установите соответствия между обозначениями операторов и их описаниями.

![07](/Good_good_C_C++/img/07_03.PNG)

# 7.3 Ключевые слова static и extern

## Ключевое слово static

Мы продолжаем тему глобальных и локальных переменных. Когда речь шла о глобальной области видимости, то мы говорили, что неинициализированные переменные располагаются либо в секции `.bss`, а инициализированные – в секции `.data`:

```c
char name[] = "Variables";  /* в секции .data */
double big_ar[1000000];     /* в секции .bss */
 
int main(void) {
    int var_main; /* автоматическая локальная переменная */
    return 0;
}
```

Причем, расположение таких переменных в памяти устройства не меняется на всем протяжении работы программы. 

О таких переменных говорят, что они статические, то есть, не меняют свой адрес от запуска программы и до ее завершения. 

В отличие от автоматических переменных, адрес которых может меняться, и точно известен только после их появления в стековом фрейме. 

То есть, обычные локальные переменные не статические. 

Однако, при необходимости, можно объявить локальную переменную и в то же время статическую. Для этого нужно прописать ключевое слово `static` перед типом переменной, например, следующим образом:

```c
int main(void) {
    int var_main;           /* автоматическая локальная переменная */
    static short var_st;   /* локальная статическая переменная */
 
    return 0;
}
```

Что значит локальная статическая переменная? И какими свойствами она обладает? 

В действительности такие переменные располагаются или в секции `.bss` (если не инициализированы) или в секции `.data` (если инициализированы). 

То есть там же, где и глобальные переменные. 

Соответственно, на них распространяются те же правила инициализации, что и на глобальные переменные: только константами и соответствующими выражениями. 

Если же статическая переменная не имеет начального значения, то она равна нулю, так как секция `.bss` при запуске программы заполняется нулями. Мы в этом легко можем убедиться. Выведем их с помощью функции `printf()`:

```c
printf("var_main = %d, var_st = %d\n", var_main, var_st);
```

Увидим результат:

```
var_main = 3207168, var_st = 0
```

То есть, автоматические переменные изначально принимают случайные значения, а статические – нулевые. Мало того, локальные статические переменные инициализируются и формируются в памяти устройства только один раз – в момент запуска программы. А строчка:

```
static short var_st;
```

лишь связывает имя `var_st` с соответствующей областью памяти либо из секции `.bss` либо из секции `.data`. 

Это, своего рода, указатель на заранее выделенную статическую область памяти. 

В действительности, все имена переменных на уровне машинных кодов заменяются соответствующими адресами памяти. 

Поэтому имена переменных – это всего лишь некоторая абстракция на уровне языка Си. В машинных кодах они не существуют.

Спрашивается, зачем нужна такая локальная статическая переменная? 

Первая ее особенность нам уже известна – возможность не занимать память в стековом фрейме, а располагаться в основной памяти устройства. 

Следовательно, статические переменные могут занимать большие объемы памяти без каких-либо последствий в работоспособности программы. Я напомню, если бы мы захотели локально объявить массив:

```c
double big_ar[1000000];
```

в функции `main()`, то программа бы завершилась аварийно из-за нехватки памяти, отведенной под стековый фрейм. Однако если прописать перед типом `double` ключевое слово `static`:

```c
static double big_ar[1000000];
```

то никаких проблем с выполнением такой программы не будет и, кроме того, массив станет доступен по локальному имени `big_ar`. А это гораздо лучше использования глобальной переменной.

Вторая особенность локальной статической переменной проявляется из-за ее однократной инициализации: в памяти она создается только один раз и продолжает существовать даже после завершения функции, в которой была объявлена. Наглядно это можно показать с помощью такой программы:

```c
#include <stdio.h>
 
unsigned int counter() {
    static unsigned int cnt = 10;
    return ++cnt;
}
 
int main(void) {
    unsigned int times;
    times = counter();
    printf("times = %u\n", times);
    printf("counter(): %u\n", counter());
    printf("counter(): %u\n", counter());
    printf("counter(): %u\n", counter());
 
    return 0;
}
```

Здесь внутри функции `counter()` объявляется локальная статическая переменная `cnt` с начальным значением `10`. В основной функции `main()` мы несколько раз вызываем функцию `counter()` и получаем следующий вывод:

```c
times = 11
counter(): 12
counter(): 13
counter(): 14
```

О чем говорит этот результат? О том, что переменная `cnt` была инициализирована только один раз значением `10`, и при последовательных вызовах функции `counter()` бралось ее текущее значение и увеличивалось на единицу. Также это говорит о том, что переменная `cnt` не исчезает после завершения работы функции, а продолжает существовать в памяти устройства. И мы теперь знаем, что она располагается в секции `.data` (так как имеет начальное значение `10`).

## Ключевое слово extern с глобальными переменными

Давайте теперь посмотрим, как можно воспользоваться глобальной переменной в другом файле текущего проекта. Для этого создадим в том же рабочем каталоге файл, допустим, с именем `modul.c` и объявим в нем глобальную переменную:

```c
int global_var = 5;
```

А в файле lessons.c с функцией main() запишем следующее:

```c
#include <stdio.h>
 
int main(void) {
    printf("global_var = %d\n", global_var);
    return 0;
}
```

В настройках компилятора дополнительно пропишем файл `modul.c` и попробуем скомпилировать наш проект. 

Получим ошибку, что переменная `global_var` в файле `lessons.c` неизвестна. 

И это неудивительно, так как любое объявление глобальных переменных по умолчанию распространяется только на текущий файл. Чтобы получить доступ к переменной `global_var` в файле `lessons.c` нужно дать описание этой переменной. Делается это с помощью ключевого слова `extern` следующим образом:

```c
extern int global_var;
```

После этого программа скомпилируется, выполнится и выведется ее значение на экран:

```
global_var = 5
```

Обратите внимание, что с помощью ключевого слова `extern` мы не объявляем переменную `global_var`, а лишь говорим компилятору, что эта переменная будет объявлена позже, либо в этом же файле, либо в другом. То есть, это именно описание переменной, а не объявление. Память под нее здесь не резервируется.

Учитывая все сказанное, мы можем вначале сформировать описание глобальной переменной, а в конце файла объявить ее, например, так:

```c
#include <stdio.h>
 
extern int global_var;
extern char global_str[];
 
int main(void) {
    printf("global_var = %d\n", global_var);
    puts(global_str);
    return 0;
}
 
char global_str[100] = "Hello";
```

После запуска программы увидим на экране строку «Hello». И, обратите внимание, на важный момент. 

В описании массива `global_str` не указывается его размерность и уж, тем более, не прописывается инициализация. Через `extern` мы лишь задаем тип и имя переменной, чтобы компилятор корректно сформировал представление этой переменной в объектном файле. А объявление переменной должно быть в любом другом месте и модуле проекта. На этапе его сборки линковщик объединит описания переменных с их объявлениями. Кстати, если в конце убрать объявление переменной `global_str`, то, естественно, получим ошибку на этапе линковки проекта:

```c
undefined reference to `global_str'// неопределенная ссылка на `global_str'.
```

## Ключевое слово extern с функциями

Аналогичные описания можно определять и для функций. Мы с вами об этом уже говорили, когда рассматривали прототипы функций. Здесь я лишь напомню и немного дополню тот материал.

Если функция определена в другом модуле, например, в файле `modul.c`:

```c
#include <stdlib.h>
 
int global_seed_randint = 0;
 
int randint(int a, int b) {
    int right = a, left = b;
    if(a > b) {
        right = b;
        left = a;
    }
 
    return rand() % (left - right + 1) + right;
}
```

То для ее использования в файле `lessons.c` необходимо также дать ее описание (записать прототип) следующим образом:

```c
#include <stdio.h>
 
int randint(int, int);
 
int main(void) {
    int a = 1, b = 10;
 
    printf("%d\n", randint(a, b));
    printf("%d\n", randint(a, b));
    printf("%d\n", randint(a, b));
 
    return 0;
}
```

Обратите внимание, имена параметров в прототипах указывать не обязательно. Компилятор все равно их игнорирует. 

Ему здесь важна лишь сигнатура функции:
+ возвращаемый тип,
+ имя функции и
+ типы параметров. 

Этого достаточно, чтобы сформировать вызов функции на уровне машинных кодов. А адрес ее вызова подставится позже на этапе линковки проекта.

Итак, получается, что для описания связи с глобальной переменной необходимо прописывать ключевое слово `extern`:

```c
extern int global_seed_randint;
```

а в прототипе функции его нет. Почему? На самом деле его можно добавить и там:

```c
extern int randint(int a, int b);
```

Но здесь оно необязательно, т.к. компилятор легко может различить прототип от полного объявления функции. А вот с переменной лучше явно указывать `extern`.

## Ключевое слово static с глобальными переменными

А что если мы бы хотели ограничить область видимости глобальной переменной только текущим модулем. Например, сделать так, чтобы переменная `global_seed_randint` была доступна только в пределах файла `modul.c`? Для этого достаточно прописать ключевое слово `static` при объявлении этой переменной:

```c
static int global_seed_randint;
```

Тогда при попытке ее использовать в файле `lessons.c` произойдет ошибка на этапе линковки проекта:

```c
#include <stdio.h>
 
extern int global_seed_randint;
int randint(int a, int b);
 
int main(void) {
    int a = 1, b = 10;
 
    printf("global_seed_randint = %d\n", global_seed_randint);
    printf("%d\n", randint(a, b));
    printf("%d\n", randint(a, b));
    printf("%d\n", randint(a, b));
 
    return 0;
}
```

То есть, ключевое слово `static` с глобальными переменными играет совсем другую роль, чем с локальными. Если локальные из класса автоматических переменных переходили в класс статических, то с глобальными оно лишь ограничивает их область видимости в пределах текущего модуля. Вот это нужно четко понимать и запомнить.

По аналогии дела обстоят и с функциями. Если при ее реализации прописать ключевое слово `static` (в файле `modul.c`):

```c
static int randint(int a, int b) {
   
...
}
```

то использовать ее можно только в текущем модуле и нельзя за его пределами. В программировании такое поведение называют внутренним связыванием. И, наоборот, если переменную или функцию можно использовать в других модулях, то говорят, что они имеют внешнее связывание.

Надеюсь, из последних занятиях вы стали хорошо себе представлять, как объявляются глобальные и локальные переменные, чем они принципиально отличаются друг от друга, где и как размещаются в памяти. Также знаете роль ключевых слов `static` и `extern`, применительно к переменным и функциям.

Видео по теме [#50. Ключевые слова static и extern](https://www.youtube.com/watch?v=18ycGTrljXk&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, касающиеся статических переменных языка Си.

+ [x] статические переменные хранятся либо в секции .bss (неинициализированные), либо в секции .data (инициализированные)
+ [x] статические переменные создаются и инициализируются в программе только один раз, в момент запуска программы
+ [ ] локальные статические переменные создаются каждый раз при вызове той или иной функции, в которой объявлены
+ [x] статические переменные имеют постоянный адрес все время выполнения программы
+ [x] любая глобальная переменная - статическая
+ [x] локальную переменную можно превратить в статическую, прописав перед ее типом ключевое слово static

### Подвиг 2. Выберите все верные утверждения, касающиеся следующего фрагмента программы:

```c
#include <stdio.h>

int get_step(int start) {
    static int step = start;
    return step++;
}

int main(void) {
    printf("step: %d\n", get_step(5));
    printf("step: %d\n", get_step(5));
    printf("step: %d\n", get_step(5));

    return 0;
}
```

+ [ ] в процессе выполнения программы в консоль будут выведены значения 5, 6, 7
+ [ ] чтобы программа заработала достаточно параметр функции get_step объявить как const int start
+ [x] статическая переменная, объявленная внутри функции, создается и инициализируется только один раз в момент запуска программы
+ [x] команда static int step = start; недопустима, т.к. статическая переменная может быть инициализирована только значением времени компиляции
+ [x] статическая переменная, объявленная внутри функции, продолжает существовать и сохранять значение после завершения работы функции

### Подвиг 3. Выберите все верные утверждения, касающиеся следующего фрагмента программы:

```c
#include <stdio.h>
#define START_STEP  0

int get_step(int start) {
    static int step = START_STEP;
    return start + step++;
}

int main(void) {
    printf("step: %d\n", get_step(5));
    printf("step: %d\n", get_step(5));
    printf("step: %d\n", get_step(5));

    return 0;
}
```

+ [ ] в процессе выполнения программы в консоль будут выведены значения 6, 7, 8
+ [ ] к статической переменной недопустимо применять операции инкремента и декремента
+ [ ] в процессе выполнения программы в консоль будут выведены значения 5, 5, 5
+ [x] в процессе выполнения программы в консоль будут выведены значения 5, 6, 7
+ [ ] статическую переменную нельзя складывать с обычной (автоматической) переменной

### Подвиг 4. Напишите программу без использования глобальных переменных, в которой объявляется функция со следующей сигнатурой:

```c
int range(void);
```

Эта функция при каждом вызове возвращает целые числа, начиная с `5` и с шагом `3`. Например:

5, 8, 11, 14, 17, ...

В функции `main` вызовите семь раз функцию range и выведите в консоль в одну строчку через пробел числа, которые она возвратит.

```c
#include <stdio.h>
#define START_STEP 2
#define FUNC_RUNS 7

// int range(void) {
//     static int step = START_STEP;
//     step += 3;
//     return step;
// }

int range(void) {
    static int i;
    return 5 + 3 * i++;
}

int main(void) {
    for (size_t i = 0; i < FUNC_RUNS; i++) {
        printf("%d ", range());
    }

    return 0;
}
```

### Подвиг 5. Допишите программу без использования глобальных переменных, в которой объявляется функция со следующей сигнатурой:

```c
int range(int start, int stop, int step);
```

При первом запуске она должна настраивать счетчик на формирование последовательности целых чисел от `start` до `stop` (включительно) с шагом `step`. Также первый запуск возвращает первое значение последовательности. При повторных вызовах функции `range` параметры `start`, `stop`, `step` не должны играть никакого значения. Сама же функция `range` при каждом новом вызове должна возвращать очередные числа последовательности. Например, при start=5, stop 11, step=2, имеем:

5, 7, 9, 11, 5, 7, 9, 11, 5, 7, 9, 11, 5, 7, 9, 11, 5, 7, 9, 11, ...

То есть, при достижении граничного значения stop, происходит возврат на начальное значение start.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/7.3.5

```c
#include <stdio.h>

int range(int start, int stop, int step) {
    static int i = 0;
    if ((start + step * i) > stop) i = 0;
    if ((start + step * i) == stop) {
        i++;
        return stop;
    }
    int res = (start + step * i++) % (stop - start);
    return res;
}

int main(void) {
    int start, stop, step;
    scanf("%d %d %d", &start, &stop, &step);

    for (int i = 0; i < 20; ++i) printf("%d ", range(start, stop, step));

    return 0;
}
```

### Подвиг 6. Выберите все верные утверждения, касающиеся глобальных определений в языке Си.

+ [x] ключевое слово extern перед заголовком функции прописывать не обязательно
+ [x] обычная функция, объявленная в текущем модуле, может быть использована и в любом другом, если указать ее прототип
+ [x] ключевое слово extern позволяет глобальные переменные использовать за пределами текущего модуля
+ [ ] область видимости глобальной переменной по умолчанию распространяется на весь проект (все модули)
+ [ ] обычная функция, объявленная в текущем модуле, может быть использована только в этом модуле и недоступна в других
+ [ ] ключевое слово extern позволяет ограничивать область видимости глобальных переменных текущим модулем
+ [x] область видимости глобальной переменной по умолчанию распространяется только на текущий файл (модуль)

### Подвиг 7. Выберите все верные утверждения, касающиеся ключевого слова static.

+ [x] ключевое слово static у функций ограничивает их область видимости текущим модулем
+ [ ] внутреннее связывание - это когда переменная или функция может быть использована в других функциях
+ [x] внутреннее связывание - это когда переменная или функция имеет область видимости только в пределах текущего модуля
+ [ ] внешнее связывание - это когда переменная или функция использует другие внешние переменные или функции
+ [ ] ключевое слово static у функций позволяет объявлять статические функции без ограничения области их видимости
+ [x] ключевое слово static у глобальных переменных ограничивает их область видимости текущим модулем
+ [x] внешнее связывание - это когда переменная или функция доступна и за пределами текущего модуля

### Подвиг 8. Выберите все верные утверждения, касающиеся следующего фрагмента программы:

```c
#include <stdio.h>

extern int ex_var_1;
extern int ex_var_2 = 7;

int main(void) {
    printf("%d", ex_var_1);
    return 0;
}

int ex_var_1 = 10;

```

+ [ ] значение переменной ex_var_2 равно 7
+ [ ] значение переменной ex_var_1 в функции main равно 0
+ [x] переменная ex_var_2 не может быть инициализирована при наличии ключевого слова extern
+ [x] при компиляции программы возникнет ошибка
+ [x] значение переменной ex_var_1 в функции main равно 10

### Подвиг 9 (на повторение). Выберите все верные утверждения, касающиеся следующего фрагмента программы:

```c
#include <stdio.h>

short buff[100000000];

int main(void) {
    short buff[100000000];
    return 0;
}
```

+ [ ] элементы массива buff, объявленного внутри функции main, принимают нулевые начальные значения
+ [x] переменная buff, объявленная вне функции main, является глобальной
+ [ ] значения элементов глобального массива buff принимают неопределенные начальные значения
+ [x] элементы массива buff, объявленного внутри функции main, принимают неопределенные начальные значения
+ [x] значения элементов глобального массива buff автоматически заполняются нулями в момент запуска программы
+ [x] массив buff, объявленный внутри функции main, располагается в стеке вызова функции

### Подвиг 10 (на повторение). Выберите все верные утверждения, касающиеся глобальных переменных.

+ [x] глобальные переменные доступны в любом месте текущего файла (модуля), но после их объявления
+ [ ] глобальные переменные без начальной инициализацией располагаются в секции кода .data
+ [x] секция кода .bss автоматически заполняется нулями при загрузке программы
+ [x] глобальные переменные без начальной инициализацией располагаются в секции кода .bss
+ [x] глобальные переменные с начальной инициализацией располагаются в секции кода .data
+ [ ] глобальные переменные с начальной инициализацией располагаются в секции кода .bss

# 7.4 Функции malloc(), free(), calloc(), realloc(), memcpy()

До сих пор мы с вами данные программы размещали в переменных. 

Собственно, для этого они и существуют. 

Однако имеют некоторые известные нам ограничения. 

В частности, они располагаются либо в статической области памяти, если речь идет о глобальных переменных, и существуют на всем протяжении работы программы, либо в ограниченном по объему стековом фрейме, когда речь идет о локальных переменных. 

При этом вся остальная свободная память устройства, которая не занята другими процессами, работающими параллельно с нашей программой, никак не используется. 

Переменные в ней не размещаются (если не считать глобальных переменных, но они размещаются раз и навсегда, пока не завершится программа). 

Так вот, в программировании эта остальная свободная память называется «кучей» или по-английски `heap`. 

Язык Си предоставляет возможность самостоятельно выделять память в «куче», использовать ее по своему усмотрению, а затем, также самостоятельно освобождать ранее выделенную память. Для этого в заголовочном файле `stdlib.h` определены две основные функции:

```c
void* malloc(size_t size); // для выделения size байт из кучи
void free(void* ptr); // для освобождения памяти по указателю ptr
```

Прежде чем перейти к рассмотрению этих функций, поясню смысл слов «выделение» и «освобождение» памяти. 

В первых компьютерах таких понятий не существовало. 

Была память, работала одна программа в один момент времени, и программист мог совершенно свободно использовать ее, не спрашивая ни у кого разрешения. 

Все было предельно просто, пока не появились они – многозадачные ОС с параллельным выполнением сразу нескольких программ. 

Романтике программирования был нанесен серьезный урон. 

Теперь программа не могла по своему собственному усмотрению размещать данные, как ей казалось, в свободных ячейках. 

Эти ячейки могли быть совсем не свободными, а использоваться другой программой. 

В результате для контроля за использованием памяти на уровне ОС был создан посредник – менеджер памяти. 

И отныне любая программа, которая хочет получить свой неделимый кусок из набора байт, должна обращаться к этому посреднику через системный вызов и с надеждой ожидать положительного решения своей просьбы. 

К счастью, просьбы чаще всего удовлетворяются за очень редкими исключениями, когда нужного запрашиваемого объема памяти недостаточно. 

Если менеджер памяти оказался к вам благосклонен и выдал адрес начала неделимого блока из байт, то никакая другая программа его уже не получит. 

Ваша программа становится полновластным хозяином над этими ячейками памяти. И только после того, как вы благосклонно освободите их, дав свободу с помощью функции `free()`, ими могут воспользоваться другие программы, заявляя над ними свои права. 

Вот что в действительности значат невинные на первый взгляд слова «выделение» и «освобождение» памяти.

Давайте посмотрим, как в программе можно воспользоваться функциями `malloc()` и `free()`:

```c
#include <stdio.h>
#include <stdlib.h>
 
int main(void) {
    char* ar = malloc(10);   // выделение 10 байт из кучи
    int* ptr_int = malloc(sizeof(int)); // выделение памяти под тип int
    int* ptr_short = malloc(7 * sizeof(short)); // выделение памяти под 7 элементов типа short
 
    free(ar);
    free(ptr_int);
    free(ptr_short);
    
    return 0;
}
```

Обратите внимание, что в качестве аргумента функции `malloc()` указывается число байт, которую мы хотим получить из «кучи» в  виде непрерывной области памяти. Если менеджер памяти в «куче» находит такой кусок свободной памяти, то функция `malloc()` возвращает адрес первой ячейки. 

Если же возникают проблемы, то возвращается предопределенное значение `NULL`. 

Поэтому, после вызова функции `malloc()`, прежде чем использовать область памяти, нужно проверить значение указателя: оно должно быть не равно `NULL`. Пока в нашем примере этого нет, т.к. мы просто выделяем, а потом освобождаем память.

Итак, первая функция `malloc()` запрашивает у ОС `10` байт непрерывной области и, скорее всего, получит ее, т.к. это совсем небольшой размер. Во втором вызове `malloc()` запрашивается число байт для хранения целочисленного значения типа `int` в «куче». Наконец, последний вызов возвращает непрерывную память под `7` элементов типа `short`. После этого выполняется освобождение ранее выделенной памяти и программа завершается.

## Эффект утечки памяти

Надо сказать, современные ОС автоматически освобождают все ресурсы, которые использовались программой, при ее завершении. 

Поэтому, если бы мы не написали функции `free()`, то в данном конкретном случае никаких последствий бы не было. 

Но, в общем случае, и к этому нужно приучаться сразу:
+ каждому вызову `malloc()` должен соответствовать один вызов функции `free()`. 

Иначе, программа выделит под себя память, но не освободит ее, когда она уже не нужна. 

Если к тому же функция `malloc()` время от времени продолжает вызываться, то выделенная для нужд программы память, будет постоянно нарастать, не освобождаясь. 

Такой эффект в программировании называется утечкой памяти. 

Это главный бич, ахиллесова пята языка программирования Си. 

Наверное, каждый серьезный программист, пишущий на Си, сталкивался с такой проблемой. Кажется, куда уж проще, вызвал `malloc()` не забудь вызвать и `free()`. 

Но это на первый взгляд. 

Реальные программы имеют непростую логику распределения информационных потоков. И далеко не всегда удается правильно сочетать вызовы пар функций `malloc()` и `free()`. 

Отсюда и проблема утечки памяти. 

Эта проблема настолько серьезная, что многие современные языки программирования, вроде `Python`, `Java`, `C#`, `PHP` и другие, имеют встроенный механизм автоматического освобождения памяти, когда она уже не нужна программе. 

Этот механизм реализован на основе, так называемого, сборщика мусора. 

Он анализирует все выделенные блоки памяти, и если на какую-либо не ведут программные ссылки (указатели), то делается вывод, что она не нужна и освобождается. Но в языке Си такого механизма нет. И это не удивительно, так как это нарушало бы философию данного языка:
+ доверять программисту;
+ не мешать программисту делать то, что он считает необходимым;
+ без необходимости не усложнять язык, сохранять его простоту;
+ каждая операция языка должна иметь только один способ выполнения;
+ операция должна выполняться максимально быстро, даже в ущерб переносимости языка.

Язык Си – это, своего рода, ассемблер высокого уровня и в этом смысле он уникален. Сами сборщики мусора для других языков программирования написаны на Си (точнее, на `С++`). 

Поэтому язык Си – это рабочая лошадка низкоуровневого программирования. Он предоставляет огромные возможности, но накладывает и большую ответственность на программиста. В частности, ответственность за освобождение ранее выделенных ресурсов.

## Пример использования функций malloc() и free()

Давайте теперь посмотрим, в каких задачах целесообразно использовать функции `malloc()` и `free()`. 

Предположим, нам в программе нужно хранить температуру по дням в течение некоторого периода. Какой это период, никто не знает. Это может быть и 20 дней, а может 100, а возможно пользователю захочется хранить данные за последние 100 000 дней. 

Как в этом случае нам организовать хранение данных в программе, чтобы с одной стороны не занимать слишком много памяти, а с другой – разместить все необходимые данные? 

Как вы уже догадались, выход только один: воспользоваться функциями `malloc()` и `free()`.

Логика программы будет следующей. Вначале мы объявим две переменные:

```c
size_t capacity = 10;
size_t length = 0;
```

Первая `capacity` будет хранить максимальное число элементов в массиве, а вторая `length` – число сохраненных в массив значений. Пока `length` меньше `capacity` проблем никаких нет. Новые данные можно записывать по порядку в ячейки массива. Но, когда вся отведенная под массив память окажется заполненной, то сделаем «прием с переворотом», а точнее, «прием с копированием». 

Мы динамически выделим новый кусок памяти, скажем, в два раза большего размера, перенесем туда ранее записанные данные из прежнего массива и освободим из под него память. Это известная концепция, положенная в основу структуры данных, известной под названием динамический массив.

Идею динамического массива можно реализовать следующим образом:

```c
#include <stdio.h>
#include <stdlib.h>
 
void* append(short* data, size_t *length, size_t *capacity, short value) {
    if(*length >= *capacity) {
        short* ar = malloc(sizeof(short) * 2 * *capacity);
        if(ar == NULL)
            return data;
            
        (*capacity) *= 2;
        for(int i = 0;i < *length;++i)
            ar[i] = data[i];
        
        free(data);
        data = ar;
    }
 
    data[*length] = value;
    (*length)++;
    
    return data;
}
 
int main(void) 
{
    size_t capacity = 10;
    size_t length = 0;
 
    short* data = malloc(sizeof(short) * capacity);
 
    for(int i = 0; i < 11;++i)
        data = append(data, &length, &capacity, rand() % 40 - 20);
 
    printf("length = %u, capacity = %u\n", length, capacity);
 
    for(int i = 0;i < length;++i)
        printf("%d ", data[i]);
 
    free(data);
    return 0;
}
```

+ Вначале выделяется память под массив `data`, содержащий максимум `10` элементов типа `short`. 
+ Затем, выше, определена функция `append()` для добавления нового значения в массив `data`.<br> В качестве аргументов этой функции передается сам массив, адреса переменных `length` и `capacity` и новое значение.
+ После добавления функция возвращает адрес массива (на случай, если массив будет увеличен и его начальный адрес изменится).
+ Сама функция `append()` работает очень просто:
    + Вначале проверяется, нужно ли увеличивать существующий массив и если да, то значение `capacity` удваивается, создается новый массив удвоенной длины и в него поэлементно копируются значения из прежнего массива. 
    + Затем, освобождается память из под массива `data` и указателю `data` присваивается новый адрес массива `ar`. В последних строчках добавляется новое значение в массив и возвращает его адрес.

В самой функции `main()` мы добавляем 11 случайных значений, чтобы посмотреть, как будет работать алгоритм при переполнении массива. После этого на экран выводятся значения переменных `length`, `capacity`, а затем, сохраненные значения в массиве `data`.

После запуска программы увидим строчки:

```c
length = 11, capacity = 20
-19 7 -6 0 -11 -16 18 18 -18 4 5
```

Действительно, массив был динамически увеличен при его заполнении и стал в два раза больше. Так мы реализовали идею динамического массива на языке Си с помощью функций `malloc()` и `free()`.

## Функции calloc(), realloc(), memcpy() и memmove()

На самом деле эту программу можно несколько улучшить, если знать, что существуют некоторые дополнительные функции работы с памятью. В частности, не редко можно встретить использование следующих:

- заголовочный файл `stdlib.h`:
    + `void* calloc(size_t nmemb, size_t size);`
    + `void* realloc(void *ptr, size_t length);`
- заголовочный файл `string.h`:
    + `void* memcpy(void* restrict dst, const void* restrict src, size_t length);`
    + `void* memmove(void* dst, const void* src, size_t length);`

Первая функция `calloc()` выделяет память под `nmemb` элементов, каждый размером `size` байт, то есть, всего `nmemb*size` байт, и заполняет ее нулями. 

Это ключевое ее отличие от функции `malloc()`. Во всем остальном, они идентичны. Следующая функция `realloc()` служит для изменения размера ранее выделенной памяти, на которую ведет указатель `ptr`. Новый размер задается вторым параметром `length` в байтах. В частности, при `length=0` функция `realloc()` отрабатывает аналогично функции `free()`. 

Если же `length` больше ранее выделенной памяти, то функция сначала пытается расширить уже существующую область до большего размера, если ей это не удается, то создается новая с копированием всей прежней информации. Предыдущая область памяти автоматически освобождается.

Две последние функции определены в заголовочном файле `string.h`, так как предполагается их использовать с символьными массивами (строками). В частности, копировать одну строку в другую с помощью функции `memcpy()` или переносить один фрагмент строки в другой с помощью функции `memmove()`. 

Ключевое слово `restrict` в параметрах функции `memcpy()` указывает компилятору, что указатели `dst` и `src` уникальны и ведут каждый на свою независимую область памяти.

В частности, мы бы могли воспользоваться функцией `memcpy()` для копирования данных из массива `data` в новый массив `ar` следующим образом:

```c
memcpy(ar, data, *length * sizeof(short));
```

Но в нашем примере мы можем поступить еще лучше и воспользоваться функцией `realloc()`, которая и память увеличивает и данные копирует и прежнюю память освобождает:

```c
void* append(short* data, size_t *length, size_t *capacity, short value) {
    if(*length >= *capacity) {
        short* ar = realloc(data, sizeof(short) * 2 * *capacity);
        if(ar == NULL)
            return data;
 
        (*capacity) *= 2;
        data = ar;
    }
 
    data[*length] = value;
    (*length)++;
    
    return data;
}
```

Вот, в целом, набор наиболее употребительных функций для работы с памятью. 

Если по каким-либо причинам переменные не подходят для хранения данных в программе, то следует посмотреть в сторону этих функций. 

Как правило, они решают все задачи. Собственно, кроме них все равно ничего принципиально другого нет для представления и хранения данных в памяти устройства. Поэтому, мы либо используем классические переменные, либо выделяем память из кучи и работаем уже с ней.

Видео по теме [#51. Функции malloc(), free(), calloc(), realloc(), memcpy() и memmove()](https://www.youtube.com/watch?v=ihIJRxgcRQ0&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, касающиеся работы с памятью устройства на языке Си.

P. S. Здесь ОС - это операционная система.

+ [x] выделение памяти - это процесс обращения к ОС для получения непрерывной области памяти в распоряжение программы
+ [x] выделение и освобождение памяти осуществляется путем системных вызовов к ОС (менеджеру памяти)
+ [ ] под кучей (heap) понимается область памяти программы, занятой глобальными переменными
+ [x] освобождение памяти - это процесс обращения к ОС для отмены ранее выделенного блока памяти
+ [ ] освобождение памяти - это процесс обращения к ОС для отмены ранее выделенного блока памяти и заполнение ее нулевыми значениями
+ [x] под кучей (heap) понимается 

### Подвиг 2. Выберите все верные утверждения для функций malloc и free.

+ [x] если запрашиваемый объем памяти успешно выделяется, то функция malloc возвращает адрес начала выделенного блока памяти
+ [x] для использования функций работы с памятью нужно подключить файл stdlib.h
+ [x] если запрашиваемый объем памяти не может быть выделен, то функция malloc возвращает значение NULL
+ [x] функция malloc служит для выделения указанного числа байт непрерывного блока в памяти устройства
+ [x] функция free служит для освобождения ранее выделенного блока памяти устройства
+ [ ] для использования функций работы с памятью нужно подключить файл stdio.h

Подвиг 3. Выберите все верные утверждения, касающиеся следующей программы:

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    int * ptr = malloc(4);
    char * ptr_str;
    free(ptr_str);
}
```

+ [x] при завершении программы все ресурсы, которая она захватывала, автоматически освобождаются операционной системой
+ [x] функция free отработает без ошибок
+ [x] в программе потенциально происходит "утечка памяти", т.к. была выделена память, но не освобождена
+ [ ] при выполнении функции free возникнет ошибка, т.к. указатель ptr_str не ссылается на выделенную область памяти
+ [ ] указатель ptr содержит адрес начала области памяти в 4 элемента типа int (если malloc отработала успешно)
+ [x] указатель ptr содержит адрес начала области памяти в 4 байта (если malloc отработала успешно)

### Подвиг 4. Продолжите программу. Объявите указатель с именем data типа данных short и выделите из кучи память под четыре элемента типа short. Затем, через указатель data занесите в эту область памяти значения:

-4, 3, 0, 100

Указатель data, при этом не должен менять свой адрес (ссылаться по-прежнему на начало выделенной области).

P. S. В консоль ничего выводить не нужно. Не забудьте в конце (после __ASSERT_TESTS__) освободить память.

```c
#include <stdio.h>
#include <stdlib.h>
#define DATA_LEN 4

int main(void) {
    short* data = malloc(sizeof(short) * DATA_LEN);
    const short ins[] = {-4, 3, 0, 100};

    if (data != NULL) {
        for (size_t i = 0; i < DATA_LEN; i++) {
            data[i] = ins[i];
        }
    }

    // __ASSERT_TESTS__
    // макроопределение для тестирования (не убирать и должно идти непосредственно перед return 0)

    if (data != NULL) free(data);
    return 0;
}
```

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(void)
{
    short* data = malloc(4*sizeof(short));
    short data1[]={-4, 3, 0, 100};
    memcpy(data, data1, 4 * sizeof(short));

    __ASSERT_TESTS__ // макроопределение для тестирования (не убирать и должно идти непосредственно перед return 0)

    free(data);
    return 0;
}
```

### Подвиг 5. Продолжите программу. Из входного потока прочитайте вещественные значения, записанные в одну строчку через пробел, и сохраните их в массиве digits типа double. Максимальное количество читаемых значений не более 20 (это нужно контролировать, в потоке чисел может быть больше). В целочисленной переменной count должно храниться количество прочитанных чисел.

Выделите дополнительно память, ровно столько, чтобы в нее помещались все прочитанные вещественные числа (тип double). На выделенную область должен ссылаться указатель ptr_d. Скопируйте из массива digits прочитанные числа в выделенную память. Указатель ptr_d при этом не должен менять свой адрес.

P. S. В консоль ничего выводить не нужно. Не забудьте в конце (после __ASSERT_TESTS__) освободить память.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/7.4.5

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define DATA_LEN 20

int main(void) {
    double digits[DATA_LEN];
    size_t count = 0;

    while (scanf("%lf", &digits[count]) == 1 && count < DATA_LEN) count++;
    printf("%d\n", count);
    for (size_t i = 0; i < count; i++) {
        printf("%.2lf ", digits[i]);
    }
    printf("\n");

    double* ptr_d = malloc(sizeof(double) * count);

    if (ptr_d != NULL) memcpy(ptr_d, digits, sizeof(double) * count);

    // __ASSERT_TESTS__
    // макроопределение для тестирования (не убирать и должно идти непосредственно перед return 0)

    if (ptr_d != NULL) free(ptr_d);
    return 0;
}
```

### Подвиг 6. Установите соответствия между функциями и их описаниями.

![07](/Good_good_C_C++/img/07_04.PNG)

### Подвиг 7. Продолжите программу. Из входного потока прочитайте целочисленные значения, записанные в одну строчку через пробел, и сохраните их в массиве lengths типа int. Максимальное количество читаемых значений не более 20 (это нужно контролировать, в потоке чисел может быть больше). В целочисленной переменной count должно храниться количество прочитанных чисел.

Выделите память для хранения 20 целочисленных значений (тип int) с помощью функции calloc. На выделенную область должен ссылаться указатель ptr_lens. Скопируйте из массива lengths прочитанные числа в выделенную память, используя функцию memcpy (копировать следует не весь массив lengths, а только часть с хранимыми (прочитанными) данными). Указатель ptr_lens при этом не должен менять свой адрес. Выведите в консоль все 20 чисел типа int из области памяти ptr_lens в одну строчку через пробел.

P. S. Не забудьте в конце (после __ASSERT_TESTS__) освободить память.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/7.4.7

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define DATA_LEN 20

int main(void) {
    int lengths[DATA_LEN];
    size_t count = 0;

    while (scanf("%d", &lengths[count]) == 1 && count < DATA_LEN) count++;
    // printf("%d\n", count);
    // for (size_t i = 0; i < count; i++) {
    //     printf("%d ", lengths[i]);
    // }
    // printf("\n");

    int* ptr_lens = calloc(DATA_LEN, sizeof(int));

    if (ptr_lens != NULL) {
        // for (size_t i = 0; i < DATA_LEN; i++) {
        //     printf("%d ", ptr_lens[i]);
        // }
        // printf("\n");
        memcpy(ptr_lens, lengths, sizeof(int) * count);
        for (size_t i = 0; i < DATA_LEN; i++) {
            printf("%d ", ptr_lens[i]);
        }
    }
    // __ASSERT_TESTS__
    // макроопределение для тестирования (не убирать и должно идти непосредственно перед return 0)

    if (ptr_lens != NULL) free(ptr_lens);
    return 0;
}
```

### Подвиг 8. Продолжите программу. Необходимо объявить функцию со следующей сигнатурой:
```c
void* expand_array(short* ptr, size_t* len, short fill);
```

Здесь *len - длина массива (число его элементов). Данная функция должна удваивать размер области памяти, выделенной под указатель ptr, в новую область копировать прежние данные, а остальные заполнять значениями fill. Прежняя область должна освобождаться (если была выделена новая). Значение размера *len нужно также увеличить в два раза. В конце функция expand_array должна вернуть адрес удвоенной области памяти.

В функции main вызовите функцию expand_array для удвоения памяти, на которую ведет указатель ptr_d, и значением fill = -1. В результате указатель ptr_d должен ссылаться на удвоенную область памяти. Затем, через указатель ptr_d выведите в консоль в одну строчку через пробел все целые числа типа short, хранящиеся в удвоенной области памяти.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/7.4.8

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define TOTAL 10
#define FILL -1

void* expand_array(const short* ptr, size_t* len, short fill) {
    size_t new_len = *len * 2;
    short* ar = malloc(sizeof(short) * new_len);
    if (ar != NULL) {
        memcpy(ar, ptr, sizeof(short) * *len);
        for (size_t i = *len; i < new_len; i++) {
            ar[i] = fill;
        }
        *len = new_len;
    }
    return ar;
}

int main(void) {
    short* ptr_d = calloc(TOTAL, sizeof(short));
    size_t len = TOTAL;
    if (ptr_d == NULL) return 0;

    int count = 0;
    while (count < TOTAL && scanf("%hd", &ptr_d[count]) == 1) count++;

    ptr_d = expand_array(ptr_d, &len, FILL);

    if (ptr_d != NULL) {
        for (size_t i = 0; i < len; i++) {
            printf("%d ", ptr_d[i]);
        }
        free(ptr_d);
    }

    return 0;
}
```

### Подвиг 9. Продолжите программу. Объявите функцию со следующей сигнатурой:

```c
char * merge_string(const char* str1, const char* str2);
```
Данная функция должна выделить память под новую строку так, чтобы в нее помещались все символы первой (str1) и второй (str2) строк. Затем, в новую строку скопировать сначала содержимое первой строки (только символы строки), а следом за ней содержимое второй строки. В конце не забудьте добавить символ '\0', чтобы сформировать корректную Си-строку. После объединения функция merge_string должна вернуть адрес сформированной строки.

В функции main вызовите функцию merge_string для объединения строк str_1 и str_2 (именно в таком порядке). Выведите в консоль полученную строку.

P. S. Не забудьте в конце программы освободить выделенную память.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/7.4.9

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void getline(char* buffer, size_t max_len) {
    fgets(buffer, max_len - 1, stdin);
    char* ptr_n = strrchr(buffer, '\n');
    if (ptr_n != NULL) *ptr_n = '\0';
}

char* merge_string(const char* str1, const char* str2) {
    size_t len_1 = strlen(str1);
    size_t len_2 = strlen(str2);

    char* res = malloc(sizeof(char) + (len_1 + len_2));
    if (res != NULL) {
        res = memcpy(res, str1, sizeof(char) * len_1);
        res[len_1] = '\0';
        res = strcat(res, str2);
    }
    return res;
}

int main(void) {
    char str_1[200] = {0};
    char str_2[200] = {0};

    getline(str_1, sizeof(str_1));
    getline(str_2, sizeof(str_2));

    char* str = merge_string(str_1, str_2);

    puts(str);
    free(str);
    return 0;
}
```

### Подвиг 10 (на повторение). Отметьте верные объявления переменных.

+ [ ] char int ch;
+ [ ] short double sd;
+ [x] short int a;
+ [x] long int b;
+ [x] long double ld;
+ [ ] long float lf;
+ [x] long long int LLi;
+ [x] long long d;

# 7.5 Перечисления (enum). Директива typedef

## Перечисления (enum).

На этом занятии познакомимся с новым типом данных – перечислением. С его помощью в программе удобно определять наборы целочисленных констант, например, следующим образом:

```c
enum colors {red, green, blue};
```

Здесь `enum` – это ключевое слово для объявления перечислимого типа; `colors` – идентификатор перечисления; `red`, `green`, `blue` – целочисленные константы типа `int`.

Прежде чем двигаться дальше, я думаю, нужно сразу ответить на вопрос, который, наверное, одолевает многих из вас: зачем нужно это перечисление? 

Неужели нельзя список констант определить или через директивы `#define`:

```c
#define REG     1
#define GREEN   2
#define BLUE    3
```

или через константные переменные:

```c
const int c_red = 1;
const int c_green = 2;
const int c_blue = 3;
```

На самом деле константы в перечислениях отличаются от всего того, что нам до сих известно. От константных переменных их отличает то, что их значения формируются в момент компиляции программы, то есть, они являются константами времени компиляции. И это очень важный момент. В частности, по этой причине их можно использовать в метках условного оператора `switch`. А от директив константы в перечислениях отличает безопасность их использования в различных конструкциях языка Си. Именно поэтому такие константы записывают, как правило, малыми буквами, а не большими, как макроимена, так как они не приводят к каким-либо скрытым ошибкам в коде программы. Все это делает перечисления незаменимым инструментом для объявления и использования целочисленных констант.

Давайте вначале посмотрим на способы объявления перечислений. Самый простой из них мы уже видели:

```c
enum colors {red, green, blue};
```

При этом константы `red`, `green`, `blue` соответствуют типу `int` и принимают значения `0`, `1` и `2` соответственно. Мы их даже можем вывести на экран с помощью функции `printf()`:

```c
#include <stdio.h>
enum colors {red, green, blue};
 
int main(void) {
    printf("red = %d, green = %d, blue = %d\n", red, green, blue);
    return 0;
}
```

После выполнения программы увидим строчку:

```c
red = 0, green = 1, blue = 2
```

Но, при необходимости, значения констант можно задавать вручную, например, такими способами:

```c
enum keys {vk_enter=27, vk_space, vk_del=30};
enum {
    go = 0x1f00, 
    stop = 0x0001, 
    forward = go,
    run = 0x00a2,
    back = run -1
};
```

В перечислении `keys` константа `vk_enter` принимает значение `27`, следующая константа `vk_space` на единицу больше, то есть, `28`, и последняя `vk_del` равна `30`. 

А перечисление без идентификатора (имени) задает константы, причем некоторые из них определены на основе других, ранее объявленных и с использованием арифметических операций. Так тоже можно делать. Главное, чтобы выражение использовало данные времени компиляции. Последнее перечисление без имени обычно прописывают, если целью является только объявление целочисленных констант.

А как можно использовать именованные перечисления, например, `keys`? В языке Си ключевое слово `enum` с последующим именем образуют новый составной тип данных. То есть, мы вполне можем объявить переменную такого типа следующим образом:

```c
enum keys k_var;
```

Что это за тип? 

На уровне машинных кодов компилятор представляет переменную `k_var` как целочисленную типа `int`. А раз так, значит, мы вполне можем заменить тип enum `keys` на `int`? 

Формально да, можем, и программа будет работать абсолютно также. Но есть один нюанс. Тип `enum keys` для компилятора не в точности соответствует типу `int`. Отличие я покажу на конкретном примере. Пусть переменная `k_var` используется в операторе `switch` следующим образом:

```c
#include <stdio.h>
 
enum keys {vk_enter=27, vk_space, vk_del=30};
 
int main(void) {
    enum keys k_var = vk_enter;
 
    switch(k_var) {
    case vk_enter:
        puts("vk_enter");
        break;
    case vk_space:
        puts("vk_space");
        break;
    }
 
    return 0;
}
```

Если скомпилировать эту программу с указанием флага `–Wall` (отображение всех предупреждений), то увидим сообщение:

```c
warning: enumeration value 'vk_del' not handled in switch
```

Компилятор предупреждает нас, что мы в операторе `switch` указали не все варианты значений, заданные в перечислении `enum keys`. При этом программа компилируется и запускается. Это предупреждение появилось из-за того, что тип переменной `k_var` соответствует `enum keys`, а не просто `int`. Если мы пропишем `int`:

```c
int k_var = vk_enter;
```

то компилятор не сможет отловить этот момент, никаких предупреждений выдано не будет. Поэтому, на практике все же лучше не пренебрегать перечислимым типом и использовать именно его, а не тип `int`. Во всем остальном, переменная `k_var` ведет себя так же, как и обычная целочисленная переменная. В общем случае ей можно присваивать любые целые значения:

```c
enum keys k_var = vk_enter * 2 - vk_space * 100;
```

Хотя, так делать не стоит и лучше присваивать константы, записанные в соответствующем перечислении (в данном случае в `keys`).

Переменные перечислимого типа можно задавать при объявлении перечисления. Например, так:

```c
enum colors {red, green, blue} wnd_colors;
 
enum {
    go = 0x1f00, 
    stop = 0x0001, 
    forward = go,
    run = 0x00a2,
    back = run -1
} actions, commands;
```

В результате получим объявление глобальных переменных `wnd_colors`, `actions` и `commands`.

## Директива typedef

Во второй части занятия рассмотрим директиву `typedef`, которая позволяет задавать пользовательское имя типа. Попросту говоря, она любой тип данных позволяет представить другим именем. Например, так:

```c
typedef unsigned char BYTE;
```

В результате в программе появляется новое имя `BYTE` как синоним типа `unsigned char`. Соответственно, его можно использовать всюду как полноценный тип данных, например:

```c
typedef unsigned char BYTE;
 
int main(void) {
    BYTE byte;
    BYTE ch, var_ch = '0';
 
    return 0;
}
```

Компилятор вместо слова `BYTE` подставит `unsigned char` и программа будет работать с объявленными переменными, как с беззнаковыми байтовыми.

На первый взгляд кажется, что этот же фокус можно проделать и с помощью директивы препроцессора `#define` следующим образом:

```c
#define BYTE unsigned char
```

И, действительно, программа скомпилировалась без проблем и отработала бы абсолютно также. Но все же, между определением через директиву `#define` и директиву `typedef` есть существенная разница. Директива `typedef` обрабатывается не препроцессором, а самим компилятором, а потому это более тонкое и безопасное действие. Покажу это на следующем примере:

```c
#include <stdio.h>
 
#define PTR_INT int*
 
typedef int* PTR;
 
int main(void) {
    PTR_INT a, b;      // int* a, b;
    PTR ptr_a, ptr_b;  // int *ptr_a, *ptr_b;
    printf("*a = %d, *b = %d\n", *a, *b);
    printf("*ptr_a = %d, *ptr_b = %d\n", *ptr_a, *ptr_b);
 
    return 0;
}
```

Мы двумя способами переопределяем тип `int*` для объявления целочисленных указателей. Затем, в функции `main()` объявляем два указателя `a`, `b` с помощью макровызова `PTR_INT` и еще два указателя `ptr_a`, `ptr_b` с помощью введенного типа `PTR`. В итоге, после обработки текста программы, мы получим следующий эквивалент объявлений:

```c
int* a, b;
int *ptr_a, *ptr_b;
```

Как говорится, почувствуйте разницу. Благодаря тому, что `typedef` – это директива уровня компилятора, он корректно применяет подмененный тип и каждую переменную делает указателем. А макровызов `PTR_INT` срабатывает на уровне препроцессора, который «в лоб» на уровне текста программы делает подмену. В итоге получаем не совсем корректный результат.

Довольно часто директиву `typedef` применяют с составными типами данных. Обычно, это структуры, о которых мы будем говорить на следующем занятии. Но сейчас я приведу пример с составным перечислимым типом:

```c
#include <stdio.h>
 
typedef enum {
    buffer_size = 2048,
    element_size = 12,
    window_size = 400
} SIZE_CONSTS;
 
int main(void) {
    SIZE_CONSTS sizes = window_size;
    printf("%d\n", sizes);
    printf("%d\n", buffer_size);
 
    return 0;
}
```

Обратите внимание, в этом случае имя перечисления прописывать не имеет особого смысла. В дальнейшем все равно предполагается использовать имя типа `SIZE_CONSTS` для объявления переменных перечислимого типа.

После всех этих примеров, у вас все равно может остаться вопрос, зачем все это нужно? Только лишь для удобства? Или есть другие причины? 

Да, причины есть, по крайней мере, еще одна. Помните, когда мы с вами рассматривали некоторые функции, то тип данных у них имел вид `size_t`. Например, такой тип имеет параметр функции `malloc()`:

```c
void* malloc(size_t size);
```

В действительности, это переопределенный тип с помощью оператора `typedef`. В моей реализации это следующая замена:

```c
typedef unsigned int size_t;
```

Какую роль играет это переопределение? Смотрите, когда компьютеры были максимум 32-разрядные, то типа `unsigned int` было вполне достаточно для выделения максимально возможного блока памяти. При переходе к 64-разрядным системам этого размера может быть уже недостаточно и потребуется другое переопределение, например:

```c
typedef unsigned long long size_t;
```

При этом сама запись типа `size_t` сохраняется неизменной. А, значит, неизменными остаются и все прототипы функций, которые используют тип `size_t`, а также все объявления переменных этого типа. Получается некоторая универсальность текста программы. При необходимости, нам достаточно подменить тип `size_t` с одного на другой и можно просто перекомпилировать ранее написанные программы без дальнейших переделок. В этом удобство и практичность введенного типа `size_t` и других ему подобных.

Наконец, оператор `typedef` можно использовать для упрощения записи сложных типов данных, например, указателей на функции или многомерные массивы:

```c
#include <stdio.h>
#include <stdlib.h>
 
int is_even(int x) {
    return x % 2 == 0;
}
 
typedef int (*PTR_EVEN)(int);
typedef char (*PTR_AR_2D)[4];
 
int main(void) {
    char ar_2d[5][4] = {0};
    PTR_AR_2D ptr_2d = ar_2d;
    ar_2d[1][2] = 5;
   
    PTR_EVEN func_even = is_even;
 
    printf("%d\n", func_even(2));
    printf("%d\n", func_even(3));
 
    printf("%d\n", ptr_2d[1][2]);
 
    return 0;
}
```

Как видите, при замене программа становится более читаемой, поэтому, в ряде случаев, такие замены вполне могут быть использованы.

Видео по теме [#52. Перечисления (enum). Директива typedef](https://www.youtube.com/watch?v=lnXZSkCbD5s&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, касающиеся перечислимого типа языка Си.

+ [x] константы перечисления связаны с целыми числами и не имеют скрытого поведения, как например, директивы
+ [ ] константы перечисления нельзя использовать в метках case оператора switch
+ [ ] перечисления позволяют задавать числовые константы времени выполнения программы (не компиляции)
+ [x] константы перечисления можно использовать в метках case оператора switch
+ [x] перечисления позволяют задавать числовые константы времени компиляции

### Подвиг 2. Выберите все верные объявления перечислений.

+ [x] enum types {type_int, type_double, type_long};
+ [x] enum sizes {width=1280, height=720};
+ [x] enum {black=0, red=0xCC0000, green = 0x00CC00, blue=0x0000CC, white=255};
+ [x] enum window_styles {border=2, caption=4, sizeable=8} style;
+ [x] enum {v2=2, v3=3, v4=4} vector_dim;

### Подвиг 3. Выберите все верные утверждения, касающиеся следующего фрагмента программы:

```c
#include <stdio.h>

enum window_styles {border=2, caption=4, sizeable=8};

int main(void) {
    enum window_styles style = 0;
    style = border | caption;

    return 0;
}
```

+ [x] переменная style сначала инициализируется нулем, а затем ей присваивается десятичное значение 6
+ [x] в программе объявлена переменная style перечисляемого типа
+ [x] переменную style можно использовать, как целочисленную переменную типа int (но делать так не рекомендуется)
+ [x] переменная style на уровне машинных кодов представляется и обрабатывается, как целочисленная переменная типа int
+ [ ] переменная style сначала инициализируется нулем, а затем ей присваивается десятичное значение 5
+ [x] в программе объявлено перечисление с идентификатором window_styles

### Подвиг 4. Напишите программу, в которой объявляется перечисление с идентификатором menu_item и константами:

```c
item_exit = 1, item_c = 2, item_python = 3, item_java = 4
```

В функции main прочитайте из входного потока целочисленное значение и сравните его с одной из констант перечисления. Сравнение следует выполнить с помощью оператора switch. При совпадениях в консоль выведите следующие строки (без кавычек):

item_exit: "Выход";
item_c: "Язык Си";
item_python: "Язык Python";
item_java: "Язык Java".

Если ни одна из констант не была выбрана, то вывести строку:

"Не верный пункт меню"

```c
#include <stdio.h>

enum menu_item { item_exit = 1, item_c = 2, item_python = 3, item_java = 4 };

int main(void) {
    enum menu_item menu;
    int num;
    scanf("%d", &num);

    menu = num;

    switch (menu) {
        case item_exit:
            puts("Выход");
            break;
        case item_c:
            puts("Язык Си");
            break;
        case item_python:
            puts("Язык Python");
            break;
        case item_java:
            puts("Язык Java");
            break;
        default:
            puts("Не верный пункт меню");
    }

    return 0;
}
```

### Подвиг 5. Напишите программу, в которой объявляется перечисление с идентификатором calc_types и константами:

```c
_perimetr=1, _square=2
```

Объявите функцию с именем `calc_rect`, которая имеет следующие параметры (порядок важен):
+ ширина прямоугольника width (тип double);
+ высота прямоугольника height (тип double);
+ тип вычислений type (тип calc_types).

Функция должна вычислять либо площадь прямоугольника (если `types` равен `_square`), либо его периметр (если types равен `_perimetr`) и возвращать вычисленное значение (тип `double`). 

В функции `main` прочитайте из входного потока одно целое число (для `type`) и два вещественных числа (`width` и `height`), записанных в одну строчку через пробел. Вызовите функцию `calc_types` с передачей ей прочитанных значений в качестве аргументов. Выведите в консоль вычисленное значение с точностью до десятых.

```c
#include <stdio.h>

typedef enum calc_types { _perimetr = 1, _square = 2 } types;

double calc_rect(double width, double height, types form) {
    double res = 0;
    switch (form) {
        case _perimetr:
            res = (width + height) * 2;
            break;
        case _square:
            res = width * height;
            break;
        default:
            puts("Wrong type");
    }
    return res;
}

int main(void) {
    types oper;
    int num;
    double w, h;
    scanf("%d %lf %lf", &num, &w, &h);

    oper = num;

    double result = calc_rect(w, h, oper);

    printf("%.1lf", result);

    return 0;
}
```

### Подвиг 6. Выберите все верные утверждения, касающиеся директивы typedef

+ [ ] директива typedef позволяет создавать новые типы данных
+ [x] директива typedef позволяет задавать новые имена существующим типам данных
+ [x] typedef обрабатывается компилятором, а не препроцессором, поэтому работает "более тонко" и корректно, чем обычные директивы препроцессора
+ [ ] директива typedef обрабатывается текстовым препроцессором и небезопасна в использовании (как и все директивы препроцессора)
+ [x] при помощи директивы typedef достигается лучшая переносимость текста программы с одной платформы на другую (пример, использование типа size_t)
+ [x] директива typedef удобна при замене длинных названий типов на более короткие имена

### Подвиг 7. Выберите все верные варианты использования директивы typedef.

+ [ ] typedef double(*)(int, int) PTR_FUNC;
+ [x] typedef double (*PTR_FUNC)(int, int);
+ [x] typedef enum {type_int, type_double, type_long} TYPES;
+ [x] typedef char* P_STR;
+ [ ] typedef TYPES enum {type_int, type_double, type_long};
+ [ ] typedef int long;
+ [x] typedef unsigned long ULONG;
+ [x] typedef enum menu_item {item_exit, item_c} MENU;
+ [ ] typedef char[100] STR;

### Подвиг 8. Напишите программу, в которой объявляется перечисление без идентификатора и константами:

```
_do=1, _re=2, _mi=3, _fa=4, _sol=5, _la=6, _si=7
```

Определите тип этого перечисления как `NOTES`. Объявите функцию с именем `get_major`, которая имеет один параметр с типом `NOTES`. Функция должна возвращать `1`, если были переданы значения констант: `_do`, или `_mi`, или `_sol`. В противном случае функция `get_major` возвращает `0`.

В функции `main` прочитайте из входного потока пять целых чисел в диапазоне `[1; 7]`, записанных в одну строчку через пробел. Выведите в консоль (в одну строчку через пробел) только те числа, для которых функция `get_major` вернула истинное значение (единицу).

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/7.5.8

```c
#include <stdio.h>
#define NOTES_COUNT 5

typedef enum { _do = 1, _re = 2, _mi = 3, _fa = 4, _sol = 5, _la = 6, _si = 7 } NOTES;

int get_major(NOTES note) {
    int res = 0;
    switch (note) {
        case _do:
        case _mi:
        case _sol:
            res = 1;
            break;
        default:
            res = 0;
    }
    return res;
}

int main(void) {
    NOTES accord[NOTES_COUNT];
    for (size_t i = 0; i < NOTES_COUNT; i++) {
        int note;
        scanf("%d", &note);
        accord[i] = note;
    }

    for (size_t i = 0; i < NOTES_COUNT; i++) {
        if (get_major(accord[i])) printf("%d ", accord[i]);
    }

    return 0;
}
```

### Подвиг 9 (с повторением). Напишите программу, которая в функции main читает из входного потока слова (разделены пробелом). Максимальное количество слов не более 20, а максимальная длина каждого слова не более 50 символов.

Объявите функцию со следующей сигнатурой:

```c
int is_correct(const char* str);
```

Функция `is_correct` должна проверять, что в строке содержится фрагмент "`ra`" без учета регистра. Если это так, то она возвращает `1`, иначе `0`. Определите на эту функцию указатель нового типа `FUNC_CORRECT` (тип данных).

Объявите еще одну функцию с сигнатурой:

```c
int get_correct_words(const char (*words)[50], int count_words, FUNC_CORRECT filter);
```

Функция `get_correct_words` должна подсчитывать количество корректных слов (для которых `is_correct` возвращает 1) в массиве `words` и возвращать вычисленное значение.

В функции  `main` (для прочитанных из входного потока слов) вызовите функцию `get_correct_words` с фильтром `is_correct` и выведите в консоль число корректных слов.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/7.5.9

```c
#include <stdio.h>
#include <string.h>

#define MAX_WORDS 20

int is_correct(const char* str) {
    int res = 0;
    char* str_for_search[4] = {"RA", "Ra", "rA", "ra"};
    for (size_t i = 0; i < 4; i++) {
        if (strstr(str, str_for_search[i]) != NULL) {
            res = 1;
            break;
        }
    }
    return res;
}

typedef int (*FUNC_CORRECT)(const char*);

FUNC_CORRECT filter = is_correct;

int get_correct_words(const char (*words)[50], int count_words, FUNC_CORRECT filter) {
    int res = 0;
    for (int i = 0; i < count_words; i++) {
        // puts(words[i]);
        if (filter(words[i])) res++;
    }
    return res;
}

int main() {
    char words[MAX_WORDS][50];

    int count = 0;
    int result;

    while (count < MAX_WORDS && scanf("%49s", words[count]) == 1) {
        if (strlen(words[count]) < 2) break;
        // puts(words[count]);
        count++;
    }

    // for (size_t i = 0; i < count; i++) {
    //     puts(words[i]);
    // }

    result = get_correct_words(words, count, filter);

    printf("%d", result);

    return 0;
}
```

### Подвиг 10 (на повторение). Пусть имеется следующий фрагмент программы:

```c
double* p1 = (void *)128000, *p2 = (void *)128064;  // тип double 64 бит
int count = p2 - p1;
```

Чему будет равно значение переменной `count` при выполнении этих двух строчек?

$\dfrac{128064 - 128000}{64 : 8} = \dfrac{64}{8} = 8$

# 7.6 Структуры. Вложенные структуры

## Структуры

На этом занятии познакомимся с еще одним составным типом данных – структурами. Чтобы было понятно, о чем идет речь, давайте сразу приведу пример объявления простой структуры для хранения координат точек в трехмерном пространстве:

```c
struct tag_point {
    int x;
    int y;
    int z;
};
```

Такая запись логически объединяет три переменные `x`, `y`, `z` целочисленного типа в одном новом составном типе данных под названием `struct tag_point`. То есть, чтобы объявить ту или иную структуру в программе, используется следующий синтаксис:

```c
struct [имя структуры] {
    [поля струкутры]
};
```

Здесь под полями структуры понимаются переменные, записанные при ее объявлении. В нашем примере поля – это переменные `x`, `y`, `z`. В конце объявления структуры ставится точка с запятой.

Обратите внимание, что объявление структуры – это описание нового составного типа в тексте программы. 

Не более того. 

Компилятор здесь не создает никаких переменных и не размещает их в памяти. Это, всего лишь, новый тип данных, подобно базовым типам `char`, `int`, `double`, ... . А раз у нас есть тип, значит, можно объявить переменную этого типа. Сделать это можно следующим образом:

```c
int main(void) {
    struct tag_point pt;
    return 0;
}
```

Мы объявили локальную переменную `pt` типа `struct tag_point`. В языке Си тип структуры обязательно включает в себя два слова: `struct` и имя структуры. В отличие от языка С++, в котором первое слово `struct` можно опускать.

Итак, что из себя представляет переменная `pt` в памяти, то есть, на уровне машинных кодов? 

В действительности, структуры – это абстракция языка Си. В машинных кодах она, естественно, не существует. Поэтому когда мы объявляем переменную этого типа, то в памяти устройства выделяется нужный непрерывный участок из байт и все поля структуры (ее переменные) по порядку располагаются друг за другом:

![07](/Good_good_C_C++/img/07_05.jpg)

При этом в памяти, где размещаются поля структуры, компилятор может самостоятельно добавлять, так называемые, выравнивающие байты. 

Для чего это нужно? 

Дело в том, что чтение данных из оперативной памяти пакетом в две или четыре ячейки может происходить быстрее, если читаемые данные расположены по четным адресам. 

Например, это имеет место в интелловской архитектуре процессоров, а в некоторых других архитектурах данные размером в машинное слово или двойное машинное слово вообще строго обязательно размещать по четным адресам. 

Именно по этой причине компилятор может добавлять выравнивающие байты, чтобы переменные размером в машинное слово попадали в четные адреса. Этот процесс по-английски называется `alignment` – выравнивание. 

В результате, размер данных в структуре может превышать сумму размеров каждого из ее полей. И истинный размер можно получить с помощью знакомой нам операции `sizeof` следующим образом:

```c
size_t sz_pt = sizeof(pt);
size_t sz_st = sizeof(struct tag_point);
 
printf("sz_pt = %d, sz_st = %d\n", sz_pt, sz_st);
```

После запуска программы получились значения `12`:

```
sz_pt = 12, sz_st = 12
```

То есть, в данном случае размер структуры в памяти равен сумме размеров трех целочисленных переменных int:

```
12 = 3 × 4
```

После того, как мы объявили переменную `pt` на структуру, ее можно заполнить конкретными значениями. Делается это следующим образом:

```c
pt.x = 1;
pt.y = 2;
pt.z = 3;
```

То есть, пишется имя переменной, ставится точка и указывается имя поля, с которым мы собираемся работать. При этом запись `pt.x` или `pt.y` или `pt.z` – это уже отдельные целочисленные переменные типа `int`. И с ними мы работает как с обычными целочисленными переменными: присваиваем и считываем значения.

Помимо присваивания отдельным полям тех или иных значений, структуры можно инициализировать подобно массивам. Для этого используется похожий синтаксис:

```c
<тип структуры> <имя переменной> = {[значения полей]};
```

В нашем примере инициализатор можно записать в следующих вариантах:

```c
struct tag_point pt = {10, 20, 30};
struct tag_point pt = {10};
struct tag_point pt = {};
```

В последнем случае наличие пустого инициализатора просто обнуляет значения полей.

Стандарт С99 дополнительно вводит выделенные инициализаторы, которые позволяют задавать начальные значения полей по их именам следующим образом:

```c
struct tag_point pt = {.y = -1, .x = 2};
```

### Вложенные структуры

Вообще в качестве полей структур можно использовать любые типы данных, в том числе, и другие структуры. Давайте вначале определим структуру для хранения имени и фамилии сотрудника:

```c
enum {name_length=50, b_length=20};
 
struct tag_fio {
    char name[name_length]; /* имя */
    char last[name_length]; /* фамилия */
};
```

А, затем еще одну структуру для общих данных о сотруднике, включая его имя:

```c
struct tag_person {
    struct tag_fio fio;     /* ФИО */
    char sex;               /* пол: м или ж */
    unsigned short old;     /* возраст */
    char b_date[b_length];   /* дата рождения */
};
```

Как видите, здесь вторая структура имеет поле `fio`, которое является переменной первой структуры. Давайте теперь посмотрим, как можно инициализировать такие структуры и обрабатывать. Объявим переменную `person` на структуру `struct tag_person` со следующим инициализатором:

```c
int main(void) {
    struct tag_person person = {
        {"Sergey", "Balakirev"},
        'M',
        98,
        "32.07.1925"
    };
 
    return 0;
}
```

Далее, если нам нужно получить значения полей `sex` и `b_date` и вывести их на экран, то это можно сделать так:

```c
printf("sex: %c, b_date: %s\n", person.sex, person.b_date);
```

То есть, мы также через операцию «точка» обращаемся к нужному полю по его имени и читаем данные. В итоге, `person.sex` – это переменная типа `char`, а `person.b_date` – одномерный массив символов.

Давайте теперь изменим поля `old` и `b_date`. Сделать это можно следующим образом:

```c
person.old = 17;
strcpy(person.b_date, "31.07.2006");
```

Обратите внимание, `person.b_date` – это одномерный массив типа `char`, поэтому для копирования в него новой строки нужно использовать функцию `strcpy()`, которая выполняет эту операцию. Просто присвоить одному массиву другой массив, как мы с вами уже говорили, нельзя:

```c
person.b_date = "31.07.2006";    // ошибка, так не работает
```

Только с использованием строковых функций, о которых мы также с вами уже говорили. Хотя, в инициализаторе можно прописывать строковые литералы и они будут копироваться в соответствующие массивы. Но это отличия в работе инициализаторов и операции присваивания.

А теперь самое главное, как обратиться к полям вложенной структуры? Думаю, многие из вас уже догадались. Сначала, конечно, нужно взять поле `fio`:

```c
person.fio
```

Но это поле, в свою очередь, тоже структура с двумя своими полями `name` и `last`. Следовательно, после `fio` также нужно поставить точку и указать одно из этих полей, например, так:

```c
printf("name: %s, last: %s\n", person.fio.name, person.fio.last);
```

Увидим строчку:

```c
name: Sergey, last: Balakirev
```

Как видите, все предельно просто. Соответственно, если нужно изменить одно из полей вложенной структуры, то делается аналогично полю `b_date`, например:

```c
strcpy(person.fio.name, "Sergiy");
```

## Копирование одной структуры в другую

Благодаря тому, что структуры образуют полноценный тип данных языка Си, переменные одного и того же типа можно присваивать друг другу с копированием всей информации. Например, определим еще одну переменную типа `struct tag_person`:

```
struct tag_person p;
```

Тогда в нее можно скопировать всю информацию из переменной `person` того же типа с помощью обычной операции присваивания:

```
p = person;
```

Обратите внимание, здесь происходит именно копирование информации. На уровне машинных кодов область памяти, занимаемой структурой `person`, копируется в область памяти структуры `p`. В результате, все данные один в один копируются в структуру `p`. 

Поэтому, если вам нужно перенести данные из всех полей из одной структуры в другую, то лучше использовать обычное присваивание, чем по отдельности копировать поля. Это и быстрее и, кроме того, при изменении набора полей в структуре, в программе не понадобится вносить никаких изменений, что очень удобно.

Давайте выведем некоторые поля переменной `p` и убедимся, что они не были изменены переменной `person`:

```c
printf("old: %d, b_date: %s\n", p.old, p.b_date);
```

Увидим начальные значения:

```
old: 98, b_date: 32.07.1925
```

Интересно, что массивы тоже можно было бы скопировать один в другой, если они прописаны внутри структуры. Например, пусть объявлена структура с одним одномерным массивом:

```c
#include <stdio.h>
 
struct tag_array {
    int marks[b_length];
};
 
int main(void) {
    struct tag_array marks_1 = {2, 2, 2, 3, 2, 2};
    struct tag_array marks_2;
 
    marks_2 = marks_1;
    for(int i = 0;i < sizeof(marks_2.marks) / sizeof(*marks_2.marks); ++i)
        printf("%d ", marks_2.marks[i]);
        
    return 0;
}
```

Смотрите, мы поместили одномерный массив в структуру, затем в функции `main()` объявили две переменные, одну из которых инициализировали, то есть, по сути, инициализировали элементы массива. Затем, второму массиву присвоили значения первого, данные были скопированы и цикл `for` их вывел в консоль:

```
2 2 2 3 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0
```

Получился довольно оригинальный способ работы с массивами. Хотя на практике так не делают. 

Объявлять структуру с массивом только ради возможности его копирования, не лучший ход. Если уж нам действительно так важно быстро перенести данные из одного массива в такой же другой, то для этого можно воспользоваться функцией:

```c
void* memcpy(void* restrict dst, const void* restrict src, size_t length);
```

о которой мы с вами ранее уже говорили.

## Массивы структур

В заключение этого занятия отмечу такой очевидный момент, как объявление массивов из структур. Допустим, некоторая фигура описывается набором точек (вершин) в трехмерном пространстве. Для представления одной точки можно записать структуру:

```c
enum {max_points=10};
 
struct tag_point {
    double x, y, z;
};
```

А, затем, использовать ее при объявлении массива:

```c
int main(void) {
    struct tag_point figure[max_points];
    int figure_points = 0;       // число точек в фигуре
 
    return 0;
}
```

В итоге получаем массив `figure`, каждый элемент которого является структурой типа `struct tag_point`:

![07](/Good_good_C_C++/img/07_06.jpg)

Работать с этим массивом можно очевидным образом. Так как каждый его элемент figure[0], …, figure[9] является структурой, то, например, запись значений в его первые два элемента можно выполнить следующим образом:

```c
figure[0].x = 1.2;
figure[0].y = -5.6;
figure[0].z = 10.0;
 
figure[1].x = 12.4;
figure[1].y = 3.2;
figure[1].z = 7.6;
 
figure_points = 2;
```

Подобным образом можно определять массивы из любых типов структур и работать с ними.

Видео по теме [#53. Структуры. Вложенные структуры](https://www.youtube.com/watch?v=yRSBSmxw2l4&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, касающиеся структур языка Си.

+ [ ] объявление структуры - это объявление новой переменной (составного) типа
+ [x] объявление структуры - это объявление нового (составного) типа данных
+ [x] структура позволяет в программе единым образом представлять разнотипные данные
+ [x] каждое поле структуры располагается в независимой области памяти и следуют друг за другом (не обязательно подряд)
+ [x] оператор sizeof, применительно к структуре, возвращает ее полный размер в байтах
+ [ ] каждое поле структуры располагается в памяти, начиная с одного и того же адреса памяти

### Подвиг 2. Выберите все верные варианты объявление структур.

+ [ ] struct {char ch; int d; double vd; };
+ [x] struct {char ch; int d; double vd; } var;
+ [x] struct tag_var {char ch; int d; double vd; } var;
+ [x] struct tag_var {char ch; int d; double vd; };

### Подвиг 3. Продолжите программу, в которой объявляется структура с идентификатором tag_vector и целочисленными полями x, y, z типа short. В функции main объявите переменную этой структуры с именем vector. Заполните поля x, y, z значениями, прочитанными из входного потока, идущими в одну строчку через пробел.

P. S. В консоль ничего выводить не нужно.

```c
#include <stdio.h>

typedef struct tag_vector {
    short x;
    short y;
    short z;
} VECTOR;

int main() {

    VECTOR vector;

    scanf("%hd %hd %hd", &vector.x, &vector.y, &vector.z);

    // __ASSERT_TESTS__
    // макроопределение для тестирования (не убирать и должно идти непосредственно перед return 0)

    return 0;
}
```

### Подвиг 4. Выберите все верные варианты инициализации полей структуры tag_thing языка Си стандарта C99:

```c
struct tag_thing {
    unsigned int id;
    char name[50];
    double weight;
    double price;
};
```

+ [x] struct tag_thing thing_4 = {.id = 5, .name="toy"};
+ [x] struct tag_thing thing_5 = {.price=103.5, .weight = 5.45};
+ [x] struct tag_thing thing_3 = {};
+ [x] struct tag_thing thing_2 = {1, "book"};
+ [x] struct tag_thing thing_1 = {1, "book", 0.5, 3500.0};

### Подвиг 5. Продолжите программу. Выше в тексте программы объявлена переменная price_100 структуры tag_price (она скрыта, но она существует). В функции main необходимо объявить переменную с именем pr той же структуры tag_price и скопировать данные из переменной price_100 в переменную pr. Выведите значения полей переменной pr в консоль в одну строчку через пробел в порядке их описания в структуре tag_price. Все поля, кроме name, должны выводиться десятичными числами.

```c
#include <stdio.h>

struct tag_price {
    char name[100];
    unsigned int rubs;
    unsigned short kops;
    unsigned int foreign_key;
};

struct tag_price price_100 = {};

int main(void) {
    struct tag_price pr = price_100;

    printf("%s %d %d %d", pr.name, pr.rubs, pr.kops, pr.foreign_key);

    // __ASSERT_TESTS__
    // макроопределение для тестирования (не убирать и должно идти непосредственно перед return 0)
    return 0;
}
```

### Подвиг 6. Продолжите программу. Объявите структуру tag_fio с полями firstname, otch, lastname как строки максимальной длины 50 символов. Следом объявите еще одну структуру tag_student с полями: fio (тип: структура tag_fio); old, height, weight (тип short). В функции main создайте переменную с именем st структуры tag_student и заполните ее поля данными из переменных: fname, otch, lname, old, height, weight.

P. S. В консоль ничего выводить не нужно.

```c
#include <stdio.h>
#include <string.h>

typedef struct tag_fio {
    char firstname[50];
    char otch[50];
    char lastname[50];
} FIO;

typedef struct tag_student {
    FIO fio;
    short old;
    short height;
    short weight;
} STUDENT;

void _getline(char* buffer, size_t max_len) {
    fgets(buffer, max_len - 1, stdin);
    char* ptr_n = strrchr(buffer, '\n');
    if (ptr_n != NULL) *ptr_n = '\0';
}

int main(void) {
    char fname[50], otch[50], lname[50];  // имя, отчество, фамилия
    short old, height, weight;            // возраст, высота, вес

    _getline(fname, sizeof(fname));
    _getline(otch, sizeof(otch));
    _getline(lname, sizeof(lname));

    scanf("%hd, %hd, %hd", &old, &height, &weight);

    STUDENT st = {.old = old, .height = height, .weight = weight};

    strcpy(st.fio.firstname, fname);
    strcpy(st.fio.otch, otch);
    strcpy(st.fio.lastname, lname);

    // printf("%s\n%s\n%s\n%d\n%d\n%d", st.fio.firstname, st.fio.otch, st.fio.lastname, st.height, st.old,
    // st.weight);

    // __ASSERT_TESTS__
    // макроопределение для тестирования (не убирать и должно идти непосредственно перед return 0)
    return 0;
}
```

### Подвиг 7. Продолжите программу. В функции main объявите две переменные tm1 и tm2 структуры tag_time. Значения их полей (шесть целых неотрицательных чисел, записанных в одну строчку через пробел) прочитайте из входного потока. Объявите еще одну переменную tm_sum структуры tag_time, поля которой должны содержать сумму времен переменных tm1 и tm2. Время нужно складывать так, чтобы минуты и секунды не выходили из пределов [0; 59]. Выведите в консоль полученное время tm_sum в формате:

hh:mm:ss

Например:

12:08:43

(Обратите внимание на наличие незначащего нуля перед числами меньше 10).

```c
#include <stdio.h>

typedef struct tag_time {
    unsigned char hours;
    unsigned char minutes;
    unsigned char seconds;
} TIME;

int main(void) {
    TIME tm1, tm2, tm_sum;

    char shift_minutes = 0;
    char shift_hours = 0;

    scanf("%d %d %d", &tm1.hours, &tm1.minutes, &tm1.seconds);
    scanf("%d %d %d", &tm2.hours, &tm2.minutes, &tm2.seconds);

    tm_sum.seconds = (tm1.seconds + tm2.seconds) % 60;
    shift_minutes = tm1.seconds + tm2.seconds < 60 ? 0 : 1;
    tm_sum.minutes = (tm1.minutes + tm2.minutes + shift_minutes) % 60;
    shift_hours = tm1.minutes + tm2.minutes + shift_minutes < 60 ? 0 : 1;
    tm_sum.hours = tm1.hours + tm2.hours + shift_hours;

    printf("%02d:%02d:%02d", tm_sum.hours, tm_sum.minutes, tm_sum.seconds);

    // __ASSERT_TESTS__
    // макроопределение для тестирования (не убирать и должно идти непосредственно перед return 0)
    return 0;
}
```

### Подвиг 8. Объявите в программе структуру с идентификатором tag_point_3d и полями x, y, z типа int (координаты точки в трехмерном пространстве). В функции main объявите массив points структуры tag_point_3d размером total_points. Константа total_points должна быть объявлена через перечисление и равна 100. Из входного потока (в функции main) читайте целые числа (записанные в одну строчку через пробел) и последовательно записывайте в массив points. То есть, первый элемент массива points будет содержать первые три числа из входного потока, второй элемент points - следующие три числа, и так далее. Если на каком-либо этапе читается меньше трех чисел, то считывание завершается и неполные данные (менее трех чисел) в очередной элемент массива points не заносятся. В переменной total должно содержаться общее число корректно сформированных элементов массива points. Выведите в консоль в одну строчку через пробел значения координат x, y, z последнего элемента массива points, в который производилась запись.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/7.6.8

```c
#include <stdio.h>

typedef struct tag_point_3d {
    int x;
    int y;
    int z;
} POINTS_3D;

int main(void) {
    enum { total_points = 100 };

    POINTS_3D points[total_points];

    size_t i;

    for (i = 0; i < total_points; i++) {
        if (scanf("%d %d %d", &points[i].x, &points[i].y, &points[i].z) != 3) break;
    }
    i--;
    printf("%d %d %d", points[i].x, points[i].y, points[i].z);

    // __ASSERT_TESTS__
    // макроопределение для тестирования (не убирать и должно идти непосредственно перед return 0)
    return 0;
}
```

### Подвиг 9 (на повторение). Установите соответствия между математическими функциями округления и их описаниями.

![07](/Good_good_C_C++/img/07_07.PNG)

### Подвиг 10 (на повторение). Установите соответствия между математическими степенными функциями и их описаниями.

![07](/Good_good_C_C++/img/07_08.PNG)

# 7.7 Указатели на структуры. Передача структур в функции

## Указатели на структуры.

Начнем это занятие с указателей на структуры. Мы уже с вами знаем, что такое указатели и как с ними можно работать с обычными переменными базовых типов: `char`, `int`, `double`, …. Пришло время узнать, как используются указатели совместно со структурами.

Для примера опишем в программе простую структуру для представления двумерных радиус-векторов:

```c
struct tag_vector {
    double x;
    double y;
};
```

А ниже в функции `main()` объявим переменную на эту структуру и указатель этого типа:

```c
int main(void) {
    struct tag_vector v = {1.0, 2.0};
    struct tag_vector *ptr_v;
    
    return 0;
}
```

Чтобы через указатель `ptr_v` работать с переменной `v`, необходимо присвоить адрес этой переменной указателю. Делается это уже известным нам образом с помощью операции взятия адреса:

```c
ptr_v = &v;
```

После этого мы можем считывать и записывать информацию в структуру с помощью указателя `ptr`. Используя текущие знания об указателях, нам пришлось бы делать это, например, так:

```c
(*ptr_v).x = 10.0;      // запись нового значения
double y = (*ptr_v).y;  // считывание значения
```

Причем круглые скобки вокруг указателя обязательны, так как приоритет унарных операций возрастает при движении справа-налево. Поэтому приоритет операции «точка» выше приоритета операции разыменования. Если круглые скобки не прописывать:

```c
*ptr_v.x = 10.0;
```

то операция «точка» была бы применена к указателю `ptr_v`, а не к структуре, на которую он указывает.

Как видите, имеем не очень удобную запись для доступа к отдельным полям структуры через указатель. 

Поэтому в языке Си именно для целей доступа к полям составных типов данных через указатель, был введен специальный оператор, состоящий из двух символов: «-» минус и «>» больше. И используется следующим образом:

```c
ptr_v->x = 10.0;      // запись нового значения
double y = ptr_v->y;  // считывание значения
```

Эта запись и предыдущая – абсолютно одно и то же. Но так визуально программа выглядит куда нагляднее и понятнее. И, обратите внимание, когда используется операция `->`, то звездочку перед указателем записывать не нужно.

Далее, имея указатели на структуры, мы получаем возможность их динамического формирования в основной памяти устройства - «куче». Для этого можно воспользоваться уже знакомой нам функцией `malloc()` для выделения памяти под структуру:

```c
ptr_v = malloc(sizeof(struct tag_vector));
```

Записать туда какие-либо значения:

```c
ptr_v->x = -1.0;
ptr_v->y = 2.0;
```

и вывести их на экран:

```c
printf("x = %.2f, y = %.2f\n", ptr_v->x, ptr_v->y);
```

с последующим освобождением памяти:

```c
free(ptr_v);
```

Фактически, с помощью функций `malloc()` и `free()` мы самостоятельно создали новую переменную на структуру `struct tag_vector` в основной памяти устройства (а не в стеке вызова функций), записали туда данные и прочитали их с выводом на экран. 

И, так как область памяти выделялась в «куче», то такая переменная продолжает существовать после завершения функции, где была создана, пока не будет вызвана функция `free()` для этой области памяти. Все эти детали нужно очень хорошо понимать для грамотного составления программного кода.

## Возврат структур из функций

Давайте теперь посмотрим, как можно возвращать структуры из функций. Для примера объявим функцию, которая будет формировать структуру `struct tag_vector` по переданным ей вещественным значениям:

```c
struct tag_vector create_vector(double x, double y) {
    struct tag_vector v = {x, y};
    return v;
}
```

Затем, в функции `main()` вызовем эту функцию:

```c
int main(void) {
    struct tag_vector bias = create_vector(2.56, -7.88);
    printf("bias.x = %.2f, bias.y = %.2f\n", bias.x, bias.y);
 
    return 0;
}
```

После запуска программы увидим строку:

```
bias.x = 2.56, bias.y = -7.88
```

Как работает функция `create_vector()`? 

При ее вызове формируется переменная на структуру `struct tag_vector`, инициализируется переданными значениями и возвращается. Вот здесь важный момент. 

Возврат структуры есть не что иное, как копирование всего ее содержимого в переменную `bias`. 

Сама же переменная `v` перестает существовать после завершения функции `create_vector()`. Вот такие процессы создания переменной `v` и копирования ее содержимого присутствуют в нашей программе. 

Если структура небольшого размера, то это не критично. Но если она занимает большие объемы, то возникает сразу две проблемы:
+ первая – это значительный расход ограниченной памяти стекового фрейма;
+ вторая – копирование большого объема памяти при возврате такой структуры из функции.

Для разрешения этих проблем можно воспользоваться механизмом динамического выделения памяти с помощью функций `malloc()` и `free()`. В этом случае функцию `create_vector()` можно переписать в таком виде:

```c
struct tag_vector* create_vector(double x, double y) {
    struct tag_vector* v = malloc(sizeof(struct tag_vector));
    v->x = x;
    v->y = y;
    
    return v;
}
```

И, затем использовать ее следующим образом:

```c
int main(void) {
    struct tag_vector* bias = create_vector(2.56, -7.88);
    printf("bias.x = %.2f, bias.y = %.2f\n", bias->x, bias->y);
 
    free(bias);
    return 0;
}
```

Но это более тонкий процесс. 

Как только мы прописали функцию `malloc()` нужно не забыть вызвать функцию `free()`. 

Казалось бы, в нашем простом примере сделать это не сложно. Однако не все так очевидно. Например, если дважды вызвать функцию `create_vector()` с присвоением адреса одному и тому же указателю:

```c
int main(void) {
    struct tag_vector* bias = create_vector(2.56, -7.88);
    bias = create_vector(3.0, -7.0);
 
    printf("bias.x = %.2f, bias.y = %.2f\n", bias->x, bias->y);
 
    free(bias);
    return 0;
}
```

То адрес первой выделенной области памяти окажется потерянным. И мы уже в рамках программы не сможем ее освободить. Она будет освобождена только самой ОС при завершении программы. Это пример того самого эффекта под названием утечка памяти. И, как видите, допустить такой промах проще простого! 

Поэтому переходить на уровень указателей стоит только в случаях, когда размещение и копирование больших структур действительно критически сказывается на скорости работы программы. Без этого лучше прописывать структуры на уровне обычных автоматических переменных, как мы это сделали в первом случае.

## Передача структур в функции

Следующим шагом посмотрим на механизм передачи структур в функции. Предположим, нам нужно объявить функцию, которая бы складывала два вектора между собой. В самом простом варианте это можно сделать так:

```c
struct tag_vector sum_vector(const struct tag_vector v1, const struct tag_vector v2) {
    struct tag_vector res = {v1.x + v2.x, v1.y + v2.y};
    return res;
}
```

А, затем, вызвать ее из функции `main()` следующим образом:

```c
int main(void) {
    struct tag_vector bias = create_vector(2.56, -7.88);
    struct tag_vector one = create_vector(1.0, 1.0);
    struct tag_vector result = sum_vector(bias, one);
 
    printf("result.x = %.2f, result.y = %.2f\n", result.x, result.y);
 
    return 0;
}
```

Здесь `create_vector()` – первый вариант этой функции без указателей. 

В итоге, сначала создаются две структуры `bias` и `one`, а затем, вызывается функция `sum_vector()`, которой передаются структуры в качестве аргументов. 

Что происходит дальше? 

Да, содержимое структур `bias` и `one` копируется в соответствующие параметры `v1` и `v2`. Внутри функции `sum_vector()` работа ведется уже с копиями и на основе их данных создается третья переменная `res` с суммой координат векторов `v1` и `v2`. Затем, сформированная структура возвращается функцией опять же с копированием данных в переменную `result`. После завершения функции `sum_vector()` все ее параметры и переменная `res` автоматически исчезают.

Такой не самый быстрый, но безопасный процесс мы получаем при работе функции `sum_vector()`. Можно ли как то ускорить ее работу, сохранив безопасность работы? На самом деле да, можно, если в качестве параметров прописать константные указатели:

```c
struct tag_vector sum_vector(const struct tag_vector* v1, const struct tag_vector* v2) {
    struct tag_vector res = {v1->x + v2->x, v1->y + v2->y};
    return res;
}
```

Обратите внимание, только у параметров, но не у возвращаемого значения. 

Возвращать мы по-прежнему будем структуру целиком. Безопасность обеспечивается благодаря использованию указателей, которые могут только читать данные из переданных структур, но не менять их. А более высокая скорость за счет того, что теперь нам не нужно копировать структуры целиком в каждый параметр, а лишь передать адреса:

```c
struct tag_vector result = sum_vector(&bias, &one);
```

Это и безопасно и быстро. В таких случаях применение указателей оправданно.

Давайте пропишем еще одну функцию, которая бы суммировала координаты в первом переданном векторе:

```c
void isum_vector(struct tag_vector* v1, const struct tag_vector* v2) {
    v1->x += v2->x;
    v1->y += v2->y;
}
```

Смотрите, функция ничего не возвращает, но первый указатель не константный, через него можно менять данные в структуре, на которую он ссылается. В результате, функция `isum_vector()` изменяет координаты первой переданной структуры:

```c
isum_vector(&bias, &one);
```

Или, вместо второго аргумента `one` можно сразу объявить структуру с нужным набором данных:

```c
isum_vector(&bias, &(struct tag_vector) {0.5, -0.5});
```

Обратите внимание на эту конструкцию. В круглых скобках мы прописываем тип структуры, а затем, в фигурных – ее данные. Это бывает очень удобно, чтобы не создавать отдельно временные переменные только для передачи данных в нужном формате. И то же самое относится к возвращаемым значениям. Функции `create_vector()` и `sum_vector()` можно переписать таким образом:

```c
struct tag_vector create_vector(double x, double y) {
    return (struct tag_vector) {x, y};
}
```

```c
struct tag_vector sum_vector(const struct tag_vector* v1, const struct tag_vector* v2) {
    return (struct tag_vector) {v1->x + v2->x, v1->y + v2->y};
}
```

То есть, буквально в одну строчку.

## Директива typedef со структурами

В заключение этого занятия сделаем еще одно небольшое улучшение нашего текста программы. В ней очень часто фигурирует тип `struct tag_vector` и визуально это воспринимается не лучшим образом, да и, кроме того, постоянно приходится с клавиатуры набирать эту длинную последовательность символов. Поправим этот момент с помощью уже знакомой нам директивы `typedef`. Напомню, что она позволяет любой существующий тип заменить другим именем. Воспользуемся этим и запишем определение структуры следующим образом:

```c
typedef struct tag_vector {
    double x;
    double y;
} VECTOR;
```

Теперь вместо слов `struct tag_vector` можно использовать имя `VECTOR`:

```c
VECTOR create_vector(double x, double y) {
    return (VECTOR) {x, y};
}
 
VECTOR sum_vector(const VECTOR* v1, const VECTOR* v2) {
    return (VECTOR) {v1->x + v2->x, v1->y + v2->y};
}
 
void isum_vector(VECTOR* v1, const VECTOR* v2) {
    v1->x += v2->x;
    v1->y += v2->y;
}
 
int main(void) {
    VECTOR bias = create_vector(2.56, -7.88);
    VECTOR one = create_vector(1.0, 1.0);
    VECTOR result = sum_vector(&bias, &one);
    isum_vector(&bias, &(VECTOR) {0.5, -0.5});
 
    return 0;
}
```

Теперь тип стал более читабельным, а текст программы более наглядным.

Видео по теме [#54. Указатели на структуры. Передача структур в функции](https://www.youtube.com/watch?v=yWmFfpPz2A4&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные варианты обращения к полям структуры через указатель.

```c
#include <string.h>

struct tag_data {
    char name[50];
    int var_i;
    double var_d;
};

struct tag_data *data;
```

+ [x] data->var_d = 0.45;
+ [x] strncpy(data->name, "hello", sizeof(data->name));
+ [ ] data->name = "hello"
+ [ ] *data->var_d = 0.54;
+ [x] *data.var_i = 128;
+ [ ] (*data).var_i = -6435;

### Подвиг 2. Продолжите программу. Объявите структуру с идентификатором tag_geom и полями:

```c
char type;  // тип геометрической фигуры
int x0, y0; // координаты верхнего левого угла
int x1, y1; // координаты нижнего правого угла
```

В функции `main` объявите переменную `geom` структуры `tag_geom` и заполните поля следующими значениями:

```c
type = 1; (x0, y0) = (10, 20); (x1, y1) = (50, 30).
```

Объявите в функции `main` указатель `ptr_geom` на переменную `geom`. С помощью указателя выведите в консоль значения полей переменной `geom` в виде целых чисел в одну строчку через пробел в порядке: `type, x0, y0, x1, y1`.

```c
#include <stdio.h>

typedef struct tag_geom {
    char type;   // тип геометрической фигуры
    int x0, y0;  // координаты верхнего левого угла
    int x1, y1;  // координаты нижнего правого угла
} GEOM;

int main(void) {
    GEOM geom = {1, 10, 20, 50, 30};

    GEOM* ptr_geom = &geom;

    printf("%d %d %d %d %d", ptr_geom->type, ptr_geom->x0, ptr_geom->y0, ptr_geom->x1, ptr_geom->y1);

    // __ASSERT_TESTS__
    // макроопределение для тестирования (не убирать)
    return 0;
}
```

### Подвиг 3. Продолжите программу. Объявите структуру с идентификатором tag_rub и полями:

```c
double ratio_usd;  // курс доллара к рублю (1$ = xx рублей)
int rubs; // количество рублей
```

В функции `main` объявите указатель `account_r` структуры `tag_rub` и выделите память под структуру `tag_rub` (указатель `account_r` должен ссылаться на выделенную область памяти). Затем, через указатель `account_r` значение `ratio_usd` установите равным `91.32`, а значение `rubs` прочитайте из входного потока.

Вычислите количество долларов на счете в соответствии с курсом `ratio_usd`. Выведите в консоль полученное значение в виде вещественного числа с точностью до сотых.

P. S. Не забудьте в конце (после __ASSERT_TESTS__) освободить память.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/7.7.3

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct tag_rub {
    double ratio_usd;  // курс доллара к рублю (1$ = xx рублей)
    int rubs;          // количество рублей
} RUB;

int main(void) {
    RUB* account_r = malloc(sizeof(RUB));

    account_r->ratio_usd = 91.32;

    scanf("%d", &account_r->rubs);

    printf("%.2lf", account_r->rubs / account_r->ratio_usd);

    // __ASSERT_TESTS__
    // макроопределение для тестирования (не убирать)

    free(account_r);
    return 0;
}
```

### Подвиг 4. Выберите все верные варианты использования директивы typedef совместно со структурами.

+ [x] typedef struct {int a; double b;} DATA;
+ [x] typedef struct tag_data {int a; double b;} DATA;
+ [ ] typedef DATA struct {int a; double b;};
+ [ ] typedef struct DATA {int a; double b;};
+ [ ] struct tag_data {int a; double b;} data; typedef data DATA;

### Подвиг 5. Выберите все верные варианты присвоения значений переменной d типа VAR (на структуру):

```c
typedef struct {
    int var_i;
    double var_d;
} VAR;

VAR d;
```

+ [x] d.var_i = 10;
+ [x] d.var_d = -0.12;
+ [ ] d = 10;
+ [x] d = (VAR){10};
+ [x] d = (VAR){.var_d = 0.5, .var_i = -5};
+ [x] d = (VAR){.var_d = 0.5};

### Подвиг 6. Продолжите программу. Объявите функцию с именем complex_sum и двумя параметрами, через которые передаются (с копированием) две структуры типа COMPLEX. Функция complex_sum должна складывать переданные комплексные числа по формуле:

$a + j \cdot b=(a_1 + a_2) + j \cdot (b_1 + b_2)$

где j - мнимая единица (формально в структуре отсутствует). 

То есть, складываются отдельно действительные части (`re`) и мнимые (`im`) и записываются в новую созданную структуру типа `COMPLEX` внутри тела функции `complex_sum`. После сложения функция `complex_sum` должна возвращать сформированную структуру (через копирование).

В функции `main` объявите две переменные `cmp_1`, `cmp_2` типа `COMPLEX`. Прочитайте из входного потока четыре вещественных числа, записанных в одну строчку через запятую. Первые два числа в порядке `re`, `im` сохраните в первой переменной `cmp_1`, а вторые два числа в том же порядке - во второй переменной `cmp_2`. Вызовите функцию `complex_sum` для сложения чисел `cmp_1`, `cmp_2`. Результат сохраните в переменной `res` типа `COMPLEX`.

P. S. В консоль ничего выводить не нужно.

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    double re;  // действительная часть
    double im;  // мнимая часть
} COMPLEX;

COMPLEX complex_sum(COMPLEX cmp1, COMPLEX cmp2) {
    COMPLEX res = {cmp1.re + cmp2.re, cmp1.im + cmp2.im};
    return res;
}

int main(void) {
    COMPLEX cmp_1, cmp_2;

    scanf("%lf, %lf, %lf, %lf", &cmp_1.re, &cmp_1.im, &cmp_2.re, &cmp_2.im);

    COMPLEX result = complex_sum(cmp_1, cmp_2);

    // __ASSERT_TESTS__
    // макроопределение для тестирования (не убирать)

    return 0;
}
```

### Подвиг 7. Объявите в программе структуру с полями x, y типа int и определите для нее тип POINT. Объявите функцию с именем rect_square и двумя параметрами в виде указателей, через которые передаются структуры типа POINT. Функция rect_square должна вычислять площадь прямоугольника, заданного двумя точками (типа POINT): верхнего левого угла и нижнего правого:

![07](/Good_good_C_C++/img/07_09.png)

Вычисленное значение возвращается функцией `rect_square` в виде целого числа.

В функции main прочитайте из входного потока четыре целых числа, записанных в одну строчку через пробел, и сохраните их в двух переменных типа `POINT` в порядке `x0, y0, x1, y1`. Вызовите функцию `rect_square` для сформированных точек (структур `POINT`) и выведите в консоль возвращенное функцией значение в виде одного целого числа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/7.7.7

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int x;
    int y;
} POINT;

int rect_square(const POINT* left_up, const POINT* right_down) {
    int res = (right_down->x - left_up->x) * (right_down->y - left_up->y);
    return res;
}

int main(void) {
    POINT p1, p2;

    scanf("%d %d %d %d", &p1.x, &p1.y, &p2.x, &p2.y);

    int result = rect_square(&p1, &p2);

    printf("%d", result);

    return 0;
}
```

### Подвиг 8. Объявите в программе структуру с полями x, y типа int и определите для нее тип POINT. Объявите функцию с именем get_means и двумя параметрами (порядок важен):
+ одномерным массивом структур `POINT`;
+ длиной (числом элементов) этого массива (тип `size_t`).

Функция `get_means` должна вычислять два средних арифметических числа:
+ отдельно для первой координаты x и
+ отдельно для второй координаты y. 

Вычисленные вещественные значения сохранить в структуре типа `DATA` (объявить до функции), которая содержит два поля: `mean_x` и `mean_y` типа `double`. Функция `get_means` должна возвращать сформированную структуру `DATA`.

В функции `main` объявите массив `points` структур `POINT` длиной 20 элементов. Прочитайте из входного потока целые числа `x0, y0, x1, y1, ...`, записанные в одну строчку через пробел. Максимальное число пар чисел не превышает `20`, но может быть и меньше. Вызовите функцию `get_means` для вычисления средних только для актуальных элементов массива `points` (тех, в которых хранятся данные из входного потока, а не все 20). Возвращенные значения вывести в консоль в одну строчку через пробел с точностью до сотых.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/7.7.8

```c
#include <stdio.h>
#include <stdlib.h>
#define MAX 20

typedef struct {
    int x;
    int y;
} POINT;

typedef struct {
    double mean_x;
    double mean_y;
} DATA;

DATA get_means(const POINT points[], size_t count) {
    DATA res = {0, 0};
    for (size_t i = 0; i < count; i++) {
        res.mean_x += points[i].x;
        res.mean_y += points[i].y;
    }
    res.mean_x /= count;
    res.mean_y /= count;

    return res;
}

int main(void) {
    POINT points[MAX];

    size_t count = 0;
    for (size_t i = 0; i < MAX; i++) {
        if (scanf("%d %d", &points[i].x, &points[i].y) == 2)
            count++;
        else
            break;
    }

    DATA result = get_means(points, count);

    printf("%.2lf %.2lf", result.mean_x, result.mean_y);

    return 0;
}
```

### Подвиг 9 (с повторением). Объявите структуру с полями:

+ fname: строка максимальной длиной 100 символов (фамилия);
+ old: целое число (тип char); возраст;
+ stag: целое число (тип char); стаж;
+ salary; целое число (тип int); зарплата;
+ efs; вещественное число (тип double); эффективность труда сотрудника

Определите для этой структуры тип `PERSON`. 

Объявите функцию с именем `fill_data`, которая ничего не возвращает и первые два параметра (порядок важен) - это указатель на структуру `PERSON` и форматная строка. Следующие параметры вариадические (то есть, функция принимает произвольное число параметров). Форматная строка определяет данные, которые записываются в указанную структуру `PERSON`, а также набор и порядок следования вариадических данных. Форматная строка может включать следующие символы:
+ #f - строка с фамилией;
+ #o - возраст;
+ #g - стаж;
+ #s - зарплата;
+ #e - эффективность сотрудника.

Например:

```
"#f #e#s, #o"
```

соответствует вариадическим параметрам с типами данных:

```c
char*, double, int, char
```

То есть, в форматной строке достаточно выделять спецификаторы #<символ> и их порядок, остальные символы форматной строки значения не имеют.

В функции `main` вызовите функцию `fill_data` с передачей в нее всех необходимых аргументов (значения придумайте сами) и следующей форматной строкой:

"#o #e #s #f"

P. S. В консоль ничего выводить не нужно.

```c
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    char fname[100];  // строка максимальной длиной 100 символов (фамилия)
    char old;         // возраст;
    char stag;        // стаж;
    int salary;       // зарплата;
    double efs;       // эффективность труда сотрудника;
} PERSON;

void fill_data(PERSON* p, char* str, ...) {
    va_list arg;
    char* ptr = str;
    // puts(str);
    va_start(arg, str);
    while (ptr != NULL) {
        switch (*(++ptr)) {
            case 'f':
                strcpy(p->fname, va_arg(arg, char*));
                // puts(p->fname);
                break;
            case 'o':
                p->old = va_arg(arg, int);
                // printf("%d\n", p->old);
                break;
            case 'g':
                p->stag = va_arg(arg, int);
                // printf("%d\n", p->stag);
                break;
            case 's':
                p->salary = va_arg(arg, int);
                // printf("%d\n", p->salary);
                break;
            case 'e':
                p->efs = va_arg(arg, double);
                // printf("%.2lf\n", p->efs);
                break;
            default:
                break;
        }
        ptr = strpbrk(ptr, "#");
        // if (ptr != NULL) puts(ptr);
    }
    va_end(arg);
}

int main(void) {
    PERSON user;

    fill_data(&user, "#o #e #s #f", 47, 23.5, 500000, "Alexander");

    return 0;
}
```

### Подвиг 10 (на повторение). Выберите все верные утверждения, касающиеся глобальных определений в языке Си.

+ [ ] область видимости глобальной переменной по умолчанию распространяется на весь проект (все модули)
+ [x] ключевое слово extern перед заголовком функции прописывать не обязательно
+ [x] ключевое слово extern позволяет глобальные переменные использовать за пределами текущего модуля
+ [x] обычная функция, объявленная в текущем модуле, может быть использована и в любом другом, если указать ее прототип
+ [ ] обычная функция, объявленная в текущем модуле, может быть использована только в этом модуле и недоступна в других
+ [ ] ключевое слово extern позволяет ограничивать область видимости глобальных переменных текущим модулем
+ [x] область видимости глобальной переменной по умолчанию распространяется только на текущий файл (модуль)

### Подвиг 11 (на повторение). Выберите все верные утверждения, касающиеся ключевого слова static.


+ [x] внешнее связывание - это когда переменная или функция доступна и за пределами текущего модуля
+ [ ] внутреннее связывание - это когда переменная или функция может быть использована в других функциях
+ [ ] внешнее связывание - это когда переменная или функция использует другие внешние переменные или функции
+ [x] ключевое слово static у глобальных переменных ограничивает их область видимости текущим модулем
+ [ ] ключевое слово static у функций позволяет объявлять статические функции без ограничения области их видимости
+ [x] ключевое слово static у функций ограничивает их область видимости текущим модулем
+ [x] внутреннее связывание - это когда переменная или функция имеет область видимости только в пределах текущего модуля

# 7.8 Реализация стека (пример использования структур)

На этом занятии мы сделаем небольшую программу по реализации стека данных с использованием ранее приобретенных знаний.

Я напомню, что стек – это такая структура данных, которая добавляет новые объекты наверх и извлекает тоже сверху. Получается очередь, в которой последний добавленный объект извлекается первым. Сокращенно по-английски эта аббревиатура звучит как:

```
LIFO (Last In, First Out)
```

Структура стека в нашей реализации будет выглядеть следующим образом:

![07](/Good_good_C_C++/img/07_10.jpg)

Здесь:
+ `top` – это указатель на самый верхний объект;
+ `next` – указатель на следующий объект стека. 

Самый нижний элемент имеет значение указателя `next` равное `NULL`. Это будет маркер конца стека.

Каждый объект стека будем описывать следующей структурой:

```c
typedef struct tag_obj {
    int data;
    struct tag_obj* next;
} OBJ;
```

Она содержит целочисленное поле `data` – это данные, которые мы сохраняем в объектах стека, и указатель `next`. 

Обратите внимание, как задан тип указателя. Мы используем тип текущей структуры внутри нее самой. 

Компилятор языка Си позволяет нам это делать, но только для определения указателей. 

Обычные переменные внутри структуры ее же типа объявлять нельзя. 

Это, так называемый, неполный тип. 

Прописывать вместо него, например, тип `OBJ` не получится, так как на этот момент он еще просто неизвестен.

Далее, в функции `main()` мы объявим указатель `top` с начальным значением `NULL`:

```c
int main(void) {
    OBJ* top = NULL;
 
    return 0;
}
```

Это будет означать, что стек пуст, то есть, не содержит ни одного элемента. Для добавления нового объекта в стек определим функцию с именем `push()`:

```c
OBJ* push(OBJ* top, int data) {
    OBJ* ptr = malloc(sizeof(OBJ));
    ptr->data = data;
    ptr->next = top;
    return ptr;
}
```

В качестве параметров она принимает указатель на вершину стека и данные, которые нужно сохранить в добавляемом элементе. 

В теле функции сначала создается новый объект для структуры; в поле `data` сохраняется переданное значение; указателю `next` присваивается значение адреса указателя `top` (так как мы добавляем объект на верх стека); возвращаем адрес нового созданного объекта (вершины стека).

Воспользоваться этой функцией можно следующим образом:

```c
int main(void) {
    OBJ* top = NULL;
 
    top = push(top, 1);
    top = push(top, 2);
    top = push(top, 3);
    top = push(top, 4);
 
    return 0;
}
```

Мы здесь последовательно добавляем четыре объекта и каждый раз меняем значение указателя `top`, чтобы он ссылался на самый верхний объект, тот, что был добавлен в последнюю очередь.

Следующая функция будет извлекать самый верхний объект из стека, удаляя его:

```c
OBJ* pop(OBJ* top) {
    if(top == NULL)
        return top;
    
    printf("Deleted: %d\n", top->data);
 
    OBJ* ptr_next = top->next;
    free(top);
 
    return ptr_next;
}
```

Мы также передаем указатель на вершину стека и далее проверяем, если указатель равен `NULL`, значит, стек пуст и удалять нечего, завершаем функцию. Если же объекты есть, то создаем временный указатель `ptr_next` на следующий объект стека и освобождаем память из под текущего верхнего объекта. В конце возвращаем адрес следующего (но теперь верхнего) элемента стека.

Наконец, последняя функция, будет перебирать все элементы стека и отображать их на экране:

```c
void show_stack(const OBJ* top) {
    const OBJ* current = top;
    while(current != NULL) {
        printf("%d\n", current->data);
        current = current->next;
    }
}
```

Для этого реализован цикл `while`, пока мы не дойдем до последнего элемента, адрес которого равен `NULL`. В цикле выполняется отображение поля `data` текущего объекта и переход к следующему, используя указатель `next`.

Всеми этими функция можно воспользоваться так:

```c
int main(void) {
    OBJ* top = NULL;
 
    top = push(top, 1);
    top = push(top, 2);
    top = push(top, 3);
    top = push(top, 4);
 
    show_stack(top);
 
    while(top)
        top = pop(top);
 
    return 0;
}
```

Вначале формируется стек из четырех элементов, затем отображается сверху-вниз и в конце освобождается память из под всех элементов стека. После запуска программы увидим результат:

```
4
3
2
1
Deleted: 4
Deleted: 3
Deleted: 2
Deleted: 1
```

То есть, были созданы, а потом удалены все четыре объекта стека.

Видео по теме [#55. Реализация стека (пример использования структур)](/Good_good_C_C++/img/07_10.jpg)

### Подвиг 1. Выберите все верные утверждения, касающиеся стека (stack).

+ [x] каждый элемент (объект) стека содержит полезные данные и ссылку на следующий элемент стека
+ [x] у последнего элемента (объекта) стека указатель next ссылается на значение NULL
+ [ ] каждый элемент стека удобно описывать с помощью массива чисел
+ [ ] стек реализован по принципу очереди типа FIFO
+ [x] каждый элемент стека удобно описывать с помощью структуры
+ [x] стек реализован по принципу очереди типа LIFO

### Подвиг 2*. Необходимо написать программу, которая в стеке хранит историю посещения пользователем веб-страниц (URL-адреса страниц). Для этого необходимо повторить реализацию стека, приведенного в занятии (или написать свою собственную), со следующим функционалом:

1. Каждый объект стека представляется структурой с идентификатором `tag_obj` и содержит поля: указатель `next` на следующий объект; строку `url` максимальной длиной `1024` символа (адрес посещенной страницы). Объявить еще одно имя типа `OBJ` для struct `tag_obj`.

2. На первый элемент стека должен вести указатель top типа `OBJ`. Если стек пуст, то `top` равен `NULL`.

3. Для добавления нового элемента в стек реализовать функцию push со следующей сигнатурой:

```c
OBJ* push(OBJ* top, const char* url);
```

Функция возвращает указатель на новый созданный объект.

4. Для удаления объекта из стека реализовать функцию pop со следующей сигнатурой:

```c
OBJ* pop(OBJ* top);
```

В функции `main` создайте стек, в который последовательно (в указанном порядке) поместите следующие URL-адреса:
+ https://proproprogs.ru/c_base/c_etapy-translyacii-programmy-v-mashinnyy-kod-standarty
+ https://proproprogs.ru/c_base/c_struktura-i-ponimanie-raboty-programmy-hello-world
+ https://proproprogs.ru/c_base/c_dvoichnaya-shestnadcaterichnaya-i-vosmerichnaya-sistemy-schisleniya
+ https://proproprogs.ru/c_base/c_lokalnye-i-globalnye-peremennye
+ https://proproprogs.ru/c_base/c_perechisleniya-enum-direktiva-typedef

P. S. В консоль ничего выводить не нужно. Не забудьте в конце программы освободить память (после макроопределения __ASSERT_TESTS__), занимаемую элементами стека.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct tag_obj {
    struct tag_obj* next;
    char url[1024];
} OBJ;

OBJ* push(OBJ* top, char* url) {
    OBJ* ptr = malloc(sizeof(OBJ));
    ptr->next = top;
    strcpy(ptr->url, url);
    return ptr;
}

OBJ* pop(OBJ* top) {
    if (top == NULL) return top;

    OBJ* ptr_next = top->next;
    free(top);

    return ptr_next;
}

void show_stack(const OBJ* top) {
    const OBJ* current = top;
    while (current != NULL) {
        printf("%s\n", current->url);
        current = current->next;
    }
}

int main(void) {
    OBJ* top = NULL;

    top = push(top, "https://proproprogs.ru/c_base/c_etapy-translyacii-programmy-v-mashinnyy-kod-standarty");
    top = push(top, "https://proproprogs.ru/c_base/c_struktura-i-ponimanie-raboty-programmy-hello-world");
    top = push(top,
               "https://proproprogs.ru/c_base/"
               "c_dvoichnaya-shestnadcaterichnaya-i-vosmerichnaya-sistemy-schisleniya");
    top = push(top, "https://proproprogs.ru/c_base/c_lokalnye-i-globalnye-peremennye");
    top = push(top, "https://proproprogs.ru/c_base/c_perechisleniya-enum-direktiva-typedef");

    // show_stack(top);

    // while (top) top = pop(top);
    //__ASSERT_TESTS__
    // макроопределение для тестирования (не убирать)

    // здесь освобождайте память, занимаемую стеком
    return 0;
}
```

# TODO

### Подвиг 3 (на повторение, без стека). Необходимо написать программу, которая бы описывала следующую схему станций метро:

![07](/Good_good_C_C++/img/07_11.png)

Для этого необходимо объявить следующую структуру:

```c
enum {name_length=50, total_links=50, max_path_station=100};

typedef struct tag_station {
    char name[name_length];                 // название станции метро
    struct tag_station* links[total_links]; // связи станции метро с другими соседними станциями
    short count_links;                      // общее количество связей
    char fl_reserved;                       // зарезервированная переменная (полезна при реализации алгоритма поиска маршрута)
} STATION;
```

После этого объявите вариадическую функцию `set_station_links` со следующей сигнатурой:

```c
void set_station_links(STATION* st, int count_links, ...)
```

Здесь `st` - станция метро, для которой формируются связи с другими соседними станциями; `count_links` - общее число таких связей; вариадические параметры должны представлять собой указатели типа `STATION*` в количестве `count_links`, которые заносятся в массив `links` объекта `st`. 

То есть, функция `set_station_links` связывает объект `st` с другими, указанными в вариадических параметрах объектами, записывая их адреса в массив `links`. Также не забудьте задать значение поля `count_links` в объекте (структуре) `st`.

Продолжите функцию `main`, в которой с помощью функции `set_station_links` сформируйте связи между станциями метро в соответствии с приведенным рисунком.

P. S. В консоль ничего выводить не нужно.

### Подвиг 4* (продолжение, на повторение). Скопируйте программу, написанную в предыдущем 3-м подвиге. Необходимо добавить функцию поиска кратчайшего маршрута от одной станции до другой. Функция должна иметь следующую сигнатуру:

```c
void find_path(STATION* from, STATION* to, STATION *path[], int* count_st);
```

Здесь `from` - начальная станция; `to` - конечная станция; `path` - массив указателей из станций метро кратчайшего маршрута (включая станции `from` и `to`); `count_st` - указатель на целочисленную переменную, хранящую общее число станций в найденном маршруте. Станции в массиве `path` должны следовать от начальной `from` до конечной `to`, без перескоков через станции, последовательно.

Пример использования функции `find_path`:

```c
STATION* path[max_path_station];
int count_st = 0;

find_path(&st[0], &st[9], path, &count_st);

for(int i = 0;i < count_st;++i)
    printf("[%s] ", path[i]->name);
```

P. S. В консоль ничего выводить не нужно, только добавить функцию `find_path` и другие вспомогательные функции для поиска кратчайшего маршрута.

# 7.9 Объединения (union). Битовые поля

## Объединения (union)

На этом занятии речь пойдет об объединениях. Это еще один составной тип данных, синтаксически похожий на структуру и определяется следующим образом:

```c
union [имя объединения] {
    [поля]
};
```


Например, в программе мы его можем объявить так:

```c
union tag_var {
    char var_ch;
    int var_i;
    double var_d;
};
```

В чем отличие такого типа от аналогичной структуры? 

Если бы была структура, то все ее поля в памяти располагались бы по порядку друг за другом. 

Тогда как в объединении все переменные хранятся с одного и того же начального адреса:

![07](/Good_good_C_C++/img/07_12.jpg)

Но в этом случае значение одной переменной будет затирать значения двух других? 

Совершенно верно! 

Объединения не предназначены для одновременного хранения всех трех полей. 

Эту роль играют структуры. 

Роль объединения хранения только одного, последнего записанного значения.

Тогда зачем все это надо? 

Давайте представим, что нам в программе потребовалось создать универсальную переменную, которая могла бы хранить или байтовые значения, или целочисленные, или вещественные. 

То есть, какое-то одно в один момент времени. Очевидно, для этого напрашивается использование объединения, а не структуры, так как объединение занимает меньше памяти: по размеру наибольшего из полей. Например, размер объединения `tag_var` составит 8 байт – размер типа `double`. А структура бы занимала, как минимум:

$1 + 4 + 8 = 13$ байт

Выигрыш в 5 байт. Но если бы были массивы из таких переменных, то экономия памяти была бы очевидной.

Далее, в программе в функции `main()` можно создать переменную на объединение следующим образом:

```c
int main(void) {
    union tag_var var;
    return 0;
}
```

и записать туда какое-либо значение, например:

```c
var.var_ch = 'C';
```

В результате, именно в переменной `var_ch` будет храниться символ 'C', другие поля объединения принимают неопределенные значения. Если же мы следом запишем новое значение, скажем, в переменную `var_i`:

```c
var.var_i = 45;
```

то значение переменной `var_ch` затрется и станет другим.

А теперь давайте передадим объединение некоторой функции, которая бы отображала последнее сохраненное значение. Запишем ее следующим образом:

```c
void show_var(union tag_var v)
{
}
```

И дальше возникает вопрос: какое поле отображать в объединении `v`? 

Как функции `show_var` узнать, в какую переменную было записано последнее значение? 

В действительности, никак. Поэтому нам нужна еще одна переменная, которая бы обозначала номер актуального поля с данными. Для этого определим следующее перечисление:

```c
typedef enum {
    union_var_none, union_var_ch, union_var_i, union_var_d
} TYPE_VAR;
```

И допишем функцию со вторым параметром этого типа:

```c
void show_var(union tag_var v, TYPE_VAR type) {
    switch(type) {
    case union_var_ch:
        printf("var_ch = %c\n", v.var_ch);
        break;
    case union_var_i:
        printf("var_i = %d\n", v.var_i);
        break;
    case union_var_d:
        printf("var_d = %.2f\n", v.var_d);
        break;
    case union_var_none:
        puts("Undefined type var");
        break;
    }
}
```

Воспользоваться ей можно следующим образом:

```c
int main(void) {
    union tag_var var;
 
    var.var_ch = 'C';
    var.var_i = 45;
 
    show_var(var, union_var_i);
    
    return 0;
}
```

То есть, для отображения текущего значения из объединения нам явно нужно указать тип поля, в котором хранится актуальная информация.

Конечно, было бы правильно улучшить эту программу и объявить структуру, которая бы содержала в себе объединение и переменную типа `TYPE_VAR`, например, так:

```c
typedef struct {
    union tag_var var;
    TYPE_VAR type;
} VAR;
```

А, затем уже она использовалась бы как универсальная переменная:

```c
void show_var(VAR v)
{
...
}
 
int main(void) 
{
    VAR variable;
 
    variable.var.var_ch = 'C';
    variable.var.var_i = 45;
    variable.type = union_var_i;
 
    show_var(variable);
 
    return 0;
}
```

Вот один наглядный пример использования объединения. В целом, работа с ними происходит так же, как и со структурами, о которых мы с вами подробно уже говорили.

Конечно, в практике программирования существует множество других задач, где объединения играют свою особую роль. По мере погружения в тему IT вы с ними время от времени будете сталкиваться.

## Битовые поля

Во второй части занятия мы с вами познакомимся с еще одним способом компактного представления данных – битовыми полями. 

Что это такое?

В языке Си есть возможность объявлять структуры с целочисленными полями типа `int` и дополнительно для каждого из них указывать число бит, которые они будут занимать в памяти устройства.

Давайте я сразу на конкретном примере покажу пример использования битовых полей. Предположим, нам нужно в программе хранить дату и время. Для этого можно определить следующую структуру:

```c
struct date_time {
    unsigned day : 5;
    unsigned month : 4;
    unsigned year : 12;
    unsigned sec : 6;
    unsigned min : 6;
    unsigned hour : 5;
};
```

Напомню, что ключевое слово `unsigned` соответствует типу `unsigned int`, именно типа `int` должны быть переменные в качестве битовых полей согласно стандарту языка Си. 

Хотя, некоторые компиляторы допускают использование других типов. Но для переносимости программы лучше этого не делать. Кроме того, сам тип `int` лучше обозначать беззнаковым, опять же, для лучшей совместимости с разными компиляторами.

Итак, в нашей структуре имеются поля в виде беззнакового типа `int`, после которых стоят двоеточия и числа. Эти числа – количество бит, которое отводится для представления того или иного поля в структуре `date_time`. Например, для хранения дней достаточно 5 бит, так как 2^5 = 32 (а максимум дней 31). И так для всех остальных полей. В сумме получаем:

$5 + 4 + 12 + 6 + 6 + 5 = 38$ бит.

Так как данные в битовых полях кратны длине целочисленного типа `int`, который в наших примерах занимает `4` байта или `32` бита, общий размер структуры составит `8` байт (два раза по `4` байта). Мы в этом можем легко убедиться, создав такую переменную и отобразив ее размер:

```c
int main(void) {
    struct date_time dt;
    printf("%d\n", sizeof(dt));
    
    return 0;
}
```

А вот если из структуры убрать любое поле размером `6` бит (чтобы получить ровно `32` бита), например, `min`, то размер структуры составит `4` байта. 

Дальнейшее использование этой структуры происходит абсолютно так же, как и с обычными структурами. Например:

```c
int main(void) {
    struct date_time dt = {3, 5, 2023, 11, 7, 10};
    printf("%02d/%02d/%d %02d:%02d:%02d\n", dt.day, dt.month, dt.year, dt.hour, dt.min, dt.sec);
    
    return 0;
}
```
Увидим результат:

```
03/05/2023 10:07:11
```

![07](/Good_good_C_C++/img/07_13.PNG)

Вот основная идея, положенная в основу битовых полей. Однако в реальной практике программирования на Си такие структуры используются крайне редко. 

Вместо них предпочитают использовать обычные битовые операции, о которых мы с вами подробно уже говорили.

Видео по теме [#56. Объединения (union). Битовые поля](https://www.youtube.com/watch?v=cmQKr4et8uE&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, касающиеся объединений.

+ [x] поля в объединении располагаются с одного и того же адреса
+ [x] объединения задаются согласно синтаксису: union [идентификатор] {[поля]};
+ [x] в программе на Си допустимо создавать указатели типа объединения
+ [ ] объединения задаются согласно синтаксису: [идентификатор] union {[поля]};
+ [x] работа с полями объединений синтаксически осуществляется также, как и в структурах
+ [ ] поля в объединении располагаются в памяти строго друг за другом

### Подвиг 2. Выберите все верные варианты объявления объединений.

+ [x] union tag_var {char ch; int d; double vd; } var;
+ [ ] union {char ch; int d; double vd; };
+ [ ] typedef union VAR {char ch; int d; double vd; };
+ [x] union tag_var {char ch; int d; double vd; };
+ [x] typedef union tag_var {char ch; int d; double vd; } VAR;
+ [x] union {char ch; int d; double vd; } var;
+ [x] typedef union {char ch; int d; double vd; } VAR;

### Подвиг 3. Выберите все верные утверждения, касающиеся следующего фрагмента программы:

```c
union tag_var {
    char ch;
    int d;
    double vd; 
};

int main(void) {
    union tag_var var;
    var.ch = 'a';
    var.d = 10;
    var.vd = 0.5;

    return 0;
}
```

+ [ ] поле ch переменной var хранит символ 'a'
+ [x] для чтения корректно записанного значения из переменной var нужно знать последнее поле, в которое осуществлялась запись
+ [x] поле vd переменной var хранит значение 0.5
+ [ ] поле d переменной var хранит значение 10

### Подвиг 4. Объявите в программе перечисление с именем типа TYPE_COORD и константами coord_int, coord_double со значениями 1 и 2 соответственно. Объявите в программе объединение с именем типа COORD и полями:

```c
coord_i (тип int);
coord_d (тип double).
```

Объявите в программе структуру с именем типа `POINT2` и полями:

```c
x, y (тип COORD);
type (тип TYPE_COORD).
```

В функции `main` создайте переменную с именем `pt` типа `POINT2`. Прочитайте из входного потока данные в следующем формате:

```
<тип данных, целое число> <координата x> <координата y>
```

Если первое значение (тип данных) равно `1`, то следующие координаты `x`, `y` - целочисленные (константа `coord_int`), иначе - вещественные (константа `coord_double`). Занесите в переменную `pt` прочитанные значения в соответствии с их типами. Не забудьте присвоить нужное значение полю `type` переменной `pt`.

P. S. В консоль ничего выводить не нужно.

```c
#include <stdio.h>
#include <stdlib.h>

typedef enum { coord_int = 1, coord_double = 2 } TYPE_COORD;

typedef union {
    int coord_i;
    double coord_d;
} COORD;

typedef struct {
    COORD x, y;
    TYPE_COORD type;
} POINT2;

int main(void) {
    POINT2 pt;
    int type = 0;
    scanf("%d", &type);
    pt.type = type;
    // printf("%d ", pt.type);
    if (pt.type == 1) {
        scanf("%d %d", &pt.x.coord_i, &pt.y.coord_i);
        // printf("%d %d", pt.x.coord_i, pt.y.coord_i);
    } else {
        scanf("%lf %lf", &pt.x.coord_d, &pt.y.coord_d);
        // printf("%.2lf %.2lf", pt.x.coord_d, pt.y.coord_d);
    }
    // __ASSERT_TESTS__ 
    return 0;
}
```

### Подвиг 5. Выберите все верные варианты присвоения значений переменной d типа DATA (на объединение):

```c
typedef union {
    int data_i;
    double data_d;
} DATA;

DATA d;
```

+ [x] d = (DATA){.data_d = 0.5, .data_i = -5};
+ [x] d = (DATA){10};
+ [ ] d = (DATA)10;
+ [ ] d = (DATA)0.74;
+ [x] d.data_i = 12;
+ [x] d = (DATA){.data_d = 0.5};
+ [x] d.data_d = -0.01;

### Подвиг 6. Изучите следующую программу и отметьте все верные утверждения, связанные с ней:

```c
#include <stdio.h>

typedef enum {param_int=1, param_double=2} TYPE_PARAM;

typedef union {
    int data_i;
    double data_d;
} DATA;

DATA get_rect_sq(DATA a, DATA b, TYPE_PARAM type_params) {
    return (type_params == param_int) ? 
            (DATA){.data_i = a.data_i * b.data_i} :
            (DATA){.data_d = a.data_d * b.data_d};
}

int main(void) {
    DATA sq_int = get_rect_sq((DATA){.data_i=10}, (DATA){.data_i=10}, param_int);
    DATA sq_double = get_rect_sq((DATA){.data_d=0.5}, (DATA){.data_d=1.5}, param_double);

    printf("rect_sq = %d\n", sq_int.data_i);
    printf("rect_sq = %f\n", sq_double.data_d);
   
    return 0;
}
```

+ [x] фрагмент (DATA){.data_i=10} создает анонимный объект объединения и копирует его в параметр функции get_rect_sq
+ [x] благодаря использованию объединения DATA в программе не расходуется лишнего памяти при передаче аргументов функции get_rect_sq
+ [x] фрагмент (DATA){.data_i=10} создает в памяти только целочисленную переменную со значением 10 и передает ее как объединение в параметр функции
+ [x] при возврате значения функции get_rect_sq "на лету" создает объект объединения и возвращает его (через копирование)
+ [x] функция get_rect_sq позволяет вычислять площадь прямоугольника как с целочисленными данными, так и с вещественными

### Подвиг 7. Объявите в программе перечисление с типом TYPE_PARAM и константами param_int, param_double; объявите объединение с типом DATA и полями data_i (тип int), data_d (тип double). Объявление делается подобно примеру из предыдущего подвига. Затем, объявите функцию с именем sum_ar с набором параметров (порядок важен):
+ массив элементов типа DATA;
+ число элементов переданного массива (тип size_t);
+ тип данных в массиве (тип TYPE_PARAM).

Функция sum_ar должна вычислять сумму значений элементов массива в зависимости от типа данных. Если тип параметра равен константе param_int, то значения берутся из поля data_i объединения DATA, иначе - из поля data_d. Функция sum_ar должна сохранять вычисленную сумму в соответствующее поле переменной типа DATA (объединение) и возвращать его (через копирование).

В функции main вызовите функцию sum_ar для суммирования целочисленных значений 1, 2, 3, 4, 5 и еще раз вызовите для вещественных 1.1, 2.2, 3.3, 4.4, 5.5. Результат сохраните в переменных res_1 и res_2 типа DATA в соответствующих полях.

Подумайте, как можно сразу создать анонимный объект-массив из элементов DATA с нужными значениями элементов в момент вызова функции sum_ar (то есть, заранее массивы можно не создавать).

P. S. В консоль ничего выводить не нужно.

```c
#include <stdio.h>

typedef enum { param_int = 1, param_double = 2 } TYPE_PARAM;

typedef union {
    int data_i;
    double data_d;
} DATA;

DATA sum_ar(DATA a[], size_t count, TYPE_PARAM type) {
    DATA res = {0};
    for (size_t i = 0; i < count; i++) {
        if (type == param_int)
            res.data_i += a[i].data_i;
        else
            res.data_d += a[i].data_d;
    }
    return res;
}

int main(void) {
    // DATA arr_i[] = {{1}, {2}, {3}, {4}, {5}};
    // DATA arr_d[] = {{.data_d = 1.1},
                    // {.data_d = 2.2}, 
                    // {.data_d = 3.3}, 
                    // {.data_d = 4.4}, 
                    // {.data_d = 5.5}};

    // size_t len_i = sizeof(arr_i) / sizeof(arr_i[0]);
    // size_t len_d = sizeof(arr_d) / sizeof(arr_d[0]);

    // printf("%d: ", (int)len_i);
    // for (size_t i = 0; i < len_i; i++) {
    //     printf("%d ", arr_i[i].data_i);
    // }

    // printf("\n%d: ", (int)len_d);
    // for (size_t i = 0; i < len_d; i++) {
    //     printf("%.1lf ", arr_d[i].data_d);
    // }

    // DATA res_1 = sum_ar(arr_i, len_i, 1);
    // DATA res_2 = sum_ar(arr_d, len_d, 2);
    DATA res_1 = sum_ar((DATA[]){{1}, {2}, {3}, {4}, {5}}, 5, 1);
    DATA res_2 = sum_ar((DATA[]){
                        {.data_d = 1.1}, 
                        {.data_d = 2.2}, 
                        {.data_d = 3.3}, 
                        {.data_d = 4.4}, 
                        {.data_d = 5.5}}, 5, 2);

    // printf("\nres_1 = %d res_2 = %.1lf", res_1.data_i, res_2.data_d);
    // printf("\nres_i = %d res_d = %.1lf", res_i.data_i, res_d.data_d);
    return 0;
}
```

### Подвиг 8. Выберите все верные утверждения, касающиеся битовых полей.

+ [x] общий размер всех битовых полей кратен одному байту (то есть, составляет целое число байт в памяти)
+ [x] битовые поля определяются через структуру, каждое поле которой рекомендуется определять типом unsigned int
+ [x] битовые поля определяются через структуру, каждое поле которой рекомендуется определять типом unsigned char
+ [x] битовые поля определяются через объединение, каждое поле которой рекомендуется определять типом unsigned char
+ [x] после переменной через двоеточие указывается число бит, которое отводится под хранение данных в ней
+ [x] общий размер всех битовых полей в памяти устройства равен сумме бит, отведенных каждому полю

### Подвиг 9. Продолжите программу. Объявите в программе битовое поле с типом PERSON_DATA и следующими переменными (порядок важен):
+ old; 7 бит; возраст
+ salary; 20 бит; зарплата
+ height; 8 бит; рост
+ weight; 7 бит; вес

В функции `main` объявите переменную с именем `pd` и типом `PERSON_DATA`. Занесите в нее значения:

возраст 45, зарплата 876043, рост 186, вес 83

Выведите в консоль размер, который занимает переменная `pd` в памяти компьютера.

```c
#include <stdio.h>

typedef struct {
    unsigned old : 7;
    unsigned salary : 20;
    unsigned height : 8;
    unsigned weight : 7;
} PERSON_DATA;

int main(void) {
    PERSON_DATA pd = {45, 876043, 186, 83};

    printf("%d", (int)sizeof(pd));

    // __ASSERT_TESTS__

    return 0;
}
```

### Подвиг 10 (на повторение). Выберите все верные варианты объявления строк.

+ [x] char s_1[] = {'B', 'a', 'l', 'a', 'k', 'i', 'r', 'e', 'v', '\0'};
+ [ ] char s_7 = "Balakirev";
+ [x] char s_6[100] = "Sergey " "Balakirev";
+ [x] char s_4[100] = "Balakirev";
+ [ ] char s_5[100] = {"Balakirev", 'S', 'e', 'r', 'g', 'e', 'i', '\0'};
+ [x] char s_2[20] = {'B', 'a', 'l', 'a', 'k', 'i', 'r', 'e', 'v', '\0'};
+ [x] char s_3[] = "Balakirev";
+ [x] const char* s_8 = "Balakirev";

