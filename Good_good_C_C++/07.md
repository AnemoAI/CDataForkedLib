# 7. Классы памяти. Составные типы

# 7.1 Локальные и глобальные переменные

На этом занятии поговорим об областях видимости переменных. О чем здесь речь? Смотрите. Переменные в программе можно объявлять, по сути, в двух разных местах: внутри функций (включая их параметры) и вне каких-либо функций – во внешнем блоке кода:

```c
#include <stdio.h>
/* Внешний блок кода */
char name[] = "Variables";

int main(void) {
    int var_main; /* внутренняя переменная */
    return 0;
}
```

Так вот, переменные внутри функций и вне их ведут себя по-разному. Начнем с внутренних переменных.

## Локальные переменные

Когда мы с вами рассматривали функции, то видели, что параметры и переменные, объявленные непосредственно внутри тела функции создаются в стековом фрейме в момент ее вызова. 

А при завершении функции память с блоком ее данных как бы исчезает, а значит, пропадают и все значения переменных, связанных с работой этой функции. 

То есть, получается, что параметры функции и переменные, объявленные внутри тела функции, автоматически формируются в момент ее вызова и перестают существовать после ее завершения. 

Про такие переменные говорят, что они имеют область видимости в пределах функции и являются автоматическими (автоматически создаются и уничтожаются). 

Кроме того, все переменные с ограниченной областью видимости называются локальными.

Давайте детальнее посмотрим на поведение локальных переменных. 

Предположим мы имеем объявление целочисленной локальной переменной с именем `var_main` в функции `main()`. 

Эта переменная не инициализирована никаким начальным значением. 

Спрашивается, чему она равна? 

В общем случае мы не сможем ответить на этот вопрос, так как переменная `var_main` будет размещена в некоторой области стекового фрейма и принимать значение из тех данных, которые будут находиться в ячейках этой переменной. 

Попросту говоря, значение переменной `var_main` неопределенное, случайное. 

Мы в этом с вами уже убеждались на одном из прошлых занятий, но сделаем это еще раз, выведем ее значение на экран:

```c
printf("%d\n", var_main);
```
После запуска программы высветилось значение:

```
3821568
```

И так со всеми локальными переменными, объявленными внутри тела функции. Все они размещаются в стековом фрейме и принимают неопределенное начальное значение.

Также нужно помнить, что стековый фрейм создается в момент запуска программы и, как правило, имеет фиксированный, ограниченный размер в памяти устройства. 

Это накладывает определенные ограничения на нас, как программистов: локальные переменные не должны занимать слишком много памяти. В частности, объявлять внутри функций массивы больших размеров далеко не лучшая практика. Например, так:

```c
int main(void) {
    int var_main; /* внутренняя переменная */
    double big_ar[100000];

    return 0;
}
```

Из-за массива `big_ar` размер стекового фрейма сразу сокращается на 800 000 байт! А если добавить еще один порядок к его размеру:

```c
double big_ar[1000000];
```

то стекового фрейма в моем случае будет и вовсе недостаточно для размещения такого объема данных! 

Поэтому логику программы следует продумывать так, чтобы все локальные переменные играли служебную, вспомогательную роль, а не содержали большие объемы данных, подменяя собой базы данных.

## Глобальные переменные

Несколько иная картина вырисовывается для переменных, объявленных вне каких-либо функций. Если мы перенесем наш большой массив во внешний блок кода:

```c
#include <stdio.h>
/* Внешний блок кода */
char name[] = "Variables";
double big_ar[1000000];

int main(void) {
    int var_main; /* внутренняя переменная */
    return 0;
}
```

то программа скомпилируется, запустится и завершится без каких-либо ошибок. 

С чем это связано? 

Смотрите. Все переменные из внешнего блока размещаются либо в секции `.bss`, если не инициализированы начальными значениями, либо в секции `.data`, если начальная инициализация присутствует:

![07](/Good_good_C_C++/img/07_01.jpg)

Эти секции формируются в момент загрузки программы и размещаются в оперативной памяти устройства. 

То есть, их размер ограничивается только доступной памятью компьютера и при этом они никак не связаны со стековым фреймом. 

Поэтому массив `big_ar` совершенно спокойно размещается в памяти и не мешает дальнейшей работе программы. 

В результате переменные в секциях `.bss` и `.data` формируются в момент загрузки программы и существуют на всем протяжении ее работы. 

В частности, это означает, что область видимости этих переменных не ограничена и их можно совершенно спокойно использовать в любом месте программы, как минимум, в пределах текущего файла. 

Про такие переменные говорят, что они имеют глобальную область видимости или просто глобальные.

Секция `.bss` после размещения в оперативной памяти автоматически заполняется нулями. 

В результате, все глобальные переменные, которые в нее попадают, имеют нулевые начальные значения. 

И в этом мы можем быть уверены. 

А значения переменных секции `.data` формируются в результате загрузки в нее данных из исполняемого файла. 

Да, содержимое всех переменных этой секции содержится непосредственно в файле программы, которое загружается в секцию `.data` в момент загрузки программы. 

С одной стороны это очень удобно, так как начальные значения инициализируются очень быстро, но с другой такие переменные можно инициализировать только константными величинами и соответствующими выражениями. Например, так:

```c
#include <stdio.h>
/* Внешний блок кода */
char name[] = "Variables";
int global_var_1 = 5;
int global_var_2 = 5 * 7;
int global_var_3 = sizeof(name) + 1;

int main(void) {
    int var_main; /* внутренняя переменная */
    return 0;
}
```

А вот, например, использовать переменные недопустимо:

```c
int global_var_4 = global_var_1;    // ошибка, нельзя использовать переменные
```

Хотя, если переменная будет объявлена с ключевым словом `const`, тогда компилятор поймет, что она неизменяема и подставит вместо нее соответствующее значение (ошибки не будет):

```c
const int global_var_1 = 5;
...
int global_var_4 = global_var_1;   // ok
```

Иначе обстоит дело с инициализацией локальных переменных. Так как они формируются в процессе работы программы, а не при ее загрузке, то их начальные значения можно определять любыми допустимыми выражениями языка Си. Например:

```c
#include <stdio.h>
char name[] = "Variables";
int global_var_1 = 5;
int global_var_2 = 5 * 7;
int global_var_3 = sizeof(name) + 1;

int main(void) {
    int a = 1;
    int b = a * 2 + global_var_2;
    int size = global_var_3 * 10;

    return 0;
}
```

Как видите, здесь вполне можно использовать обычные переменные, в том числе, и глобальные. 

Сразу отмечу, что использование глобальных переменных при реализации логики работы программы – это очень плохая практика. 

Связано это с тем, что значения таких переменных можно менять в любом месте программы, в любой функции текущего файла. 

Из-за этого поведение функций, использующие глобальные переменные, становится непредсказуемым. 

А ошибки, к которым они могут приводить, – трудно отслеживаемые. 

Поэтому в практике программирования на языке Си (и то же касается языка С++) глобальные переменные используются, как правило, для определения набора констант (числовых или строковых) и не более того. Очень редко имеет смысл объявлять переменную как глобальную.

Возможно, здесь у вас возникает вопрос: а как тогда нам в программе хранить данные большого размера, если для этого не стоит использовать стековый фрейм (то есть, локальные переменные) и глобальные переменные? 

На самом деле для таких целей, когда данные занимают от нескольких сот килобайт и более, лучше самостоятельно выделять нужный объем памяти и, затем, освобождать ее. Это можно сделать с помощью функций `malloc()` и `free()`, о которых мы еще будем говорить. А пока главное запомнить, что обычные переменные для представления больших данных, лучше не использовать.

Видео по теме [#48. Локальные и глобальные переменные](https://www.youtube.com/watch?v=0TeKFgaYDWg&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, касающиеся переменных языка Си.

+ [x] переменная является автоматической, если она определена внутри тела функции
+ [ ] переменная является автоматической, если она объявлена вне каких-либо блоков
+ [ ] переменная является глобальной, если она определена внутри тела функции
+ [x] переменная является локальной, если она определена внутри тела функции
+ [x] переменная является глобальной, если она объявлена вне каких-либо блоков

### Подвиг 2. Выберите все верные утверждения, касающиеся следующего фрагмента программы:

```c
#include <stdio.h>

short buff[100000000];

int main(void) {
    short buff[100000000];
    return 0;
}
```

+ [x] переменная buff, объявленная вне функции main, является глобальной
+ [x] массив buff, объявленный внутри функции main, располагается в стеке вызова функции
+ [x] элементы массива buff, объявленного внутри функции main, принимают неопределенные начальные значения
+ [ ] значения элементов глобального массива buff принимают неопределенные начальные значения
+ [x] значения элементов глобального массива buff автоматически заполняются нулями в момент запуска программы
+ [ ] элементы массива buff, объявленного внутри функции main, принимают нулевые начальные значения

### Подвиг 3. Выберите все верные утверждения, касающиеся глобальных переменных.

+ [x] глобальные переменные доступны в любом месте текущего файла (модуля), но после их объявления
+ [x] секция кода .bss автоматически заполняется нулями при загрузке программы
+ [x] глобальные переменные с начальной инициализацией располагаются в секции кода .data
+ [x] глобальные переменные без начальной инициализацией располагаются в секции кода .bss
+ [ ] глобальные переменные с начальной инициализацией располагаются в секции кода .bss
+ [ ] глобальные переменные без начальной инициализацией располагаются в секции кода .data

### Подвиг 4. Выберите все верные варианты инициализации глобальных переменных.

+ [x] double global_2 = 2 * 3.53;
+ [ ] short global_3 = 4; long global_6 = global_3 + 2;
+ [x] const int global_1 = -10;
+ [x] const int global_1 = -10; short global_3 = global_1 * 3;
+ [x] const int global_1 = -10; char global_4 = sizeof(global_1);
+ [x] char global_5[10] = "hello";

### Подвиг 5. Выберите все верные варианты инициализации автоматических переменных.

+ [x] float var_3 = 3.87f;
+ [x] int var_2[] = {1, 2, 3};
+ [x] double var_4 = var_2[0] * 0.5;
+ [x] const char* ptr_str = "C/C++";
+ [x] int var_1 = 0;

### Подвиг 6 (на повторение). Продолжите программу, которая последовательно читает из входного потока целые числа в переменную x. Необходимо объявить функцию с именем is_positive, которая принимает целое значение и проверяет его на неотрицательность. Если число неотрицательное (>= 0), то функция is_positive возвращает 1, а иначе 0. В записанном цикле while вызовите функцию is_positive для каждого прочитанного числа и выведите в консоль в одну строчку через пробел только неотрицательные числа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/7.1.6

```c
#include <stdio.h>

int is_positive(int num) {
    int res = num >= 0;
    return res;
}

int main(void) {
    int x;
    while (scanf("%d", &x) == 1) {
        if (is_positive(x)) printf("%d ", x);
    }

    return 0;
}
```

### Подвиг 7 (на повторение). Продолжите программу. В функции main из стандартного входного потока читаются целые числа. Необходимо все их сохранять в массиве marks (не более 20). То есть, чисел может быть и больше 20, но сохранять только первые 20 в порядке их считывания. 

Допишите функцию `mean_ar`, которая бы вычисляла среднее арифметическое чисел переданного ей массива `ar`. Учитывать при вычислении следует только те числа, для которых переданная функция (через указатель) с сигнатурой:

```c
int <имя функции>(int);
```

возвращает истину (не нулевое значение). Полученное значение должно возвращаться функцией `mean_ar`.

В функции `main` вызовите функцию `mean_ar` для массива `marks`, обрабатывая только числа от 1 до 5 включительно (проверка выполняется дополнительной, вспомогательной функцией, которая, затем, передается последним аргументом в функцию `mean_ar`). Выведите в консоль вещественное значение с точностью до десятых, которое вернула функция `mean_ar`.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/7.1.7

```c
#include <stdio.h>
#define RANGE_DOWN 1
#define RANGE_UP 5
#define MAX_LEN 20

double mean_ar(const int *ar, size_t len_ar, int (*in_range)(int)) {
    double res = 0;
    int count = 0;
    for (size_t i = 0; i < len_ar; i++) {
        if (in_range(ar[i])) {
            res += ar[i];
            count++;
        }
    }
    return res / count;
}

int in_range(int num) {
    int res = (num >= RANGE_DOWN) * (num <= RANGE_UP);
    return res;
}

int main(void) {
    int marks[MAX_LEN] = {0};
    int x, count = 0;
    while (scanf("%d", &x) == 1 && count < MAX_LEN) {
        marks[count++] = x;
    }
    double result = mean_ar(marks, count, in_range);

    printf("%.1lf", result);

    return 0;
}
```

### Подвиг 8 (на повторение). Выберите все верные утверждения, касающиеся размещения переменных в памяти устройства

+ [x] адресом переменной называют порядковый номер ячейки, начиная с которой переменная хранится в памяти
+ [ ] разные переменные (обычные) могут использовать одни и те же ячейки памяти
+ [x] порядковый номер ячейки памяти называется ее адресом
+ [ ] адресом переменной называют порядковый номер ячейки, которой оканчивается область памяти, отведенная под переменную
+ [x] через имя переменной на уровне языка Си осуществляется доступ к непрерывной области памяти из одной или нескольких ячеек
+ [x] разные переменные (обычные) хранятся в разных не пересекающихся ячейках памяти

# 7.2 Локальные переменные во вложенных блоках

Мы продолжаем тему областей видимости переменных. Теперь, когда мы в целом узнали, что из себя представляют локальные и глобальные переменные, давайте более детально разберем поведение локальных переменных.

В языке Си операторные фигурные скобки образуют свой собственный независимый блок данных со своим набором локальных переменных. Например, в функции `main()` можно прописать в теле функции еще одни фигурные скобки и в них объявить внутреннюю переменную `b`:

```c
#include <stdio.h>

int main(void) {
    int a = 1;

    {
        int b = 2;
        printf("a = %d, b = %d\n", a, b);
    }

    printf("a = %d\n", a);

    return 0;
}
```

Как следует воспринимать такую конструкцию? 

Смотрите, в теле функции определена локальная переменная с именем `a` и начальным значением `1`. 

При этом, в стековом фрейме только эта переменная и появляется. 

Затем, когда выполнение доходит до внутреннего блока фигурных скобок, в стековом фрейме появляется еще одна переменная `b`. 

Соответственно, обе переменных существуют и могут быть выведены на экран с помощью функции `printf()`. 

После завершения внутреннего блока, все данные связанные с ним в стековом фрейме пропадают и, следовательно, перестает существовать и переменная `b`. Поэтому вторая функция `printf()` может вывести только одну переменную `a`. После запуска программы увидим следующий результат:

```
a = 1, b = 2
a = 1
```

Если же попытаться вывести значение переменной `b` за пределами вложенного блока, например:

```c
printf("a = %d, b = %d\n", a, b);
```

то получим ошибку на этапе компиляции программы, говорящей, что переменная `b` не существует.

Такая логика работы довольно полезна, когда во внутренних блоках нужно объявить временные переменные, которые не нужны за его пределами. 

Например, в функции `main()` объявлены две локальные переменные `a` и `b` и мы бы хотели, чтобы большее значение было в переменной `a`, а меньшее – в переменной `b`. Реализовать это можно следующим образом:

```c
#include <stdio.h>

int main(void) {
    int a = 1, b = 3;

    if (a < b) {
        int t = a;
        a = b;
        b = t;
    }

    printf("a = %d, b = %d\n", a, b);

    return 0;
}
```

Здесь внутренний блок срабатывает только при истинности условия и в нем объявляется вспомогательная временная переменная `t`, которая существует только в нем и недоступна за его пределами. 

Это очень удобно, учитывая, что такая переменная вполне может быть за пределами внутреннего блока и играть свою собственную роль. Например:

```c
#include <stdio.h>

int main(void) {
    int a = 1, b = 3;
    int t = a + b;

    if (a < b) {
        int t = a;
        a = b;
        b = t;
    }

    printf("a = %d, b = %d, t = %d\n", a, b, t);

    return 0;
}
```

Смотрите, как здесь все работает. Вначале в функции `main()` определены три локальных переменных `a`, `b` и `t`. Затем, по условию отрабатывает внутренний блок, в котором объявляется переменная с тем же именем `t`. 

Однако это имя связано с совсем другой областью памяти, которая отводится в стековом фрейме. 

И изменение этой переменной никак не скажется на значении другой переменной с тем же именем `t`. 

В программировании такой эффект называется сокрытием переменной. Действительно, когда выполнение внутреннего блока завершается, все данные, связанные с ним в стековом фрейме, исчезают, а имя `t` теперь будет вести на прежнюю область памяти со значением `a+b`. Именно оно выводится функцией `printf()`:

```
a = 3, b = 1, t = 4
```

Разумеется, если бы мы не объявляли внутреннюю переменную `t`, то имя `t` вело бы к переменной из внешнего блока – из тела функции `main()`. Тогда значение этой переменной изменилось бы.

## Собственные блоки операторов if, while, for, do-while

В языке Си стандарта `C99` операторы `if`, `while`, `for`, `do-while` и некоторые другие образуют свои собственные блоки. Это можно показать на следующем примере:

```c
#include <stdio.h>

int main(void) {
    int t = 3;

    while (t-- > 0) {
        int t = 10;
        t--;
        printf("t = %d\n", t);
    }

    printf("main: t = %d\n", t);

    return 0;
}
```

Здесь в условии цикла `while` используется переменная `t` из функции `main()`, а в теле цикла – новая переменная с тем же именем `t`. В результате, цикл сработает ровно три раза и выведет строчки:

```c
t = 9
t = 9
t = 9
main: t = -1
```

Возможно, здесь все достаточно очевидно. Но вот менее очевидный пример с оператором цикла `for`:

```c
#include <stdio.h>

int main(void) {
    int t = 33;

    for (int t = 0; t < 3; ++t) {
        printf("t = %d\n", t);
    }

    printf("main: t = %d\n", t);

    return 0;
}
```

Здесь оператор `for` образует свой вложенный блок с переменной `t`, которая, затем, используется в его теле цикла. После завершения цикла на экран выводится значение прежней переменной `t` функции `main`:

```
t = 0
t = 1
t = 2
main: t = 33
```

Как видим, локальная переменная `t` не была изменена в операторе цикла `for`. Конечно, если бы мы не делали ее объявление в `for`:

```c
for(t = 0; t < 3; ++t) ...
```

то использовалась бы внешняя переменная `t` из функции `main()`. Увидели бы результат:

```
t = 0
t = 1
t = 2
main: t = 3
```

## Регистровые переменные

В заключение этого занятия отмечу еще один способ представления переменных доступный в языке Си. 

На самом первом занятии мы с вами видели, что центральный процессор компьютера сохраняет промежуточные данные в своих регистрах. 

Эти регистры физически находятся внутри процессора, а потому с ними очень быстро происходит обмен данными. 

Быстрее, чем с ячейками памяти, а значит, быстрее, чем с переменными.

![07](/Good_good_C_C++/img/07_02.jpg)

Так вот, составляя программу, мы можем попросить компилятор разместить ту или иную переменную непосредственно в одном из регистров процессора. 

Разумеется, размер этой переменной (по числу бит) не должен превышать размер регистров ЦП. Делается это с помощью ключевого слова `register`, следующим образом:

```c
#include <stdio.h>

int main(void) {
    int p = 1;
    int n = 7;

    for (register int i = 2; i <= n; ++i) p *= i;

    return 0;
}
```

Конечно, гарантии того, что переменная `i` будет соответствовать некоторому регистру ЦП, нет. Мы лишь выражаем свое желание, чтобы эта переменная стала регистровой. А поместит ли ее компилятор в регистр или нет зависит от множества факторов: от наличия свободного регистра; от типа и использования самой переменной `i` в программе. Например, если мы попытаемся получить адрес регистровой переменной, то она точно не будет в регистре, т.к. у регистров нет адреса и компилятор решит, что программист что-то напутал и сделает переменную самой обычной.

Во всем остальном регистровые переменные ведут себя, как обычные локальные автоматические, то есть, они автоматически создаются внутри блока и исчезают за пределами блока.

Видео по теме [#49. Локальные во вложенных блоках](https://www.youtube.com/watch?v=PV903MfZ4_M&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, касающиеся следующего фрагмента программы:

```c
#include <stdio.h>

int var = 0;

int main(void) {
    int var = 10;

    {
        int var = 20;
        printf("%d\n", var);
    }

    printf("%d\n", var);

    return 0;
}
```

+ [x] переменная var со значением 0 является глобальной
+ [ ] при выполнении программы в консоли увидим числа: 10 и 10
+ [ ] фигурные скобки внутри тела функции main недопустимы по синтаксису языка Си
+ [x] фигурные скобки внутри тела функции main образуют свой независимый блок видимости
+ [x] переменная var со значением 0 в функции main подменяется локальными переменными var
+ [x] при выполнении программы в консоли увидим числа: 20 и 10

### Подвиг 2. Выберите все верные утверждения, касающиеся блоков видимости.

+ [ ] тело цикла операторов while, for, do-while не образует свою локальную область видимости
+ [x] в языке Си стандарта C99 блок из фигурных скобок в любом месте программы образуют свою область видимости
+ [x] тело цикла операторов while, for, do-while образует свою локальную область видимости
+ [x] тело любой функции языка Си образует свою локальную область видимости

### Подвиг 3. Выберите все верные утверждения, касающиеся следующего фрагмента программы языка Си стандарта C99:

```c
#include <stdio.h>

int main(void) {
    int n = 10;
    for (int i = 0; i < n; ++i) printf("%d ", i + 1);

    printf("\n%d\n", i);

    return 0;
}
```

+ [ ]при выполнении программы в консоли увидим целые числа от 1 до 10 в одну строчку через пробел
+ [x]переменная i, объявленная в операторе for, существует только в пределах этого оператора
+ [x]в строчке printf("\n%d\n", i); при компиляции возникнет ошибка, т.к. переменная i за пределами цикла не существует
+ [ ]команда printf("\n%d\n", i); выведет в консоль значение 10
+ [ ]переменная i, объявленная в операторе for, существует и за пределами оператора for

### Подвиг 4. Выберите все верные утверждения, касающиеся следующего фрагмента программы языка Си стандарта C99:

```c
#include <stdio.h>

int main(void) {
    int n = 7;
    while (n-- > 0) {
        int n = 5;
        printf("%d\n", n);
        n++;
    }

    printf("%d\n", n);

    return 0;
}
```

+ [x] при выполнении программы в консоли семь раз отобразится число 5, а в конце число -1
+ [ ] цикл while будет работать "вечно", т.к. значение n на каждой итерации устанавливается равным 5
+ [ ] при выполнении программы в консоли восемь раз отобразится число 5, а в конце число 0
+ [x] цикл while сработает ровно семь раз (семь итераций)
+ [x] в теле цикла while переменная n каждый раз инициализируется значением 5
+ [ ] при выполнении программы в консоли шесть раз отобразится число 5, а в конце число -1

### Подвиг 5 (на повторение). Напишите программу, которая читает из входного потока натуральное число n. Необходимо найти все делители этого числа (то есть, натуральные числа, которые нацело делят число n, начиная с 1). Все найденные делители вывести по порядку (начиная с наименьшего) в одну строчку через пробел.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/7.2.5

```c
#include <stdio.h>

int main(void) {
    int n;

    scanf("%d", &n);
    // Выведем 1, на единицу всё делиться без остатка
    printf("%d ", 1);

    // Достаточно проверять до половины n
    for (int i = 2; i <= n / 2; i++) {
        if (n % i == 0) printf("%d ", i);
    }
    // если n = 1, то не будем печатать её второй раз
    if (n > 1) printf("%d", n);

    return 0;
}
```

### Подвиг 6 (на повторение). Напишите программу, которая читает из входного потока натуральное число n. Вычислите у этого числа все его простые множители (разложить число по простым множителям) и выведите их в порядке возрастания (неубывания) в одну строчку через пробел.

Например, число 140 = 2 * 2 * 5 * 7. В консоли должно отображаться 2 2 5 7.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/7.2.6

```c
#include <stdio.h>

int main(void) {
    int n;

    scanf("%d", &n);

    for (int i = 2; i <= n; i++) {
        while (n % i == 0) {
            printf("%d ", i);
            n /= i;
        }
    }

    return 0;
}
```

### Подвиг 7 (на повторение). Напишите программу, которая читает из входного потока два натуральных числа n, m, записанных через пробел, и вычисляет следующую сумму:

$S = \displaystyle\sum_{i=0}^{n}\sum_{j=0}^{m}i+j$

Сумма должна вычисляться до тех пор, пока слагаемое `i+j` меньше `20`. Как только `i+j` окажется больше или равно `20`, прервать подсчет суммы и вывести результат (полученную сумму) в консоль в виде одного целого числа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/7.2.7

```c
#include <stdio.h>
#define MAX 20

int main(void) {
    int n, m, result = 0;

    scanf("%d %d", &n, &m);

    for (int i = 0; i <= n; i++) {
        for (int j = 0; j <= m; j++) {
            int sum = i + j;
            if (sum == MAX) goto A;
            result += sum;
        }
    }

A:
    printf("%d", result);
    return 0;
}
```

### Подвиг 8 (на повторение). Установите соответствия между обозначениями операторов и их описаниями.

![07](/Good_good_C_C++/img/07_03.PNG)

# 7.3 Ключевые слова static и extern

## Ключевое слово static

Мы продолжаем тему глобальных и локальных переменных. Когда речь шла о глобальной области видимости, то мы говорили, что неинициализированные переменные располагаются либо в секции `.bss`, а инициализированные – в секции `.data`:

```c
char name[] = "Variables";  /* в секции .data */
double big_ar[1000000];     /* в секции .bss */
 
int main(void) {
    int var_main; /* автоматическая локальная переменная */
    return 0;
}
```

Причем, расположение таких переменных в памяти устройства не меняется на всем протяжении работы программы. 

О таких переменных говорят, что они статические, то есть, не меняют свой адрес от запуска программы и до ее завершения. 

В отличие от автоматических переменных, адрес которых может меняться, и точно известен только после их появления в стековом фрейме. 

То есть, обычные локальные переменные не статические. 

Однако, при необходимости, можно объявить локальную переменную и в то же время статическую. Для этого нужно прописать ключевое слово `static` перед типом переменной, например, следующим образом:

```c
int main(void) {
    int var_main;           /* автоматическая локальная переменная */
    static short var_st;   /* локальная статическая переменная */
 
    return 0;
}
```

Что значит локальная статическая переменная? И какими свойствами она обладает? 

В действительности такие переменные располагаются или в секции `.bss` (если не инициализированы) или в секции `.data` (если инициализированы). 

То есть там же, где и глобальные переменные. 

Соответственно, на них распространяются те же правила инициализации, что и на глобальные переменные: только константами и соответствующими выражениями. 

Если же статическая переменная не имеет начального значения, то она равна нулю, так как секция `.bss` при запуске программы заполняется нулями. Мы в этом легко можем убедиться. Выведем их с помощью функции `printf()`:

```c
printf("var_main = %d, var_st = %d\n", var_main, var_st);
```

Увидим результат:

```
var_main = 3207168, var_st = 0
```

То есть, автоматические переменные изначально принимают случайные значения, а статические – нулевые. Мало того, локальные статические переменные инициализируются и формируются в памяти устройства только один раз – в момент запуска программы. А строчка:

```
static short var_st;
```

лишь связывает имя `var_st` с соответствующей областью памяти либо из секции `.bss` либо из секции `.data`. 

Это, своего рода, указатель на заранее выделенную статическую область памяти. 

В действительности, все имена переменных на уровне машинных кодов заменяются соответствующими адресами памяти. 

Поэтому имена переменных – это всего лишь некоторая абстракция на уровне языка Си. В машинных кодах они не существуют.

Спрашивается, зачем нужна такая локальная статическая переменная? 

Первая ее особенность нам уже известна – возможность не занимать память в стековом фрейме, а располагаться в основной памяти устройства. 

Следовательно, статические переменные могут занимать большие объемы памяти без каких-либо последствий в работоспособности программы. Я напомню, если бы мы захотели локально объявить массив:

```c
double big_ar[1000000];
```

в функции `main()`, то программа бы завершилась аварийно из-за нехватки памяти, отведенной под стековый фрейм. Однако если прописать перед типом `double` ключевое слово `static`:

```c
static double big_ar[1000000];
```

то никаких проблем с выполнением такой программы не будет и, кроме того, массив станет доступен по локальному имени `big_ar`. А это гораздо лучше использования глобальной переменной.

Вторая особенность локальной статической переменной проявляется из-за ее однократной инициализации: в памяти она создается только один раз и продолжает существовать даже после завершения функции, в которой была объявлена. Наглядно это можно показать с помощью такой программы:

```c
#include <stdio.h>
 
unsigned int counter() {
    static unsigned int cnt = 10;
    return ++cnt;
}
 
int main(void) {
    unsigned int times;
    times = counter();
    printf("times = %u\n", times);
    printf("counter(): %u\n", counter());
    printf("counter(): %u\n", counter());
    printf("counter(): %u\n", counter());
 
    return 0;
}
```

Здесь внутри функции `counter()` объявляется локальная статическая переменная `cnt` с начальным значением `10`. В основной функции `main()` мы несколько раз вызываем функцию `counter()` и получаем следующий вывод:

```c
times = 11
counter(): 12
counter(): 13
counter(): 14
```

О чем говорит этот результат? О том, что переменная `cnt` была инициализирована только один раз значением `10`, и при последовательных вызовах функции `counter()` бралось ее текущее значение и увеличивалось на единицу. Также это говорит о том, что переменная `cnt` не исчезает после завершения работы функции, а продолжает существовать в памяти устройства. И мы теперь знаем, что она располагается в секции `.data` (так как имеет начальное значение `10`).

## Ключевое слово extern с глобальными переменными

Давайте теперь посмотрим, как можно воспользоваться глобальной переменной в другом файле текущего проекта. Для этого создадим в том же рабочем каталоге файл, допустим, с именем `modul.c` и объявим в нем глобальную переменную:

```c
int global_var = 5;
```

А в файле lessons.c с функцией main() запишем следующее:

```c
#include <stdio.h>
 
int main(void) {
    printf("global_var = %d\n", global_var);
    return 0;
}
```

В настройках компилятора дополнительно пропишем файл `modul.c` и попробуем скомпилировать наш проект. 

Получим ошибку, что переменная `global_var` в файле `lessons.c` неизвестна. 

И это неудивительно, так как любое объявление глобальных переменных по умолчанию распространяется только на текущий файл. Чтобы получить доступ к переменной `global_var` в файле `lessons.c` нужно дать описание этой переменной. Делается это с помощью ключевого слова `extern` следующим образом:

```c
extern int global_var;
```

После этого программа скомпилируется, выполнится и выведется ее значение на экран:

```
global_var = 5
```

Обратите внимание, что с помощью ключевого слова `extern` мы не объявляем переменную `global_var`, а лишь говорим компилятору, что эта переменная будет объявлена позже, либо в этом же файле, либо в другом. То есть, это именно описание переменной, а не объявление. Память под нее здесь не резервируется.

Учитывая все сказанное, мы можем вначале сформировать описание глобальной переменной, а в конце файла объявить ее, например, так:

```c
#include <stdio.h>
 
extern int global_var;
extern char global_str[];
 
int main(void) {
    printf("global_var = %d\n", global_var);
    puts(global_str);
    return 0;
}
 
char global_str[100] = "Hello";
```

После запуска программы увидим на экране строку «Hello». И, обратите внимание, на важный момент. 

В описании массива `global_str` не указывается его размерность и уж, тем более, не прописывается инициализация. Через `extern` мы лишь задаем тип и имя переменной, чтобы компилятор корректно сформировал представление этой переменной в объектном файле. А объявление переменной должно быть в любом другом месте и модуле проекта. На этапе его сборки линковщик объединит описания переменных с их объявлениями. Кстати, если в конце убрать объявление переменной `global_str`, то, естественно, получим ошибку на этапе линковки проекта:

```c
undefined reference to `global_str'// неопределенная ссылка на `global_str'.
```

## Ключевое слово extern с функциями

Аналогичные описания можно определять и для функций. Мы с вами об этом уже говорили, когда рассматривали прототипы функций. Здесь я лишь напомню и немного дополню тот материал.

Если функция определена в другом модуле, например, в файле `modul.c`:

```c
#include <stdlib.h>
 
int global_seed_randint = 0;
 
int randint(int a, int b) {
    int right = a, left = b;
    if(a > b) {
        right = b;
        left = a;
    }
 
    return rand() % (left - right + 1) + right;
}
```

То для ее использования в файле `lessons.c` необходимо также дать ее описание (записать прототип) следующим образом:

```c
#include <stdio.h>
 
int randint(int, int);
 
int main(void) {
    int a = 1, b = 10;
 
    printf("%d\n", randint(a, b));
    printf("%d\n", randint(a, b));
    printf("%d\n", randint(a, b));
 
    return 0;
}
```

Обратите внимание, имена параметров в прототипах указывать не обязательно. Компилятор все равно их игнорирует. 

Ему здесь важна лишь сигнатура функции:
+ возвращаемый тип,
+ имя функции и
+ типы параметров. 

Этого достаточно, чтобы сформировать вызов функции на уровне машинных кодов. А адрес ее вызова подставится позже на этапе линковки проекта.

Итак, получается, что для описания связи с глобальной переменной необходимо прописывать ключевое слово `extern`:

```c
extern int global_seed_randint;
```

а в прототипе функции его нет. Почему? На самом деле его можно добавить и там:

```c
extern int randint(int a, int b);
```

Но здесь оно необязательно, т.к. компилятор легко может различить прототип от полного объявления функции. А вот с переменной лучше явно указывать `extern`.

## Ключевое слово static с глобальными переменными

А что если мы бы хотели ограничить область видимости глобальной переменной только текущим модулем. Например, сделать так, чтобы переменная `global_seed_randint` была доступна только в пределах файла `modul.c`? Для этого достаточно прописать ключевое слово `static` при объявлении этой переменной:

```c
static int global_seed_randint;
```

Тогда при попытке ее использовать в файле `lessons.c` произойдет ошибка на этапе линковки проекта:

```c
#include <stdio.h>
 
extern int global_seed_randint;
int randint(int a, int b);
 
int main(void) {
    int a = 1, b = 10;
 
    printf("global_seed_randint = %d\n", global_seed_randint);
    printf("%d\n", randint(a, b));
    printf("%d\n", randint(a, b));
    printf("%d\n", randint(a, b));
 
    return 0;
}
```

То есть, ключевое слово `static` с глобальными переменными играет совсем другую роль, чем с локальными. Если локальные из класса автоматических переменных переходили в класс статических, то с глобальными оно лишь ограничивает их область видимости в пределах текущего модуля. Вот это нужно четко понимать и запомнить.

По аналогии дела обстоят и с функциями. Если при ее реализации прописать ключевое слово `static` (в файле `modul.c`):

```c
static int randint(int a, int b) {
   
...
}
```

то использовать ее можно только в текущем модуле и нельзя за его пределами. В программировании такое поведение называют внутренним связыванием. И, наоборот, если переменную или функцию можно использовать в других модулях, то говорят, что они имеют внешнее связывание.

Надеюсь, из последних занятиях вы стали хорошо себе представлять, как объявляются глобальные и локальные переменные, чем они принципиально отличаются друг от друга, где и как размещаются в памяти. Также знаете роль ключевых слов `static` и `extern`, применительно к переменным и функциям.

Видео по теме [#50. Ключевые слова static и extern](https://www.youtube.com/watch?v=18ycGTrljXk&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, касающиеся статических переменных языка Си.

+ [x] статические переменные хранятся либо в секции .bss (неинициализированные), либо в секции .data (инициализированные)
+ [x] статические переменные создаются и инициализируются в программе только один раз, в момент запуска программы
+ [ ] локальные статические переменные создаются каждый раз при вызове той или иной функции, в которой объявлены
+ [x] статические переменные имеют постоянный адрес все время выполнения программы
+ [x] любая глобальная переменная - статическая
+ [x] локальную переменную можно превратить в статическую, прописав перед ее типом ключевое слово static

### Подвиг 2. Выберите все верные утверждения, касающиеся следующего фрагмента программы:

```c
#include <stdio.h>

int get_step(int start) {
    static int step = start;
    return step++;
}

int main(void) {
    printf("step: %d\n", get_step(5));
    printf("step: %d\n", get_step(5));
    printf("step: %d\n", get_step(5));

    return 0;
}
```

+ [ ] в процессе выполнения программы в консоль будут выведены значения 5, 6, 7
+ [ ] чтобы программа заработала достаточно параметр функции get_step объявить как const int start
+ [x] статическая переменная, объявленная внутри функции, создается и инициализируется только один раз в момент запуска программы
+ [x] команда static int step = start; недопустима, т.к. статическая переменная может быть инициализирована только значением времени компиляции
+ [x] статическая переменная, объявленная внутри функции, продолжает существовать и сохранять значение после завершения работы функции

### Подвиг 3. Выберите все верные утверждения, касающиеся следующего фрагмента программы:

```c
#include <stdio.h>
#define START_STEP  0

int get_step(int start) {
    static int step = START_STEP;
    return start + step++;
}

int main(void) {
    printf("step: %d\n", get_step(5));
    printf("step: %d\n", get_step(5));
    printf("step: %d\n", get_step(5));

    return 0;
}
```

+ [ ] в процессе выполнения программы в консоль будут выведены значения 6, 7, 8
+ [ ] к статической переменной недопустимо применять операции инкремента и декремента
+ [ ] в процессе выполнения программы в консоль будут выведены значения 5, 5, 5
+ [x] в процессе выполнения программы в консоль будут выведены значения 5, 6, 7
+ [ ] статическую переменную нельзя складывать с обычной (автоматической) переменной

### Подвиг 4. Напишите программу без использования глобальных переменных, в которой объявляется функция со следующей сигнатурой:

```c
int range(void);
```

Эта функция при каждом вызове возвращает целые числа, начиная с `5` и с шагом `3`. Например:

5, 8, 11, 14, 17, ...

В функции `main` вызовите семь раз функцию range и выведите в консоль в одну строчку через пробел числа, которые она возвратит.

```c
#include <stdio.h>
#define START_STEP 2
#define FUNC_RUNS 7

// int range(void) {
//     static int step = START_STEP;
//     step += 3;
//     return step;
// }

int range(void) {
    static int i;
    return 5 + 3 * i++;
}

int main(void) {
    for (size_t i = 0; i < FUNC_RUNS; i++) {
        printf("%d ", range());
    }

    return 0;
}
```

### Подвиг 5. Допишите программу без использования глобальных переменных, в которой объявляется функция со следующей сигнатурой:

```c
int range(int start, int stop, int step);
```

При первом запуске она должна настраивать счетчик на формирование последовательности целых чисел от `start` до `stop` (включительно) с шагом `step`. Также первый запуск возвращает первое значение последовательности. При повторных вызовах функции `range` параметры `start`, `stop`, `step` не должны играть никакого значения. Сама же функция `range` при каждом новом вызове должна возвращать очередные числа последовательности. Например, при start=5, stop 11, step=2, имеем:

5, 7, 9, 11, 5, 7, 9, 11, 5, 7, 9, 11, 5, 7, 9, 11, 5, 7, 9, 11, ...

То есть, при достижении граничного значения stop, происходит возврат на начальное значение start.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/7.3.5

```c
#include <stdio.h>

int range(int start, int stop, int step) {
    static int i = 0;
    if ((start + step * i) > stop) i = 0;
    if ((start + step * i) == stop) {
        i++;
        return stop;
    }
    int res = (start + step * i++) % (stop - start);
    return res;
}

int main(void) {
    int start, stop, step;
    scanf("%d %d %d", &start, &stop, &step);

    for (int i = 0; i < 20; ++i) printf("%d ", range(start, stop, step));

    return 0;
}
```

### Подвиг 6. Выберите все верные утверждения, касающиеся глобальных определений в языке Си.

+ [x] ключевое слово extern перед заголовком функции прописывать не обязательно
+ [x] обычная функция, объявленная в текущем модуле, может быть использована и в любом другом, если указать ее прототип
+ [x] ключевое слово extern позволяет глобальные переменные использовать за пределами текущего модуля
+ [ ] область видимости глобальной переменной по умолчанию распространяется на весь проект (все модули)
+ [ ] обычная функция, объявленная в текущем модуле, может быть использована только в этом модуле и недоступна в других
+ [ ] ключевое слово extern позволяет ограничивать область видимости глобальных переменных текущим модулем
+ [x] область видимости глобальной переменной по умолчанию распространяется только на текущий файл (модуль)

### Подвиг 7. Выберите все верные утверждения, касающиеся ключевого слова static.

+ [x] ключевое слово static у функций ограничивает их область видимости текущим модулем
+ [ ] внутреннее связывание - это когда переменная или функция может быть использована в других функциях
+ [x] внутреннее связывание - это когда переменная или функция имеет область видимости только в пределах текущего модуля
+ [ ] внешнее связывание - это когда переменная или функция использует другие внешние переменные или функции
+ [ ] ключевое слово static у функций позволяет объявлять статические функции без ограничения области их видимости
+ [x] ключевое слово static у глобальных переменных ограничивает их область видимости текущим модулем
+ [x] внешнее связывание - это когда переменная или функция доступна и за пределами текущего модуля

### Подвиг 8. Выберите все верные утверждения, касающиеся следующего фрагмента программы:

```c
#include <stdio.h>

extern int ex_var_1;
extern int ex_var_2 = 7;

int main(void) {
    printf("%d", ex_var_1);
    return 0;
}

int ex_var_1 = 10;

```

+ [ ] значение переменной ex_var_2 равно 7
+ [ ] значение переменной ex_var_1 в функции main равно 0
+ [x] переменная ex_var_2 не может быть инициализирована при наличии ключевого слова extern
+ [x] при компиляции программы возникнет ошибка
+ [x] значение переменной ex_var_1 в функции main равно 10

### Подвиг 9 (на повторение). Выберите все верные утверждения, касающиеся следующего фрагмента программы:

```c
#include <stdio.h>

short buff[100000000];

int main(void) {
    short buff[100000000];
    return 0;
}
```

+ [ ] элементы массива buff, объявленного внутри функции main, принимают нулевые начальные значения
+ [x] переменная buff, объявленная вне функции main, является глобальной
+ [ ] значения элементов глобального массива buff принимают неопределенные начальные значения
+ [x] элементы массива buff, объявленного внутри функции main, принимают неопределенные начальные значения
+ [x] значения элементов глобального массива buff автоматически заполняются нулями в момент запуска программы
+ [x] массив buff, объявленный внутри функции main, располагается в стеке вызова функции

### Подвиг 10 (на повторение). Выберите все верные утверждения, касающиеся глобальных переменных.

+ [x] глобальные переменные доступны в любом месте текущего файла (модуля), но после их объявления
+ [ ] глобальные переменные без начальной инициализацией располагаются в секции кода .data
+ [x] секция кода .bss автоматически заполняется нулями при загрузке программы
+ [x] глобальные переменные без начальной инициализацией располагаются в секции кода .bss
+ [x] глобальные переменные с начальной инициализацией располагаются в секции кода .data
+ [ ] глобальные переменные с начальной инициализацией располагаются в секции кода .bss

# 7.4 Функции malloc(), free(), calloc(), realloc(), memcpy()

До сих пор мы с вами данные программы размещали в переменных. 

Собственно, для этого они и существуют. 

Однако имеют некоторые известные нам ограничения. 

В частности, они располагаются либо в статической области памяти, если речь идет о глобальных переменных, и существуют на всем протяжении работы программы, либо в ограниченном по объему стековом фрейме, когда речь идет о локальных переменных. 

При этом вся остальная свободная память устройства, которая не занята другими процессами, работающими параллельно с нашей программой, никак не используется. 

Переменные в ней не размещаются (если не считать глобальных переменных, но они размещаются раз и навсегда, пока не завершится программа). 

Так вот, в программировании эта остальная свободная память называется «кучей» или по-английски `heap`. 

Язык Си предоставляет возможность самостоятельно выделять память в «куче», использовать ее по своему усмотрению, а затем, также самостоятельно освобождать ранее выделенную память. Для этого в заголовочном файле `stdlib.h` определены две основные функции:

```c
void* malloc(size_t size); // для выделения size байт из кучи
void free(void* ptr); // для освобождения памяти по указателю ptr
```

Прежде чем перейти к рассмотрению этих функций, поясню смысл слов «выделение» и «освобождение» памяти. 

В первых компьютерах таких понятий не существовало. 

Была память, работала одна программа в один момент времени, и программист мог совершенно свободно использовать ее, не спрашивая ни у кого разрешения. 

Все было предельно просто, пока не появились они – многозадачные ОС с параллельным выполнением сразу нескольких программ. 

Романтике программирования был нанесен серьезный урон. 

Теперь программа не могла по своему собственному усмотрению размещать данные, как ей казалось, в свободных ячейках. 

Эти ячейки могли быть совсем не свободными, а использоваться другой программой. 

В результате для контроля за использованием памяти на уровне ОС был создан посредник – менеджер памяти. 

И отныне любая программа, которая хочет получить свой неделимый кусок из набора байт, должна обращаться к этому посреднику через системный вызов и с надеждой ожидать положительного решения своей просьбы. 

К счастью, просьбы чаще всего удовлетворяются за очень редкими исключениями, когда нужного запрашиваемого объема памяти недостаточно. 

Если менеджер памяти оказался к вам благосклонен и выдал адрес начала неделимого блока из байт, то никакая другая программа его уже не получит. 

Ваша программа становится полновластным хозяином над этими ячейками памяти. И только после того, как вы благосклонно освободите их, дав свободу с помощью функции `free()`, ими могут воспользоваться другие программы, заявляя над ними свои права. 

Вот что в действительности значат невинные на первый взгляд слова «выделение» и «освобождение» памяти.

Давайте посмотрим, как в программе можно воспользоваться функциями `malloc()` и `free()`:

```c
#include <stdio.h>
#include <stdlib.h>
 
int main(void) {
    char* ar = malloc(10);   // выделение 10 байт из кучи
    int* ptr_int = malloc(sizeof(int)); // выделение памяти под тип int
    int* ptr_short = malloc(7 * sizeof(short)); // выделение памяти под 7 элементов типа short
 
    free(ar);
    free(ptr_int);
    free(ptr_short);
    
    return 0;
}
```

Обратите внимание, что в качестве аргумента функции `malloc()` указывается число байт, которую мы хотим получить из «кучи» в  виде непрерывной области памяти. Если менеджер памяти в «куче» находит такой кусок свободной памяти, то функция `malloc()` возвращает адрес первой ячейки. 

Если же возникают проблемы, то возвращается предопределенное значение `NULL`. 

Поэтому, после вызова функции `malloc()`, прежде чем использовать область памяти, нужно проверить значение указателя: оно должно быть не равно `NULL`. Пока в нашем примере этого нет, т.к. мы просто выделяем, а потом освобождаем память.

Итак, первая функция `malloc()` запрашивает у ОС `10` байт непрерывной области и, скорее всего, получит ее, т.к. это совсем небольшой размер. Во втором вызове `malloc()` запрашивается число байт для хранения целочисленного значения типа `int` в «куче». Наконец, последний вызов возвращает непрерывную память под `7` элементов типа `short`. После этого выполняется освобождение ранее выделенной памяти и программа завершается.

## Эффект утечки памяти

Надо сказать, современные ОС автоматически освобождают все ресурсы, которые использовались программой, при ее завершении. 

Поэтому, если бы мы не написали функции `free()`, то в данном конкретном случае никаких последствий бы не было. 

Но, в общем случае, и к этому нужно приучаться сразу:
+ каждому вызову `malloc()` должен соответствовать один вызов функции `free()`. 

Иначе, программа выделит под себя память, но не освободит ее, когда она уже не нужна. 

Если к тому же функция `malloc()` время от времени продолжает вызываться, то выделенная для нужд программы память, будет постоянно нарастать, не освобождаясь. 

Такой эффект в программировании называется утечкой памяти. 

Это главный бич, ахиллесова пята языка программирования Си. 

Наверное, каждый серьезный программист, пишущий на Си, сталкивался с такой проблемой. Кажется, куда уж проще, вызвал `malloc()` не забудь вызвать и `free()`. 

Но это на первый взгляд. 

Реальные программы имеют непростую логику распределения информационных потоков. И далеко не всегда удается правильно сочетать вызовы пар функций `malloc()` и `free()`. 

Отсюда и проблема утечки памяти. 

Эта проблема настолько серьезная, что многие современные языки программирования, вроде `Python`, `Java`, `C#`, `PHP` и другие, имеют встроенный механизм автоматического освобождения памяти, когда она уже не нужна программе. 

Этот механизм реализован на основе, так называемого, сборщика мусора. 

Он анализирует все выделенные блоки памяти, и если на какую-либо не ведут программные ссылки (указатели), то делается вывод, что она не нужна и освобождается. Но в языке Си такого механизма нет. И это не удивительно, так как это нарушало бы философию данного языка:
+ доверять программисту;
+ не мешать программисту делать то, что он считает необходимым;
+ без необходимости не усложнять язык, сохранять его простоту;
+ каждая операция языка должна иметь только один способ выполнения;
+ операция должна выполняться максимально быстро, даже в ущерб переносимости языка.

Язык Си – это, своего рода, ассемблер высокого уровня и в этом смысле он уникален. Сами сборщики мусора для других языков программирования написаны на Си (точнее, на `С++`). 

Поэтому язык Си – это рабочая лошадка низкоуровневого программирования. Он предоставляет огромные возможности, но накладывает и большую ответственность на программиста. В частности, ответственность за освобождение ранее выделенных ресурсов.

## Пример использования функций malloc() и free()

Давайте теперь посмотрим, в каких задачах целесообразно использовать функции `malloc()` и `free()`. 

Предположим, нам в программе нужно хранить температуру по дням в течение некоторого периода. Какой это период, никто не знает. Это может быть и 20 дней, а может 100, а возможно пользователю захочется хранить данные за последние 100 000 дней. 

Как в этом случае нам организовать хранение данных в программе, чтобы с одной стороны не занимать слишком много памяти, а с другой – разместить все необходимые данные? 

Как вы уже догадались, выход только один: воспользоваться функциями `malloc()` и `free()`.

Логика программы будет следующей. Вначале мы объявим две переменные:

```c
size_t capacity = 10;
size_t length = 0;
```

Первая `capacity` будет хранить максимальное число элементов в массиве, а вторая `length` – число сохраненных в массив значений. Пока `length` меньше `capacity` проблем никаких нет. Новые данные можно записывать по порядку в ячейки массива. Но, когда вся отведенная под массив память окажется заполненной, то сделаем «прием с переворотом», а точнее, «прием с копированием». 

Мы динамически выделим новый кусок памяти, скажем, в два раза большего размера, перенесем туда ранее записанные данные из прежнего массива и освободим из под него память. Это известная концепция, положенная в основу структуры данных, известной под названием динамический массив.

Идею динамического массива можно реализовать следующим образом:

```c
#include <stdio.h>
#include <stdlib.h>
 
void* append(short* data, size_t *length, size_t *capacity, short value) {
    if(*length >= *capacity) {
        short* ar = malloc(sizeof(short) * 2 * *capacity);
        if(ar == NULL)
            return data;
            
        (*capacity) *= 2;
        for(int i = 0;i < *length;++i)
            ar[i] = data[i];
        
        free(data);
        data = ar;
    }
 
    data[*length] = value;
    (*length)++;
    
    return data;
}
 
int main(void) 
{
    size_t capacity = 10;
    size_t length = 0;
 
    short* data = malloc(sizeof(short) * capacity);
 
    for(int i = 0; i < 11;++i)
        data = append(data, &length, &capacity, rand() % 40 - 20);
 
    printf("length = %u, capacity = %u\n", length, capacity);
 
    for(int i = 0;i < length;++i)
        printf("%d ", data[i]);
 
    free(data);
    return 0;
}
```

+ Вначале выделяется память под массив `data`, содержащий максимум `10` элементов типа `short`. 
+ Затем, выше, определена функция `append()` для добавления нового значения в массив `data`.<br> В качестве аргументов этой функции передается сам массив, адреса переменных `length` и `capacity` и новое значение.
+ После добавления функция возвращает адрес массива (на случай, если массив будет увеличен и его начальный адрес изменится).
+ Сама функция `append()` работает очень просто:
    + Вначале проверяется, нужно ли увеличивать существующий массив и если да, то значение `capacity` удваивается, создается новый массив удвоенной длины и в него поэлементно копируются значения из прежнего массива. 
    + Затем, освобождается память из под массива `data` и указателю `data` присваивается новый адрес массива `ar`. В последних строчках добавляется новое значение в массив и возвращает его адрес.

В самой функции `main()` мы добавляем 11 случайных значений, чтобы посмотреть, как будет работать алгоритм при переполнении массива. После этого на экран выводятся значения переменных `length`, `capacity`, а затем, сохраненные значения в массиве `data`.

После запуска программы увидим строчки:

```c
length = 11, capacity = 20
-19 7 -6 0 -11 -16 18 18 -18 4 5
```

Действительно, массив был динамически увеличен при его заполнении и стал в два раза больше. Так мы реализовали идею динамического массива на языке Си с помощью функций `malloc()` и `free()`.

## Функции calloc(), realloc(), memcpy() и memmove()

На самом деле эту программу можно несколько улучшить, если знать, что существуют некоторые дополнительные функции работы с памятью. В частности, не редко можно встретить использование следующих:

- заголовочный файл `stdlib.h`:
    + `void* calloc(size_t nmemb, size_t size);`
    + `void* realloc(void *ptr, size_t length);`
- заголовочный файл `string.h`:
    + `void* memcpy(void* restrict dst, const void* restrict src, size_t length);`
    + `void* memmove(void* dst, const void* src, size_t length);`

Первая функция `calloc()` выделяет память под `nmemb` элементов, каждый размером `size` байт, то есть, всего `nmemb*size` байт, и заполняет ее нулями. 

Это ключевое ее отличие от функции `malloc()`. Во всем остальном, они идентичны. Следующая функция `realloc()` служит для изменения размера ранее выделенной памяти, на которую ведет указатель `ptr`. Новый размер задается вторым параметром `length` в байтах. В частности, при `length=0` функция `realloc()` отрабатывает аналогично функции `free()`. 

Если же `length` больше ранее выделенной памяти, то функция сначала пытается расширить уже существующую область до большего размера, если ей это не удается, то создается новая с копированием всей прежней информации. Предыдущая область памяти автоматически освобождается.

Две последние функции определены в заголовочном файле `string.h`, так как предполагается их использовать с символьными массивами (строками). В частности, копировать одну строку в другую с помощью функции `memcpy()` или переносить один фрагмент строки в другой с помощью функции `memmove()`. 

Ключевое слово `restrict` в параметрах функции `memcpy()` указывает компилятору, что указатели `dst` и `src` уникальны и ведут каждый на свою независимую область памяти.

В частности, мы бы могли воспользоваться функцией `memcpy()` для копирования данных из массива `data` в новый массив `ar` следующим образом:

```c
memcpy(ar, data, *length * sizeof(short));
```

Но в нашем примере мы можем поступить еще лучше и воспользоваться функцией `realloc()`, которая и память увеличивает и данные копирует и прежнюю память освобождает:

```c
void* append(short* data, size_t *length, size_t *capacity, short value) {
    if(*length >= *capacity) {
        short* ar = realloc(data, sizeof(short) * 2 * *capacity);
        if(ar == NULL)
            return data;
 
        (*capacity) *= 2;
        data = ar;
    }
 
    data[*length] = value;
    (*length)++;
    
    return data;
}
```

Вот, в целом, набор наиболее употребительных функций для работы с памятью. 

Если по каким-либо причинам переменные не подходят для хранения данных в программе, то следует посмотреть в сторону этих функций. 

Как правило, они решают все задачи. Собственно, кроме них все равно ничего принципиально другого нет для представления и хранения данных в памяти устройства. Поэтому, мы либо используем классические переменные, либо выделяем память из кучи и работаем уже с ней.

Видео по теме [#51. Функции malloc(), free(), calloc(), realloc(), memcpy() и memmove()](https://www.youtube.com/watch?v=ihIJRxgcRQ0&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, касающиеся работы с памятью устройства на языке Си.

P. S. Здесь ОС - это операционная система.

+ [x] выделение памяти - это процесс обращения к ОС для получения непрерывной области памяти в распоряжение программы
+ [x] выделение и освобождение памяти осуществляется путем системных вызовов к ОС (менеджеру памяти)
+ [ ] под кучей (heap) понимается область памяти программы, занятой глобальными переменными
+ [x] освобождение памяти - это процесс обращения к ОС для отмены ранее выделенного блока памяти
+ [ ] освобождение памяти - это процесс обращения к ОС для отмены ранее выделенного блока памяти и заполнение ее нулевыми значениями
+ [x] под кучей (heap) понимается 

### Подвиг 2. Выберите все верные утверждения для функций malloc и free.

+ [x] если запрашиваемый объем памяти успешно выделяется, то функция malloc возвращает адрес начала выделенного блока памяти
+ [x] для использования функций работы с памятью нужно подключить файл stdlib.h
+ [x] если запрашиваемый объем памяти не может быть выделен, то функция malloc возвращает значение NULL
+ [x] функция malloc служит для выделения указанного числа байт непрерывного блока в памяти устройства
+ [x] функция free служит для освобождения ранее выделенного блока памяти устройства
+ [ ] для использования функций работы с памятью нужно подключить файл stdio.h

Подвиг 3. Выберите все верные утверждения, касающиеся следующей программы:

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    int * ptr = malloc(4);
    char * ptr_str;
    free(ptr_str);
}
```

+ [x] при завершении программы все ресурсы, которая она захватывала, автоматически освобождаются операционной системой
+ [x] функция free отработает без ошибок
+ [x] в программе потенциально происходит "утечка памяти", т.к. была выделена память, но не освобождена
+ [ ] при выполнении функции free возникнет ошибка, т.к. указатель ptr_str не ссылается на выделенную область памяти
+ [ ] указатель ptr содержит адрес начала области памяти в 4 элемента типа int (если malloc отработала успешно)
+ [x] указатель ptr содержит адрес начала области памяти в 4 байта (если malloc отработала успешно)

### Подвиг 4. Продолжите программу. Объявите указатель с именем data типа данных short и выделите из кучи память под четыре элемента типа short. Затем, через указатель data занесите в эту область памяти значения:

-4, 3, 0, 100

Указатель data, при этом не должен менять свой адрес (ссылаться по-прежнему на начало выделенной области).

P. S. В консоль ничего выводить не нужно. Не забудьте в конце (после __ASSERT_TESTS__) освободить память.

```c
#include <stdio.h>
#include <stdlib.h>
#define DATA_LEN 4

int main(void) {
    short* data = malloc(sizeof(short) * DATA_LEN);
    const short ins[] = {-4, 3, 0, 100};

    if (data != NULL) {
        for (size_t i = 0; i < DATA_LEN; i++) {
            data[i] = ins[i];
        }
    }

    // __ASSERT_TESTS__
    // макроопределение для тестирования (не убирать и должно идти непосредственно перед return 0)

    if (data != NULL) free(data);
    return 0;
}
```

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(void)
{
    short* data = malloc(4*sizeof(short));
    short data1[]={-4, 3, 0, 100};
    memcpy(data, data1, 4 * sizeof(short));

    __ASSERT_TESTS__ // макроопределение для тестирования (не убирать и должно идти непосредственно перед return 0)

    free(data);
    return 0;
}
```

### Подвиг 5. Продолжите программу. Из входного потока прочитайте вещественные значения, записанные в одну строчку через пробел, и сохраните их в массиве digits типа double. Максимальное количество читаемых значений не более 20 (это нужно контролировать, в потоке чисел может быть больше). В целочисленной переменной count должно храниться количество прочитанных чисел.

Выделите дополнительно память, ровно столько, чтобы в нее помещались все прочитанные вещественные числа (тип double). На выделенную область должен ссылаться указатель ptr_d. Скопируйте из массива digits прочитанные числа в выделенную память. Указатель ptr_d при этом не должен менять свой адрес.

P. S. В консоль ничего выводить не нужно. Не забудьте в конце (после __ASSERT_TESTS__) освободить память.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/7.4.5

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define DATA_LEN 20

int main(void) {
    double digits[DATA_LEN];
    size_t count = 0;

    while (scanf("%lf", &digits[count]) == 1 && count < DATA_LEN) count++;
    printf("%d\n", count);
    for (size_t i = 0; i < count; i++) {
        printf("%.2lf ", digits[i]);
    }
    printf("\n");

    double* ptr_d = malloc(sizeof(double) * count);

    if (ptr_d != NULL) memcpy(ptr_d, digits, sizeof(double) * count);

    // __ASSERT_TESTS__
    // макроопределение для тестирования (не убирать и должно идти непосредственно перед return 0)

    if (ptr_d != NULL) free(ptr_d);
    return 0;
}
```

### Подвиг 6. Установите соответствия между функциями и их описаниями.

![07](/Good_good_C_C++/img/07_04.PNG)

### Подвиг 7. Продолжите программу. Из входного потока прочитайте целочисленные значения, записанные в одну строчку через пробел, и сохраните их в массиве lengths типа int. Максимальное количество читаемых значений не более 20 (это нужно контролировать, в потоке чисел может быть больше). В целочисленной переменной count должно храниться количество прочитанных чисел.

Выделите память для хранения 20 целочисленных значений (тип int) с помощью функции calloc. На выделенную область должен ссылаться указатель ptr_lens. Скопируйте из массива lengths прочитанные числа в выделенную память, используя функцию memcpy (копировать следует не весь массив lengths, а только часть с хранимыми (прочитанными) данными). Указатель ptr_lens при этом не должен менять свой адрес. Выведите в консоль все 20 чисел типа int из области памяти ptr_lens в одну строчку через пробел.

P. S. Не забудьте в конце (после __ASSERT_TESTS__) освободить память.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/7.4.7

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define DATA_LEN 20

int main(void) {
    int lengths[DATA_LEN];
    size_t count = 0;

    while (scanf("%d", &lengths[count]) == 1 && count < DATA_LEN) count++;
    // printf("%d\n", count);
    // for (size_t i = 0; i < count; i++) {
    //     printf("%d ", lengths[i]);
    // }
    // printf("\n");

    int* ptr_lens = calloc(DATA_LEN, sizeof(int));

    if (ptr_lens != NULL) {
        // for (size_t i = 0; i < DATA_LEN; i++) {
        //     printf("%d ", ptr_lens[i]);
        // }
        // printf("\n");
        memcpy(ptr_lens, lengths, sizeof(int) * count);
        for (size_t i = 0; i < DATA_LEN; i++) {
            printf("%d ", ptr_lens[i]);
        }
    }
    // __ASSERT_TESTS__
    // макроопределение для тестирования (не убирать и должно идти непосредственно перед return 0)

    if (ptr_lens != NULL) free(ptr_lens);
    return 0;
}
```

### Подвиг 8. Продолжите программу. Необходимо объявить функцию со следующей сигнатурой:
```c
void* expand_array(short* ptr, size_t* len, short fill);
```

Здесь *len - длина массива (число его элементов). Данная функция должна удваивать размер области памяти, выделенной под указатель ptr, в новую область копировать прежние данные, а остальные заполнять значениями fill. Прежняя область должна освобождаться (если была выделена новая). Значение размера *len нужно также увеличить в два раза. В конце функция expand_array должна вернуть адрес удвоенной области памяти.

В функции main вызовите функцию expand_array для удвоения памяти, на которую ведет указатель ptr_d, и значением fill = -1. В результате указатель ptr_d должен ссылаться на удвоенную область памяти. Затем, через указатель ptr_d выведите в консоль в одну строчку через пробел все целые числа типа short, хранящиеся в удвоенной области памяти.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/7.4.8

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define TOTAL 10
#define FILL -1

void* expand_array(const short* ptr, size_t* len, short fill) {
    size_t new_len = *len * 2;
    short* ar = malloc(sizeof(short) * new_len);
    if (ar != NULL) {
        memcpy(ar, ptr, sizeof(short) * *len);
        for (size_t i = *len; i < new_len; i++) {
            ar[i] = fill;
        }
        *len = new_len;
    }
    return ar;
}

int main(void) {
    short* ptr_d = calloc(TOTAL, sizeof(short));
    size_t len = TOTAL;
    if (ptr_d == NULL) return 0;

    int count = 0;
    while (count < TOTAL && scanf("%hd", &ptr_d[count]) == 1) count++;

    ptr_d = expand_array(ptr_d, &len, FILL);

    if (ptr_d != NULL) {
        for (size_t i = 0; i < len; i++) {
            printf("%d ", ptr_d[i]);
        }
        free(ptr_d);
    }

    return 0;
}
```

### Подвиг 9. Продолжите программу. Объявите функцию со следующей сигнатурой:

```c
char * merge_string(const char* str1, const char* str2);
```
Данная функция должна выделить память под новую строку так, чтобы в нее помещались все символы первой (str1) и второй (str2) строк. Затем, в новую строку скопировать сначала содержимое первой строки (только символы строки), а следом за ней содержимое второй строки. В конце не забудьте добавить символ '\0', чтобы сформировать корректную Си-строку. После объединения функция merge_string должна вернуть адрес сформированной строки.

В функции main вызовите функцию merge_string для объединения строк str_1 и str_2 (именно в таком порядке). Выведите в консоль полученную строку.

P. S. Не забудьте в конце программы освободить выделенную память.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/7.4.9

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void getline(char* buffer, size_t max_len) {
    fgets(buffer, max_len - 1, stdin);
    char* ptr_n = strrchr(buffer, '\n');
    if (ptr_n != NULL) *ptr_n = '\0';
}

char* merge_string(const char* str1, const char* str2) {
    size_t len_1 = strlen(str1);
    size_t len_2 = strlen(str2);

    char* res = malloc(sizeof(char) + (len_1 + len_2));
    if (res != NULL) {
        res = memcpy(res, str1, sizeof(char) * len_1);
        res[len_1] = '\0';
        res = strcat(res, str2);
    }
    return res;
}

int main(void) {
    char str_1[200] = {0};
    char str_2[200] = {0};

    getline(str_1, sizeof(str_1));
    getline(str_2, sizeof(str_2));

    char* str = merge_string(str_1, str_2);

    puts(str);
    free(str);
    return 0;
}
```

### Подвиг 10 (на повторение). Отметьте верные объявления переменных.

+ [ ] char int ch;
+ [ ] short double sd;
+ [x] short int a;
+ [x] long int b;
+ [x] long double ld;
+ [ ] long float lf;
+ [x] long long int LLi;
+ [x] long long d;

# 7.5 Перечисления (enum). Директива typedef

## Перечисления (enum).

На этом занятии познакомимся с новым типом данных – перечислением. С его помощью в программе удобно определять наборы целочисленных констант, например, следующим образом:

```c
enum colors {red, green, blue};
```

Здесь `enum` – это ключевое слово для объявления перечислимого типа; `colors` – идентификатор перечисления; `red`, `green`, `blue` – целочисленные константы типа `int`.

Прежде чем двигаться дальше, я думаю, нужно сразу ответить на вопрос, который, наверное, одолевает многих из вас: зачем нужно это перечисление? 

Неужели нельзя список констант определить или через директивы `#define`:

```c
#define REG     1
#define GREEN   2
#define BLUE    3
```

или через константные переменные:

```c
const int c_red = 1;
const int c_green = 2;
const int c_blue = 3;
```

На самом деле константы в перечислениях отличаются от всего того, что нам до сих известно. От константных переменных их отличает то, что их значения формируются в момент компиляции программы, то есть, они являются константами времени компиляции. И это очень важный момент. В частности, по этой причине их можно использовать в метках условного оператора `switch`. А от директив константы в перечислениях отличает безопасность их использования в различных конструкциях языка Си. Именно поэтому такие константы записывают, как правило, малыми буквами, а не большими, как макроимена, так как они не приводят к каким-либо скрытым ошибкам в коде программы. Все это делает перечисления незаменимым инструментом для объявления и использования целочисленных констант.

Давайте вначале посмотрим на способы объявления перечислений. Самый простой из них мы уже видели:

```c
enum colors {red, green, blue};
```

При этом константы `red`, `green`, `blue` соответствуют типу `int` и принимают значения `0`, `1` и `2` соответственно. Мы их даже можем вывести на экран с помощью функции `printf()`:

```c
#include <stdio.h>
enum colors {red, green, blue};
 
int main(void) {
    printf("red = %d, green = %d, blue = %d\n", red, green, blue);
    return 0;
}
```

После выполнения программы увидим строчку:

```c
red = 0, green = 1, blue = 2
```

Но, при необходимости, значения констант можно задавать вручную, например, такими способами:

```c
enum keys {vk_enter=27, vk_space, vk_del=30};
enum {
    go = 0x1f00, 
    stop = 0x0001, 
    forward = go,
    run = 0x00a2,
    back = run -1
};
```

В перечислении `keys` константа `vk_enter` принимает значение `27`, следующая константа `vk_space` на единицу больше, то есть, `28`, и последняя `vk_del` равна `30`. 

А перечисление без идентификатора (имени) задает константы, причем некоторые из них определены на основе других, ранее объявленных и с использованием арифметических операций. Так тоже можно делать. Главное, чтобы выражение использовало данные времени компиляции. Последнее перечисление без имени обычно прописывают, если целью является только объявление целочисленных констант.

А как можно использовать именованные перечисления, например, `keys`? В языке Си ключевое слово `enum` с последующим именем образуют новый составной тип данных. То есть, мы вполне можем объявить переменную такого типа следующим образом:

```c
enum keys k_var;
```

Что это за тип? 

На уровне машинных кодов компилятор представляет переменную `k_var` как целочисленную типа `int`. А раз так, значит, мы вполне можем заменить тип enum `keys` на `int`? 

Формально да, можем, и программа будет работать абсолютно также. Но есть один нюанс. Тип `enum keys` для компилятора не в точности соответствует типу `int`. Отличие я покажу на конкретном примере. Пусть переменная `k_var` используется в операторе `switch` следующим образом:

```c
#include <stdio.h>
 
enum keys {vk_enter=27, vk_space, vk_del=30};
 
int main(void) {
    enum keys k_var = vk_enter;
 
    switch(k_var) {
    case vk_enter:
        puts("vk_enter");
        break;
    case vk_space:
        puts("vk_space");
        break;
    }
 
    return 0;
}
```

Если скомпилировать эту программу с указанием флага `–Wall` (отображение всех предупреждений), то увидим сообщение:

```c
warning: enumeration value 'vk_del' not handled in switch
```

Компилятор предупреждает нас, что мы в операторе `switch` указали не все варианты значений, заданные в перечислении `enum keys`. При этом программа компилируется и запускается. Это предупреждение появилось из-за того, что тип переменной `k_var` соответствует `enum keys`, а не просто `int`. Если мы пропишем `int`:

```c
int k_var = vk_enter;
```

то компилятор не сможет отловить этот момент, никаких предупреждений выдано не будет. Поэтому, на практике все же лучше не пренебрегать перечислимым типом и использовать именно его, а не тип `int`. Во всем остальном, переменная `k_var` ведет себя так же, как и обычная целочисленная переменная. В общем случае ей можно присваивать любые целые значения:

```c
enum keys k_var = vk_enter * 2 - vk_space * 100;
```

Хотя, так делать не стоит и лучше присваивать константы, записанные в соответствующем перечислении (в данном случае в `keys`).

Переменные перечислимого типа можно задавать при объявлении перечисления. Например, так:

```c
enum colors {red, green, blue} wnd_colors;
 
enum {
    go = 0x1f00, 
    stop = 0x0001, 
    forward = go,
    run = 0x00a2,
    back = run -1
} actions, commands;
```

В результате получим объявление глобальных переменных `wnd_colors`, `actions` и `commands`.

## Директива typedef

Во второй части занятия рассмотрим директиву `typedef`, которая позволяет задавать пользовательское имя типа. Попросту говоря, она любой тип данных позволяет представить другим именем. Например, так:

```c
typedef unsigned char BYTE;
```

В результате в программе появляется новое имя `BYTE` как синоним типа `unsigned char`. Соответственно, его можно использовать всюду как полноценный тип данных, например:

```c
typedef unsigned char BYTE;
 
int main(void) {
    BYTE byte;
    BYTE ch, var_ch = '0';
 
    return 0;
}
```

Компилятор вместо слова `BYTE` подставит `unsigned char` и программа будет работать с объявленными переменными, как с беззнаковыми байтовыми.

На первый взгляд кажется, что этот же фокус можно проделать и с помощью директивы препроцессора `#define` следующим образом:

```c
#define BYTE unsigned char
```

И, действительно, программа скомпилировалась без проблем и отработала бы абсолютно также. Но все же, между определением через директиву `#define` и директиву `typedef` есть существенная разница. Директива `typedef` обрабатывается не препроцессором, а самим компилятором, а потому это более тонкое и безопасное действие. Покажу это на следующем примере:

```c
#include <stdio.h>
 
#define PTR_INT int*
 
typedef int* PTR;
 
int main(void) {
    PTR_INT a, b;      // int* a, b;
    PTR ptr_a, ptr_b;  // int *ptr_a, *ptr_b;
    printf("*a = %d, *b = %d\n", *a, *b);
    printf("*ptr_a = %d, *ptr_b = %d\n", *ptr_a, *ptr_b);
 
    return 0;
}
```

Мы двумя способами переопределяем тип `int*` для объявления целочисленных указателей. Затем, в функции `main()` объявляем два указателя `a`, `b` с помощью макровызова `PTR_INT` и еще два указателя `ptr_a`, `ptr_b` с помощью введенного типа `PTR`. В итоге, после обработки текста программы, мы получим следующий эквивалент объявлений:

```c
int* a, b;
int *ptr_a, *ptr_b;
```

Как говорится, почувствуйте разницу. Благодаря тому, что `typedef` – это директива уровня компилятора, он корректно применяет подмененный тип и каждую переменную делает указателем. А макровызов `PTR_INT` срабатывает на уровне препроцессора, который «в лоб» на уровне текста программы делает подмену. В итоге получаем не совсем корректный результат.

Довольно часто директиву `typedef` применяют с составными типами данных. Обычно, это структуры, о которых мы будем говорить на следующем занятии. Но сейчас я приведу пример с составным перечислимым типом:

```c
#include <stdio.h>
 
typedef enum {
    buffer_size = 2048,
    element_size = 12,
    window_size = 400
} SIZE_CONSTS;
 
int main(void) {
    SIZE_CONSTS sizes = window_size;
    printf("%d\n", sizes);
    printf("%d\n", buffer_size);
 
    return 0;
}
```

Обратите внимание, в этом случае имя перечисления прописывать не имеет особого смысла. В дальнейшем все равно предполагается использовать имя типа `SIZE_CONSTS` для объявления переменных перечислимого типа.

После всех этих примеров, у вас все равно может остаться вопрос, зачем все это нужно? Только лишь для удобства? Или есть другие причины? 

Да, причины есть, по крайней мере, еще одна. Помните, когда мы с вами рассматривали некоторые функции, то тип данных у них имел вид `size_t`. Например, такой тип имеет параметр функции `malloc()`:

```c
void* malloc(size_t size);
```

В действительности, это переопределенный тип с помощью оператора `typedef`. В моей реализации это следующая замена:

```c
typedef unsigned int size_t;
```

Какую роль играет это переопределение? Смотрите, когда компьютеры были максимум 32-разрядные, то типа `unsigned int` было вполне достаточно для выделения максимально возможного блока памяти. При переходе к 64-разрядным системам этого размера может быть уже недостаточно и потребуется другое переопределение, например:

```c
typedef unsigned long long size_t;
```

При этом сама запись типа `size_t` сохраняется неизменной. А, значит, неизменными остаются и все прототипы функций, которые используют тип `size_t`, а также все объявления переменных этого типа. Получается некоторая универсальность текста программы. При необходимости, нам достаточно подменить тип `size_t` с одного на другой и можно просто перекомпилировать ранее написанные программы без дальнейших переделок. В этом удобство и практичность введенного типа `size_t` и других ему подобных.

Наконец, оператор `typedef` можно использовать для упрощения записи сложных типов данных, например, указателей на функции или многомерные массивы:

```c
#include <stdio.h>
#include <stdlib.h>
 
int is_even(int x) {
    return x % 2 == 0;
}
 
typedef int (*PTR_EVEN)(int);
typedef char (*PTR_AR_2D)[4];
 
int main(void) {
    char ar_2d[5][4] = {0};
    PTR_AR_2D ptr_2d = ar_2d;
    ar_2d[1][2] = 5;
   
    PTR_EVEN func_even = is_even;
 
    printf("%d\n", func_even(2));
    printf("%d\n", func_even(3));
 
    printf("%d\n", ptr_2d[1][2]);
 
    return 0;
}
```

Как видите, при замене программа становится более читаемой, поэтому, в ряде случаев, такие замены вполне могут быть использованы.

Видео по теме [#52. Перечисления (enum). Директива typedef](https://www.youtube.com/watch?v=lnXZSkCbD5s&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, касающиеся перечислимого типа языка Си.

+ [x] константы перечисления связаны с целыми числами и не имеют скрытого поведения, как например, директивы
+ [ ] константы перечисления нельзя использовать в метках case оператора switch
+ [ ] перечисления позволяют задавать числовые константы времени выполнения программы (не компиляции)
+ [x] константы перечисления можно использовать в метках case оператора switch
+ [x] перечисления позволяют задавать числовые константы времени компиляции

### Подвиг 2. Выберите все верные объявления перечислений.

+ [x] enum types {type_int, type_double, type_long};
+ [x] enum sizes {width=1280, height=720};
+ [x] enum {black=0, red=0xCC0000, green = 0x00CC00, blue=0x0000CC, white=255};
+ [x] enum window_styles {border=2, caption=4, sizeable=8} style;
+ [x] enum {v2=2, v3=3, v4=4} vector_dim;

### Подвиг 3. Выберите все верные утверждения, касающиеся следующего фрагмента программы:

```c
#include <stdio.h>

enum window_styles {border=2, caption=4, sizeable=8};

int main(void) {
    enum window_styles style = 0;
    style = border | caption;

    return 0;
}
```

+ [x] переменная style сначала инициализируется нулем, а затем ей присваивается десятичное значение 6
+ [x] в программе объявлена переменная style перечисляемого типа
+ [x] переменную style можно использовать, как целочисленную переменную типа int (но делать так не рекомендуется)
+ [x] переменная style на уровне машинных кодов представляется и обрабатывается, как целочисленная переменная типа int
+ [ ] переменная style сначала инициализируется нулем, а затем ей присваивается десятичное значение 5
+ [x] в программе объявлено перечисление с идентификатором window_styles

### Подвиг 4. Напишите программу, в которой объявляется перечисление с идентификатором menu_item и константами:

```c
item_exit = 1, item_c = 2, item_python = 3, item_java = 4
```

В функции main прочитайте из входного потока целочисленное значение и сравните его с одной из констант перечисления. Сравнение следует выполнить с помощью оператора switch. При совпадениях в консоль выведите следующие строки (без кавычек):

item_exit: "Выход";
item_c: "Язык Си";
item_python: "Язык Python";
item_java: "Язык Java".

Если ни одна из констант не была выбрана, то вывести строку:

"Не верный пункт меню"

```c
#include <stdio.h>

enum menu_item { item_exit = 1, item_c = 2, item_python = 3, item_java = 4 };

int main(void) {
    enum menu_item menu;
    int num;
    scanf("%d", &num);

    menu = num;

    switch (menu) {
        case item_exit:
            puts("Выход");
            break;
        case item_c:
            puts("Язык Си");
            break;
        case item_python:
            puts("Язык Python");
            break;
        case item_java:
            puts("Язык Java");
            break;
        default:
            puts("Не верный пункт меню");
    }

    return 0;
}
```

### Подвиг 5. Напишите программу, в которой объявляется перечисление с идентификатором calc_types и константами:

```c
_perimetr=1, _square=2
```

Объявите функцию с именем `calc_rect`, которая имеет следующие параметры (порядок важен):
+ ширина прямоугольника width (тип double);
+ высота прямоугольника height (тип double);
+ тип вычислений type (тип calc_types).

Функция должна вычислять либо площадь прямоугольника (если `types` равен `_square`), либо его периметр (если types равен `_perimetr`) и возвращать вычисленное значение (тип `double`). 

В функции `main` прочитайте из входного потока одно целое число (для `type`) и два вещественных числа (`width` и `height`), записанных в одну строчку через пробел. Вызовите функцию `calc_types` с передачей ей прочитанных значений в качестве аргументов. Выведите в консоль вычисленное значение с точностью до десятых.

```c
#include <stdio.h>

typedef enum calc_types { _perimetr = 1, _square = 2 } types;

double calc_rect(double width, double height, types form) {
    double res = 0;
    switch (form) {
        case _perimetr:
            res = (width + height) * 2;
            break;
        case _square:
            res = width * height;
            break;
        default:
            puts("Wrong type");
    }
    return res;
}

int main(void) {
    types oper;
    int num;
    double w, h;
    scanf("%d %lf %lf", &num, &w, &h);

    oper = num;

    double result = calc_rect(w, h, oper);

    printf("%.1lf", result);

    return 0;
}
```

### Подвиг 6. Выберите все верные утверждения, касающиеся директивы typedef

+ [ ] директива typedef позволяет создавать новые типы данных
+ [x] директива typedef позволяет задавать новые имена существующим типам данных
+ [x] typedef обрабатывается компилятором, а не препроцессором, поэтому работает "более тонко" и корректно, чем обычные директивы препроцессора
+ [ ] директива typedef обрабатывается текстовым препроцессором и небезопасна в использовании (как и все директивы препроцессора)
+ [x] при помощи директивы typedef достигается лучшая переносимость текста программы с одной платформы на другую (пример, использование типа size_t)
+ [x] директива typedef удобна при замене длинных названий типов на более короткие имена

### Подвиг 7. Выберите все верные варианты использования директивы typedef.

+ [ ] typedef double(*)(int, int) PTR_FUNC;
+ [x] typedef double (*PTR_FUNC)(int, int);
+ [x] typedef enum {type_int, type_double, type_long} TYPES;
+ [x] typedef char* P_STR;
+ [ ] typedef TYPES enum {type_int, type_double, type_long};
+ [ ] typedef int long;
+ [x] typedef unsigned long ULONG;
+ [x] typedef enum menu_item {item_exit, item_c} MENU;
+ [ ] typedef char[100] STR;

### Подвиг 8. Напишите программу, в которой объявляется перечисление без идентификатора и константами:

```
_do=1, _re=2, _mi=3, _fa=4, _sol=5, _la=6, _si=7
```

Определите тип этого перечисления как `NOTES`. Объявите функцию с именем `get_major`, которая имеет один параметр с типом `NOTES`. Функция должна возвращать `1`, если были переданы значения констант: `_do`, или `_mi`, или `_sol`. В противном случае функция `get_major` возвращает `0`.

В функции `main` прочитайте из входного потока пять целых чисел в диапазоне `[1; 7]`, записанных в одну строчку через пробел. Выведите в консоль (в одну строчку через пробел) только те числа, для которых функция `get_major` вернула истинное значение (единицу).

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/7.5.8