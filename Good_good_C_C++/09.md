# 9  Движемся от Си к C++

# 9.1 C++. Начало

На заря 80-х годов, когда язык С достиг своего могущества и покрыл собой немалую часть программистского сообщества, из недр неуёмного сознания Бьёрна Струструппа явилось то, что в последствии стали кратко называть С++. Время разделилось на до и после. Непримиримые сторонники языка С напрочь отвергли зарождающееся явление С++, сохранив верность базовым принципам языка С.

Но историю было уже не остановить. И в 1983 году IT-мир содрогнулся. Язык C++ был официально признан новым языком программирования. 

Привычный порядок пришел в движение.
+ В C++ появились классы и объектно ориентированное программирование.
+ Структуры объединения стали специальными видами тех же классов. 
+ Появился механизм исключений.
+ Стала возможна перегрузка функций объявлений с аргументами по умолчанию.
+ Формированию inline и lambda функций.
+ Возникло то, что стало называться шаблонами и обобщенным программированием. Но и это еще не все.
+ В C++ появилось пространство имен,
+ новый способ объявления переменных через ссылки и вычисляемый тип,
+ возник самостоятельный булевый тип с двумя возможными стоянием `true` и `false`,
+ появились новые типы для символьных переменных,
+ новый вид цикла `for` для перебора последовательностей.
+ новый способ работы с потоком ввода вывода через объекты `cin`/`cout`
+  в обиход вошли такие операторы как `new` и `delete`. 

![09](/Good_good_C_C++/img/09_01.PNG)

И это лишь то не малое, что принес с собой C++. 

Потребовалось несколько лет кропотливой и напряженной работы, чтобы упорядочить все эти знания и лишь в 1998 году прийти к ратификации первого стандарта языка C++ под кодовым названием ISO-IC 14882.1998. 

С этого момента язык C++ было уже не остановить. 

Совсем скоро C++ поглотил стандартную библиотеку STL. Стали появляться все новые и новые стандарты — C++11, C++14, C++17, C++20. 

В ряды этого языка вступало все больше и больше программистов со всех уголков мира. На нем стали писать огромное количество проектов. Он проник везде где требовалась высокая скорость обработки данных, и в итоге стал конкурентом самому C. 

Оба языка C и C++ продолжили эволюционировать уже независимо друг от друга, как непримиримые враги.

И то, что ранее воспринималось как развитие, теперь по сути превратилось во два разных языка. 

Программа, написанная на современном C, почти наверняка не скомпилируется под C++. И наоборот.

Но несмотря на десятилетие эволюции, в ДНК языка C++ четко видны гены его предшественника. 

Эти следы C++ будет нести до конца своих дней, наследуя многие недостатки языка C. 

Но главное, внедрение в C++ многих популярных идей техник программирования превратили его в настоящего монстра. 

Сторонники языка считают это преимуществом. По их мнению, благодаря богатому функционалу можно реализовывать проекты самыми разными способами. 

И программист фактически ограничен только своими способностями. 

Противники же утверждают, что это часто приводит лишь к усложнению кода, сложности его понимания и дальнейшей модификации, особенно сторонними программистами. 

Мало того, в C++ гораздо больше подводных камней, нежели в языке C. Например, корпорация Google запретила своим разработчикам на C++ использовать механизмы исключения, потому что он часто приводит к заметному замедлению скорости работы программ. 

А это именно то, ради чего вообще стоит рассматривать язык C++ в качестве инструмента. 

Некоторые откровенно считают, что C++ ни при каких обстоятельствах не стоит применять при разработке больших проектов. Здесь можно привести известную цитату Линуса Торвальда. "Си плюс плюс – кошмарный язык». Его делает еще более кошмаром тот факт, множество недостаточных грамотных программистов используют его. Откровенно говоря, даже если нет никаких причин для выбора C, кроме того, чтобы держать программистов C++ подальше, то одного этого же будет достаточно веским основанием для использования C." 

Тем не менее, практика программирования показала, что грамотное применение языка C++ без фанатизма и неоправданного усложнения текста программы позволяет со всеми вытекающими плюсами и преимуществами перед языком C. 

Не зря C++ завоевал такую большую популярность, на которую способен далеко не каждый язык программирования. И главное, он остается востребованным и по сей день, несмотря на свою долголетнюю историю. 

Как вы уже догадались, в этом дополнение к курсу языка C мы не будем пускаться во все тяжкие, а рассмотрим лишь основные, базовые и часто применяемые возможности языка C++.

Мало того, я даже не буду опираться на какой-то определенный стандарт, ограничусь лишь стандартом не выше C++14. Все что нам будет нужно есть в нем. Итак, поехали.

Видео по теме [С++. Начало](https://www.youtube.com/watch?v=QYZbN2g-Dxc&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

# 9.2 Первая программа на С++

Первым делом нам нужно настроить среду программирования с компилятором языка С++. Для учебных целей вполне подойдет Visual Studio Code с ранее установленным компилятором `gcc`. Для проверки работоспособности компилятора достаточно открыть командное окно и ввести команду:

```
g++ --version
```

Если отобразится версия, значит, все настроено и готово к работе. Иначе, необходимо установить компилятор. О том, как это делается, рассказывается на одном из первых занятий по языку Си.

После этого я создам каталог:

```
D:\Projects\vscode\course_cpp
```

в котором будут размещаться файлы с программой на С++ и соответствующие исполняемые файлы. У вас может быть любой другой маршрут расположения файлов. Старайтесь только в названиях не использовать кириллицу и символы пробела.

Перейдем в программу Visual Studio Code и откроем созданную папку. Нажмем «New File...» и создадим текстовый файл с именем:

```
course.cpp
```

Обратите внимание на расширение файла – cpp. Модули с текстами программ на языке С++ принято сохранять с таким расширением.

Далее, запишем первую программу на С++. Она будет следующей:

```cpp
// Первая программа на языке С++
#include <iostream>
 
int main() {
    std::cout << "Hello World!" << std::endl;
    
    return 0;
}
```

Позже я поясню, что означают все эти строчки, а вначале давайте попробуем ее скомпилировать и запустить. 

Для этого я из папки с программой на чистом Си скопирую каталог .vscode с настроечными JSON-файлами. 

И открою в VS Code файл settings.json. В этом файле прописаны связи между расширениями файлов и соответствующими запусками компиляторов. В частности, для расширения cpp используется компилятор g++. В целом, меня здесь все устраивает, дополнительно только пропишу версию стандарта этого компилятора С++14 следующим образом:

```
cd $dir && g++ -std=c++14 $fileName -o $fileNameWithoutExt && $dir$fileNameWithoutExt
```

Попробуем теперь откомпилировать и запустить программу (Ctrl + Alt + n). Видим на экране сообщение «Hello World!».

И сделаем еще одну настройку автоматической прокрутки скроллинга вкладки OUTPUT среды VS Code. Для этого перейдем в настройки (File -> Preferences -> Settings). Здесь выберем Features -> Output и уберем галочку у «Smart Scroll».

Давайте, теперь вернемся к самой программе и разберемся, из чего она состоит. В первой строчке записан однострочный комментарий (появился в языке С++) и все, что идет после символов `//` до конца строки помечается, как комментарий. 

Причем, однострочное комментирование не обязательно начинать с начала строки, его можно указать в любом месте, например, после объявления заголовка функции `main`:

```cpp
int main()  // точка входа в программу
```

Для одной строки такие комментарии прописывать гораздо удобнее, чем `/* */`, которые изначально были определены в языке Си. В С++ можно применять оба вида.

Следующая строчка – это уже знакомая вам директива `#include` для включения файла `iostream` в текущем модуле. 

В данном случае это необходимо для использования объекта `cout`, с помощью которого удобно выводить данные в стандартный выходной поток `stdout`. 

Ранее, в языке Си, мы для этой цели часто использовали функцию `printf()`. В языке С++ этот процесс несколько упрощен благодаря объекту `cout`. Что это за объект и как он в деталях работает, речь еще впереди.

Далее, идет стандартная функция `main()`, которая определяет точку входа в программу, то есть, в языке С++ (также, как и в языке Си) программа начинает выполняться с автоматического вызова функции `main()` и завершается, при ее завершении.

Следующая конструкция:

```c
std::cout << "Hello World!" << std::endl;
```
отвечает за вывод информации в стандартный выходной поток. Здесь в глаза бросается фрагмент `std::…`. 
Ключевое слово `std` – это предопределенное название пространства имен, так называемой, стандартной библиотеки языка С++. 

Как я отмечал во вступлении, в язык С++ на уровне стандарта включили библиотеку `STL`, которая заметно упрощает работу со сложными коллекциями и типами данных, таких как:
+ строки `(std::string)`;
+ массивы `(std::array)`;
+ динамический массив `(std::vector)`;
+ двухсвязный список `(std::list)`;
+ очередь `(std::deque)`;
+ упорядоченные множества `(std::set)`;
+ упорядоченные ассоциативные массивы `(std::map)`

и многое другое. 

Так вот, чтобы обратиться к тому или иному определению в пространстве стандартной библиотеки, следует прописать название этого пространства `std` и через два двоеточия (четвероточие) указать нужный элемент. 

В частности, `cout` – это объект класса `ostream`, который отвечает за вывод информации в стандартный выходной поток. Затем, используя переопределенную операцию `<<`, указываются выводимые данные. 

В конце, после вывода строки «Hello World!» прописан `endl`. Он передает символ переноса строки и очищает буфер потока, к которому применен.

Вас может удивить, что для понимания работы такой простой программы на С++ нужно знать и о пространстве имен, и об объектах классов, и, по-хорошему, о самих классах. 

Это, действительно, так. 

Конечно, на начальном этапе подобные моменты можно просто запомнить и применять без глубокого понимания их работы. 

Часто так и делается. 

В конце концов, язык С++ (равно, как и Си) был придуман не для обучения программированию, а чтобы дать программистам эффективный и высокоуровневый инструмент разработки программ качественно транслирующихся в машинный код, то есть, выполняющихся с наибольшей скоростью. 

Поэтому, если вам не понятны слова «объект», «класс», «пространство имен» и прочее, то пока просто запоминайте приведенные конструкции по факту, а более глубокое понимание придет позже.

Итак, на этом занятии мы с вами сделали первый шаг в языке С++. Настроили интегрированную среду с компилятором g++ стандарта C++14, написали и выполнили первую простую программу. На следующем занятии уже непосредственно начнем изучать конструкции языка С++.

Видео по теме [#1. Первая программа на С++](https://www.youtube.com/watch?v=c7Nb0lJHVtU&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, касающиеся языка программирования C++.

+ [x] автором языка С++ является Бьерн Страуструп
+ [x] язык С++ появился как развитие языка Си
+ [x] концептуально язык С++ отличается от языка Си объектно-ориентированным подходом к программированию (ООП) и обобщенным программированием (шаблонами)
+ [x] язык С++ имеет гораздо больше возможностей, чем язык Си, но и накладывает на программиста больше ответственности при написании программ
+ [x] современная программа, написанная на языке Си, может не скомпилироваться под С++
+ [x] в С++ гораздо больше "подводных камней", нежели в языке Си

### Подвиг 2. Как в тексте программы на С++ оформляются комментарии?

+ [x] `//` (однострочный комментарий)
+ [ ] `\* *\` (многострочный комментарий)
+ [x] `/* */` (многострочный комментарий)
+ [ ] `\\` (однострочный комментарий)

### Подвиг 3. Какую роль играет функция main() в тексте программы на языке C++?

+ [x] если функция main() возвращает 0, значит, программа была выполнена успешно (без ошибок)
+ [ ] если функция main() возвращает не нулевое значение, значит, программа была выполнена успешно (без ошибок)
+ [x] как только функция main() завершает свою работу, завершается выполнение всей программы
+ [ ] функция main() служит для начальной инициализации переменных в программе (и только для этого)
+ [x] это функция, которая автоматически запускается при запуске исполняемого файла
+ [x] если функция main() отсутствует в тексте программы (проекта), то при компиляции возникает ошибка

### Подвиг 4 (на повторение). Какую роль играет текстовый препроцессор при компиляции программы на языке C/C++?

+ [x] обрабатывает директивы препроцессора в исходных файлах текстов программы
+ [ ] выполняет сборку объектных модулей программы в единый исполняемый файл
+ [ ] обрабатывает директивы препроцессора в полученных объектных файлах
+ [ ] добавляет специальные директивы в текст программы для оптимизации процесса компиляции

### Подвиг 5 (на повторение). Какую роль играет непосредственно компилятор при транслировании программы на языке C/C++ в машинный код?

+ [x] отдельные файлы с текстами программы преобразует в машинный код, формируя объектные файлы
+ [ ] объединяет все файлы с текстами программы текущего проекта в единую программу и переводит ее в машинный код
+ [ ] выполняет сборку объектных модулей программы в единый исполняемый файл
+ [ ] отдельные файлы с текстами программы преобразует в машинный код, формируя конечный исполняемый файл

### Подвиг 6 (на повторение). Какую роль играет линкер (редактор связей) при компиляции программы на языке C/C++?

+ [ ] соединяет между собой объектные файлы, формируя единую программу, без добавления какой-либо дополнительной информации
+ [ ] соединяет между собой объектные файлы, формируя единую программу, добавляет код запуска и коды всех библиотечных функций используемых в программе библиотек
+ [ ] объединяет все файлы с текстами программы текущего проекта в единую программу и переводит ее в машинный код
+ [x] соединяет между собой объектные файлы, формируя единую программу, добавляет код запуска и коды используемых библиотечных функций

### Подвиг 7. Напишите по аналогии (с рассмотренной на этом занятии) программу на C++ с выводом на экран строки "I love C++" по следующей схеме:

1. Подключите заголовок `iostream`
2. Запишите функцию `main()`, которая возвращает целочисленное значение типа `int`.
3. В теле функции main с помощью объекта `std::cout` выведите в консоль указанную строку с переводом на новую строку, используя функцию `std::endl`.
4. Пропишите оператор `return`, который возвращает целое число `0`.

P. S. Постарайтесь соблюдать оформление программы, приведенное на этом занятии.

```c
#include <iostream>

int main() {
    std::cout << "I love C++" << std::endl;

    return 0;
}
```

# 9.3 Ввод-вывод с помощью объектов cin и cout

Раз уж мы в первой программе на С++ использовали объект `cout` для вывода строки в стандартный выходной поток, то давайте сразу разберем работу двух таких объектов:
+ `cin` – объект класса `istream` для работы с потоком `stdin`;
+ `cout` – объект класса `ostream` для работы с потоком `stdout`.

Если вы не знакомы с концепцией классов и их объектов, то есть, с ООП языка С++, то фраза «объект класса» вас может поставить в тупик. Конечно, мы сейчас не будем пускаться во все тяжкие и уходить в изучение ООП. На данном этапе будет вполне достаточным воспринимать объекты `cin`/`cout`, как некие переменные, через которые можно работать со стандартными потоками ввода/вывода.

Я напомню, что в курсе по языку Си мы подробно с вами говорили об этих потоках, которые часто обозначаются через определения `stdin`/`stdout`. И я приводил следующую схему их работы:

![09](/Good_good_C_C++/img/09_02.jpg)

Так вот, в С++ вместо функций `printf()`, `scanf()` и им подобных предлагается использовать более дружественные объекты `cout` и `cin`. 

В чем их дружественность и отличия от уже знакомых нам функций ввода/вывода? 

Начнем с более простого объекта `cout`. Чтобы им воспользоваться, в программе на С++ вначале необходимо подключить файл `iostream`. После этого в пространстве имен `std` будет доступен объект `cout`. Затем, объявим в программе несколько переменных разных типов и выведем их в стандартный поток с помощью `cout`. Сделать это можно следующим образом:

```c
#include <iostream>
 
int main() {
    char str[100] = "Hi, Sergey!";
    short old = 99;
    double weight = 82.54;
 
    std::cout << str << "\n";
    std::cout << old << "\n";
    std::cout << weight << std::endl;
}
```

Первое, что бросается в глаза – это вывод значения переменной без дополнительного указания ее типа. Например, если бы мы эту же операцию захотели бы повторить с помощью функции `printf()`, то пришлось бы прописывать форматную строку со спецификаторами:

```c
printf("%s\n%d\n%.2f\n", str, old, weight);
```

При использовании объекта `cout` ничего этого делать не нужно. Просто прописываем переменную, значение которой хотим вывести в поток `stdout` и все.

Если кому интересно, как это все работает «под капотом», то скажу буквально пару слов. 

У каждого класса в С++ можно делать переопределение стандартных операций. В частности, операция `<<` для класса `ostream` переопределена для каждого стандартного, базового типа и компилятор в соответствии с типом переменной (или, в общем случае, по данным в правом операнде), выбирает соответствующую реализацию операции `<<`. Сама же операция `<<` выполняет передачу в выходной поток `stdout` соответствующих данных и возвращает объект `cout`. А раз так, то мы можем записать вывод трех переменных следующим образом:

```c
std::cout << str << '\n' << old << "\n" << weight << std::endl;
```
Получим абсолютно тот же самый результат.

Второе, на что следует обратить внимание – это использование управляющих символов `\n`. Сначала я его прописал, как символ, а второй раз – как строку. Для объекта `cout` это не имеет большого значения, но, конечно, если нам нужно вывести отдельный символ, то лучше это делать через одинарные кавычки.

В самом конце вывода прописана функция `endl`. Она выполняет два действия: переводит курсор на новую строку и очищает выходной буфер, указывая конечному устройству, связанному с выходным потоком, что все данные переданы и их можно обрабатывать. 

В случае с выводом на монитор очистка мало что дает, т.к. информация сразу отображается на экране. Но, вполне могут быть и другие ситуации, когда вместо монитора подключено другое устройство и вывод осуществляется только в момент очистки выходного буфера.

Следующий объект `cin` работает похожим образом, но осуществляет уже считывание информации из стандартного входного потока `stdin` и запись прочитанных данных в указанную переменную или, в общем случае, `lvalue` выражение.

Давайте, для примера выполним считывание данных в переменные `old` и `weight` с помощью `cin` следующим образом:

```c
#include <iostream>
 
int main() {
    char str[100] = "Hi, Sergey!";
    short old = 99;
    double weight = 82.54;
 
    std::cin >> old;
    std::cin >> weight;
    
    std::cout << str << '\n' << old << '\n' << weight << std::endl;
}
```

Обратите внимание, что для объекта `cin` переопределена операция `>>` также для каждого стандартного типа языка С++. 

Поэтому нам достаточно прописать переменную без указания ее типа. Причем после имени переменной не нужно прописывать операцию взятия адреса, как это мы делали в функции `scanf()`. В операции `>>` для этого применяется механизм ссылок. О них мы с вами еще будем подробнее говорить.

Если данные введены верно (целочисленное значение и вещественное), то переменные `old` и `weight` будут содержать корректные введенные значения. 

Причем ввести их можно каждый с новой строки или через пробел. Если во входном потоке `stdin` встречаются данные, не соответствующие типу переменной, то значение переменной обнуляется с неверной интерпретацией последующих операций считывания. Поэтому формат входных данных в `stdin` должен совпадать с типами читаемых данных.

Операция `>>` после чтения порции данных возвращает объект `cin`, поэтому два последовательных вызова `cin` можно объединить в один:

```c
std::cin >> old >> weight;
```

Результат будет тем же самым.

Последний важный момент, связанный с использованием объекта `cin`, это чтение строк из входного потока. Допустим, мы в переменную `str` читаем строковые данные следующим образом:

```c
std::cin >> str;
```

и вводим строку «hello world». В результате в массив `str` будет помещен только первый фрагмент до пробела, то есть, `«hello»`, а второй останется во входном потоке. 

То есть, `cin` со строками работает так же, как и функция `scanf()` языка Си. 

Если вам нужно читать строку целиком (до символа перевода строки или до конца данных), то следует использовать новую функцию `getline()` языка С++. Она работает с объектом `std::string` и речь о ней еще впереди.

Я думаю, вы теперь в целом хорошо понимаете, как использовать объекты `cout`/`cin` языка С++ для работы со стандартными потоками ввода/вывода.

Видео по теме [#2. Ввод-вывод с помощью объектов cin и cout](https://www.youtube.com/watch?v=mi1YqRF03IQ&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Установите соответствия между объектами, операциями и их описаниями.

![09](/Good_good_C_C++/img/09_03.PNG)

### Подвиг 2. Выберите все верные утверждения, касающиеся объектов cin и cout

+ [ ] для использования объектов cin и cout в программе необходимо подключить заголовок stdio.h
+ [x] объекты cin и cout автоматически определяют формат читаемых данных по типу переменных, с которыми они записаны
+ [x] cin - это объект класса istream для работы с потоком stdin
+ [x] для использования объектов cin и cout в программе необходимо подключить заголовок iostream
+ [x] объекты cin и cout располагаются в пространстве имен std
+ [ ] объекты cin и cout располагаются в пространстве имен iostream
+ [x] cout - это объект класса ostream для работы с потоком stdout

### Подвиг 3. Напишите программу, которая читает из входного потока stdin два целых числа, записанных в одну строчку через пробел, и выводит их в консоль в формате:

<первое число>; <второе число>

P. S. Ввод/вывод данных реализовать через объекты `cin`/`cout`.

```c
#include <iostream>

int main() {
    int a, b;
    std::cin >> a >> b;
    std::cout << a << "; " << b << std::endl;

    return 0;
}
```

### Подвиг 4. Напишите программу, которая читает из входного потока stdin два целых числа a и b (a < b), записанных в одну строчку через пробел, и выводит в консоль все числа диапазона [a; b], кратные 3 в порядке возрастания в одну строчку через пробел.

P. S. Ввод/вывод данных реализовать через объекты cin/cout.

```c
#include <iostream>

int main() {
    int a, b;
    std::cin >> a >> b;
    for (int i = a; i <= b; i++) {
        if (i % 3 == 0) std::cout << i << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

### Подвиг 5 (с повторением). Продолжите программу, которая читает в массив data целые числа из входного потока, записанные в одну строчку через пробел. Необходимо контролировать максимальное количество читаемых значений не более max_size_ar. Выведите в консоль в одну строчку через пробел записанные значения в массив data (по порядку от начала до конца).

P. S. Ввод/вывод данных реализовать через объекты cin/cout.

```c
#include <iostream>

using namespace std;

enum { max_size_ar = 20 };

int main() {
    int data[max_size_ar];
    size_t count = 0;
    while (count < max_size_ar && cin.good()) {
        cin >> data[count];
        count++;
    }

    cout << count << '\n';

    for (size_t i = 0; i < count - 1; i++) {
        cout << data[i] << ' ';
    }

    cout << std::endl;

    return 0;
}
```
### Подвиг 6 (с повторением). Продолжите программу, которая читает в массив data целые числа из входного потока, записанные в одну строчку через точку с запятой (или любой другой символьный не числовой разделитель). Необходимо контролировать максимальное количество читаемых значений не более max_size_ar. Выведите в консоль в одну строчку через пробел значения массива data (по порядку от начала до конца).

P. S. Ввод/вывод данных реализовать через объекты cin/cout.

Sample Input:

9; 11; 0; -9; 3; 100; 8; 7; 4
Sample Output:

9 11 0 -9 3 100 8 7 4

```c
#include <iostream>

using namespace std;

enum { max_size_ar = 20 };

int main() {
    int data[max_size_ar];
    size_t count = 0;
    char ch;
    while (count < max_size_ar && cin.good()) {
        cin >> data[count] >> ch;
        count++;
    }

    cout << count << '\n';

    for (size_t i = 0; i < count; i++) {
        cout << data[i] << ' ';
    }

    cout << std::endl;

    return 0;
}
```

### Подвиг 7 (с повторением). Напишите программу. Объявите структуру с именем типа THING и следующими полями:

+ id; идентификатор; тип unsigned int;
+ name; название (строка); максимальная длина max_size_name = 50 (константа max_size_name задается в перечислении);
+ weight; вес; тип double;
+ price; цена; тип unsigned int.

В функции main объявите переменную с именем box типа THING. С помощью объекта cin выполните чтение из входного потока данных, записанных в следующем формате:

<идентификатор> <название> <вес> <цена>

Выведите с помощью объекта cout в консоль структуру box в формате:

<название> <идентификатор>: <вес>, <цена>

```c
#include <iostream>

enum { max_size_name = 50 };
using namespace std;

typedef struct {
    unsigned id;
    char name[max_size_name];
    double weight;
    unsigned price;
} THING;

int main() {
    THING box;

    cin >> box.id >> box.name >> box.weight >> box.price;

    cout << box.name << ' ' << box.id << ": " << box.weight << ", " << box.price << endl;

    return 0;
}
```

### Подвиг 8 (с повторением). Объявите функцию со следующей сигнатурой:

double triangle_sq(int a, int b, int c);
которая вычисляет и возвращает площадь треугольника со сторонами a, b, c. Площадь вычисляется по формуле Герона:

$S = \sqrt{p⋅(p−a)⋅(p−b)⋅(p−c)}$
​
где $p=(a+b+c)/2$ - полупериметр треугольника.

В функции main прочитайте из входного потока три целых натуральных числа, записанных в одну строчку через пробел. Вызовите для них функцию triangle_sq и выведите в консоль значение площади с точностью до сотых.

P. S. Чтение данных из потока stdin выполнить с помощью объекта cin.

Sample Input:

10 12 5
Sample Output:

24.54

```c
#include <cmath>
#include <iostream>

using namespace std;

double triangle_sq(int a, int b, int c) {
    double p = (a + b + c) / 2.0, res;
    res = powf(p * (p - a) * (p - b) * (p - c), 0.5);
    return res;
}

int main() {
    int a, b, c;

    cin >> a >> b >> c;

    double res = triangle_sq(a, b, c);

    printf("%.2lf", res);

    return 0;
}
```

манипуляторы

```c

#include <iostream>
#include <iomanip> // fixed и setprecision
#include <cmath> // sqrt

double triangle_sq(int a, int b, int c);

int main() {
    
    int a, b, c;
    std::cin >> a >> b >> c;
    std::cout << std::fixed << std::setprecision(2) << triangle_sq(a, b, c);
        
    return 0;
}

double triangle_sq(int a, int b, int c) {
    
    double s;
    s = (a + b + c) / 2.0; // полупериметр 
    
    return sqrt(s * (s - a) * (s - b) * (s - c));;
}
```

### Подвиг 9 (на повторение). Выберите все верные утверждения, касающиеся вариадических функций.

+ [x] для обработки вариадических параметров функции необходимо подключение заголовка stdarg.h
+ [ ] вариадическая функция может быть прописана только с вариадическими параметрами
+ [ ] вариадическая функция "знает" о количестве вариадических параметров
+ [x] вариадическая функция должна иметь хотя бы один явно прописанный параметр
+ [x] вариадические параметры всегда располагаются последними в списке параметров функции
+ [x] вариадическая функция "не знает" о настоящем количестве вариадических параметров

### Подвиг 10 (на повторение). Установите соответствия между определениями и функциями и их описаниями.

![09](/Good_good_C_C++/img/09_04.PNG)

### Подвиг 11 (на повторение). Выберите все верные записи вещественных числовых литералов.

P. S. Здесь d - вещественная переменная типа double.

+ [x] d = 3.2e5;
+ [ ] d = e-2;
+ [x] d = -.5;
+ [ ] d = e2;
+ [x] d = 1e-2;
+ [x] d = -1e2;
+ [x] d = 32e-5;
+ [x] d = 123.;

# 9.4 Пространства имен (namespace)