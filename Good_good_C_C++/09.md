# 9  Движемся от Си к C++

# 9.1 C++. Начало

На заря 80-х годов, когда язык С достиг своего могущества и покрыл собой немалую часть программистского сообщества, из недр неуёмного сознания Бьёрна Струструппа явилось то, что в последствии стали кратко называть С++. Время разделилось на до и после. Непримиримые сторонники языка С напрочь отвергли зарождающееся явление С++, сохранив верность базовым принципам языка С.

Но историю было уже не остановить. И в 1983 году IT-мир содрогнулся. Язык C++ был официально признан новым языком программирования. 

Привычный порядок пришел в движение.
+ В C++ появились классы и объектно ориентированное программирование.
+ Структуры объединения стали специальными видами тех же классов. 
+ Появился механизм исключений.
+ Стала возможна перегрузка функций объявлений с аргументами по умолчанию.
+ Формированию inline и lambda функций.
+ Возникло то, что стало называться шаблонами и обобщенным программированием. Но и это еще не все.
+ В C++ появилось пространство имен,
+ новый способ объявления переменных через ссылки и вычисляемый тип,
+ возник самостоятельный булевый тип с двумя возможными стоянием `true` и `false`,
+ появились новые типы для символьных переменных,
+ новый вид цикла `for` для перебора последовательностей.
+ новый способ работы с потоком ввода вывода через объекты `cin`/`cout`
+  в обиход вошли такие операторы как `new` и `delete`. 

![09](/Good_good_C_C++/img/09_01.PNG)

И это лишь то не малое, что принес с собой C++. 

Потребовалось несколько лет кропотливой и напряженной работы, чтобы упорядочить все эти знания и лишь в 1998 году прийти к ратификации первого стандарта языка C++ под кодовым названием ISO-IC 14882.1998. 

С этого момента язык C++ было уже не остановить. 

Совсем скоро C++ поглотил стандартную библиотеку STL. Стали появляться все новые и новые стандарты — C++11, C++14, C++17, C++20. 

В ряды этого языка вступало все больше и больше программистов со всех уголков мира. На нем стали писать огромное количество проектов. Он проник везде где требовалась высокая скорость обработки данных, и в итоге стал конкурентом самому C. 

Оба языка C и C++ продолжили эволюционировать уже независимо друг от друга, как непримиримые враги.

И то, что ранее воспринималось как развитие, теперь по сути превратилось во два разных языка. 

Программа, написанная на современном C, почти наверняка не скомпилируется под C++. И наоборот.

Но несмотря на десятилетие эволюции, в ДНК языка C++ четко видны гены его предшественника. 

Эти следы C++ будет нести до конца своих дней, наследуя многие недостатки языка C. 

Но главное, внедрение в C++ многих популярных идей техник программирования превратили его в настоящего монстра. 

Сторонники языка считают это преимуществом. По их мнению, благодаря богатому функционалу можно реализовывать проекты самыми разными способами. 

И программист фактически ограничен только своими способностями. 

Противники же утверждают, что это часто приводит лишь к усложнению кода, сложности его понимания и дальнейшей модификации, особенно сторонними программистами. 

Мало того, в C++ гораздо больше подводных камней, нежели в языке C. Например, корпорация Google запретила своим разработчикам на C++ использовать механизмы исключения, потому что он часто приводит к заметному замедлению скорости работы программ. 

А это именно то, ради чего вообще стоит рассматривать язык C++ в качестве инструмента. 

Некоторые откровенно считают, что C++ ни при каких обстоятельствах не стоит применять при разработке больших проектов. Здесь можно привести известную цитату Линуса Торвальда. "Си плюс плюс – кошмарный язык». Его делает еще более кошмаром тот факт, множество недостаточных грамотных программистов используют его. Откровенно говоря, даже если нет никаких причин для выбора C, кроме того, чтобы держать программистов C++ подальше, то одного этого же будет достаточно веским основанием для использования C." 

Тем не менее, практика программирования показала, что грамотное применение языка C++ без фанатизма и неоправданного усложнения текста программы позволяет со всеми вытекающими плюсами и преимуществами перед языком C. 

Не зря C++ завоевал такую большую популярность, на которую способен далеко не каждый язык программирования. И главное, он остается востребованным и по сей день, несмотря на свою долголетнюю историю. 

Как вы уже догадались, в этом дополнение к курсу языка C мы не будем пускаться во все тяжкие, а рассмотрим лишь основные, базовые и часто применяемые возможности языка C++.

Мало того, я даже не буду опираться на какой-то определенный стандарт, ограничусь лишь стандартом не выше C++14. Все что нам будет нужно есть в нем. Итак, поехали.

Видео по теме [С++. Начало](https://www.youtube.com/watch?v=QYZbN2g-Dxc&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

# 9.2 Первая программа на С++

Первым делом нам нужно настроить среду программирования с компилятором языка С++. Для учебных целей вполне подойдет Visual Studio Code с ранее установленным компилятором `gcc`. Для проверки работоспособности компилятора достаточно открыть командное окно и ввести команду:

```
g++ --version
```

Если отобразится версия, значит, все настроено и готово к работе. Иначе, необходимо установить компилятор. О том, как это делается, рассказывается на одном из первых занятий по языку Си.

После этого я создам каталог:

```
D:\Projects\vscode\course_cpp
```

в котором будут размещаться файлы с программой на С++ и соответствующие исполняемые файлы. У вас может быть любой другой маршрут расположения файлов. Старайтесь только в названиях не использовать кириллицу и символы пробела.

Перейдем в программу Visual Studio Code и откроем созданную папку. Нажмем «New File...» и создадим текстовый файл с именем:

```
course.cpp
```

Обратите внимание на расширение файла – cpp. Модули с текстами программ на языке С++ принято сохранять с таким расширением.

Далее, запишем первую программу на С++. Она будет следующей:

```cpp
// Первая программа на языке С++
#include <iostream>
 
int main() {
    std::cout << "Hello World!" << std::endl;
    
    return 0;
}
```

Позже я поясню, что означают все эти строчки, а вначале давайте попробуем ее скомпилировать и запустить. 

Для этого я из папки с программой на чистом Си скопирую каталог .vscode с настроечными JSON-файлами. 

И открою в VS Code файл settings.json. В этом файле прописаны связи между расширениями файлов и соответствующими запусками компиляторов. В частности, для расширения cpp используется компилятор g++. В целом, меня здесь все устраивает, дополнительно только пропишу версию стандарта этого компилятора С++14 следующим образом:

```
cd $dir && g++ -std=c++14 $fileName -o $fileNameWithoutExt && $dir$fileNameWithoutExt
```

Попробуем теперь откомпилировать и запустить программу (Ctrl + Alt + n). Видим на экране сообщение «Hello World!».

И сделаем еще одну настройку автоматической прокрутки скроллинга вкладки OUTPUT среды VS Code. Для этого перейдем в настройки (File -> Preferences -> Settings). Здесь выберем Features -> Output и уберем галочку у «Smart Scroll».

Давайте, теперь вернемся к самой программе и разберемся, из чего она состоит. В первой строчке записан однострочный комментарий (появился в языке С++) и все, что идет после символов `//` до конца строки помечается, как комментарий. 

Причем, однострочное комментирование не обязательно начинать с начала строки, его можно указать в любом месте, например, после объявления заголовка функции `main`:

```cpp
int main()  // точка входа в программу
```

Для одной строки такие комментарии прописывать гораздо удобнее, чем `/* */`, которые изначально были определены в языке Си. В С++ можно применять оба вида.

Следующая строчка – это уже знакомая вам директива `#include` для включения файла `iostream` в текущем модуле. 

В данном случае это необходимо для использования объекта `cout`, с помощью которого удобно выводить данные в стандартный выходной поток `stdout`. 

Ранее, в языке Си, мы для этой цели часто использовали функцию `printf()`. В языке С++ этот процесс несколько упрощен благодаря объекту `cout`. Что это за объект и как он в деталях работает, речь еще впереди.

Далее, идет стандартная функция `main()`, которая определяет точку входа в программу, то есть, в языке С++ (также, как и в языке Си) программа начинает выполняться с автоматического вызова функции `main()` и завершается, при ее завершении.

Следующая конструкция:

```c
std::cout << "Hello World!" << std::endl;
```
отвечает за вывод информации в стандартный выходной поток. Здесь в глаза бросается фрагмент `std::…`. 
Ключевое слово `std` – это предопределенное название пространства имен, так называемой, стандартной библиотеки языка С++. 

Как я отмечал во вступлении, в язык С++ на уровне стандарта включили библиотеку `STL`, которая заметно упрощает работу со сложными коллекциями и типами данных, таких как:
+ строки `(std::string)`;
+ массивы `(std::array)`;
+ динамический массив `(std::vector)`;
+ двухсвязный список `(std::list)`;
+ очередь `(std::deque)`;
+ упорядоченные множества `(std::set)`;
+ упорядоченные ассоциативные массивы `(std::map)`

и многое другое. 

Так вот, чтобы обратиться к тому или иному определению в пространстве стандартной библиотеки, следует прописать название этого пространства `std` и через два двоеточия (четвероточие) указать нужный элемент. 

В частности, `cout` – это объект класса `ostream`, который отвечает за вывод информации в стандартный выходной поток. Затем, используя переопределенную операцию `<<`, указываются выводимые данные. 

В конце, после вывода строки «Hello World!» прописан `endl`. Он передает символ переноса строки и очищает буфер потока, к которому применен.

Вас может удивить, что для понимания работы такой простой программы на С++ нужно знать и о пространстве имен, и об объектах классов, и, по-хорошему, о самих классах. 

Это, действительно, так. 

Конечно, на начальном этапе подобные моменты можно просто запомнить и применять без глубокого понимания их работы. 

Часто так и делается. 

В конце концов, язык С++ (равно, как и Си) был придуман не для обучения программированию, а чтобы дать программистам эффективный и высокоуровневый инструмент разработки программ качественно транслирующихся в машинный код, то есть, выполняющихся с наибольшей скоростью. 

Поэтому, если вам не понятны слова «объект», «класс», «пространство имен» и прочее, то пока просто запоминайте приведенные конструкции по факту, а более глубокое понимание придет позже.

Итак, на этом занятии мы с вами сделали первый шаг в языке С++. Настроили интегрированную среду с компилятором g++ стандарта C++14, написали и выполнили первую простую программу. На следующем занятии уже непосредственно начнем изучать конструкции языка С++.

Видео по теме [#1. Первая программа на С++](https://www.youtube.com/watch?v=c7Nb0lJHVtU&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, касающиеся языка программирования C++.

+ [x] автором языка С++ является Бьерн Страуструп
+ [x] язык С++ появился как развитие языка Си
+ [x] концептуально язык С++ отличается от языка Си объектно-ориентированным подходом к программированию (ООП) и обобщенным программированием (шаблонами)
+ [x] язык С++ имеет гораздо больше возможностей, чем язык Си, но и накладывает на программиста больше ответственности при написании программ
+ [x] современная программа, написанная на языке Си, может не скомпилироваться под С++
+ [x] в С++ гораздо больше "подводных камней", нежели в языке Си

### Подвиг 2. Как в тексте программы на С++ оформляются комментарии?

+ [x] `//` (однострочный комментарий)
+ [ ] `\* *\` (многострочный комментарий)
+ [x] `/* */` (многострочный комментарий)
+ [ ] `\\` (однострочный комментарий)

### Подвиг 3. Какую роль играет функция main() в тексте программы на языке C++?

+ [x] если функция main() возвращает 0, значит, программа была выполнена успешно (без ошибок)
+ [ ] если функция main() возвращает не нулевое значение, значит, программа была выполнена успешно (без ошибок)
+ [x] как только функция main() завершает свою работу, завершается выполнение всей программы
+ [ ] функция main() служит для начальной инициализации переменных в программе (и только для этого)
+ [x] это функция, которая автоматически запускается при запуске исполняемого файла
+ [x] если функция main() отсутствует в тексте программы (проекта), то при компиляции возникает ошибка

### Подвиг 4 (на повторение). Какую роль играет текстовый препроцессор при компиляции программы на языке C/C++?

+ [x] обрабатывает директивы препроцессора в исходных файлах текстов программы
+ [ ] выполняет сборку объектных модулей программы в единый исполняемый файл
+ [ ] обрабатывает директивы препроцессора в полученных объектных файлах
+ [ ] добавляет специальные директивы в текст программы для оптимизации процесса компиляции

### Подвиг 5 (на повторение). Какую роль играет непосредственно компилятор при транслировании программы на языке C/C++ в машинный код?

+ [x] отдельные файлы с текстами программы преобразует в машинный код, формируя объектные файлы
+ [ ] объединяет все файлы с текстами программы текущего проекта в единую программу и переводит ее в машинный код
+ [ ] выполняет сборку объектных модулей программы в единый исполняемый файл
+ [ ] отдельные файлы с текстами программы преобразует в машинный код, формируя конечный исполняемый файл

### Подвиг 6 (на повторение). Какую роль играет линкер (редактор связей) при компиляции программы на языке C/C++?

+ [ ] соединяет между собой объектные файлы, формируя единую программу, без добавления какой-либо дополнительной информации
+ [ ] соединяет между собой объектные файлы, формируя единую программу, добавляет код запуска и коды всех библиотечных функций используемых в программе библиотек
+ [ ] объединяет все файлы с текстами программы текущего проекта в единую программу и переводит ее в машинный код
+ [x] соединяет между собой объектные файлы, формируя единую программу, добавляет код запуска и коды используемых библиотечных функций

### Подвиг 7. Напишите по аналогии (с рассмотренной на этом занятии) программу на C++ с выводом на экран строки "I love C++" по следующей схеме:

1. Подключите заголовок `iostream`
2. Запишите функцию `main()`, которая возвращает целочисленное значение типа `int`.
3. В теле функции main с помощью объекта `std::cout` выведите в консоль указанную строку с переводом на новую строку, используя функцию `std::endl`.
4. Пропишите оператор `return`, который возвращает целое число `0`.

P. S. Постарайтесь соблюдать оформление программы, приведенное на этом занятии.

```c
#include <iostream>

int main() {
    std::cout << "I love C++" << std::endl;

    return 0;
}
```

# 9.3 Ввод-вывод с помощью объектов cin и cout

Раз уж мы в первой программе на С++ использовали объект `cout` для вывода строки в стандартный выходной поток, то давайте сразу разберем работу двух таких объектов:
+ `cin` – объект класса `istream` для работы с потоком `stdin`;
+ `cout` – объект класса `ostream` для работы с потоком `stdout`.

Если вы не знакомы с концепцией классов и их объектов, то есть, с ООП языка С++, то фраза «объект класса» вас может поставить в тупик. Конечно, мы сейчас не будем пускаться во все тяжкие и уходить в изучение ООП. На данном этапе будет вполне достаточным воспринимать объекты `cin`/`cout`, как некие переменные, через которые можно работать со стандартными потоками ввода/вывода.

Я напомню, что в курсе по языку Си мы подробно с вами говорили об этих потоках, которые часто обозначаются через определения `stdin`/`stdout`. И я приводил следующую схему их работы:

![09](/Good_good_C_C++/img/09_02.jpg)

Так вот, в С++ вместо функций `printf()`, `scanf()` и им подобных предлагается использовать более дружественные объекты `cout` и `cin`. 

В чем их дружественность и отличия от уже знакомых нам функций ввода/вывода? 

Начнем с более простого объекта `cout`. Чтобы им воспользоваться, в программе на С++ вначале необходимо подключить файл `iostream`. После этого в пространстве имен `std` будет доступен объект `cout`. Затем, объявим в программе несколько переменных разных типов и выведем их в стандартный поток с помощью `cout`. Сделать это можно следующим образом:

```c
#include <iostream>
 
int main() {
    char str[100] = "Hi, Sergey!";
    short old = 99;
    double weight = 82.54;
 
    std::cout << str << "\n";
    std::cout << old << "\n";
    std::cout << weight << std::endl;
}
```

Первое, что бросается в глаза – это вывод значения переменной без дополнительного указания ее типа. Например, если бы мы эту же операцию захотели бы повторить с помощью функции `printf()`, то пришлось бы прописывать форматную строку со спецификаторами:

```c
printf("%s\n%d\n%.2f\n", str, old, weight);
```

При использовании объекта `cout` ничего этого делать не нужно. Просто прописываем переменную, значение которой хотим вывести в поток `stdout` и все.

Если кому интересно, как это все работает «под капотом», то скажу буквально пару слов. 

У каждого класса в С++ можно делать переопределение стандартных операций. В частности, операция `<<` для класса `ostream` переопределена для каждого стандартного, базового типа и компилятор в соответствии с типом переменной (или, в общем случае, по данным в правом операнде), выбирает соответствующую реализацию операции `<<`. Сама же операция `<<` выполняет передачу в выходной поток `stdout` соответствующих данных и возвращает объект `cout`. А раз так, то мы можем записать вывод трех переменных следующим образом:

```c
std::cout << str << '\n' << old << "\n" << weight << std::endl;
```
Получим абсолютно тот же самый результат.

Второе, на что следует обратить внимание – это использование управляющих символов `\n`. Сначала я его прописал, как символ, а второй раз – как строку. Для объекта `cout` это не имеет большого значения, но, конечно, если нам нужно вывести отдельный символ, то лучше это делать через одинарные кавычки.

В самом конце вывода прописана функция `endl`. Она выполняет два действия: переводит курсор на новую строку и очищает выходной буфер, указывая конечному устройству, связанному с выходным потоком, что все данные переданы и их можно обрабатывать. 

В случае с выводом на монитор очистка мало что дает, т.к. информация сразу отображается на экране. Но, вполне могут быть и другие ситуации, когда вместо монитора подключено другое устройство и вывод осуществляется только в момент очистки выходного буфера.

Следующий объект `cin` работает похожим образом, но осуществляет уже считывание информации из стандартного входного потока `stdin` и запись прочитанных данных в указанную переменную или, в общем случае, `lvalue` выражение.

Давайте, для примера выполним считывание данных в переменные `old` и `weight` с помощью `cin` следующим образом:

```c
#include <iostream>
 
int main() {
    char str[100] = "Hi, Sergey!";
    short old = 99;
    double weight = 82.54;
 
    std::cin >> old;
    std::cin >> weight;
    
    std::cout << str << '\n' << old << '\n' << weight << std::endl;
}
```

Обратите внимание, что для объекта `cin` переопределена операция `>>` также для каждого стандартного типа языка С++. 

Поэтому нам достаточно прописать переменную без указания ее типа. Причем после имени переменной не нужно прописывать операцию взятия адреса, как это мы делали в функции `scanf()`. В операции `>>` для этого применяется механизм ссылок. О них мы с вами еще будем подробнее говорить.

Если данные введены верно (целочисленное значение и вещественное), то переменные `old` и `weight` будут содержать корректные введенные значения. 

Причем ввести их можно каждый с новой строки или через пробел. Если во входном потоке `stdin` встречаются данные, не соответствующие типу переменной, то значение переменной обнуляется с неверной интерпретацией последующих операций считывания. Поэтому формат входных данных в `stdin` должен совпадать с типами читаемых данных.

Операция `>>` после чтения порции данных возвращает объект `cin`, поэтому два последовательных вызова `cin` можно объединить в один:

```c
std::cin >> old >> weight;
```

Результат будет тем же самым.

Последний важный момент, связанный с использованием объекта `cin`, это чтение строк из входного потока. Допустим, мы в переменную `str` читаем строковые данные следующим образом:

```c
std::cin >> str;
```

и вводим строку «hello world». В результате в массив `str` будет помещен только первый фрагмент до пробела, то есть, `«hello»`, а второй останется во входном потоке. 

То есть, `cin` со строками работает так же, как и функция `scanf()` языка Си. 

Если вам нужно читать строку целиком (до символа перевода строки или до конца данных), то следует использовать новую функцию `getline()` языка С++. Она работает с объектом `std::string` и речь о ней еще впереди.

Я думаю, вы теперь в целом хорошо понимаете, как использовать объекты `cout`/`cin` языка С++ для работы со стандартными потоками ввода/вывода.

Видео по теме [#2. Ввод-вывод с помощью объектов cin и cout](https://www.youtube.com/watch?v=mi1YqRF03IQ&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Установите соответствия между объектами, операциями и их описаниями.

![09](/Good_good_C_C++/img/09_03.PNG)

### Подвиг 2. Выберите все верные утверждения, касающиеся объектов cin и cout

+ [ ] для использования объектов cin и cout в программе необходимо подключить заголовок stdio.h
+ [x] объекты cin и cout автоматически определяют формат читаемых данных по типу переменных, с которыми они записаны
+ [x] cin - это объект класса istream для работы с потоком stdin
+ [x] для использования объектов cin и cout в программе необходимо подключить заголовок iostream
+ [x] объекты cin и cout располагаются в пространстве имен std
+ [ ] объекты cin и cout располагаются в пространстве имен iostream
+ [x] cout - это объект класса ostream для работы с потоком stdout

### Подвиг 3. Напишите программу, которая читает из входного потока stdin два целых числа, записанных в одну строчку через пробел, и выводит их в консоль в формате:

<первое число>; <второе число>

P. S. Ввод/вывод данных реализовать через объекты `cin`/`cout`.

```c
#include <iostream>

int main() {
    int a, b;
    std::cin >> a >> b;
    std::cout << a << "; " << b << std::endl;

    return 0;
}
```

### Подвиг 4. Напишите программу, которая читает из входного потока stdin два целых числа a и b (a < b), записанных в одну строчку через пробел, и выводит в консоль все числа диапазона [a; b], кратные 3 в порядке возрастания в одну строчку через пробел.

P. S. Ввод/вывод данных реализовать через объекты cin/cout.

```c
#include <iostream>

int main() {
    int a, b;
    std::cin >> a >> b;
    for (int i = a; i <= b; i++) {
        if (i % 3 == 0) std::cout << i << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

### Подвиг 5 (с повторением). Продолжите программу, которая читает в массив data целые числа из входного потока, записанные в одну строчку через пробел. Необходимо контролировать максимальное количество читаемых значений не более max_size_ar. Выведите в консоль в одну строчку через пробел записанные значения в массив data (по порядку от начала до конца).

P. S. Ввод/вывод данных реализовать через объекты cin/cout.

```c
#include <iostream>

using namespace std;

enum { max_size_ar = 20 };

int main() {
    int data[max_size_ar];
    size_t count = 0;
    while (count < max_size_ar && cin.good()) {
        cin >> data[count];
        count++;
    }

    cout << count << '\n';

    for (size_t i = 0; i < count - 1; i++) {
        cout << data[i] << ' ';
    }

    cout << std::endl;

    return 0;
}
```
### Подвиг 6 (с повторением). Продолжите программу, которая читает в массив data целые числа из входного потока, записанные в одну строчку через точку с запятой (или любой другой символьный не числовой разделитель). Необходимо контролировать максимальное количество читаемых значений не более max_size_ar. Выведите в консоль в одну строчку через пробел значения массива data (по порядку от начала до конца).

P. S. Ввод/вывод данных реализовать через объекты cin/cout.

Sample Input:

9; 11; 0; -9; 3; 100; 8; 7; 4
Sample Output:

9 11 0 -9 3 100 8 7 4

```c
#include <iostream>

using namespace std;

enum { max_size_ar = 20 };

int main() {
    int data[max_size_ar];
    size_t count = 0;
    char ch;
    while (count < max_size_ar && cin.good()) {
        cin >> data[count] >> ch;
        count++;
    }

    cout << count << '\n';

    for (size_t i = 0; i < count; i++) {
        cout << data[i] << ' ';
    }

    cout << std::endl;

    return 0;
}
```

### Подвиг 7 (с повторением). Напишите программу. Объявите структуру с именем типа THING и следующими полями:

+ id; идентификатор; тип unsigned int;
+ name; название (строка); максимальная длина max_size_name = 50 (константа max_size_name задается в перечислении);
+ weight; вес; тип double;
+ price; цена; тип unsigned int.

В функции main объявите переменную с именем box типа THING. С помощью объекта cin выполните чтение из входного потока данных, записанных в следующем формате:

<идентификатор> <название> <вес> <цена>

Выведите с помощью объекта cout в консоль структуру box в формате:

<название> <идентификатор>: <вес>, <цена>

```c
#include <iostream>

enum { max_size_name = 50 };
using namespace std;

typedef struct {
    unsigned id;
    char name[max_size_name];
    double weight;
    unsigned price;
} THING;

int main() {
    THING box;

    cin >> box.id >> box.name >> box.weight >> box.price;

    cout << box.name << ' ' << box.id << ": " << box.weight << ", " << box.price << endl;

    return 0;
}
```

### Подвиг 8 (с повторением). Объявите функцию со следующей сигнатурой:

double triangle_sq(int a, int b, int c);
которая вычисляет и возвращает площадь треугольника со сторонами a, b, c. Площадь вычисляется по формуле Герона:

$S = \sqrt{p⋅(p−a)⋅(p−b)⋅(p−c)}$
​
где $p=(a+b+c)/2$ - полупериметр треугольника.

В функции main прочитайте из входного потока три целых натуральных числа, записанных в одну строчку через пробел. Вызовите для них функцию triangle_sq и выведите в консоль значение площади с точностью до сотых.

P. S. Чтение данных из потока stdin выполнить с помощью объекта cin.

Sample Input:

10 12 5
Sample Output:

24.54

```c
#include <cmath>
#include <iostream>

using namespace std;

double triangle_sq(int a, int b, int c) {
    double p = (a + b + c) / 2.0, res;
    res = powf(p * (p - a) * (p - b) * (p - c), 0.5);
    return res;
}

int main() {
    int a, b, c;

    cin >> a >> b >> c;

    double res = triangle_sq(a, b, c);

    printf("%.2lf", res);

    return 0;
}
```

манипуляторы

```c

#include <iostream>
#include <iomanip> // fixed и setprecision
#include <cmath> // sqrt

double triangle_sq(int a, int b, int c);

int main() {
    
    int a, b, c;
    std::cin >> a >> b >> c;
    std::cout << std::fixed << std::setprecision(2) << triangle_sq(a, b, c);
        
    return 0;
}

double triangle_sq(int a, int b, int c) {
    
    double s;
    s = (a + b + c) / 2.0; // полупериметр 
    
    return sqrt(s * (s - a) * (s - b) * (s - c));;
}
```

### Подвиг 9 (на повторение). Выберите все верные утверждения, касающиеся вариадических функций.

+ [x] для обработки вариадических параметров функции необходимо подключение заголовка stdarg.h
+ [ ] вариадическая функция может быть прописана только с вариадическими параметрами
+ [ ] вариадическая функция "знает" о количестве вариадических параметров
+ [x] вариадическая функция должна иметь хотя бы один явно прописанный параметр
+ [x] вариадические параметры всегда располагаются последними в списке параметров функции
+ [x] вариадическая функция "не знает" о настоящем количестве вариадических параметров

### Подвиг 10 (на повторение). Установите соответствия между определениями и функциями и их описаниями.

![09](/Good_good_C_C++/img/09_04.PNG)

### Подвиг 11 (на повторение). Выберите все верные записи вещественных числовых литералов.

P. S. Здесь d - вещественная переменная типа double.

+ [x] d = 3.2e5;
+ [ ] d = e-2;
+ [x] d = -.5;
+ [ ] d = e2;
+ [x] d = 1e-2;
+ [x] d = -1e2;
+ [x] d = 32e-5;
+ [x] d = 123.;

# 9.4 Пространства имен (namespace)

На этом занятии мы с вами познакомимся с новой концепцией языка С++ пространством имен. Из курса по языку Си мы знаем, что в глобальной области видимости можно объявлять функции, переменные, структуры и так далее:

```c
void foo() {
    std::cout << "function: foo()" << std::endl;
}
 
int global_a = 5;
 
struct point {
    double x, y;
};
```

Так вот, в языке С++ все подобные объявления попадают в так называемое глобальное пространство имен. В частности, это означает, что внутри функции `main()` мы можем обращаться к этим определениям следующим образом:

```c
int main() {
    point pt {};
 
    foo();
    std::cout << global_a << std::endl;
 
    return 0;
}
```

или так:

```c
int main() {
    ::point pt {};
 
    ::foo();
    std::cout << ::global_a << std::endl;
 
    return 0;
}
```

Обратите внимание на два двоеточия (программисты еще иногда их называют «четвероточием»). Формально, это символ раскрытия области видимости. Если перед ним (слева) не указана какая-либо область видимости, то подразумевается глобальная область (глобальное пространство имен).

Что нам дает этот символ? Смотрите, если, к примеру, внутри функции `main()` объявить еще одну переменную с именем `global_a`:

```c
int global_a = 10;
```

то мы можем их различать с помощью «четвероточия»:

```c
std::cout << ::global_a << " " << global_a << std::endl;
```

Увидим значения `5` и `10`. Поэтому, если мы хотим быть уверены, что обращаемся к глобальной переменной, то перед ее именем достаточно прописать два двоеточия. В ряде случаев это бывает очень полезно.

Далее, из курса по Си мы знаем, что если в глобальном пространстве имен определить два определения с одинаковыми именами, например, две функции с именем `foo`:

```c
void foo() ...
void foo() ...
```

то компилятор выдаст сообщение об ошибке. Но, несмотря на всю очевидность этого факта, такое все же вполне может произойти. Например, когда над большим проектом работает группа разработчиков, то независимо друг от друга программисты могут создавать совершенно одинаковые прототипы функций с разными реализациями. И при попытке собрать проект целиком возникает описанная проблема.

Или же мы написали свою библиотеку функций или классов, подключаем ее к проекту, где используются другие стандартные библиотеки, и видим тот же конфликт имен. Хотя при разработке своего отдельного модуля мы с этим никак не сталкивались. И подобных ситуаций может быть множество. 

Как же этого избежать? 

Для в С++ существует возможность создавать свои пространства имен, которые позволяют разделять один набор определений от другого набора. Для этого используется ключевое слово namespace, после которого указывается название нового или существующего пространства. Например, так:

```c
namespace firstSpace {
    void foo() {
        std::cout << "function from firstSpace: foo()" << std::endl;
    }
}
 
void foo() {
    std::cout << "function: foo()" << std::endl;
}
```

Здесь название `firstSpace` мы придумываем сами подобно именам переменных и функций, а, затем, в фигурных скобках следует содержимое этого пространства. В нашем примере там располагается функция с именем `foo`. Теперь программа будет компилироваться без проблем, так как функции `foo()` находятся в разных пространствах имен. Но давайте вторую функцию тоже поместим в отдельное пространство с именем `secondSpace`:

```c
namespace secondSpace { 
    void foo() {
        std::cout << "function from secondSpace: foo()" << std::endl;
    }
}
```

Отлично, но как теперь следует вызывать эти функции? Делается это следующим образом:

```c
firstSpace::foo();
```

То есть, сначала указывается название пространства имен, а затем, через два двоеточия элемент этого пространства. В данном случае вызывается функция `foo()`.

Аналогично можно вызвать функцию `foo()` из другого пространства:

```c
secondSpace::foo();
```

После запуска программы видим, что были вызваны две разные функции `foo()` из соответствующих пространств имен. Как видите, все достаточно просто.

Теперь несколько важных деталей. Во-первых, определение одного и того же пространства имен определять в разных местах программы (проекта), например, следующим образом:

```c
namespace firstSpace {
    void foo() {
        std::cout << "function from firstSpace: foo()" << std::endl;
    }
}
 
namespace firstSpace {
    struct point {
        double x, y;
    };
}
```

В результате будет создано пространство `firstSpace` с функцией `foo` и структурой `point`. Это эквивалентно тому, если бы мы их прописали в одном определении `firstSpace`:

```c
namespace firstSpace {
    void foo() {
        std::cout << "function from firstSpace: foo()" << std::endl;
    }
 
    struct point {
        double x, y;
    };
}
```

Данный прием бывает полезен, когда программист разбивает свой проект на несколько файлов и в каждом нужно прописывать свою реализацию одного и того же пространства имен. Тогда в каждом файле достаточно прописать одно и то же имя после ключевого слова `namespace`.

Следующее важное замечание касается вложенных пространств имен. Например, так:

```c
namespace secondSpace {
    namespace functions {
        void foo() {
            std::cout << "function from secondSpace: foo()" << std::endl;
        }
    }
 
    namespace params {
        int global_a = 5;
    }
}
```


Соответственно, обращение к элементам такого пространства будет выглядеть следующим образом:

```c
secondSpace::functions::foo();
std::cout << secondSpace::params::global_a << std::endl;
```

И последний штрих. Если перед именем вложенного пространства прописать ключевое слово `inline`, например, так:

```c
namespace secondSpace {
    inline namespace functions {
        void foo() {
            std::cout << "function from secondSpace: foo()" << std::endl;
        }
    }
    ...
}
```

то доступ к функции `foo()` можно делать следующим образом:

```c
secondSpace::functions::foo();
secondSpace::foo();
```

То есть, имя `inline`-пространства указывать не обязательно.

На этом мы с вами завершим текущее занятие, а на следующем рассмотрим оператор `using`, который позволяет включать все или отдельные определения одного пространства имен в другое.

Видео по теме [#3. Пространства имен (namespace)](https://www.youtube.com/watch?v=mP0inCfi_9w&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, касающиеся пространства имен (namespace) языка С++.

+ [x] при объявлении переменных или функций вне каких-либо конструкций языка С++ они попадают в глобальное пространство имен
+ [ ] пространство имен позволяет разбивать проект на подмодули и отдельно (независимо) их компилировать
+ [ ] при объявлении переменных или функций вне каких-либо конструкций языка С++ они попадают в пространство (namespace) std
+ [x] пространство имен объявляется согласно синтаксису: namespace <идентификатор пространства> {[содержимое пространства имен]}
+ [x] пространство имен позволяет изолировать идентификаторы (имена переменных, функций) с одинаковыми именами при сборке проекта (особенно больших)

### Подвиг 2. Выберите все верные утверждения, касающиеся следующего фрагмента программы:

```c
int module_id = -1;

namespace params {
int global_result = 0;
}

namespace triangle {
double square(int a, int b, int c) {
    double p = (a+b+c) / 2.0;
    return sqrt(p*(p-a)*(p-b)*(p-c));
}
}

namespace params {
typedef union {
    int res_int;
    double res_dbl;
} RESULT;
}
```

+ [ ] в пространстве имен нельзя определять типы данных, поэтому последнее определение params приведет к ошибке
+ [x] в пространстве triangle присутствует функция с именем square
+ [x] в пространстве params описана переменная global_result и тип RESULT
+ [x] обращение к функции square следует прописывать в виде triangle::square
+ [x] символ :: называется символом раскрытия области видимости
+ [ ] в пространстве params будет содержаться только тип RESULT
+ [x] обращение к переменной module_id в теле функций можно записывать в виде module_id или в виде ::module_id
+ [x] обращение к типу RESULT следует записывать в виде params::RESULT

### Подвиг 3. Объявите в программе два пространства имен: triangle и rectangle. В пространстве triangle пропишите функцию с именем perimetr, которая вычисляет периметр треугольника с целочисленными сторонами a, b, c (формула: a+b+c). Вычисленный результат (целочисленный) возвращается этой функцией. По аналогии определите в пространстве имен rectangle функцию с таким же именем perimetr, которая вычисляет периметр прямоугольника с целочисленными сторонами width и height (формула: 2*(width+height)). Вычисленный результат (целочисленный) возвращается этой функцией. 

В функции main прочитайте из входного потока три целых числа a0, a1, a2, записанных в одну строчку через пробел. Вызовите функцию perimetr из пространства triangle с аргументами a0, a1, a2 и функцию perimetr из пространства rectangle с аргументами a0, a1. Выведите в консоль в одну строчку через пробел два вычисленных периметра: сначала для треугольника, а затем для прямоугольника.

Sample Input:

3 4 5
Sample Output:

12 14

```c
#include <cmath>
#include <iostream>

using namespace std;

namespace triangle {
int perimetr(int a, int b, int c) {
    int p = a + b + c;
    return p;
}
}  // namespace triangle

namespace rectangle {
int perimetr(int a, int b) {
    int p = (a + b) * 2;
    return p;
}
}  // namespace rectangle

int main() {
    int a0, a1, a2;

    cin >> a0 >> a1 >> a2;

    int res1 = triangle::perimetr(a0, a1, a2);
    int res2 = rectangle::perimetr(a0, a1);

    printf("%d %d", res1, res2);

    return 0;
}
```

### Подвиг 4. Объявите в программе пространство имен math, в котором пропишите функцию сравнения двух целочисленных массивов типа short со следующей сигнатурой:

int ar_compare(const short* a1, size_t len_a1, const short* a2, size_t len_a2);
Функция возвращает 1, если переданные массивы a1 и a2 равны, и 0 в противном случае. Массивы считаются равными, если равны их длины и попарно все  элементы массивов a1 и a2 между собой. То есть, первый элемент массива a1 должен быть равен первому элементу массива a2 и так до конца для всех их элементов.

В функции main с помощью функции ar_compare сравните между собой два следующих массива:

short ar1[] = {1, 2, 3, 4, 5};
short ar2[] = {1, 2, 5, 3, 4};
Результат сравнения сохраните в целочисленной переменной res.

P. S. В консоль ничего выводить не нужно.

```c
#include <cmath>
#include <iostream>

using namespace std;

namespace math {
int ar_compare(const short* a1, size_t len_a1, const short* a2, size_t len_a2) {
    if (len_a1 != len_a2) {
        return 0;
    } else {
        for (size_t i = 0; i < len_a1; i++) {
            if (a1[i] != a2[i]) {
                return 0;
            }
        }
    }
    return 1;
}
}  // namespace math

int main() {
    short ar1[] = {1, 2, 3, 4, 5};
    short ar2[] = {1, 2, 5, 3, 4};

    int res = math::ar_compare(ar1, sizeof(ar1) / sizeof(*ar1), ar2, sizeof(ar2) / sizeof(*ar2));

    printf("%d", res);

    return 0;
}
```

### Подвиг 5 (с повторением). Объявите в программе пространство имен array_alg. В этом пространстве объявите функцию sorted_int со следующей сигнатурой:

```c
void sorted_int(int* ar, size_t len_ar, TYPE_SORT type);
```

Здесь
+ `ar` - сортируемый массив;
+ `len_ar` - число первых сортируемых элементов массива `ar`;
+ `type` - тип сортировки (по возрастанию или убыванию). 

Тип сортировки `TYPE_SORT` определяется в том же пространстве имен `array_alg` как перечисление с двумя константами:
+ `sort_asc` - сортировка по возрастанию;
+ `sort_desc` - сортировка по убыванию.

В функции `main` прочитайте из входного потока целые числа, записанные в одну строчку через пробел, в количестве не более 20. Все эти значения занесите в массив (по порядку) и отсортируйте массив по убыванию с помощью функции `sorted_int`. Выведите в консоль отсортированные значения в одну строчку через пробел.

Sample Input:

45 324 645 324 2 -10 11 0 -54 2

Sample Output:

645 324 324 45 11 2 2 0 -10 -54

```c
#include <iostream>

using namespace std;

enum { max_len = 20 };

namespace array_alg {

typedef enum { sort_asc, sort_desc } TYPE_SORT;

void swap(int* a, int* b) {
    int tmp = *a;
    *a = *b;
    *b = tmp;
}

void sorted_int(int* ar, size_t len_ar, TYPE_SORT type) {
    for (size_t i = 0; i < len_ar; i++) {
        for (size_t j = i + 1; j < len_ar; j++) {
            switch (type) {
                case sort_asc:
                    if (ar[i] > ar[j]) swap(&ar[i], &ar[j]);
                    break;
                case sort_desc:
                    if (ar[i] < ar[j]) swap(&ar[i], &ar[j]);
                    break;
            }
        }
    }
}

}  // namespace array_alg

int main() {
    int array[max_len];

    size_t count = 0;

    while (count < max_len && cin.good()) {
        cin >> array[count++];
    }

    array_alg::sorted_int(array, count, array_alg::sort_desc);

    for (size_t i = 0; i < count; i++) {
        cout << array[i] << ' ';
    }

    return 0;
}
```

### Подвиг 6 (с повторением). Объявите в программе пространство имен array_alg. В этом пространстве объявите функцию filter_int, которая должна оставлять только определенные значения в массиве. Эта функция должна иметь следующую сигнатуру:

```c
size_t filter_int(int* ar, size_t len_ar, PTR_FILTER_FUNC func);
```

Здесь:
+ `ar` - обрабатываемый массив;
+ `len_ar` - начальная длина массива `ar`;
+ `func` - указатель на функцию для отбора (фильтрации) значений массива `ar`. 

Функция `filter_int` должна возвращать результирующую длину массива `ar` (количество оставшихся в нем элементов).

Указатель `PTR_FILTER_FUNC` должен быть определен в пространстве имен `array_alg` для функций с сигнатурой:

```c
int <имя_функции> (int);
```

Если такая функция, вызванная для определенного элемента массива, возвращает истину (не нулевое значение), то это значение остается в массиве, а иначе - удаляется. При удалении размер массива `len_ar` также должен уменьшаться. 

В пространстве имен `array_alg` объявите еще одно пространство имен (вложенное) с именем `filter_func` и объявите в нем функцию с именем even для отбора четных значений массива (четные значения должны оставаться).

В функции `main` прочитайте из входного потока целые числа, записанные в одну строчку через пробел, в количестве не более 20. Все эти значения занесите в массив (по порядку) и отфильтруйте его с помощью функции `filter_int` с передачей в качестве критерия фильтрации функцию `even`. То есть, в массиве должны оставаться только четные числа или никаких, если четных чисел нет. Выведите в консоль отфильтрованные значения в одну строчку через пробел.

Sample Input:

5 34 10 4 7 8 3 2
Sample Output:

34 10 4 8 2

```c
#include <iostream>

enum { max_len = 20 };

namespace array_alg {

typedef int (*PTR_FILTER_FUNC)(int);

namespace filter_func {

int even(int a) { return a % 2 == 0; }
}  // namespace filter_func

PTR_FILTER_FUNC func = filter_func::even;

size_t filter_int(int* ar, size_t len_ar, PTR_FILTER_FUNC func) {
    size_t count = 0;
    for (size_t i = 0; i < len_ar; i++) {
        if (func(ar[i])) ar[count++] = ar[i];
    }
    return count;
}

}  // namespace array_alg

int main() {
    int array[max_len];

    size_t count = 0;

    while (count < max_len && scanf("%d", &array[count]) == 1) count++;

    count = array_alg::filter_int(array, count, array_alg::filter_func::even);

    for (size_t i = 0; i < count; i++) {
        printf("%d ", array[i]);
    }

    return 0;
}
```

### Подвиг 7 (с повторением). Объявите в программе пространство имен array_alg. В этом пространстве объявите функцию add_int, которая должна добавлять к массиву только определенные значения из другого массива. Эта функция должна иметь следующую сигнатуру:

```c
size_t add_int(int* src, size_t start, size_t max_len_src, const int* dest, size_t len_dest, PTR_FILTER_FUNC func);
```

+ `src` - массив, в который добавляются новые значения; 
+ `start` - начальный индекс, с которого происходит добавление в массив src; 
+ `max_len_src` - длина массива src; 
+ `dest` - массив, из которого добавляются значения;
+ `len_dest` - количество добавляемых элементов из массива dest в массив src;
+ `func` - указатель на функцию для отбора (фильтрации) значений массива dest.  

Функция `add_int` должна возвращать новую результирующую длину массива `src`. Указатель `PTR_FILTER_FUNC` должен быть определен в пространстве имен `array_alg` для функций с сигнатурой:

```c
int <имя_функции> (int);
```

Если такая функция, вызванная для определенного элемента массива `dest`, возвращает истину (не нулевое значение), то это значение добавляется в массив `src`, а иначе - пропускается.

При добавлении значений нужно контролировать возможное превышение длины `max_len_src` массива `src`. При достижении значения `max_len_src` процесс добавления следует останавливать.

В пространстве имен `array_alg` объявите еще одно пространство имен (вложенное) с именем `filter_func` и объявите в нем функцию с именем `mark_positive` для отбора оценок от `4` и выше (значения >= `4` должны добавляться).

Продолжите функцию `main` прочитайте из входного потока целые числа в массив `ar`, записанные в одну строчку через пробел, в количестве не более `20`. С помощью функции `add_int` добавьте в массив `marks` прочитанные значения из массива `ar` с передачей в качестве критерия добавления функцию `mark_positive`. Выведите в консоль сформированные значения массива `marks` в одну строчку через пробел в порядке их следования, начиная с первого.

Sample Input:

2 5 4 3 3 2

Sample Output:

3 2 5 4 3 5 4

```c
#include <iostream>

enum { max_len = 20, max_len_marks = 100 };

namespace array_alg {

typedef int (*PTR_FILTER_FUNC)(int);

namespace filter_func {

int mark_positive(int a) { return a >= 4; }
}  // namespace filter_func

PTR_FILTER_FUNC func = filter_func::mark_positive;

size_t add_int(int* src, size_t start, size_t max_len_src, const int* dest, size_t len_dest,
               PTR_FILTER_FUNC func) {
    for (size_t i = 0; i < len_dest; i++) {
        if (func(dest[i])) {
            src[start++] = dest[i];
            if (start == max_len_src) break;
        }
    }

    return start;
}

}  // namespace array_alg

int main() {
    int marks[max_len_marks] = {3, 2, 5, 4, 3};
    int ar[max_len];
    size_t count = 0, count_marks = 5;

    while (count < max_len && scanf("%d", &ar[count]) == 1) count++;

    count = array_alg::add_int(marks, count_marks, max_len_marks, ar, count,
                               array_alg::filter_func::mark_positive);

    for (size_t i = 0; i < count; i++) {
        printf("%d ", marks[i]);
    }

    return 0;
}
```

### Подвиг 8 (на повторение). Выберите все верные утверждения, касающиеся следующих объявлений указателей:

```c
const int* ptr_cnst;
int * const cnst_ptr;
```

+ [ ] через указатель ptr_cnst можно читать и записывать значения в ячейки памяти
+ [x] имя массива в языке Си подобно (по принципу использования) указателю cnst_ptr
+ [x] через указатель cnst_ptr можно читать и записывать значения в ячейки памяти
+ [x] указатель cnst_ptr не может менять значение своего адреса, который задается при инициализации
+ [x] через указатель ptr_cnst можно только читать значения из ячеек памяти, но не записывать
+ [x] указатель ptr_cnst может менять значение своего адреса в процессе выполнения программы
+ [ ] через указатель cnst_ptr можно только читать значения из ячеек памяти, но не записывать

### Подвиг 9 (на повторение). Выберите все верные (работающие) конструкции со следующими указателями:

```c
int* ptr;
const int* ptr_cnst;
int * const cnst_ptr;
```

+ [x] --ptr_cnst;
+ [ ] *ptr_cnst = 10;
+ [ ] ptr = ptr_cnst;
+ [x] ptr_cnst = ptr;
+ [x] *cnst_ptr = 77;
+ [ ] cnst_ptr++;
+ [ ] cnst_ptr = ptr;
+ [x] ptr = cnst_ptr;

# 9.5 Оператор using

## Оператор using

На прошлых занятиях для обращения к элементам пространства имен `std` нам приходилось прописывать `std::cin`, `std::cout` и так далее. 

Это не очень удобно. 

Если в модуле (файле) предполагается постоянное использование каких-либо элементов из того или иного пространства имен, то эти элементы можно импортировать непосредственно в этот модуль. В частности, для этого предназначен оператор `using`. Использовать его можно в соответствии со следующим синтаксисом:

```c
using <пространство имен>::<элемент>;
```

Например, чтобы импортировать объекты `cin`/`cout` и функцию `endl` в текущий модуль в глобальное пространство имен, достаточно прописать:

```c
#include <iostream>
 
using std::cout;
using std::cin;
using std::endl;
 
int main() {
    char str[50];
 
    cin >> str;
    cout << "Hello, " << str << "!" << endl;
 
    return 0;
}
```

Если же этот оператор прописать в каком-либо блоке, например, в теле функции `main()`, то импорт будет сделан в пределах этого блока:

```c
#include <iostream>
 
int main() {
    using std::cout;
    using std::cin;
    using std::endl;
 
    char str[50];
 
    cin >> str;
    cout << "Hello, " << str << "!" << endl;
 
    return 0;
}
```

Соответственно, определения `cout`, `cin` и `endl` доступны теперь только внутри тела функции `main()` и не доступны за его пределами.

Обычно, на практике, отдельные элементы импортируются в глобальную область или в пространство имен, где их активно предполагается использовать. А вот делать импорт всех определений того или иного пространства имен следует исключительно в локальные области.

Давайте посмотрим, как синтаксически выполняется импорт всего пространства. Для этого также прописывается ключевое слово `using`, за которым следует еще одно ключевое слово `namespace` с указанием имени импортируемого пространства. Например:

```c
int main() {
    using namespace std;
    // using std::cout;
    // using std::cin;
    // using std::endl;
 
    char str[50];
 
    cin >> str;
    cout << "Hello, " << str << "!" << endl;
 
    return 0;
}
```

В результате, все определения из `std` становятся доступными напрямую в теле функции `main()`. И, еще раз, обратите внимание. Писать подобный импорт в глобальной области – крайне плохая практика:

```c
#include <iostream>
 
using namespace std;
 
int main() {
    char str[50];
 
    cin >> str;
    cout << "Hello, " << str << "!" << endl;
 
    return 0;
}
```

Часто, далеко не все, что прописано в `std`, используется в текущем модуле. И программист вполне может случайно объявить переменную или функцию или что-либо еще с тем же именем, что и импортированный элемент. Возникнет конфликт имен и компиляция программы завершится с ошибкой. Как раз чтобы этого избежать, лучше явно указывать импортируемые элементы:

```c
using std::cout;
using std::cin;
using std::endl;
```

Или, в крайнем случае, делать полный импорт в локальную область видимости.

## Определение псевдонимов типов

Но это еще не все, что умеет делать оператор `using`. С его помощью можно создавать псевдонимы (алиасы) существующих в программе типов данных. Делается это по следующему синтаксису:

```c++
using <alias> = <тип данных>;
```

Например, в самом простом варианте, можно прописать что-то вроде:

```c++
using byte_8 = unsigned char;
```

В программе появляется новое имя `byte_8` базового типа `unsigned char`, которое полноценно можно использовать следующим образом:

```c++
byte_8 byte;
byte_8* byte_ptr;
```
Или, такой пример. Пусть у нас в программе объявлено пространство имен с определением функции и структуры:

```c++
namespace firstSpace {
    void foo() {
        cout << "function from firstSpace: foo()" << endl;
    }
 
    struct point {
        double x, y;
    };
}
```

Тогда для типа `firstSpace::point` можно создать псевдоним следующим образом:

```c++
using point2D = firstSpace::point;
```

и использовать его для объявления соответствующей переменной на структуру:

```c
point2D pt;
```

При этом прежний тип `firstSpace::point`, конечно же продолжает существовать. Мы лишь создаем еще одно имя этого типа не более того. И `using` создает псевдонимы именно для типов данных. Например, запись вида:

```c++
using func = firstSpace::foo;
```

приведет к ошибке, т.к. `foo` – это имя функции, а не тип данных.

Вообще конструкция

```c++
using <alias> = <тип данных>;
```

очень напоминает оператор `typedef` языка Си. Например, с его помощью мы также можем записать:

```c++
typedef unsigned char byte_8;
typedef firstSpace::point point2D;
```

На первый взгляд никаких отличий. Но они все же имеются. Оператор `using` полностью покрывает функциональность оператора `typedef` и привносит некоторые дополнительные возможности и улучшения. Например, объявление типа указателя на функцию через `typedef` выглядит так:

```c
typedef float (*func_ptr)(int);
```

а с использованием `using` несколько понятнее и красивее:

```c++
using func_ptr = float (*)(int);
```

Но, конечно, главное преимущество `using` перед `typedef` проявляются при работе с шаблонами (`templates`). 

Но это уже выходит за пределы нашего базового курса по С++. 

Отмечу лишь, что в современных программах на С++ нет смысла использовать `typedef` и от него лучше отказываться в пользу оператора `using`. 

Хотя это не строгое правило и применение `typedef` все же допустимо.

Видео по теме [#4. Оператор using](https://www.youtube.com/watch?v=IJEga9b25gQ&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, касающиеся оператора using языка С++.

+ [x] не рекомендуется с помощью using импортировать пространство имен целиком в глобальную область
+ [x] оператор using позволяет создавать псевдонимы для существующих в программе типов данных
+ [x] оператор using позволяет импортировать пространство имен целиком
+ [x] допускается делать импорт отдельных элементов в глобальную область из пространств имен
+ [x] оператор using позволяет импортировать отдельные элементы из указанного пространства имен

### Подвиг 2. Выберите все верные варианты записи импортов из пространства имен std.

+ [ ] using std.endl;
+ [ ] using namespace std::cout;
+ [ ] using std::std::cin;
+ [x] using namespace std;
+ [x] using std::cout;
+ [ ] using std namespace;

### Подвиг 3. Выполните в программе импорт элементов cin, cout и endl в глобальную область и в функции main прочитайте из входного потока слово (максимальная длина 50 символов) и выведите его в консоль.

Sample Input:

Straustrup
Sample Output:

Straustrup

```c++
#include <iostream>

enum { max_len_str = 50 };

using std::cin;
using std::cout;
using std::endl;

int main() {
    char str[50];

    cin >> str;
    cout << str << endl;

    return 0;
}
```

### Подвиг 4. Учитывая приведенный фрагмент программы, выберите все верные варианты определения алиасов (псевдонимов) с помощью оператора using языка С++.

```c
int global_var = 1;

namespace test {
typedef union {
    char ch;
    int vi;
    double vd;
} VAR;

int odd(int x) {
    return x % 2 != 0;
}
}
```

+ [x] using AR_INT = int[10];
+ [x] using UINT = unsigned int;
+ [ ] using TEST = test;
+ [x] using DATA = test::VAR;
+ [x] using VOLUME = struct {int width, height, depth;};
+ [x] using PTR_STR = char*;
+ [ ] using GVAR = global_var;
+ [ ] using ptr_func = test::odd;

### 