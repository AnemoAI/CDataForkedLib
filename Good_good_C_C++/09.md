# 9  Движемся от Си к C++

# 9.1 C++. Начало

На заря 80-х годов, когда язык С достиг своего могущества и покрыл собой немалую часть программистского сообщества, из недр неуёмного сознания Бьёрна Струструппа явилось то, что в последствии стали кратко называть С++. Время разделилось на до и после. Непримиримые сторонники языка С напрочь отвергли зарождающееся явление С++, сохранив верность базовым принципам языка С.

Но историю было уже не остановить. И в 1983 году IT-мир содрогнулся. Язык C++ был официально признан новым языком программирования. 

Привычный порядок пришел в движение.
+ В C++ появились классы и объектно ориентированное программирование.
+ Структуры объединения стали специальными видами тех же классов. 
+ Появился механизм исключений.
+ Стала возможна перегрузка функций объявлений с аргументами по умолчанию.
+ Формированию inline и lambda функций.
+ Возникло то, что стало называться шаблонами и обобщенным программированием. Но и это еще не все.
+ В C++ появилось пространство имен,
+ новый способ объявления переменных через ссылки и вычисляемый тип,
+ возник самостоятельный булевый тип с двумя возможными стоянием `true` и `false`,
+ появились новые типы для символьных переменных,
+ новый вид цикла `for` для перебора последовательностей.
+ новый способ работы с потоком ввода вывода через объекты `cin`/`cout`
+  в обиход вошли такие операторы как `new` и `delete`. 

![09](/Good_good_C_C++/img/09_01.PNG)

И это лишь то не малое, что принес с собой C++. 

Потребовалось несколько лет кропотливой и напряженной работы, чтобы упорядочить все эти знания и лишь в 1998 году прийти к ратификации первого стандарта языка C++ под кодовым названием ISO-IC 14882.1998. 

С этого момента язык C++ было уже не остановить. 

Совсем скоро C++ поглотил стандартную библиотеку STL. Стали появляться все новые и новые стандарты — C++11, C++14, C++17, C++20. 

В ряды этого языка вступало все больше и больше программистов со всех уголков мира. На нем стали писать огромное количество проектов. Он проник везде где требовалась высокая скорость обработки данных, и в итоге стал конкурентом самому C. 

Оба языка C и C++ продолжили эволюционировать уже независимо друг от друга, как непримиримые враги.

И то, что ранее воспринималось как развитие, теперь по сути превратилось во два разных языка. 

Программа, написанная на современном C, почти наверняка не скомпилируется под C++. И наоборот.

Но несмотря на десятилетие эволюции, в ДНК языка C++ четко видны гены его предшественника. 

Эти следы C++ будет нести до конца своих дней, наследуя многие недостатки языка C. 

Но главное, внедрение в C++ многих популярных идей техник программирования превратили его в настоящего монстра. 

Сторонники языка считают это преимуществом. По их мнению, благодаря богатому функционалу можно реализовывать проекты самыми разными способами. 

И программист фактически ограничен только своими способностями. 

Противники же утверждают, что это часто приводит лишь к усложнению кода, сложности его понимания и дальнейшей модификации, особенно сторонними программистами. 

Мало того, в C++ гораздо больше подводных камней, нежели в языке C. Например, корпорация Google запретила своим разработчикам на C++ использовать механизмы исключения, потому что он часто приводит к заметному замедлению скорости работы программ. 

А это именно то, ради чего вообще стоит рассматривать язык C++ в качестве инструмента. 

Некоторые откровенно считают, что C++ ни при каких обстоятельствах не стоит применять при разработке больших проектов. Здесь можно привести известную цитату Линуса Торвальда. "Си плюс плюс – кошмарный язык». Его делает еще более кошмаром тот факт, множество недостаточных грамотных программистов используют его. Откровенно говоря, даже если нет никаких причин для выбора C, кроме того, чтобы держать программистов C++ подальше, то одного этого же будет достаточно веским основанием для использования C." 

Тем не менее, практика программирования показала, что грамотное применение языка C++ без фанатизма и неоправданного усложнения текста программы позволяет со всеми вытекающими плюсами и преимуществами перед языком C. 

Не зря C++ завоевал такую большую популярность, на которую способен далеко не каждый язык программирования. И главное, он остается востребованным и по сей день, несмотря на свою долголетнюю историю. 

Как вы уже догадались, в этом дополнение к курсу языка C мы не будем пускаться во все тяжкие, а рассмотрим лишь основные, базовые и часто применяемые возможности языка C++.

Мало того, я даже не буду опираться на какой-то определенный стандарт, ограничусь лишь стандартом не выше C++14. Все что нам будет нужно есть в нем. Итак, поехали.

Видео по теме [С++. Начало](https://www.youtube.com/watch?v=QYZbN2g-Dxc&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

# 9.2 Первая программа на С++

Первым делом нам нужно настроить среду программирования с компилятором языка С++. Для учебных целей вполне подойдет Visual Studio Code с ранее установленным компилятором `gcc`. Для проверки работоспособности компилятора достаточно открыть командное окно и ввести команду:

```
g++ --version
```

Если отобразится версия, значит, все настроено и готово к работе. Иначе, необходимо установить компилятор. О том, как это делается, рассказывается на одном из первых занятий по языку Си.

После этого я создам каталог:

```
D:\Projects\vscode\course_cpp
```

в котором будут размещаться файлы с программой на С++ и соответствующие исполняемые файлы. У вас может быть любой другой маршрут расположения файлов. Старайтесь только в названиях не использовать кириллицу и символы пробела.

Перейдем в программу Visual Studio Code и откроем созданную папку. Нажмем «New File...» и создадим текстовый файл с именем:

```
course.cpp
```

Обратите внимание на расширение файла – cpp. Модули с текстами программ на языке С++ принято сохранять с таким расширением.

Далее, запишем первую программу на С++. Она будет следующей:

```cpp
// Первая программа на языке С++
#include <iostream>
 
int main() {
    std::cout << "Hello World!" << std::endl;
    
    return 0;
}
```

Позже я поясню, что означают все эти строчки, а вначале давайте попробуем ее скомпилировать и запустить. 

Для этого я из папки с программой на чистом Си скопирую каталог .vscode с настроечными JSON-файлами. 

И открою в VS Code файл settings.json. В этом файле прописаны связи между расширениями файлов и соответствующими запусками компиляторов. В частности, для расширения cpp используется компилятор g++. В целом, меня здесь все устраивает, дополнительно только пропишу версию стандарта этого компилятора С++14 следующим образом:

```
cd $dir && g++ -std=c++14 $fileName -o $fileNameWithoutExt && $dir$fileNameWithoutExt
```

Попробуем теперь откомпилировать и запустить программу (Ctrl + Alt + n). Видим на экране сообщение «Hello World!».

И сделаем еще одну настройку автоматической прокрутки скроллинга вкладки OUTPUT среды VS Code. Для этого перейдем в настройки (File -> Preferences -> Settings). Здесь выберем Features -> Output и уберем галочку у «Smart Scroll».

Давайте, теперь вернемся к самой программе и разберемся, из чего она состоит. В первой строчке записан однострочный комментарий (появился в языке С++) и все, что идет после символов `//` до конца строки помечается, как комментарий. 

Причем, однострочное комментирование не обязательно начинать с начала строки, его можно указать в любом месте, например, после объявления заголовка функции `main`:

```cpp
int main()  // точка входа в программу
```

Для одной строки такие комментарии прописывать гораздо удобнее, чем `/* */`, которые изначально были определены в языке Си. В С++ можно применять оба вида.

Следующая строчка – это уже знакомая вам директива `#include` для включения файла `iostream` в текущем модуле. 

В данном случае это необходимо для использования объекта `cout`, с помощью которого удобно выводить данные в стандартный выходной поток `stdout`. 

Ранее, в языке Си, мы для этой цели часто использовали функцию `printf()`. В языке С++ этот процесс несколько упрощен благодаря объекту `cout`. Что это за объект и как он в деталях работает, речь еще впереди.

Далее, идет стандартная функция `main()`, которая определяет точку входа в программу, то есть, в языке С++ (также, как и в языке Си) программа начинает выполняться с автоматического вызова функции `main()` и завершается, при ее завершении.

Следующая конструкция:

```c
std::cout << "Hello World!" << std::endl;
```
отвечает за вывод информации в стандартный выходной поток. Здесь в глаза бросается фрагмент `std::…`. 
Ключевое слово `std` – это предопределенное название пространства имен, так называемой, стандартной библиотеки языка С++. 

Как я отмечал во вступлении, в язык С++ на уровне стандарта включили библиотеку `STL`, которая заметно упрощает работу со сложными коллекциями и типами данных, таких как:
+ строки `(std::string)`;
+ массивы `(std::array)`;
+ динамический массив `(std::vector)`;
+ двухсвязный список `(std::list)`;
+ очередь `(std::deque)`;
+ упорядоченные множества `(std::set)`;
+ упорядоченные ассоциативные массивы `(std::map)`

и многое другое. 

Так вот, чтобы обратиться к тому или иному определению в пространстве стандартной библиотеки, следует прописать название этого пространства `std` и через два двоеточия (четвероточие) указать нужный элемент. 

В частности, `cout` – это объект класса `ostream`, который отвечает за вывод информации в стандартный выходной поток. Затем, используя переопределенную операцию `<<`, указываются выводимые данные. 

В конце, после вывода строки «Hello World!» прописан `endl`. Он передает символ переноса строки и очищает буфер потока, к которому применен.

Вас может удивить, что для понимания работы такой простой программы на С++ нужно знать и о пространстве имен, и об объектах классов, и, по-хорошему, о самих классах. 

Это, действительно, так. 

Конечно, на начальном этапе подобные моменты можно просто запомнить и применять без глубокого понимания их работы. 

Часто так и делается. 

В конце концов, язык С++ (равно, как и Си) был придуман не для обучения программированию, а чтобы дать программистам эффективный и высокоуровневый инструмент разработки программ качественно транслирующихся в машинный код, то есть, выполняющихся с наибольшей скоростью. 

Поэтому, если вам не понятны слова «объект», «класс», «пространство имен» и прочее, то пока просто запоминайте приведенные конструкции по факту, а более глубокое понимание придет позже.

Итак, на этом занятии мы с вами сделали первый шаг в языке С++. Настроили интегрированную среду с компилятором g++ стандарта C++14, написали и выполнили первую простую программу. На следующем занятии уже непосредственно начнем изучать конструкции языка С++.

Видео по теме [#1. Первая программа на С++](https://www.youtube.com/watch?v=c7Nb0lJHVtU&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, касающиеся языка программирования C++.

+ [x] автором языка С++ является Бьерн Страуструп
+ [x] язык С++ появился как развитие языка Си
+ [x] концептуально язык С++ отличается от языка Си объектно-ориентированным подходом к программированию (ООП) и обобщенным программированием (шаблонами)
+ [x] язык С++ имеет гораздо больше возможностей, чем язык Си, но и накладывает на программиста больше ответственности при написании программ
+ [x] современная программа, написанная на языке Си, может не скомпилироваться под С++
+ [x] в С++ гораздо больше "подводных камней", нежели в языке Си

### Подвиг 2. Как в тексте программы на С++ оформляются комментарии?

+ [x] `//` (однострочный комментарий)
+ [ ] `\* *\` (многострочный комментарий)
+ [x] `/* */` (многострочный комментарий)
+ [ ] `\\` (однострочный комментарий)

### Подвиг 3. Какую роль играет функция main() в тексте программы на языке C++?

+ [x] если функция main() возвращает 0, значит, программа была выполнена успешно (без ошибок)
+ [ ] если функция main() возвращает не нулевое значение, значит, программа была выполнена успешно (без ошибок)
+ [x] как только функция main() завершает свою работу, завершается выполнение всей программы
+ [ ] функция main() служит для начальной инициализации переменных в программе (и только для этого)
+ [x] это функция, которая автоматически запускается при запуске исполняемого файла
+ [x] если функция main() отсутствует в тексте программы (проекта), то при компиляции возникает ошибка

### Подвиг 4 (на повторение). Какую роль играет текстовый препроцессор при компиляции программы на языке C/C++?

+ [x] обрабатывает директивы препроцессора в исходных файлах текстов программы
+ [ ] выполняет сборку объектных модулей программы в единый исполняемый файл
+ [ ] обрабатывает директивы препроцессора в полученных объектных файлах
+ [ ] добавляет специальные директивы в текст программы для оптимизации процесса компиляции

### Подвиг 5 (на повторение). Какую роль играет непосредственно компилятор при транслировании программы на языке C/C++ в машинный код?

+ [x] отдельные файлы с текстами программы преобразует в машинный код, формируя объектные файлы
+ [ ] объединяет все файлы с текстами программы текущего проекта в единую программу и переводит ее в машинный код
+ [ ] выполняет сборку объектных модулей программы в единый исполняемый файл
+ [ ] отдельные файлы с текстами программы преобразует в машинный код, формируя конечный исполняемый файл

### Подвиг 6 (на повторение). Какую роль играет линкер (редактор связей) при компиляции программы на языке C/C++?

+ [ ] соединяет между собой объектные файлы, формируя единую программу, без добавления какой-либо дополнительной информации
+ [ ] соединяет между собой объектные файлы, формируя единую программу, добавляет код запуска и коды всех библиотечных функций используемых в программе библиотек
+ [ ] объединяет все файлы с текстами программы текущего проекта в единую программу и переводит ее в машинный код
+ [x] соединяет между собой объектные файлы, формируя единую программу, добавляет код запуска и коды используемых библиотечных функций

### Подвиг 7. Напишите по аналогии (с рассмотренной на этом занятии) программу на C++ с выводом на экран строки "I love C++" по следующей схеме:

1. Подключите заголовок `iostream`
2. Запишите функцию `main()`, которая возвращает целочисленное значение типа `int`.
3. В теле функции main с помощью объекта `std::cout` выведите в консоль указанную строку с переводом на новую строку, используя функцию `std::endl`.
4. Пропишите оператор `return`, который возвращает целое число `0`.

P. S. Постарайтесь соблюдать оформление программы, приведенное на этом занятии.

```c
#include <iostream>

int main() {
    std::cout << "I love C++" << std::endl;

    return 0;
}
```

# 9.3 Ввод-вывод с помощью объектов cin и cout

Раз уж мы в первой программе на С++ использовали объект `cout` для вывода строки в стандартный выходной поток, то давайте сразу разберем работу двух таких объектов:
+ `cin` – объект класса `istream` для работы с потоком `stdin`;
+ `cout` – объект класса `ostream` для работы с потоком `stdout`.

Если вы не знакомы с концепцией классов и их объектов, то есть, с ООП языка С++, то фраза «объект класса» вас может поставить в тупик. Конечно, мы сейчас не будем пускаться во все тяжкие и уходить в изучение ООП. На данном этапе будет вполне достаточным воспринимать объекты `cin`/`cout`, как некие переменные, через которые можно работать со стандартными потоками ввода/вывода.

Я напомню, что в курсе по языку Си мы подробно с вами говорили об этих потоках, которые часто обозначаются через определения `stdin`/`stdout`. И я приводил следующую схему их работы:

![09](/Good_good_C_C++/img/09_02.jpg)

Так вот, в С++ вместо функций `printf()`, `scanf()` и им подобных предлагается использовать более дружественные объекты `cout` и `cin`. 

В чем их дружественность и отличия от уже знакомых нам функций ввода/вывода? 

Начнем с более простого объекта `cout`. Чтобы им воспользоваться, в программе на С++ вначале необходимо подключить файл `iostream`. После этого в пространстве имен `std` будет доступен объект `cout`. Затем, объявим в программе несколько переменных разных типов и выведем их в стандартный поток с помощью `cout`. Сделать это можно следующим образом:

```c
#include <iostream>
 
int main() {
    char str[100] = "Hi, Sergey!";
    short old = 99;
    double weight = 82.54;
 
    std::cout << str << "\n";
    std::cout << old << "\n";
    std::cout << weight << std::endl;
}
```

Первое, что бросается в глаза – это вывод значения переменной без дополнительного указания ее типа. Например, если бы мы эту же операцию захотели бы повторить с помощью функции `printf()`, то пришлось бы прописывать форматную строку со спецификаторами:

```c
printf("%s\n%d\n%.2f\n", str, old, weight);
```

При использовании объекта `cout` ничего этого делать не нужно. Просто прописываем переменную, значение которой хотим вывести в поток `stdout` и все.

Если кому интересно, как это все работает «под капотом», то скажу буквально пару слов. 

У каждого класса в С++ можно делать переопределение стандартных операций. В частности, операция `<<` для класса `ostream` переопределена для каждого стандартного, базового типа и компилятор в соответствии с типом переменной (или, в общем случае, по данным в правом операнде), выбирает соответствующую реализацию операции `<<`. Сама же операция `<<` выполняет передачу в выходной поток `stdout` соответствующих данных и возвращает объект `cout`. А раз так, то мы можем записать вывод трех переменных следующим образом:

```c
std::cout << str << '\n' << old << "\n" << weight << std::endl;
```
Получим абсолютно тот же самый результат.

Второе, на что следует обратить внимание – это использование управляющих символов `\n`. Сначала я его прописал, как символ, а второй раз – как строку. Для объекта `cout` это не имеет большого значения, но, конечно, если нам нужно вывести отдельный символ, то лучше это делать через одинарные кавычки.

В самом конце вывода прописана функция `endl`. Она выполняет два действия: переводит курсор на новую строку и очищает выходной буфер, указывая конечному устройству, связанному с выходным потоком, что все данные переданы и их можно обрабатывать. 

В случае с выводом на монитор очистка мало что дает, т.к. информация сразу отображается на экране. Но, вполне могут быть и другие ситуации, когда вместо монитора подключено другое устройство и вывод осуществляется только в момент очистки выходного буфера.

Следующий объект `cin` работает похожим образом, но осуществляет уже считывание информации из стандартного входного потока `stdin` и запись прочитанных данных в указанную переменную или, в общем случае, `lvalue` выражение.

Давайте, для примера выполним считывание данных в переменные `old` и `weight` с помощью `cin` следующим образом:

```c
#include <iostream>
 
int main() {
    char str[100] = "Hi, Sergey!";
    short old = 99;
    double weight = 82.54;
 
    std::cin >> old;
    std::cin >> weight;
    
    std::cout << str << '\n' << old << '\n' << weight << std::endl;
}
```

Обратите внимание, что для объекта `cin` переопределена операция `>>` также для каждого стандартного типа языка С++. 

Поэтому нам достаточно прописать переменную без указания ее типа. Причем после имени переменной не нужно прописывать операцию взятия адреса, как это мы делали в функции `scanf()`. В операции `>>` для этого применяется механизм ссылок. О них мы с вами еще будем подробнее говорить.

Если данные введены верно (целочисленное значение и вещественное), то переменные `old` и `weight` будут содержать корректные введенные значения. 

Причем ввести их можно каждый с новой строки или через пробел. Если во входном потоке `stdin` встречаются данные, не соответствующие типу переменной, то значение переменной обнуляется с неверной интерпретацией последующих операций считывания. Поэтому формат входных данных в `stdin` должен совпадать с типами читаемых данных.

Операция `>>` после чтения порции данных возвращает объект `cin`, поэтому два последовательных вызова `cin` можно объединить в один:

```c
std::cin >> old >> weight;
```

Результат будет тем же самым.

Последний важный момент, связанный с использованием объекта `cin`, это чтение строк из входного потока. Допустим, мы в переменную `str` читаем строковые данные следующим образом:

```c
std::cin >> str;
```

и вводим строку «hello world». В результате в массив `str` будет помещен только первый фрагмент до пробела, то есть, `«hello»`, а второй останется во входном потоке. 

То есть, `cin` со строками работает так же, как и функция `scanf()` языка Си. 

Если вам нужно читать строку целиком (до символа перевода строки или до конца данных), то следует использовать новую функцию `getline()` языка С++. Она работает с объектом `std::string` и речь о ней еще впереди.

Я думаю, вы теперь в целом хорошо понимаете, как использовать объекты `cout`/`cin` языка С++ для работы со стандартными потоками ввода/вывода.

Видео по теме [#2. Ввод-вывод с помощью объектов cin и cout](https://www.youtube.com/watch?v=mi1YqRF03IQ&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Установите соответствия между объектами, операциями и их описаниями.

![09](/Good_good_C_C++/img/09_03.PNG)

### Подвиг 2. Выберите все верные утверждения, касающиеся объектов cin и cout

+ [ ] для использования объектов cin и cout в программе необходимо подключить заголовок stdio.h
+ [x] объекты cin и cout автоматически определяют формат читаемых данных по типу переменных, с которыми они записаны
+ [x] cin - это объект класса istream для работы с потоком stdin
+ [x] для использования объектов cin и cout в программе необходимо подключить заголовок iostream
+ [x] объекты cin и cout располагаются в пространстве имен std
+ [ ] объекты cin и cout располагаются в пространстве имен iostream
+ [x] cout - это объект класса ostream для работы с потоком stdout

### Подвиг 3. Напишите программу, которая читает из входного потока stdin два целых числа, записанных в одну строчку через пробел, и выводит их в консоль в формате:

<первое число>; <второе число>

P. S. Ввод/вывод данных реализовать через объекты `cin`/`cout`.

```c
#include <iostream>

int main() {
    int a, b;
    std::cin >> a >> b;
    std::cout << a << "; " << b << std::endl;

    return 0;
}
```

### Подвиг 4. Напишите программу, которая читает из входного потока stdin два целых числа a и b (a < b), записанных в одну строчку через пробел, и выводит в консоль все числа диапазона [a; b], кратные 3 в порядке возрастания в одну строчку через пробел.

P. S. Ввод/вывод данных реализовать через объекты cin/cout.

```c
#include <iostream>

int main() {
    int a, b;
    std::cin >> a >> b;
    for (int i = a; i <= b; i++) {
        if (i % 3 == 0) std::cout << i << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

### Подвиг 5 (с повторением). Продолжите программу, которая читает в массив data целые числа из входного потока, записанные в одну строчку через пробел. Необходимо контролировать максимальное количество читаемых значений не более max_size_ar. Выведите в консоль в одну строчку через пробел записанные значения в массив data (по порядку от начала до конца).

P. S. Ввод/вывод данных реализовать через объекты cin/cout.

```c
#include <iostream>

using namespace std;

enum { max_size_ar = 20 };

int main() {
    int data[max_size_ar];
    size_t count = 0;
    while (count < max_size_ar && cin.good()) {
        cin >> data[count];
        count++;
    }

    cout << count << '\n';

    for (size_t i = 0; i < count - 1; i++) {
        cout << data[i] << ' ';
    }

    cout << std::endl;

    return 0;
}
```
### Подвиг 6 (с повторением). Продолжите программу, которая читает в массив data целые числа из входного потока, записанные в одну строчку через точку с запятой (или любой другой символьный не числовой разделитель). Необходимо контролировать максимальное количество читаемых значений не более max_size_ar. Выведите в консоль в одну строчку через пробел значения массива data (по порядку от начала до конца).

P. S. Ввод/вывод данных реализовать через объекты cin/cout.

Sample Input:

9; 11; 0; -9; 3; 100; 8; 7; 4
Sample Output:

9 11 0 -9 3 100 8 7 4

```c
#include <iostream>

using namespace std;

enum { max_size_ar = 20 };

int main() {
    int data[max_size_ar];
    size_t count = 0;
    char ch;
    while (count < max_size_ar && cin.good()) {
        cin >> data[count] >> ch;
        count++;
    }

    cout << count << '\n';

    for (size_t i = 0; i < count; i++) {
        cout << data[i] << ' ';
    }

    cout << std::endl;

    return 0;
}
```

### Подвиг 7 (с повторением). Напишите программу. Объявите структуру с именем типа THING и следующими полями:

+ id; идентификатор; тип unsigned int;
+ name; название (строка); максимальная длина max_size_name = 50 (константа max_size_name задается в перечислении);
+ weight; вес; тип double;
+ price; цена; тип unsigned int.

В функции main объявите переменную с именем box типа THING. С помощью объекта cin выполните чтение из входного потока данных, записанных в следующем формате:

<идентификатор> <название> <вес> <цена>

Выведите с помощью объекта cout в консоль структуру box в формате:

<название> <идентификатор>: <вес>, <цена>

```c
#include <iostream>

enum { max_size_name = 50 };
using namespace std;

typedef struct {
    unsigned id;
    char name[max_size_name];
    double weight;
    unsigned price;
} THING;

int main() {
    THING box;

    cin >> box.id >> box.name >> box.weight >> box.price;

    cout << box.name << ' ' << box.id << ": " << box.weight << ", " << box.price << endl;

    return 0;
}
```

### Подвиг 8 (с повторением). Объявите функцию со следующей сигнатурой:

double triangle_sq(int a, int b, int c);
которая вычисляет и возвращает площадь треугольника со сторонами a, b, c. Площадь вычисляется по формуле Герона:

$S = \sqrt{p⋅(p−a)⋅(p−b)⋅(p−c)}$
​
где $p=(a+b+c)/2$ - полупериметр треугольника.

В функции main прочитайте из входного потока три целых натуральных числа, записанных в одну строчку через пробел. Вызовите для них функцию triangle_sq и выведите в консоль значение площади с точностью до сотых.

P. S. Чтение данных из потока stdin выполнить с помощью объекта cin.

Sample Input:

10 12 5
Sample Output:

24.54

```c
#include <cmath>
#include <iostream>

using namespace std;

double triangle_sq(int a, int b, int c) {
    double p = (a + b + c) / 2.0, res;
    res = powf(p * (p - a) * (p - b) * (p - c), 0.5);
    return res;
}

int main() {
    int a, b, c;

    cin >> a >> b >> c;

    double res = triangle_sq(a, b, c);

    printf("%.2lf", res);

    return 0;
}
```

манипуляторы

```c

#include <iostream>
#include <iomanip> // fixed и setprecision
#include <cmath> // sqrt

double triangle_sq(int a, int b, int c);

int main() {
    
    int a, b, c;
    std::cin >> a >> b >> c;
    std::cout << std::fixed << std::setprecision(2) << triangle_sq(a, b, c);
        
    return 0;
}

double triangle_sq(int a, int b, int c) {
    
    double s;
    s = (a + b + c) / 2.0; // полупериметр 
    
    return sqrt(s * (s - a) * (s - b) * (s - c));;
}
```

### Подвиг 9 (на повторение). Выберите все верные утверждения, касающиеся вариадических функций.

+ [x] для обработки вариадических параметров функции необходимо подключение заголовка stdarg.h
+ [ ] вариадическая функция может быть прописана только с вариадическими параметрами
+ [ ] вариадическая функция "знает" о количестве вариадических параметров
+ [x] вариадическая функция должна иметь хотя бы один явно прописанный параметр
+ [x] вариадические параметры всегда располагаются последними в списке параметров функции
+ [x] вариадическая функция "не знает" о настоящем количестве вариадических параметров

### Подвиг 10 (на повторение). Установите соответствия между определениями и функциями и их описаниями.

![09](/Good_good_C_C++/img/09_04.PNG)

### Подвиг 11 (на повторение). Выберите все верные записи вещественных числовых литералов.

P. S. Здесь d - вещественная переменная типа double.

+ [x] d = 3.2e5;
+ [ ] d = e-2;
+ [x] d = -.5;
+ [ ] d = e2;
+ [x] d = 1e-2;
+ [x] d = -1e2;
+ [x] d = 32e-5;
+ [x] d = 123.;

# 9.4 Пространства имен (namespace)

На этом занятии мы с вами познакомимся с новой концепцией языка С++ пространством имен. Из курса по языку Си мы знаем, что в глобальной области видимости можно объявлять функции, переменные, структуры и так далее:

```c
void foo() {
    std::cout << "function: foo()" << std::endl;
}
 
int global_a = 5;
 
struct point {
    double x, y;
};
```

Так вот, в языке С++ все подобные объявления попадают в так называемое глобальное пространство имен. В частности, это означает, что внутри функции `main()` мы можем обращаться к этим определениям следующим образом:

```c
int main() {
    point pt {};
 
    foo();
    std::cout << global_a << std::endl;
 
    return 0;
}
```

или так:

```c
int main() {
    ::point pt {};
 
    ::foo();
    std::cout << ::global_a << std::endl;
 
    return 0;
}
```

Обратите внимание на два двоеточия (программисты еще иногда их называют «четвероточием»). Формально, это символ раскрытия области видимости. Если перед ним (слева) не указана какая-либо область видимости, то подразумевается глобальная область (глобальное пространство имен).

Что нам дает этот символ? Смотрите, если, к примеру, внутри функции `main()` объявить еще одну переменную с именем `global_a`:

```c
int global_a = 10;
```

то мы можем их различать с помощью «четвероточия»:

```c
std::cout << ::global_a << " " << global_a << std::endl;
```

Увидим значения `5` и `10`. Поэтому, если мы хотим быть уверены, что обращаемся к глобальной переменной, то перед ее именем достаточно прописать два двоеточия. В ряде случаев это бывает очень полезно.

Далее, из курса по Си мы знаем, что если в глобальном пространстве имен определить два определения с одинаковыми именами, например, две функции с именем `foo`:

```c
void foo() ...
void foo() ...
```

то компилятор выдаст сообщение об ошибке. Но, несмотря на всю очевидность этого факта, такое все же вполне может произойти. Например, когда над большим проектом работает группа разработчиков, то независимо друг от друга программисты могут создавать совершенно одинаковые прототипы функций с разными реализациями. И при попытке собрать проект целиком возникает описанная проблема.

Или же мы написали свою библиотеку функций или классов, подключаем ее к проекту, где используются другие стандартные библиотеки, и видим тот же конфликт имен. Хотя при разработке своего отдельного модуля мы с этим никак не сталкивались. И подобных ситуаций может быть множество. 

Как же этого избежать? 

Для в С++ существует возможность создавать свои пространства имен, которые позволяют разделять один набор определений от другого набора. Для этого используется ключевое слово namespace, после которого указывается название нового или существующего пространства. Например, так:

```c
namespace firstSpace {
    void foo() {
        std::cout << "function from firstSpace: foo()" << std::endl;
    }
}
 
void foo() {
    std::cout << "function: foo()" << std::endl;
}
```

Здесь название `firstSpace` мы придумываем сами подобно именам переменных и функций, а, затем, в фигурных скобках следует содержимое этого пространства. В нашем примере там располагается функция с именем `foo`. Теперь программа будет компилироваться без проблем, так как функции `foo()` находятся в разных пространствах имен. Но давайте вторую функцию тоже поместим в отдельное пространство с именем `secondSpace`:

```c
namespace secondSpace { 
    void foo() {
        std::cout << "function from secondSpace: foo()" << std::endl;
    }
}
```

Отлично, но как теперь следует вызывать эти функции? Делается это следующим образом:

```c
firstSpace::foo();
```

То есть, сначала указывается название пространства имен, а затем, через два двоеточия элемент этого пространства. В данном случае вызывается функция `foo()`.

Аналогично можно вызвать функцию `foo()` из другого пространства:

```c
secondSpace::foo();
```

После запуска программы видим, что были вызваны две разные функции `foo()` из соответствующих пространств имен. Как видите, все достаточно просто.

Теперь несколько важных деталей. Во-первых, определение одного и того же пространства имен определять в разных местах программы (проекта), например, следующим образом:

```c
namespace firstSpace {
    void foo() {
        std::cout << "function from firstSpace: foo()" << std::endl;
    }
}
 
namespace firstSpace {
    struct point {
        double x, y;
    };
}
```

В результате будет создано пространство `firstSpace` с функцией `foo` и структурой `point`. Это эквивалентно тому, если бы мы их прописали в одном определении `firstSpace`:

```c
namespace firstSpace {
    void foo() {
        std::cout << "function from firstSpace: foo()" << std::endl;
    }
 
    struct point {
        double x, y;
    };
}
```

Данный прием бывает полезен, когда программист разбивает свой проект на несколько файлов и в каждом нужно прописывать свою реализацию одного и того же пространства имен. Тогда в каждом файле достаточно прописать одно и то же имя после ключевого слова `namespace`.

Следующее важное замечание касается вложенных пространств имен. Например, так:

```c
namespace secondSpace {
    namespace functions {
        void foo() {
            std::cout << "function from secondSpace: foo()" << std::endl;
        }
    }
 
    namespace params {
        int global_a = 5;
    }
}
```


Соответственно, обращение к элементам такого пространства будет выглядеть следующим образом:

```c
secondSpace::functions::foo();
std::cout << secondSpace::params::global_a << std::endl;
```

И последний штрих. Если перед именем вложенного пространства прописать ключевое слово `inline`, например, так:

```c
namespace secondSpace {
    inline namespace functions {
        void foo() {
            std::cout << "function from secondSpace: foo()" << std::endl;
        }
    }
    ...
}
```

то доступ к функции `foo()` можно делать следующим образом:

```c
secondSpace::functions::foo();
secondSpace::foo();
```

То есть, имя `inline`-пространства указывать не обязательно.

На этом мы с вами завершим текущее занятие, а на следующем рассмотрим оператор `using`, который позволяет включать все или отдельные определения одного пространства имен в другое.

Видео по теме [#3. Пространства имен (namespace)](https://www.youtube.com/watch?v=mP0inCfi_9w&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, касающиеся пространства имен (namespace) языка С++.

+ [x] при объявлении переменных или функций вне каких-либо конструкций языка С++ они попадают в глобальное пространство имен
+ [ ] пространство имен позволяет разбивать проект на подмодули и отдельно (независимо) их компилировать
+ [ ] при объявлении переменных или функций вне каких-либо конструкций языка С++ они попадают в пространство (namespace) std
+ [x] пространство имен объявляется согласно синтаксису: namespace <идентификатор пространства> {[содержимое пространства имен]}
+ [x] пространство имен позволяет изолировать идентификаторы (имена переменных, функций) с одинаковыми именами при сборке проекта (особенно больших)

### Подвиг 2. Выберите все верные утверждения, касающиеся следующего фрагмента программы:

```c
int module_id = -1;

namespace params {
int global_result = 0;
}

namespace triangle {
double square(int a, int b, int c) {
    double p = (a+b+c) / 2.0;
    return sqrt(p*(p-a)*(p-b)*(p-c));
}
}

namespace params {
typedef union {
    int res_int;
    double res_dbl;
} RESULT;
}
```

+ [ ] в пространстве имен нельзя определять типы данных, поэтому последнее определение params приведет к ошибке
+ [x] в пространстве triangle присутствует функция с именем square
+ [x] в пространстве params описана переменная global_result и тип RESULT
+ [x] обращение к функции square следует прописывать в виде triangle::square
+ [x] символ :: называется символом раскрытия области видимости
+ [ ] в пространстве params будет содержаться только тип RESULT
+ [x] обращение к переменной module_id в теле функций можно записывать в виде module_id или в виде ::module_id
+ [x] обращение к типу RESULT следует записывать в виде params::RESULT

### Подвиг 3. Объявите в программе два пространства имен: triangle и rectangle. В пространстве triangle пропишите функцию с именем perimetr, которая вычисляет периметр треугольника с целочисленными сторонами a, b, c (формула: a+b+c). Вычисленный результат (целочисленный) возвращается этой функцией. По аналогии определите в пространстве имен rectangle функцию с таким же именем perimetr, которая вычисляет периметр прямоугольника с целочисленными сторонами width и height (формула: 2*(width+height)). Вычисленный результат (целочисленный) возвращается этой функцией. 

В функции main прочитайте из входного потока три целых числа a0, a1, a2, записанных в одну строчку через пробел. Вызовите функцию perimetr из пространства triangle с аргументами a0, a1, a2 и функцию perimetr из пространства rectangle с аргументами a0, a1. Выведите в консоль в одну строчку через пробел два вычисленных периметра: сначала для треугольника, а затем для прямоугольника.

Sample Input:

3 4 5
Sample Output:

12 14

```c
#include <cmath>
#include <iostream>

using namespace std;

namespace triangle {
int perimetr(int a, int b, int c) {
    int p = a + b + c;
    return p;
}
}  // namespace triangle

namespace rectangle {
int perimetr(int a, int b) {
    int p = (a + b) * 2;
    return p;
}
}  // namespace rectangle

int main() {
    int a0, a1, a2;

    cin >> a0 >> a1 >> a2;

    int res1 = triangle::perimetr(a0, a1, a2);
    int res2 = rectangle::perimetr(a0, a1);

    printf("%d %d", res1, res2);

    return 0;
}
```

### Подвиг 4. Объявите в программе пространство имен math, в котором пропишите функцию сравнения двух целочисленных массивов типа short со следующей сигнатурой:

int ar_compare(const short* a1, size_t len_a1, const short* a2, size_t len_a2);
Функция возвращает 1, если переданные массивы a1 и a2 равны, и 0 в противном случае. Массивы считаются равными, если равны их длины и попарно все  элементы массивов a1 и a2 между собой. То есть, первый элемент массива a1 должен быть равен первому элементу массива a2 и так до конца для всех их элементов.

В функции main с помощью функции ar_compare сравните между собой два следующих массива:

short ar1[] = {1, 2, 3, 4, 5};
short ar2[] = {1, 2, 5, 3, 4};
Результат сравнения сохраните в целочисленной переменной res.

P. S. В консоль ничего выводить не нужно.

```c
#include <cmath>
#include <iostream>

using namespace std;

namespace math {
int ar_compare(const short* a1, size_t len_a1, const short* a2, size_t len_a2) {
    if (len_a1 != len_a2) {
        return 0;
    } else {
        for (size_t i = 0; i < len_a1; i++) {
            if (a1[i] != a2[i]) {
                return 0;
            }
        }
    }
    return 1;
}
}  // namespace math

int main() {
    short ar1[] = {1, 2, 3, 4, 5};
    short ar2[] = {1, 2, 5, 3, 4};

    int res = math::ar_compare(ar1, sizeof(ar1) / sizeof(*ar1), ar2, sizeof(ar2) / sizeof(*ar2));

    printf("%d", res);

    return 0;
}
```

### Подвиг 5 (с повторением). Объявите в программе пространство имен array_alg. В этом пространстве объявите функцию sorted_int со следующей сигнатурой:

```c
void sorted_int(int* ar, size_t len_ar, TYPE_SORT type);
```

Здесь
+ `ar` - сортируемый массив;
+ `len_ar` - число первых сортируемых элементов массива `ar`;
+ `type` - тип сортировки (по возрастанию или убыванию). 

Тип сортировки `TYPE_SORT` определяется в том же пространстве имен `array_alg` как перечисление с двумя константами:
+ `sort_asc` - сортировка по возрастанию;
+ `sort_desc` - сортировка по убыванию.

В функции `main` прочитайте из входного потока целые числа, записанные в одну строчку через пробел, в количестве не более 20. Все эти значения занесите в массив (по порядку) и отсортируйте массив по убыванию с помощью функции `sorted_int`. Выведите в консоль отсортированные значения в одну строчку через пробел.

Sample Input:

45 324 645 324 2 -10 11 0 -54 2

Sample Output:

645 324 324 45 11 2 2 0 -10 -54

```c
#include <iostream>

using namespace std;

enum { max_len = 20 };

namespace array_alg {

typedef enum { sort_asc, sort_desc } TYPE_SORT;

void swap(int* a, int* b) {
    int tmp = *a;
    *a = *b;
    *b = tmp;
}

void sorted_int(int* ar, size_t len_ar, TYPE_SORT type) {
    for (size_t i = 0; i < len_ar; i++) {
        for (size_t j = i + 1; j < len_ar; j++) {
            switch (type) {
                case sort_asc:
                    if (ar[i] > ar[j]) swap(&ar[i], &ar[j]);
                    break;
                case sort_desc:
                    if (ar[i] < ar[j]) swap(&ar[i], &ar[j]);
                    break;
            }
        }
    }
}

}  // namespace array_alg

int main() {
    int array[max_len];

    size_t count = 0;

    while (count < max_len && cin.good()) {
        cin >> array[count++];
    }

    array_alg::sorted_int(array, count, array_alg::sort_desc);

    for (size_t i = 0; i < count; i++) {
        cout << array[i] << ' ';
    }

    return 0;
}
```

### Подвиг 6 (с повторением). Объявите в программе пространство имен array_alg. В этом пространстве объявите функцию filter_int, которая должна оставлять только определенные значения в массиве. Эта функция должна иметь следующую сигнатуру:

```c
size_t filter_int(int* ar, size_t len_ar, PTR_FILTER_FUNC func);
```

Здесь:
+ `ar` - обрабатываемый массив;
+ `len_ar` - начальная длина массива `ar`;
+ `func` - указатель на функцию для отбора (фильтрации) значений массива `ar`. 

Функция `filter_int` должна возвращать результирующую длину массива `ar` (количество оставшихся в нем элементов).

Указатель `PTR_FILTER_FUNC` должен быть определен в пространстве имен `array_alg` для функций с сигнатурой:

```c
int <имя_функции> (int);
```

Если такая функция, вызванная для определенного элемента массива, возвращает истину (не нулевое значение), то это значение остается в массиве, а иначе - удаляется. При удалении размер массива `len_ar` также должен уменьшаться. 

В пространстве имен `array_alg` объявите еще одно пространство имен (вложенное) с именем `filter_func` и объявите в нем функцию с именем even для отбора четных значений массива (четные значения должны оставаться).

В функции `main` прочитайте из входного потока целые числа, записанные в одну строчку через пробел, в количестве не более 20. Все эти значения занесите в массив (по порядку) и отфильтруйте его с помощью функции `filter_int` с передачей в качестве критерия фильтрации функцию `even`. То есть, в массиве должны оставаться только четные числа или никаких, если четных чисел нет. Выведите в консоль отфильтрованные значения в одну строчку через пробел.

Sample Input:

5 34 10 4 7 8 3 2
Sample Output:

34 10 4 8 2

```c
#include <iostream>

enum { max_len = 20 };

namespace array_alg {

typedef int (*PTR_FILTER_FUNC)(int);

namespace filter_func {

int even(int a) { return a % 2 == 0; }
}  // namespace filter_func

PTR_FILTER_FUNC func = filter_func::even;

size_t filter_int(int* ar, size_t len_ar, PTR_FILTER_FUNC func) {
    size_t count = 0;
    for (size_t i = 0; i < len_ar; i++) {
        if (func(ar[i])) ar[count++] = ar[i];
    }
    return count;
}

}  // namespace array_alg

int main() {
    int array[max_len];

    size_t count = 0;

    while (count < max_len && scanf("%d", &array[count]) == 1) count++;

    count = array_alg::filter_int(array, count, array_alg::filter_func::even);

    for (size_t i = 0; i < count; i++) {
        printf("%d ", array[i]);
    }

    return 0;
}
```

### Подвиг 7 (с повторением). Объявите в программе пространство имен array_alg. В этом пространстве объявите функцию add_int, которая должна добавлять к массиву только определенные значения из другого массива. Эта функция должна иметь следующую сигнатуру:

```c
size_t add_int(int* src, size_t start, size_t max_len_src, const int* dest, size_t len_dest, PTR_FILTER_FUNC func);
```

+ `src` - массив, в который добавляются новые значения; 
+ `start` - начальный индекс, с которого происходит добавление в массив src; 
+ `max_len_src` - длина массива src; 
+ `dest` - массив, из которого добавляются значения;
+ `len_dest` - количество добавляемых элементов из массива dest в массив src;
+ `func` - указатель на функцию для отбора (фильтрации) значений массива dest.  

Функция `add_int` должна возвращать новую результирующую длину массива `src`. Указатель `PTR_FILTER_FUNC` должен быть определен в пространстве имен `array_alg` для функций с сигнатурой:

```c
int <имя_функции> (int);
```

Если такая функция, вызванная для определенного элемента массива `dest`, возвращает истину (не нулевое значение), то это значение добавляется в массив `src`, а иначе - пропускается.

При добавлении значений нужно контролировать возможное превышение длины `max_len_src` массива `src`. При достижении значения `max_len_src` процесс добавления следует останавливать.

В пространстве имен `array_alg` объявите еще одно пространство имен (вложенное) с именем `filter_func` и объявите в нем функцию с именем `mark_positive` для отбора оценок от `4` и выше (значения >= `4` должны добавляться).

Продолжите функцию `main` прочитайте из входного потока целые числа в массив `ar`, записанные в одну строчку через пробел, в количестве не более `20`. С помощью функции `add_int` добавьте в массив `marks` прочитанные значения из массива `ar` с передачей в качестве критерия добавления функцию `mark_positive`. Выведите в консоль сформированные значения массива `marks` в одну строчку через пробел в порядке их следования, начиная с первого.

Sample Input:

2 5 4 3 3 2

Sample Output:

3 2 5 4 3 5 4

```c
#include <iostream>

enum { max_len = 20, max_len_marks = 100 };

namespace array_alg {

typedef int (*PTR_FILTER_FUNC)(int);

namespace filter_func {

int mark_positive(int a) { return a >= 4; }
}  // namespace filter_func

PTR_FILTER_FUNC func = filter_func::mark_positive;

size_t add_int(int* src, size_t start, size_t max_len_src, const int* dest, size_t len_dest,
               PTR_FILTER_FUNC func) {
    for (size_t i = 0; i < len_dest; i++) {
        if (func(dest[i])) {
            src[start++] = dest[i];
            if (start == max_len_src) break;
        }
    }

    return start;
}

}  // namespace array_alg

int main() {
    int marks[max_len_marks] = {3, 2, 5, 4, 3};
    int ar[max_len];
    size_t count = 0, count_marks = 5;

    while (count < max_len && scanf("%d", &ar[count]) == 1) count++;

    count = array_alg::add_int(marks, count_marks, max_len_marks, ar, count,
                               array_alg::filter_func::mark_positive);

    for (size_t i = 0; i < count; i++) {
        printf("%d ", marks[i]);
    }

    return 0;
}
```

### Подвиг 8 (на повторение). Выберите все верные утверждения, касающиеся следующих объявлений указателей:

```c
const int* ptr_cnst;
int * const cnst_ptr;
```

+ [ ] через указатель ptr_cnst можно читать и записывать значения в ячейки памяти
+ [x] имя массива в языке Си подобно (по принципу использования) указателю cnst_ptr
+ [x] через указатель cnst_ptr можно читать и записывать значения в ячейки памяти
+ [x] указатель cnst_ptr не может менять значение своего адреса, который задается при инициализации
+ [x] через указатель ptr_cnst можно только читать значения из ячеек памяти, но не записывать
+ [x] указатель ptr_cnst может менять значение своего адреса в процессе выполнения программы
+ [ ] через указатель cnst_ptr можно только читать значения из ячеек памяти, но не записывать

### Подвиг 9 (на повторение). Выберите все верные (работающие) конструкции со следующими указателями:

```c
int* ptr;
const int* ptr_cnst;
int * const cnst_ptr;
```

+ [x] --ptr_cnst;
+ [ ] *ptr_cnst = 10;
+ [ ] ptr = ptr_cnst;
+ [x] ptr_cnst = ptr;
+ [x] *cnst_ptr = 77;
+ [ ] cnst_ptr++;
+ [ ] cnst_ptr = ptr;
+ [x] ptr = cnst_ptr;

# 9.5 Оператор using

## Оператор using

На прошлых занятиях для обращения к элементам пространства имен `std` нам приходилось прописывать `std::cin`, `std::cout` и так далее. 

Это не очень удобно. 

Если в модуле (файле) предполагается постоянное использование каких-либо элементов из того или иного пространства имен, то эти элементы можно импортировать непосредственно в этот модуль. В частности, для этого предназначен оператор `using`. Использовать его можно в соответствии со следующим синтаксисом:

```c
using <пространство имен>::<элемент>;
```

Например, чтобы импортировать объекты `cin`/`cout` и функцию `endl` в текущий модуль в глобальное пространство имен, достаточно прописать:

```c
#include <iostream>
 
using std::cout;
using std::cin;
using std::endl;
 
int main() {
    char str[50];
 
    cin >> str;
    cout << "Hello, " << str << "!" << endl;
 
    return 0;
}
```

Если же этот оператор прописать в каком-либо блоке, например, в теле функции `main()`, то импорт будет сделан в пределах этого блока:

```c
#include <iostream>
 
int main() {
    using std::cout;
    using std::cin;
    using std::endl;
 
    char str[50];
 
    cin >> str;
    cout << "Hello, " << str << "!" << endl;
 
    return 0;
}
```

Соответственно, определения `cout`, `cin` и `endl` доступны теперь только внутри тела функции `main()` и не доступны за его пределами.

Обычно, на практике, отдельные элементы импортируются в глобальную область или в пространство имен, где их активно предполагается использовать. А вот делать импорт всех определений того или иного пространства имен следует исключительно в локальные области.

Давайте посмотрим, как синтаксически выполняется импорт всего пространства. Для этого также прописывается ключевое слово `using`, за которым следует еще одно ключевое слово `namespace` с указанием имени импортируемого пространства. Например:

```c
int main() {
    using namespace std;
    // using std::cout;
    // using std::cin;
    // using std::endl;
 
    char str[50];
 
    cin >> str;
    cout << "Hello, " << str << "!" << endl;
 
    return 0;
}
```

В результате, все определения из `std` становятся доступными напрямую в теле функции `main()`. И, еще раз, обратите внимание. Писать подобный импорт в глобальной области – крайне плохая практика:

```c
#include <iostream>
 
using namespace std;
 
int main() {
    char str[50];
 
    cin >> str;
    cout << "Hello, " << str << "!" << endl;
 
    return 0;
}
```

Часто, далеко не все, что прописано в `std`, используется в текущем модуле. И программист вполне может случайно объявить переменную или функцию или что-либо еще с тем же именем, что и импортированный элемент. Возникнет конфликт имен и компиляция программы завершится с ошибкой. Как раз чтобы этого избежать, лучше явно указывать импортируемые элементы:

```c
using std::cout;
using std::cin;
using std::endl;
```

Или, в крайнем случае, делать полный импорт в локальную область видимости.

## Определение псевдонимов типов

Но это еще не все, что умеет делать оператор `using`. С его помощью можно создавать псевдонимы (алиасы) существующих в программе типов данных. Делается это по следующему синтаксису:

```c++
using <alias> = <тип данных>;
```

Например, в самом простом варианте, можно прописать что-то вроде:

```c++
using byte_8 = unsigned char;
```

В программе появляется новое имя `byte_8` базового типа `unsigned char`, которое полноценно можно использовать следующим образом:

```c++
byte_8 byte;
byte_8* byte_ptr;
```
Или, такой пример. Пусть у нас в программе объявлено пространство имен с определением функции и структуры:

```c++
namespace firstSpace {
    void foo() {
        cout << "function from firstSpace: foo()" << endl;
    }
 
    struct point {
        double x, y;
    };
}
```

Тогда для типа `firstSpace::point` можно создать псевдоним следующим образом:

```c++
using point2D = firstSpace::point;
```

и использовать его для объявления соответствующей переменной на структуру:

```c
point2D pt;
```

При этом прежний тип `firstSpace::point`, конечно же продолжает существовать. Мы лишь создаем еще одно имя этого типа не более того. И `using` создает псевдонимы именно для типов данных. Например, запись вида:

```c++
using func = firstSpace::foo;
```

приведет к ошибке, т.к. `foo` – это имя функции, а не тип данных.

Вообще конструкция

```c++
using <alias> = <тип данных>;
```

очень напоминает оператор `typedef` языка Си. Например, с его помощью мы также можем записать:

```c++
typedef unsigned char byte_8;
typedef firstSpace::point point2D;
```

На первый взгляд никаких отличий. Но они все же имеются. Оператор `using` полностью покрывает функциональность оператора `typedef` и привносит некоторые дополнительные возможности и улучшения. Например, объявление типа указателя на функцию через `typedef` выглядит так:

```c
typedef float (*func_ptr)(int);
```

а с использованием `using` несколько понятнее и красивее:

```c++
using func_ptr = float (*)(int);
```

Но, конечно, главное преимущество `using` перед `typedef` проявляются при работе с шаблонами (`templates`). 

Но это уже выходит за пределы нашего базового курса по С++. 

Отмечу лишь, что в современных программах на С++ нет смысла использовать `typedef` и от него лучше отказываться в пользу оператора `using`. 

Хотя это не строгое правило и применение `typedef` все же допустимо.

Видео по теме [#4. Оператор using](https://www.youtube.com/watch?v=IJEga9b25gQ&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, касающиеся оператора using языка С++.

+ [x] не рекомендуется с помощью using импортировать пространство имен целиком в глобальную область
+ [x] оператор using позволяет создавать псевдонимы для существующих в программе типов данных
+ [x] оператор using позволяет импортировать пространство имен целиком
+ [x] допускается делать импорт отдельных элементов в глобальную область из пространств имен
+ [x] оператор using позволяет импортировать отдельные элементы из указанного пространства имен

### Подвиг 2. Выберите все верные варианты записи импортов из пространства имен std.

+ [ ] using std.endl;
+ [ ] using namespace std::cout;
+ [ ] using std::std::cin;
+ [x] using namespace std;
+ [x] using std::cout;
+ [ ] using std namespace;

### Подвиг 3. Выполните в программе импорт элементов cin, cout и endl в глобальную область и в функции main прочитайте из входного потока слово (максимальная длина 50 символов) и выведите его в консоль.

Sample Input:

Straustrup
Sample Output:

Straustrup

```c++
#include <iostream>

enum { max_len_str = 50 };

using std::cin;
using std::cout;
using std::endl;

int main() {
    char str[50];

    cin >> str;
    cout << str << endl;

    return 0;
}
```

### Подвиг 4. Учитывая приведенный фрагмент программы, выберите все верные варианты определения алиасов (псевдонимов) с помощью оператора using языка С++.

```c
int global_var = 1;

namespace test {
typedef union {
    char ch;
    int vi;
    double vd;
} VAR;

int odd(int x) {
    return x % 2 != 0;
}
}
```

+ [x] using AR_INT = int[10];
+ [x] using UINT = unsigned int;
+ [ ] using TEST = test;
+ [x] using DATA = test::VAR;
+ [x] using VOLUME = struct {int width, height, depth;};
+ [x] using PTR_STR = char*;
+ [ ] using GVAR = global_var;
+ [ ] using ptr_func = test::odd;

### Подвиг 5. С использованием оператора using объявите в программе структуру с типом AUTO, содержащую следующие поля:
+ `model` - строка максимальной длины 50 символов;
+ `max_speed` - максимальная скорость (тип `unsigned short`);
+ `weight` - вес (тип `double`);
+ `m` - габариты (тип `MEASURE`).

Тип `MEASURE` также следует определить с помощью оператора `using` и представлять собой структуру со следующими полями типа `unsigned short`:
+ `width` - ширина;
+ `height` - высота;
+ `depth` - глубина (длина).

Продолжите функцию `main`. Занесите в поля переменной `auto_sell` данные из соответствующих переменных: `model`, `weight`, `max_speed`, `width`, `height`, `depth`.

P. S. В консоль ничего выводить не нужно.

Sample Input:

toyota 240 1540.3 230 120 545

```c
#include <string.h>

#include <iostream>

using MEASURE = struct {
    unsigned short width;
    unsigned short height;
    unsigned short depth;
};

using AUTO = struct {
    char model[50];
    unsigned short max_speed;
    double weight;
    MEASURE m;
};

int main() {
    AUTO auto_sell;
    char model[50];
    unsigned short max_speed, width, height, depth;
    double weight;

    std::cin >> model >> max_speed >> weight >> width >> height >> depth;

    strcpy(auto_sell.model, model);
    auto_sell.max_speed = max_speed;
    auto_sell.weight = weight;
    auto_sell.m.width = width;
    auto_sell.m.height = height;
    auto_sell.m.depth = depth;

    // __ASSERT_TESTS__

    return 0;
}
```

### Подвиг 6. С помощью оператора using объявите в программе новый тип данных FIO_STR, соответствующий массиву символов длиной 50 элементов. С помощью оператора using объявите новый тип FIO, описывающий структуру с тремя полями типа FIO_STR:

first - имя;
otch - отчество;
last - фамилия.
Продолжите функцию main. Объявите в ней переменную fio типа FIO и прочитайте из входного потока в ее поля имя, отчество и фамилию, записанные в одну строчку через пробел.

P. S. В консоль ничего выводить не нужно.

Sample Input:

Bjarne - Stroustrup

```c
#include <iostream>

enum { max_len_str = 50 };

using FIO_STR = char[max_len_str];

using FIO = struct {
    FIO_STR first;
    FIO_STR otch;
    FIO_STR last;
};
using std::cin;
// using std::cout;

int main() {
    FIO fio;

    cin >> fio.first >> fio.otch >> fio.last;

    // cout << fio.first << ' ' << fio.otch << ' ' << fio.last;
    // __ASSERT_TESTS__
    return 0;
}
```

### Подвиг 7. С помощью оператора using объявите в программе тип THING, описывающий структуру со следующими полями:
+ `name` - название предмета; строка максимальной длиной 50 символов;
+ `weight` - вес предмета (тип double).

В функции `main` объявите массив с именем `th` типа `THING` из `max_things` элементов. Константа `max_things` = 20 должна быть определена с помощью перечисления. Прочитайте из входного потока данные по предметам в формате:

```c
<название_1> <вес_1> <название_2> <вес_2> ... <название_N> <вес_N> 
```

Общее количество прочитанных из входного потока предметов не должно превышать значения `max_things` (это нужно контролировать в программе).

Выполните сортировку массива `th` по возрастанию весов предметов. Выведите в консоль названия предметов в порядке сортировки в одну строчку через пробел.

Sample Input:

карандаш 20 зеркальце 100 зонт 500 рубашка 300

Sample Output:

карандаш зеркальце рубашка зонт

```c++
#include <iostream>

enum { max_len_str = 50, max_things = 20 };

using THING = struct {
    char name[max_len_str];
    double weight;
};

using std::cin;
using std::cout;

void swap_struct(THING* a, THING* b) {
    THING tmp = *a;
    *a = *b;
    *b = tmp;
}

int main() {
    THING th[max_things];
    size_t count = 0;

    while (count < max_things && cin >> th[count].name >> th[count].weight) count++;

    for (size_t i = 0; i < count; i++) {
        for (size_t j = i; j < count; j++) {
            if (th[i].weight > th[j].weight) swap_struct(&th[i], &th[j]);
        }
    }

    for (size_t i = 0; i < count; i++) {
        cout << th[i].name << ' ';
    }

    return 0;
}
```

### Подвиг 8. Объявите в программе структуру с именем типа THING со следующими полями:

name - название предмета; строка максимальной длиной 50 символов;
weight - вес предмета (тип unsigned int).
В функции main объявите массив things типа THING со следующими данными (предметами):

{"карандаш", 20}, {"зеркальце", 100}, {"зонт", 500}, {"рубашка", 300}, 
{"брюки", 1000}, {"бумага", 200}, {"молоток", 600}, {"пила", 400}, {"удочка", 1200},
{"расческа", 40}, {"котелок", 820}, {"палатка", 5240}, {"брезент", 2130}, {"спички", 10}

Здесь указано название и вес предмета в граммах.

Сергей собирается в поход и готов взвалить на свои хрупкие плечи максимальный вес в N кг (вводится с клавиатуры). Он решил класть в рюкзак предметы в порядке убывания их веса (сначала самые тяжелые, затем, все более легкие) так, чтобы их суммарный вес не превысил значения N кг. Все предметы даны в единственном экземпляре. Выведите в консоль названия предметов (в строчку через пробел), которые берет с собой Сергей.

P. S. 1 кг = 1000 грамм

Sample Input:

2
Sample Output:

удочка молоток бумага

```c++
#include <iostream>

enum { max_len_str = 50, max_things = 20 };

using THING = struct {
    char name[max_len_str];
    unsigned weight;
};

using std::cin;
using std::cout;

void swap_struct(THING* a, THING* b) {
    THING tmp = *a;
    *a = *b;
    *b = tmp;
}

int main() {
    THING things[] = {{"карандаш", 20},  {"зеркальце", 100}, {"зонт", 500},    {"рубашка", 300},
                      {"брюки", 1000},   {"бумага", 200},    {"молоток", 600}, {"пила", 400},
                      {"удочка", 1200},  {"расческа", 40},   {"котелок", 820}, {"палатка", 5240},
                      {"брезент", 2130}, {"спички", 10}};
    size_t count = 14;

    for (size_t i = 0; i < count; i++) {
        for (size_t j = i; j < count; j++) {
            if (things[i].weight < things[j].weight) swap_struct(&things[i], &things[j]);
        }
    }

    unsigned weight;

    cin >> weight;

    weight *= 1000;

    for (size_t i = 0; i < count; i++) {
        if (weight && things[i].weight <= weight) {
            cout << things[i].name << ' ';
            weight -= things[i].weight;

        } else break;
    }

    return 0;
}
```

### Подвиг 9 (на повторение). Выберите все верные утверждения, касающиеся объявления и использования функций языка Си.

+ [x] перед каждым параметром функции обязательно указывать его тип данных
+ [x] часто в функции выносят многократно повторяющиеся (используемые) фрагменты программного кода
+ [ ] если функция не возвращает никаких значений, то тип данных у нее не прописывается
+ [x] в качестве имен функций следует использовать глаголы
+ [x] объявление функций выполняется согласно синтаксису: <тип данных> <имя функции>([набор параметров]) {[операторы тела функции]}
+ [x] функция может быть вызвана в любом (допустимом) месте программы произвольное число раз
+ [x] оператор вызова функции - это круглые скобки, стоящие после ее имени
+ [x] если функция не возвращает никаких значений, то у нее прописывается тип void

### Подвиг 10 (на повторение). Выберите все верные утверждения, касающиеся следующего фрагмента программы.

```c
int get_square(int x) {
    return x * x;
}

int main(void) {
    int a = 7, b = 7, c = 7;
    int res_1 = get_square(a);
    int res_2 = get_square(b++);
    int res_3 = get_square(--c);

    return 0;
}
```

+ [ ] переменная res_2 принимает значение 64
+ [x] переменная res_1 принимает значение 49
+ [x] переменная res_2 принимает значение 49
+ [x] функция get_square возвращает квадрат переданного ей целого числа
+ [x] переменная res_3 принимает значение 36
+ [ ] переменная res_3 принимает значение 49

# 9.6 Новые типы данных. Приведение типов указателей

## Новые типы данных.

Продолжаем изучение дополнительных возможностей языка С++ и это занятие начнем с рассмотрения некоторых дополнительных типов данных. Сразу отмечу, что в С++ присутствуют все стандартные (базовые) типы языка Си, но дополнительно введено еще несколько:
+ `bool` – булевый тип (1 байт), принимающий два состояния true/false;
+ `wchar_t` – расширенный символьный тип (2 байта в ОС Windows; 4 байта в ОС Linux);
+ `char8_t` – символьный тип (1 байт) для символов кодировки Unicode (UTF-8) (добавлен в стандарте С++20);
+ `char16_t` – символьный тип (2 байта) для символов кодировки Unicode (UTF-16);
+ `char32_t` – символьный тип (4 байта) для символов кодировки Unicode (UTF-32).

Наибольший интерес здесь представляет тип bool, которого не хватало в языке Си. Пользоваться им очень просто. Вначале объявляется переменная этого типа, например:

```c++
bool fl_print = false;
```

а, затем, можно изменить ее значение на `true`:

```c++
fl_print = true;
```

Переменные типа bool обычно используют в условных выражениях. В частности, мы можем записать такую конструкцию:

```c++
    if (fl_print) {
        std::cout << "Hi!" << std::endl;
    }
```

Вообще, значение `false` соответствует целому числу `0`, а `true` – единице. Поэтому, запись вида:

```c++
fl_print = 1;
```

будет эквивалентна предыдущей. Тип `bool` и ключевые слова `true`/`false` введены для удобства написания и понимания программы. Принципиально нового на уровне машинных кодов ничего не появляется.

Следующий тип `wchar_t` используется для представления символов, коды которых выходят за пределы одного байта (типа char). Как мы знаем, это, например, могут быть символы кодировки `Unicode`. Если записать:

```c
wchar_t wch;
wch = L'Я';
```

и вывести значение кода буквы ‘Я’:

```c++
std::cout << wch << std::endl;
```

то увидим число `1071`. Это значение символа ‘Я’ в кодировке `UTF8`, т. к. текст программы сохранен в файле в этой кодировки. Причем, смотрите, если мы попытаемся этот же символ присвоить переменной типа `char`:

```c
char ch = 'Я';
```

то компилятор выдаст предупреждение, что код символа выходит за диапазон типа `char`. А вот с латинскими символами таких проблем уже не возникает:

```c
char ch = 'd';
```

так как их коды не превышают `127`.

Еще одно важное отличие языка С++ от Си состоит в том, что символьные литералы, записанные в программе, приводятся компилятором к типу `char`, а не `int`, как это было в языке Си. 

Во всем остальном, работа с отдельными символами или их последовательностями остается прежней. Например, можно объявить строковый литерал следующим образом:

```c
char str[] = "Привет мир!";
```

и вывести это сообщение в консоль:

```c++
std::cout << str << std::endl;
std::cout << sizeof(str) << std::endl;
```

Увидим строку «Привет мир!» и число `21`. Почему размер массива равен `21`, а не `11` по числу символов? 

Очевидно, что под русские символы здесь отводится два байта (кодировка UTF8), поэтому и размер становится больше.

Если мы далее запишем:

```c
char ch = str[0];
printf("ch = %c\n", ch);
```

то увидим вывод не символа буквы ‘П’, а кракозябру. Но, если прописать:

```c++
wchar_t str[] = L"Привет мир!";
wchar_t ch = str[0];
 
std::cout << ch << std::endl;
```

то переменная `ch` будет содержать корректный код первого символа строки.

Обратите внимание, все эти изменения актуальны для кодировок, отличающихся от кодировки ASCII, где символы латинского и русского алфавитов умещались в диапазон [0; 255], то есть, в один байт. Если, например, используется кодовая страница Windows-1251, то символы можно по-прежнему обрабатывать переменными типа `char`.

## Приведение типов указателей

Следующее важное отличие языка С++ от Си проявляется в приведении разных типов указателей друг к другу. Пусть, например, объявлены два следующих указателя:

```c
int* ptr_i = 0L;
char* ptr_ch = 0L;
```

В языке Си, далее, мы могли бы записать команду:

```c
ptr_ch = ptr_i;
```

и она бы скомпилировалась с предупреждением, что типы указателей не совпадают. Язык С++ работает строже. Если типы указателей не совпадают, то компиляция останавливается с сообщением об ошибке. Поэтому здесь нам нужно явно прописывать операцию приведения типов:

```c
ptr_ch = (char *)ptr_i;
```

сообщая компилятору, что мы знаем, что делаем и адрес указателя `ptr_i` нужно присвоить указателю `ptr_ch`.

Та же самая ситуация возникает и с обобщенным указателем `*void` языка Си:

```c
void* ptr_void = 0L;
```

Чтобы присвоить адрес, который хранится в `ptr_void`, нужно также явно прописывать операцию приведения типов:

```c
ptr_i = (int *)ptr_void;
```

Напомню, что в языке Си использование указателей `*void` с другими типами даже не приводило к предупреждениям. В С++ ситуация изменилась кардинально. В частности, из-за этого при выделении памяти с помощью функции `malloc()` нужно дополнительно записывать приведение типов:

```c
ptr_i = (int *)malloc(sizeof(int) * 5);
```

Далее, в С++ не принято использовать константу `NULL` для указания нулевого адреса. Пишется просто числовой литерал `0L`. Начиная со стандарта С++11 был введен специальный «нулевой» указатель с ключевым словом `nullptr`:

```c++
char* ptr_ch = nullptr;
printf("%p\n", ptr_ch);
```

В данном случае видим все то же значение `0`.

Если версия компилятора языка С++ позволяет использовать `nullptr`, то рекомендуется его применять для обозначения «нулевого» указателя.

В заключение этого занятия отмечу еще одно популярное нововведение в языке С++ - новую форму записи цикла for для перебора коллекций. Давайте я покажу его на конкретном примере. Пусть у нас имеется строка:

```c
char msg[] = "I like C++ language";
```

С точки зрения языка С++ - это коллекция (последовательность), которую можно перебирать. Воспользуемся для этого новой формой цикла `for`:

```c++
for (char x : msg) 
    std::cout << x << " ";
```

После запуска увидим:

```
I   l i k e   C + +   l a n g u a g e
```

То есть, массив `msg` был последовательно (от начала до конца) перебран и на каждой итерации в переменную `x` помещался текущий символ. 

В теле цикла символы выводились через пробел. Видите, как удобно можно проходить по коллекциям целиком, используя новую форму записи цикла `for`. Причем, цикл проходит именно по массиву, а не по строке. Например, если указать больший размер массива:

```c
char msg[30] = "I like C++ language";
```

то при выводе дополнительно увидим значение `NUL` в консоли, которые присутствуют в массиве `msg`. Это же касается и всех других коллекций, например, динамических массивов (`std::vector`) или связных списков (`std::list`) и многих других последовательностей библиотеки `STL`.

На следующем занятии мы продолжим знакомиться с дополнительными возможностями языка С++, которые качественно отличают его от языка Си.

Видео по теме [#5. Новые типы данных. Приведение типов указателей](https://www.youtube.com/watch?v=riEH_BMy_QE&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Установите соответствия между типами переменных языка С++ и их описаниями.

![09](/Good_good_C_C++/img/09_05.PNG)

### Подвиг 2. Выберите все верные варианты инициализации булевых переменных.

+ [x] bool b_3 = 10;
+ [x] bool b_1 = true;
+ [ ] bool b_6 = b_1 | b_2; // b_1, b_2 - булевы переменные
+ [ ] bool b_5 = b_1 & b_2; // b_1, b_2 - булевы переменные
+ [x] bool b_2 = false;
+ [x] bool b_4 = 5 - 5;

### Подвиг 3. Напишите программу, в которой происходит считывание целочисленных значений, записанных через пробел, пока не будет введено число 0. Необходимо определить, что все введенные числа являются четными. Для этого используйте булеву переменную с именем fl_even и начальным значением true. Если все введенные числа четные, то fl_even должна быть равна true, иначе - false. Выведите в консоль строку "even" если все числа четные, или строку "no" если хотя бы одно число нечетное.

P. S. Для красоты программного кода используйте операцию & для обновления значения переменной fl_even на каждой итерации. А при выводе в консоль той или иной строки - тернарный условный оператор.

Sample Input:

1 2 3 4 5 6 7 0
Sample Output:

no

```c++
#include <iostream>

enum { max_len_numbers = 100 };

using std::cout;

int main() {
    int numbers[max_len_numbers];
    size_t count = 0;
    bool fl_even = true;

    while (scanf("%d", &numbers[count]) == 1 && numbers[count] != 0) {
        fl_even *= (numbers[count] % 2 == 0);
        count++;
    }

    cout << (fl_even ? "even" : "no");
    return 0;
}
```

### Подвиг 4. Напишите программу, в которой происходит считывание целочисленных значений, записанных через пробел, пока не будет введено число 0. Необходимо определить, что хотя бы одно введенное число является четным (последнее число 0 не учитывается). Для этого используйте булеву переменную с именем fl_even и начальным значением false. Если введено хотя бы одно четное число, то fl_even должна быть равна true, иначе - false. Выведите в консоль строку "even" если было найдено четное число, или строку "no" если все числа нечетные.

P. S. Для красоты программного кода используйте операцию (подумайте какую) для обновления значения переменной fl_even на каждой итерации. А при выводе в консоль той или иной строки - тернарный условный оператор.

Sample Input:

1 2 3 4 5 6 7 0

Sample Output:

even

```c
#include <iostream>

enum { max_len_numbers = 100 };

using std::cout;

int main() {
    int numbers[max_len_numbers];
    size_t count = 0;
    bool fl_even = false;

    while (scanf("%d", &numbers[count]) == 1 && numbers[count] != 0) {
        fl_even += (numbers[count] % 2 == 0);
        count++;
    }

    cout << (fl_even ? "even" : "no");
    return 0;
}
```

### Подвиг 5. Напишите программу, в которой объявите функцию all со следующей сигнатурой:

```c++
bool all(const int* ar, size_t len, PTR_FUNC filter);
```

Данная функция должна возвращать `true`, если для всех первых `len` элементов массива `ar` функция `filter` возвращает истинное значение. Тип `PTR_FUNC` должен соответствовать указателю на функцию с сигнатурой:

```c++
bool <имя функции>(int );
```

и определяться через ключевое слово `using`.

Для проверки элементов массива в качестве примера объявите функцию со следующей сигнатурой:

```c++
bool positive(int x);
```

которая должна возвращать истину, если значение `x` положительное (строго больше нуля) и ложь в противном случае.

В функции `main` объявите массив с числами:

2, 3, 1, -10, 15

Вызовите для него функцию `all`, а в качестве критерия проверки укажите функцию `positive`. Сохраните возвращенное значение в булевой переменной `res`.

P. S. В консоль ничего выводить не нужно.

```c
#include <iostream>

bool positive(int x) { return x > 0; }

using PTR_FUNC = bool (*)(int);

bool all(const int* ar, size_t len, PTR_FUNC filter) {
    for (size_t i = 0; i < len; i++) {
        if (!filter(ar[i])) return false;
    }
    return true;
}

int main() {
    const int numbers[] = {2, 3, 1, -10, 15};

    PTR_FUNC filter = positive;

    bool res = all(numbers, 5, filter);

    std::cout << res;

    return 0;
}
```

### Подвиг 6. Напишите программу, в которой объявите функцию any со следующей сигнатурой:

```c
bool any(const double* ar, size_t len, PTR_FUNC filter);
```

Данная функция должна возвращать `true`, если хотя бы для одного из первых `len` элементов массива `ar` функция `filter` возвращает истинное значение. Тип `PTR_FUNC` должен соответствовать указателю на функцию с сигнатурой:

```c
bool <имя функции>(double );
```

и определяться через ключевое слово `using`.

Для проверки элементов массива в качестве примера объявите функцию со следующей сигнатурой:

```c
bool range_out(double x);
```

которая должна возвращать истину, если значение `x` выходит за диапазон `[-0.5; 0.5]`, и ложь в противном случае.
В функции `main` объявите массив с числами:

0.1, 0.2, 0.3, -0.4, 1.4

Вызовите для него функцию `any`, а в качестве критерия проверки укажите функцию `range_out`. Сохраните возвращенное значение в булевой переменной `res`.

P. S. В консоль ничего выводить не нужно.

```c++
#include <iostream>
#define RANGE_DOWN -0.5
#define RANGE_UP 0.5

using PTR_FUNC = bool (*)(double);

bool range_out(double x) { return x < RANGE_DOWN || x > RANGE_UP; }

bool any(const double* ar, size_t len, PTR_FUNC filter) {
    for (size_t i = 0; i < len; i++) {
        if (filter(ar[i])) return true;
    }
    return false;
}

int main() {
    const double numbers[] = {0.1, 0.2, 0.3, -0.4, 1.4};

    PTR_FUNC filter = range_out;

    bool res = any(numbers, 5, filter);

    std::cout << res;

    return 0;
}
```

+ [ ] int count = 0; do { std:: cout << ar[++count] << " "; } while(count < len);
+ [x] int count = 0; do { std::cout << ar[count++] << " "; } while(count < len);
+ [x] int count = 0; while(count < len) printf("%d ", ar[count++]);
+ [x] for(long x : ar) std::cout << x << " ";
+ [x] for(int i = 0; i < len; ++i) std::cout << ar[i] << " ";
+ [ ] int count = 0; while(count < len) printf("%d ", ar[++count]);

### Подвиг 8 (на повторение). Допишите следующую программу. Из входного потока необходимо прочитать целые числа, записанные через пробел, и занести их по порядку массив matrix (сначала заполняется первая строка, затем вторая, и так далее). Количество чисел во входном потоке от одного и до бесконечности. Необходимо контролировать, чтобы их максимальное количество не превышало размеров массива matrix.

Выведите в консоль сформированную матрицу `matrix` в виде таблицы `matrix_size` x `matrix_size` элементов.

P. S. Числа разделяются пробелом. В конце строк пробелов быть не должно.

Sample Input:

5 4 3 7 10 4

Sample Output:

5 4 3 7
10 4 0 0
0 0 0 0
0 0 0 0

```c++
#include <iostream>

enum { matrix_size = 4 };

using std::cin;
using std::cout;

int main() {
    short matrix[matrix_size][matrix_size] = {0};

    short *ptr_matrix = &(*matrix)[0];

    size_t count = 0;

    while (count < matrix_size * matrix_size && cin >> *(ptr_matrix + count)) count++;

    for (size_t i = 0; i < matrix_size; i++) {
        for (size_t j = 0; j < matrix_size; j++) {
            cout << matrix[i][j] << (j + 1 == matrix_size ? "": " ");
        }
        cout << (i + 1 == matrix_size ? "": "\n");
    }


    return 0;
}
```

### Подвиг 9. Выберите все верные утверждения, касающиеся указателей языка С++.

+ [ ] если определение nullptr не поддерживается компилятором, то вместо него следует использовать значение NULL языка Си
+ [ ] при присвоении адреса указателя с типом void* другому указателю операцию приведения типа можно не прописывать
+ [x] если определение nullptr не поддерживается компилятором, то вместо него рекомендуется указывать числовой литерал 0L
+ [x] если указатели определены с разными типами, то присвоение одного из них другому обязательно нужно прописывать с операцией приведения типа
+ [x] при присвоении адреса указателя с типом void* другому указателю необходимо прописывать операцию приведения типа
+ [x] вместо константы NULL языка Си следует использовать определение nullptr, если оно поддерживается текущей версией компилятора

### Подвиг 10. Выберите все верные (рабочие) варианты команд с указателями языка С++.

P. S. Имена всех указателей уникальны и при присвоении одного указателя другому полагается, что присваиваемый уже существует. Его определение см. в других вариантах (оно одно единственное).

+ [ ] char* p_str = ptr;
+ [x] short* marks = (short *)malloc(sizeof(short) * 10);
+ [x] const char* ptr = "Hello C++";
+ [ ] double* ds = malloc(sizeof(double) * 5);
+ [ ] int* p_int = marks;
+ [x] const int* ptr_int = (int *)marks;

# 9.7 Инициализация переменных. Ключевые слова auto и decltype

## Инициализация переменных.

Продолжаем рассматривать основные отличия языка С++ от Си. Следующим шагом будет логично рассмотреть способы инициализации переменных в С++. Напомню, что в языке Си инициализация записывается с помощью оператора ‘=’ при объявлении переменной. Например:

```c
int val = 0;  // инициализация
int pow[] = {1, 2, 4, 8};
```

Если же символ ‘=’ используется после объявления переменной:

```c
double d;
d = 5.78;  // операция присваивания
```

то он уже определяет операцию присваивания.

Эти две операции нужно четко себе различать, так как они работают по-разному. Так вот, в языке С++, чтобы четко, синтаксически отделить одну операцию от другой, введен новый синтаксис и новые операции инициализации переменных. Помимо уже знакомого нам оператора ‘=’ инициализацию можно выполнять, по крайней мере, еще двумя распространенными способами:

```c++
    short sh(10);   // functional notation
    double d(-4.37);
 
    char ch{'b'};   // braced initialization
    long lv{};
```

При выводе значений этих переменных:

```c++
cout << sh << " " << d << endl;
cout << ch << " " << lv << endl;
```
увидим:

```
10 -4.37
b 0
```

То есть, переменным были присвоены значения, указанные в скобках. Если же в скобках ничего не прописано, то переменная инициализируется нулем.

Вообще, в языках Си и С++ начальная инициализация переменных – это рекомендуемая практика. 

Напомню, что все локальные переменные, размещаемые в стековом фрейме (их еще называют автоматическими), могут принимать неопределенное начальное значение. 

Конкретное поведение зависит от компилятора С++. 

Поэтому, чтобы не возникало непредвиденных ошибок из-за неопределенного начального значения переменной, ее следует сразу инициализировать. Именно для этого введены операторы круглых и фигурных скобок.

Но здесь возникает вопрос, чем отличаются эти два способа инициализации? 

На самом деле, почти ничем, но при использовании фигурных скобок дополнительно происходит проверка типа инициализируемых данных. Например, если у переменной `lv` в фигурных скобках прописать вещественное число:

```c
long lv{5.43};
```

то компилятор выдаст ошибку из-за несовпадения типов переменной `lv (long)` и числа `5.43 (double)`. Причем, тип `double` нельзя без потерь привести к типу `long`. Но, если фигурные скобки заменить на круглые:

```c
long lv(5.43);
```

то ошибки не будет и переменная `lv` примет значение `5`, то есть, будет выполнено неявное приведение типа `double` к типу `long`.

Для полноты картины приведу еще несколько примеров инициализации переменных указанными способами:

```c++
int sum {2 + 3 + 4 + 5};
double p (1 * 2.3 * 4.5 - 1);
bool n_fl(false), t_fl(true);
```

То есть, в инициализаторе можно прописывать любые допустимые конструкции языка С++.

## Особенность модификатора const в С++

Я думаю, с инициализацией переменных, в целом, все понятно, поэтому перейдем к следующему отличию использования модификатора `const`. 

Как мы знаем из курса по Си с помощью ключевого слова `const` можно определять неизменяемые переменные, то есть, константы. Например, так:

```c
const double pi {3.1415};
```

В С++ этот модификатор используется с теми же целями, но есть одно небольшое отличие при его использовании. Константная переменная должна быть инициализирована в момент ее объявления. То есть, запись, которая была допустима в языке Си:

```c
const double pi;
```

в С++ приведет к ошибке при компиляции программы. Во всем остальном он работает так же, как и в языке Си. И это не удивительно, так как ключевое слово `const` перешло в Си из языка С++.

## Вычисляемый тип (auto и decltype)

В языке С++, начиная со стандарта С++11, ключевое слово `auto` радикально изменило свое назначение. 

Если раньше в язык Си оно вводилось для явного обозначения автоматических переменных, то есть, тех, что располагаются в стековом фрейме, то теперь с его помощью можно объявлять переменные вычисляемого типа. 

О чем здесь речь? 

Давайте я покажу это на конкретном примере. С помощью ключевого слова `auto` мы можем объявлять переменные следующим образом:

```c++
auto i = -100;      // тип int
auto d = 76.98;     // тип double
auto g = 0.55f;     // тип float
auto h = 'f';       // тип char
```

Во всех случаях компилятор сначала вычисляет тип данных, которым инициализируется переменная, а затем, вместо `auto` подставляет этот тип. В итоге получаем в приведенном примере типы: `int`, `double`, `float` и `char`.

Или, могут быть более сложные выражения, например:

```c++
auto i = 1 + 2 - 10;      // тип int
auto d = 1 + i + 3.0;     // тип double
auto g = 55u;     // тип unsigned int
auto h = (short)10 + 100000UL;       // тип unsigned long
```

Здесь также вначале компилятор вычисляет тип инициализируемых данных и только потом вместо ключевого слова `auto` подставляет вычисленный тип.

Но, как всегда, здесь есть ряд важных нюансов. Давайте объявим следующие три переменных:

```c++
int *ptr = nullptr;
int k;
int& lk = k;
```

и посмотрим, какой тип будет вычисляться компилятором с их использованием:

```c++
auto t1 = k;        // int
auto t2 = *ptr;     // int
auto t3 = ptr;      // int *
auto t4 = &ptr;     // int **
auto t5 = lk;       // int
```

Пока использовались обычные переменные и указатели, все ожидаемо, но для ссылки получили обычный тип `int`, а не ссылку.

Далее, если перед типами прописать ключевое слово `const`:

```c++
const int *ptr = nullptr;
const int k = 0;
const int& lk = k;
```

то  результат будет следующим:

```c++
auto t1 = k;        // int
auto t2 = *ptr;     // int
auto t3 = ptr;      // const int *
auto t4 = &ptr;     // const int **
auto t5 = lk;       // int
```

В целом, ожидаемо. Компилятор старается найти наиболее общий тип при учете ссылок и модификаторов. 

Поэтому везде, где это допустимо, ключевое слово `const` отбрасывается при вычислении типа переменной. 

Очевидно, его нельзя отбросить для переменных `t3` и `t4`, т. к. здесь объявляются указатели через константный указатель `ptr`. Во всех остальных случаях его можно не учитывать.

Однако если для нас важно сохранить полную идентичность типа переменной, например, ссылку оставить ссылкой, или не отбрасывать модификатор `const`, то при объявлении переменных можно воспользоваться еще одним новым ключевым словом `decltype` следующим образом:

```c++
decltype(k) var1 = 1;   // const int
decltype(ptr) var2;     // const int *
decltype(lk) var3 = k;  // const int &
```

Конечно, здесь возникает вопрос, зачем это нужно? 

Разве не проще явно объявлять типы переменных, как это делалось до сих пор? 

На самом деле, есть ряд ситуаций, когда использование `auto` несколько облегчает написание программного кода. 

Часто это касается использования `STL`-коллекций со сложными шаблонными типами данных. 

Например, в программе можно объявить двусвязный список, содержащий числа, инициализировать его и перебрать обычным циклом `for`:

```c
#include <iostream>
#include <list>
 
int main()
{
    std::list<short> dg = {-3, -2, 0, 2, 3};
 
    for(std::list<short>::iterator i = dg.begin(); i != dg.end(); ++i)
                   std::cout << *i << " ";
 
    return 0;
}
```

Смотрите, какой тип (`std::list<short>::iterator`) приходится прописывать у переменной `i`. Это не очень удобно. 

Как раз в подобных случаях проще прописать ключевое слово `auto` и компилятор сам автоматически подставит нужный тип переменной:

```c++
    for(auto i = dg.begin(); i != dg.end(); ++i)
                   std::cout << *i << " ";
```

И результат будет абсолютно такой же.

Конечно, злоупотреблять этим не стоит. 

Все же, явное обозначение чаще лучше неявного. 

И ключевое слово `auto` имеет ряд ограничений. 

Например, его нельзя (в ряде компиляторов) использовать при определении параметров функции:

```c++
void func(auto x) 
{ }
```

Компилятор GCC выдает предупреждение, но другие могут приводить к ошибке. Поэтому вместо `auto` следует использовать или перегрузку функций, или определять шаблон функции.

Я не стану дальше углубляться в эту тему. Общей информации для понимания ключевых слов `auto` и `decltype` пока достаточно. 

В дальнейшем, когда в практике программирования вам действительно понадобится их использовать, значит, вы доросли до такого уровня, когда легко сможете более глубоко усвоить этот материал.

Видео по теме [#6. Инициализация переменных. Ключевые слова auto и decltype](https://www.youtube.com/watch?v=rGNbbnUAX6k&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения по инициализации переменных языка С++.

+ [ ] инициализация локальных переменных - это не рекомендуемая практика, т.к. приводит к увеличению объема вычислений
+ [x] операцию инициализации можно записать с помощью фигурных скобок в момент объявления переменной
+ [x] операцию инициализации можно записать через символ '=' в момент объявления переменной
+ [x] инициализация с применением круглых скобок называется функциональной
+ [ ] операцию инициализации в С++ нельзя прописывать символом '='
+ [x] операцию инициализации можно записать с помощью круглых скобок в момент объявления переменной

### Подвиг 2. Выберите все верные варианты инициализации переменных в С++.

+ [x] float var_f{};
+ [x] double ld{0.5 * 11 - 7.89};
+ [x] char ch{'a'};
+ [x] int var_4(-56.4);
+ [x] char var_1{100};
+ [ ] char rsd{1024};
+ [x] short var_2(-857);
+ [x] int var_3();
+ [ ] long var_5{-5.3};
+ [x] long var_6{true};

### Подвиг 3. Установите соответствия между инициализируемыми переменными и их значениями.

![09](/Good_good_C_C++/img/09_06.PNG)

### Подвиг 4. Выберите все верные утверждения, касающиеся ключевого слова const языка С++.

+ [x] ключевое слово const запрещает изменять значение переменной после ее инициализации
+ [x] переменная может быть объявлена следующим образом: const int max_size = 100;
+ [ ] переменная может быть объявлена следующим образом: const int max_size;
+ [x] переменная, объявленная с ключевым словом const, должна быть инициализирована
+ [ ] ключевое слово const запрещает изменение переменной только через указатели на нее
+ [x] переменная может быть объявлена следующим образом: int const buffer_size = 100;

### Подвиг 5. Отметьте для переменных их вычисляемый тип данных.

```c++
auto var_1{0.5f};
auto var_2{0};
auto var_3{245u};
auto var_4(486L);
auto var_5{4.86L};
auto var_6('d');
auto var_7 = (short)-5;
```
![09](/Good_good_C_C++/img/09_07.PNG)

### Подвиг 6. Пусть в программе объявлены следующие переменные:

```c++
const char symbol_f = 'f';
const short* ptr_sh;
int count = 0;
const int& lnk = count;
```

Соберите для переменных var_1, ..., var_6 их вычисляемый тип данных. (Например, для типа const char* нужно отметить три колонки.)

![09](/Good_good_C_C++/img/09_11.PNG)

### Подвиг 7. Пусть в программе объявлены следующие переменные:

```c++
const char symbol_f = 'f';
const short* ptr_sh;
int count = 0;
const int& lnk = count;
```

Соберите для переменных var_1, ..., var_5 их вычисляемый тип данных. (Например, для типа const char* нужно отметить три колонки.)

![09](/Good_good_C_C++/img/09_12.PNG)

### Подвиг 8* (на повторение). Четырехугольник описан четырьмя точками на плоскости:

![09](/Good_good_C_C++/img/09_08.png)

Необходимо написать программу, которая бы проверяла, что произвольная точка с координатами (x, y) находится в пределах заданного четырехугольника.

Один из алгоритмов проверки следующий. Точку (x, y) нужно (условно) соединить со всеми вершинами четырехугольника (см. рисунок) и если сумма площадей образованных треугольников будет равна площади исходного четырехугольника, то точка (x, y) принадлежит этой фигуре. Площадь самого четырехугольника можно найти как сумму двух треугольников, на которые легко разбивается любой четырехугольник.

Для вычисления площади треугольника с произвольными сторонами a, b, c можно воспользоваться формулой Герона:

$S= \sqrt{p⋅(p−a)⋅(p−b)⋅(p−c)}$ 

где $p=(a+b+c)/2$ - полупериметр треугольника.

В программе ниже уже реализовано представление и считывание координат из входного потока. Продолжите ее, добавив проверку принадлежности точки `pt` четырехугольнику `figure`. Если точка принадлежит фигуре, то в консоль выведите строку "yes", а иначе - строку "no".

P. S. Повторяющиеся вычисления выносите в функции. Текст программы должен хорошо читаться.

Sample Input:

5; 2 10; 15 20; 7 13; 1<br>
11; 14

Sample Output:

yes
​
```c
#include <cmath>
#include <iostream>

enum { corners = 4 };

struct point {
    int x, y;
};

double distance(point* a, point* b) {
    double result = sqrt(pow((a->x - b->x), 2) + pow((a->y - b->y), 2));
    return result;
}

double giron_area(point* a, point* b, point* c) {
    double ab = distance(a, b);
    double ac = distance(a, c);
    double bc = distance(b, c);
    double p = (ab + ac + bc) / 2.0;
    double result = sqrt(p * (p - ab) * (p - ac) * (p - bc));
    return result;
}

double quadrangle_area(point* a, point* b, point* c, point* d) {
    double result = giron_area(a, b, c) + giron_area(a, d, c);
    return result;
}

double quadrangle_area_point(point* a, point* b, point* c, point* d, point* e) {
    double result = giron_area(a, b, e) + giron_area(b, c, e) + giron_area(c, d, e) + giron_area(a, d, e);
    return result;
}

bool in_area(point* a, point* b, point* c, point* d, point* e) {
    bool result = (quadrangle_area_point(a, b, c, d, e) - quadrangle_area(a, b, c, d)) < 0.000001;
    return result;
}

int main() {
    point figure[corners];
    point pt;

    int count = 0;
    while (count < corners && scanf("%d; %d", &figure[count].x, &figure[count].y) == 2) count++;

    if (count != corners) {
        puts("Неверное количество или формат входных данных.");
        return 1;
    }

    if (scanf("%d; %d", &pt.x, &pt.y) != 2) {
        puts("Неверное количество или формат входных данных.");
        return 2;
    }

    bool result = in_area(&figure[0], &figure[1], &figure[2], &figure[3], &pt);

    printf("%s", result ? "yes" : "no");

    return 0;
}
```

### Подвиг 9 (на повторение). Установите соответствия между функциями и их описаниями.

![09](/Good_good_C_C++/img/09_09.PNG)

### Подвиг 10 (на повторение). Установите соответствия между функциями и их описаниями.

![09](/Good_good_C_C++/img/09_10.PNG)

# 9.8 Ссылки. Константные ссылки

## Ссылки

Следующее важное нововведение языка С++ - это ссылки. Объявляются они так же, как и обычные переменные, только после типа следует поставить символ амперсанда. Например:

```c++
int d = 10;
int& lnk_d = d;  // ссылка с именем lnk_d на переменную d
```

или, что то же самое:

```c++
int& lnk_d2 {d};
int& lnk_d3 (d);
```

В итоге, с ячейками памяти, где хранится значение переменной `d`, связано теперь два имени: `d` и `lnk_d`. 

Ссылку можно воспринимать, как неявный указатель, который хранит адрес переменной, записанной при инициализации. В результате, мы через ссылку `lnk_d` можем выполнять все те же самые действия, что и с переменной `d`. Например:

```c++
lnk_d = 5;  // переменная d = 5
d = -1;     // ссылка lnk_d связана со значением -1
lnk_d *= 10; // значение d увеличено в 10 раз
lnk_d++;  // инкремент переменной d
```

Причем одна ссылка может быть связана только с одной переменной (с одним элементом данных) и связь эта прописывается в момент ее инициализации. В частности, это означает, что объявить ссылку без инициализации в С++ нельзя. Следующая строчка приведет к ошибке:

```c++
double& alias_d;
```

При этом в инициализаторе можно прописывать любое допустимое `lvalue` выражение. Например:

```c++
int a = 10;
int *ptr = &a;
int ar[] = {1, 2, 3};
 
int& lnk_1 = a;        / / ok
int& lnk_2 = *ptr;    // ok
int& lnk_3 = ar[1];   // ok
int& lnk_4 = 10;  // ошибка
int& lnk_5 = ptr;  // ошибка
```

То есть, ссылка должна быть связана с областью памяти, где хранятся данные того же типа, который указан при объявлении ссылки.

Некоторые из вас, возможно, задаются вопросом, зачем вообще нужны ссылки, когда с переменной (данными) можно работать напрямую через их имена? 

На самом деле, польза ссылок проявляется там же, где и польза указателей. 

Например, в классической задаче обмена значениями двух переменных. Без использования ссылок мы могли бы для этой цели объявить следующую функцию:

```c++
void swap_d(double* x, double* y) {
    double t = *x;
    *x = *y;
    *y = t;
}
```

И, затем, в функции `main()` вызвать ее для переменных типа `double`:

```c++
double a{1.2}, b{-3.4};
swap_d(&a, &b);
std::cout << a << " " << b << std::endl;
```

Как видите, при вызове в аргументах функции `swap_d()` дополнительно приходится указывать операцию взятия адреса переменных `a` и `b`. Это не очень удобно и красиво. 

Куда лучше было бы записать эту же функцию с использованием ссылок:

```c++
void swap_d(double& x, double& y) {
    double t = x;
    x = y;
    y = t;
}
```

И ее последующий вызов:

```c
swap_d(a, b);
```

Так все выглядит куда более естественно. 

Кроме того, ссылки куда более безопаснее указателей, так как мы уже знаем, что они могут быть инициализированы только корректными `lvalue` выражениями, а значит, работают с ячейками памяти, в которых хранятся данные соответствующего типа. 

Все это делает ссылки более удобным и безопасным инструментом, чем указатели. Поэтому часто, где это возможно, они заменяют указатели.

Также обратите внимание, что при объявлении параметров функции в виде ссылок их не нужно инициализировать. 

Компилятор поставит им в соответствие те переменные, которые мы укажем при вызове этой функции. 

Причем, сами переменные при этом не копируются, а лишь формируется связь между параметрами-ссылками и переменными, указанными при вызове функции. 

В частности, это означает, что если нужно передать в функцию какие-либо объемные данные, например, большие структуры, то часто целесообразно это сделать через ссылки.

Другое назначение ссылок – это возможность изменения данных, где другие инструменты не очень удобны в использовании. Например, дан массив:

```c
short p[] = {1, 2, 3, 4};
```

и нам нужно значения всех его элементов увеличить в два раза. Логично было бы воспользоваться новой формой записи цикла for следующим образом:

```c++
for (short& x : p)
    x *= 2;
```

И выведем полученный массив `p` в консоль:

```c++
for (int i = 0; i < sizeof(p)/sizeof(*p); ++i)
    std::cout << p[i] << " ";
```

Увидим:

```
2 4 6 8
```

Почему здесь в первом цикле `for` нужно прописывать переменную `x` в виде ссылки? 

Думаю, вы уже догадались, что в противном случае:

```c
for (short x : p)
    x *= 2;
```

мы получим копирование текущего значения массива `p` в переменную `x` и изменение (увеличение в 2 раза) коснется этой новой переменной, а не элемента массива. Ссылка же решает нашу задачу.

## Константные ссылки

В языке С++ допустимо объявлять константные ссылки, то есть, ссылки, с помощью которых можно только читать значение переменной, но не менять. Например:

```c++
int s = 0;
const int& ls = s;
 
int x = ls;  // чтение данных разрешено
ls = 5; // ошибка, запись нового значения невозможна
```

Соответственно, константные ссылки могут быть инициализированы, как обычными переменными, так и константными:

```c++
int s = 0;
const int d = -2;
 
const int& ls = s;
const int& ld = d;
```

А вот обычная ссылка может вести только на такую же обычную переменную:

```c++
int s = 0;
const int d = -2;
 
int& ls = s;    // ok
int& ld = d;    // ошибка
```

Это вполне очевидное ограничение, т.к. иначе бы мы смогли изменить константную переменную `d` через ссылку `ld`.

Когда нам могут понадобиться константные ссылки? 

Самое очевидное – это описание неизменяемых параметров функции. 

Давайте представим, что у нас имеется структура, которая описывает точки в двумерном пространстве следующим образом:

```c++
struct point {
    char name[50];      // название точки
    double x, y;        // координаты точки
};
```

Затем, объявим функцию, которая вычисляет длину такого радиус-вектора:

```c++
double length(const point& p) {
    return sqrt(p.x * p.x + p.y * p.y);
}
```

И вызовем ее в функции `main()`:

```c++
int main() {
    point p2 {"first", 10.0, 20.0};
    double len = length(p2);
    std::cout << len << std::endl;
 
    return 0;
}
```

Смотрите, в момент вызова функции `length(p2)`, структура `p2` не копируется в параметр `p`, копируется только ее адрес. В результате ссылка `p` связывается со структурой `p2`. 

А дополнительное ключевое слово `const` гарантирует, что структура `p2` никак не будет менять свое состояние внутри функции `length()`. 

Соответственно, программист, который использует эту функцию, понимает, что если какой-либо ее параметр помечен как `const`, то он может быть уверенным в неизменности передаваемого аргумента.

И еще раз отмечу, что если бы в функции `length()` передача аргумента происходила бы не по ссылке, а по значению:

```c
double length(const point p) ...
```

то выполнялось бы полное побайтовое копирование структуры `p2` в переменную `p`, в результате программа работала бы дольше, но результат был бы тем же. 

Поэтому везде, где происходит передача объемных данных в параметры функции, целесообразно подумать об использовании ссылок или указателей.

Видео по теме [#7. Ссылки. Константные ссылки](https://www.youtube.com/watch?v=QRghthGe6cI&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, касающиеся ссылок языка С++.

+ [x] ссылку можно воспринимать как второе имя переменной, с которой она связана (инициализирована)
+ [x] ссылки - это, по сути, скрытый указатель, который хранит адрес переменной (lvalue-выражения), указанного при инициализации
+ [x] ссылки - это безопасный инструмент, так как они могут быть связаны только с корректным lvalue-выражением (области памяти с данными)
+ [ ] ссылки в С++ полностью заменяют собой традиционные указатели языка Си
+ [x] ссылки удобно использовать при передаче объемных данных в параметры функций

### Подвиг 2. Пусть в программе объявлены следующие переменные:

```c++
int var {-54};
int *ptr_v {&var};
short marks[] = {4, 3, 5, 2, 5};
```

Выберите все верные варианты объявления и инициализации ссылок.

+ [ ] int& lnk_8 = &ptr_v;
+ [x] int& lnk_4 = *ptr_v;
+ [x] short& lnk_7 {marks[3]};
+ [ ] int& lnk_2 {&var};
+ [x] short& lnk_6 {*marks};
+ [ ] int& lnk_3 (ptr_v);
+ [x] int& lnk_1 = var;
+ [ ] short& lnk_5 = marks;

### Подвиг 3. Продолжите программу. Прочитайте из входного потока целые числа, записанные через пробел, в массив marks. Количество читаемых данных не должно превышать константы total_marks. Затем, с помощью цикла 

```c++
for(<переменная> : <коллекция>) {[тело цикла]}
```
нужно перебрать все элементы массива `marks` и каждое значение элемента, которое меньше трех, нужно обнулить (приравнять нулю). Выведите в консоль в одну строчку через пробел полученный массив `marks` в порядке следования его элементов (от начала и до конца).

Sample Input:

1 2 3 4 5 6 7 6 5 4 3 2 5 4 6 7 8 9 10 100 11 1 2 3 4 5 6 7
Sample Output:

0 0 3 4 5 6 7 6 5 4 3 0 5 4 6 7 8 9 10 100 11 0 0

```c++
#include <iostream>

enum { total_marks = 23 };

using std::cin;
using std::cout;
using std::endl;

int main() {
    short marks[total_marks] = {0};
    size_t count = 0;

    while (count < total_marks && cin >> marks[count]) count++;

    for (auto &i : marks) {
        if (i < 3) i = 0;
        cout << i << ' ';
    }
    cout << endl;

    return 0;
}
```

### Подвиг 4. Пусть в программе объявлены следующие переменные:

```c++
const double pi = 3.1415;
unsigned int width = 27;
```

Выберите все верные варианты объявления и инициализации обычных и константных ссылок.

+ [ ] int &lnk_3 = width;
+ [ ] double& lnk_2 = pi;
+ [x] const double& lnk_1 = pi;
+ [x] const unsigned int &lnk_5 = width;
+ [ ] short &lnk_7 = -1;
+ [x] const short &lnk_6 = 100;
+ [x] unsigned int &lnk_4 = width;

### Подвиг 5. Объявите в программе структуру с именем типа POINT, который определите с помощью оператора using. Структура должна содержать два поля:

x, y - координаты точки на плоскости (тип double).
Затем объявите функцию с именем get_length, которая должна вычислять и возвращать (тип double) евклидовое расстояние между двумя точками по формуле:

$L =  \sqrt {(x_1 − x_2)^2 + (y_1 − y_2)^2}$

Соответственно, функция `get_length` должна иметь два параметра в виде константных ссылок на тип `POINT` - координаты двух точек.

В функции main объявите две переменные типа `POINT` и присвойте им координаты:

(-2.5; 7.8) и (11.4; 43.2)

Вызовите функцию `get_length` для вычисления расстояния между этими двумя точками и выведите вычисленное значение в консоль в виде вещественного числа с точностью до сотых.

```c++
#include <cmath>
#include <iostream>

struct POINT {
    double x, y;
};

double get_length(const POINT& a, const POINT& b) {
    double result = sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2));
    return result;
}

using std::cin;
using std::cout;
using std::endl;

int main() {
    POINT a{-2.5, 7.8}, b{11.4, 43.2};

    double result = get_length(a, b);

    printf("%.2lf", result);

    return 0;
}
```

### Подвиг 6. Продолжите программу. Объявите в функции main три переменные типа point (в С++ идентификатор структуры и ее тип - это одно и то же). Прочитайте из входного потока шесть целых чисел, записанных через пробел, и запишите их в переменные (типа point) в порядке:

(x1; y1), (x2; y2), (x3; y3)

Объявите в программе функцию с именем sq_tr, которая принимает координаты трех точек посредством константных ссылок на тип point, и вычисляет площадь треугольника, представленного этими координатами:

![09](/Good_good_C_C++/img/09_13.png)

Площадь можно вычислить по формуле Герона: 

$S= \sqrt{p⋅(p−a)⋅(p−b)⋅(p−c)}$ 

где $p=(a+b+c)/2$ - полупериметр треугольника.

А длины каждой из сторон, как евклидовое расстояние по формуле:

$L =  \sqrt {(x_1 − x_2)^2 + (y_1 − y_2)^2}$

Функция sq_tr должна возвращать вычисленную площадь в виде вещественного числа типа double.

В функции main вызовите функцию sq_tr для прочитанных из входного потока координат. Вычисленное значение площади выведите в консоль с точностью до сотых.

```c++
#include <cmath>
#include <iostream>

struct point {
    double x, y;
};

double get_length(const point& a, const point& b) {
    double result = sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2));
    return result;
}

double sq_tr(const point& a, const point& b, const point& c) {
    double ab = get_length(a,b);
    double bc = get_length(b,c);
    double ac = get_length(a,c);
    double p = (ab + bc + ac)/2;
    double res = sqrt(p*(p-ab)* (p-bc) * (p-ac));
    return res;
}

using std::cin;
using std::cout;
using std::endl;

int main() {
    point a, b, c;

    cin >> a.x >> a.y >> b.x >> b.y >> c.x >> c.y;

    double result = sq_tr(a, b, c);

    printf("%.2lf", result);

    return 0;
}
```

### Подвиг 7*. Четырехугольник описан четырьмя точками на плоскости:

![09](/Good_good_C_C++/img/09_14.png)

Необходимо написать программу, которая бы вычисляла количество точек с целочисленными координатами (x, y) принадлежащих заданному четырехугольнику.

Один из алгоритмов проверки попадания точки в четырехугольник следующий. Точку (x, y) нужно (условно) соединить со всеми вершинами четырехугольника (см. рисунок) и если сумма площадей образованных треугольников будет равна площади исходного четырехугольника, то точка (x, y) принадлежит этой фигуре. Площадь самого четырехугольника можно найти как сумму двух треугольников, на которые легко разбивается любой четырехугольник.

Для вычисления площади треугольника с произвольными сторонами a, b, c можно воспользоваться формулой Герона:

$S= \sqrt{p⋅(p−a)⋅(p−b)⋅(p−c)}$ 

где $p=(a+b+c)/2$ - полупериметр треугольника.

В программе ниже уже реализовано представление и считывание координат из входного потока. Продолжите ее, добавив вычисление числа точек с целочисленными координатами, принадлежащих четырехугольнику figure. Выведите в консоль количество таких точек в виде одного целого числа.

P. S. Повторяющиеся вычисления выносите в функции. В параметрах функций используйте ссылки. Текст программы должен хорошо читаться.

```c++
#include <cmath>
#include <iostream>

using std::max;
using std::min;

enum { corners = 4 };

struct point {
    int x, y;
};

struct min_max_point {
    int min_x;
    int max_x;
    int min_y;
    int max_y;
};

double get_length(const point& a, const point& b) {
    double result = sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2));
    return result;
}

double giron_area(const point& a, const point& b, const point& c) {
    double ab = get_length(a, b);
    double bc = get_length(b, c);
    double ac = get_length(a, c);
    double p = (ab + bc + ac) / 2;
    double res = sqrt(p * (p - ab) * (p - bc) * (p - ac));
    return res;
}

double quadrangle_area(const point& a, const point& b, const point& c, const point& d) {
    double result = giron_area(a, b, c) + giron_area(a, d, c);
    return result;
}

double quadrangle_area_point(const point& a, const point& b, const point& c, const point& d, const point& e) {
    double result = giron_area(a, b, e) + giron_area(b, c, e) + giron_area(c, d, e) + giron_area(a, d, e);
    return result;
}

bool in_area(point* figure, const int& x, const int& y) {
    point a = {figure[0].x, figure[0].y};
    point b = {figure[1].x, figure[1].y};
    point c = {figure[2].x, figure[2].y};
    point d = {figure[3].x, figure[3].y};
    point e = {x, y};
    bool result = (quadrangle_area_point(a, b, c, d, e) - quadrangle_area(a, b, c, d)) < 0.000001;
    return result;
}

min_max_point min_max(point* figure) {
    min_max_point res;

    res.min_x = min(min(figure[0].x, figure[1].x), min(figure[2].x, figure[3].x));
    res.max_x = max(max(figure[0].x, figure[1].x), max(figure[2].x, figure[3].x));
    res.min_y = min(min(figure[0].y, figure[1].y), min(figure[2].y, figure[3].y));
    res.max_y = max(max(figure[0].y, figure[1].y), max(figure[2].y, figure[3].y));

    return res;
}

int point_counter(point* figure) {
    min_max_point points = min_max(figure);

    int count = 0;

    for (int x = points.min_x; x <= points.max_x; x++) {
        for (int y = points.min_y; y <= points.max_y; y++) {
            if (in_area(figure, x, y)) count++;
        }
    }
    return count;
}

int main() {
    point figure[corners];

    int count = 0;
    while (count < corners && scanf("%d; %d", &figure[count].x, &figure[count].y) == 2) count++;

    if (count != corners) {
        puts("Неверное количество или формат входных данных.");
        return 1;
    }

    int result = point_counter(figure);

    std::cout << result << std::endl;

    return 0;
}
```

### Подвиг 8 (на повторение). Имеется следующая программа:

```c
#define TOTAL   1024

int main(void) {
    int total = 100;
    // здесь выполняются объявления

    return 0;
}
```

Выберите все верные (рабочие) варианты объявления массивов внутри функции main().

+ [x] float ar_3[sizeof(total) * 5];
+ [ ] long long ar_6[0.5 * 2];
+ [x] unsigned short ar_1[100];
+ [x] long double ar_7[TOTAL / 2];
+ [x] double ar_2[5 * 3 - 2];
+ [x] short int ar_8[(int)(0.5 * 3)];
+ [x] signed char ar_4[total]; // (поддерживается не всеми компиляторами)
+ [ ] long ar_5[0];

### Подвиг 9 (на повторение). Выберите все верные варианты инициализации массивов.

+ [x] long long pows[4] = {1, 2, 4, 8};
+ [x] int row[32] = {};
+ [x] double ar_d[7] = {[2]=0.5, 0.8, [6]=0.01};
+ [ ] int ar_i[5] = {0, 1, 2, 3, 4, 5};
+ [x] char str[100] = {1, 2, 3, 10};
+ [x] short buf[] = {0, 0, 1, 1, 2, 2};
+ [x] short zeros[64] = {0};

# 9.9 Объект-строка string. Операции с объектами класса string

## Объект-строка string.

Я думаю, вы помните, насколько неудобно было работать со строками в языке Си? 

Они описывались одномерным массивом типа `char` и содержали набор символов той или иной строки. Например, фразу «Hello, World!»:

```c
char msg[] = "Hello, World!";
```

В конце каждой корректной Си-строки должен присутствовать символ `\0`, то есть, просто число `0`.

Конечно, в С++ мы можем продолжать использовать этот подход для определения набора символов и работать с ними, как со строками. 

Но теперь появилась дополнительная возможность применять объект `string`, который значительно упрощает строковые операции на уровне написания программы программистом. Для этого первым делом необходимо подключить заголовок `string` в нашей программе следующим образом:

```c
#include <string>
```

После этого в пространстве имен `std` будет доступен класс `string` с возможностью объявления строковых объектов. В самом простом варианте можно записать:

```c
std::string msg;
```

Так как мы не проходили классы и ООП, то воспринимайте `string`, как специальный тип данных для объявления строк. В результате, `msg` будет представлять собой пустую строку, то есть, строку, содержащую только одно значение `0` – маркер конца строки.

В действительности, класс `string` базируется на динамическом массиве символов, в котором хранится текущая строка. 

Поэтому, нам не обязательно прописывать максимальную длину строки, это значение будет меняться в соответствии с длиной хранимой строки. Например, для объекта `msg` можно вывести число символов в строке и физический размер динамического массива:

```c
cout << msg.size() << " " << msg.capacity() << endl;
```

Получим:

```
0 15
```

То есть, размер строки `0`, а зарезервировано под строку `15` символов. Если же инициализировать объект-строку какой-либо строкой:

```c
std::string msg {"Hello, Sergey Balakirev!"};
cout << msg.size() << " " << msg.capacity() << endl;
```

то увидим числа:

```
24 24
```

То есть, размер динамического массива автоматически был увеличен до `24` – числа символов в строке.

Саму же строку можно вывести как обычную переменную с помощью объекта `cout` следующим образом:

```c++
cout << msg << endl;
```

Или же, получить константный указатель на строковый массив символов:

```c++
const char* data = msg.data();
```

и, например, вывести данные с помощью функции `printf()`:

```c
printf("%s\n", data);
```

Все это еще раз показывает, что внутри объекта `msg` мы имеем все ту же Си-строку в виде массива символов.

Далее, для доступа к отдельным символам строки можно по-прежнему использовать оператор `[]`. Например:

```c++
std::string fio {"Sergey Balakirev!"};
std::string fio_new {fio};
 
fio_new[5] = 'i';
cout << fio_new << endl;
```

Увидим измененный символ `y`:

```
Sergei Balakirev!
```

Соответственно, можно прочитать отдельный символ по индексу:

```c++
cout << fio_new[0] << endl;
```

Или, то же самое можно выполнить с помощью метода `at()`:

```c++
fio_new.at(5) = 'i';
cout << fio_new << "\n" << fio_new.at(0) << endl;
```

Объект-строку можно перебрать по символам с помощью цикла `for`. В самом простом варианте это можно сделать так:

```c++
    for(const char& ch : fio)
        cout << ch << " ";
```

В более сложном, использовать итератор для перебора любых последовательностей, определенных в стандартной библиотеки шаблонов (STL):

```c++
    for(auto it = msg.cbegin(); it != msg.cend(); ++it)
        cout << *it << " ";
```

Я не буду сейчас углубляться в эту тему. Привел этот пример для демонстрации многообразия возможностей языка С++ и библиотеки `STL`.

Наконец, можно воспользоваться уже известным вам способом перебора Си-строки:

```c++
    const char* ptr_str = fio.data();
    for(int i = 0; ptr_str[i] != '\0'; ++i)
        cout << ptr_str[i] << " ";
```

Конечно, удобнее всего использовать первый способ, поэтому чаще всего он и встречается в программах.

## Добавление и объединение строк

Приятной возможностью объекта-строк является возможность неограниченно (пока хватает памяти устройства) добавлять новые символы в конец строки. Например, пусть имеется строка:

```c++
std::string msg {"Hello"};
```

И мы хотим ее преобразовать в строку «Hello, Sergey!», то есть в конец дописать недостающий фрагмент. Это легко сделать с помощью метода `append()` следующим образом:

```c++
msg.append(", Sergey!");
cout << msg << endl;
```

Также мы можем объединять строки между собой. Например:

```c++
std::string msg {"Hello"};
std::string name {"Sergey"};
msg.append(", ");
msg = msg + name;
cout << msg << endl;
```

Или, короче:

```c
msg += name;
```

Или, еще короче:

```c++
msg = msg.append(", ") + name;
```

Все эти варианты вполне допустимы.

## Ввод строк из стандартного входного потока

Наверное, последний важный момент связан с возможностью ввода строковых данных из стандартного входного потока `stdin`. Чаще всего – это ввод строк с клавиатуры. Так как в программе у нас имеется объект `cin`, давайте воспользуемся им и посмотрим, как это будет работать с объектами-строками:

```c++
#include <iostream>
#include <string>
 
using std::cout;
using std::cin;
using std::endl;
 
int main()
{
    std::string msg;
    cin >> msg;
    cout << msg << endl;
    return 0;
}
```

Если ввести строку «hello world», то в объекте `msg` будет только первый фрагмент «hello». 

Чтобы прочитать строку целиком (до символа перевода строки) удобно воспользоваться функцией `getline()` языка С++. Например, так:

```c++
getline(cin, msg);
```

Теперь, при вводе «hello world», вся строка целиком помещается в объект `msg`.

Третьим аргументом в этой функции можно указать разделитель, до которого будет читаться введенный фрагмент. Например, если прописать:

```c++
getline(cin, msg, ';');
```

то при вводе:

```
1, 2; 3, 4
```

в объект `msg` будет помещена строка:

```
1, 2
```

Вот базовые возможности работы с объектами-строками языка С++. Как видите, они несколько удобнее обычных одномерных массивов символов, используемых в языке Си.

Видео по теме [#8. Объект-строка string. Операции с объектами класса string](https://www.youtube.com/watch?v=9KZq7ZN2-I0&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, связанные с типом (классом) std::string языка С++.

+ [x] в С++ можно по-прежнему использовать C-строки в виде массива символов
+ [x] тип (класс) std::string предоставляет удобный инструмент для представления и обработки строк
+ [ ] перед использованием типа (класса) std::string в программе следует подключить заголовок iostream
+ [x] тип (класс) std::string основан на динамическом массиве символов (char)
+ [x] при использовании типа (класса) std::string можно не заботиться о максимальной длине строки (в разумных пределах)
+ [ ] в С++ запрещено использовать C-строки в виде массива символов
+ [x] перед использованием типа (класса) std::string в программе следует подключить заголовок string

### Подвиг 2. Выберите все верные варианты объявления и инициализации объектов-строк.

+ [x] std::string str; std::string s_5 = str;
+ [x] std::string str; const std::string s_7 = str;
+ [x] std::string s_10 {'A'};
+ [x] const std::string s_2;
+ [ ] std::string s_7 {"Sergey" + "Balakirev"};
+ [x] std::string s_1;
+ [x] std::string s1 {"A"}, s2 {"B"}; std::string s_9 = s1 + s2;
+ [x] std::string s_8 {"Sergey" "Balakirev"};
+ [x] const std::string str; std::string s_6 = str;
+ [x] std::string s_3 {"Hello, C++"};
+ [x] const std::string s_4 ("Hello, C++");

### Подвиг 3. Продолжите программу. Объявите в функции main переменные fname, lname типа string. Прочитайте из входного потока имя в переменную fname и фамилию в переменную lname (имя и фамилия записаны через пробел каждое по одному слову). Затем третья переменная fio типа string должна содержать строку в формате:

<имя>, <фамилия>

Выведите полученную строку fio в консоль.

P. S. Переменные fname и lname после чтения данных из входного потока не должны менять своего значения.

Sample Input:

Bjarne Stroustrup

Sample Output:

Bjarne, Stroustrup

```c++
#include <iostream>
#include <string>

using std::cin;
using std::cout;
using std::endl;
using std::string;

int main() {
    string fname, lname;
    cin >> fname >> lname;
    string fio{fname + ", " + lname};

    cout << fio << endl;
    // __ASSERT_TESTS__

    return 0;
}
```

### Подвиг 4. Продолжите программу. В функции main объявите две целочисленные переменные с именами width и height. Прочитайте из входного потока два целых числа, записанных через пробел, первое - в переменную width, а второе - в переменную height. Затем, объявите объект-строку с именем data_str и запишите в нее информацию в виде строки формата:

"Переменная width = <значение>, переменная height = <значение>"

Выведите в консоль сформированную строку data_str.

P. S. Для конвертации чисел в объект-строку используйте функцию to_string.

Sample Input:

10 20

Sample Output:

Переменная width = 10, переменная height = 20

```c++
#include <iostream>
#include <string>

using std::cin;
using std::cout;
using std::endl;
using std::string;
using std::to_string;  // для конвертации чисел в строки

int main() {
    int width, height;
    cin >> width >> height;
    string data_str{"Переменная width = " + to_string(width) + ", переменная height = " + to_string(height)};

    cout << data_str << endl;
    // __ASSERT_TESTS__
    return 0;
}
```

### Подвиг 5. Продолжите программу. В функции main объявите объект-строку с именем msg. Прочитайте в нее строку целиком (до символа переноса строки или до конца данных во входном потоке). Выведите в консоль по порядку первые четыре символа строки msg. (В тестах гарантируется, что строка имеет минимум 4 символа.)

P. S. Эффективнее выводить отдельные символы функцией putchar.

Sample Input:

Bjarne Stroustrup

Sample Output:

Bjar

```c++
#include <iostream>
#include <string>

enum { chars_to_print = 4 };

using std::cin;
using std::cout;
using std::endl;
using std::string;

int main() {
    string msg;

    getline(cin, msg);

    for (size_t i = 0; i < chars_to_print; i++) {
        putchar(msg[i]);
    }

    // __ASSERT_TESTS__
    return 0;
}
```

### Подвиг 6. Продолжите программу. В функции main объявите объект-строку с именем msg. Прочитайте в нее строку целиком (до символа переноса строки или до конца данных во входном потоке). Выведите в консоль последние три символа строки msg в обратном порядке (с конца). (В тестах гарантируется, что строка имеет минимум 3 символа.)

P. S. Эффективнее выводить отдельные символы функцией putchar.

Sample Input:

I love C

Sample Output:

C e

```c++
#include <iostream>
#include <string>

enum { chars_to_print = 3 };

using std::cin;
using std::cout;
using std::endl;
using std::string;

int main() {
    string msg;

    getline(cin, msg);

    for (int i = 0; i < chars_to_print; i++) {
        putchar(*(msg.cend() - i - 1));
    }

    // __ASSERT_TESTS__
    return 0;
}
```

### Подвиг 7. Продолжите программу. В функции main объявите массив объектов-строк с именем cities длиной max_cities. Константу max_cities = 10 определите через перечисление. Из входного потока по порядку прочитайте названия городов, записанных через пробел, в массив cities. Количество читаемых данных не должно превышать значения max_cities. После этого в объект-строку res запишите по порядку (с начала) через пробел все города, длины имен которых больше пяти символов. Выведите в консоль полученную строку res.

Sample Input:

Moscow Ufa Tver Piter Toliatti Samara Kazan
Sample Output:

Moscow Toliatti Samara

```c
#include <iostream>
#include <string>

enum { max_cities = 10, min_chars = 5 };

using std::cin;
using std::cout;
using std::endl;
using std::string;

int main() {
    string cities[max_cities], res{""};

    size_t count = 0;

    while (count < max_cities && cin >> cities[count]) count++;

    for (size_t i = 0; i < count; i++) {
        if (cities[i].size() > min_chars) res += cities[i] + " ";
    }

    cout << res << endl;

    // __ASSERT_TESTS__
    return 0;
}
```

### Подвиг 8. Напишите программу, в которой из входного потока считывается строка целиком в объект-строку. Строка представляет собой фрагмент URL-адреса страницы сайта и может содержать несколько подряд идущих дефисов. Например:

cpp-obekt--stroka----string-operacii-s-obektami--klassa-string

Необходимо преобразовать эту строку так, чтобы все дублирующиеся дефисы (более одного подряд) были заменены на один дефис. Результат преобразования вывести в консоль в виде строки.

Sample Input:

c_standartnye---potoki-vvodavyvoda--funkcii-putchar----i-getchar

Sample Output:

c_standartnye-potoki-vvodavyvoda-funkcii-putchar-i-getchar

```c++
#include <iostream>
#include <string>
#define CHAR_TO_DEL '-'

using std::cin;
using std::cout;
using std::endl;
using std::string;

int main() {
    string str;
    cin >> str;

    size_t shift = 0;

    for (size_t i = 0; i < str.size(); i++) {
        while (str[i + shift] == CHAR_TO_DEL && str[i + 1 + shift] == CHAR_TO_DEL) shift++;
        str[i] = str[i + shift];
    }

    str.resize(str.size() - shift);

    cout << str << endl;

    return 0;
}
```

### Подвиг 9 (на повторение). Выберите все верные варианты вычисления длины следующего массива (числа его элементов):

```c
double ar[13];
size_t size_ar;
```

+ [x] size_ar = sizeof ar / sizeof *ar;
+ [ ] size_ar = sizeof(ar);
+ [x] size_ar = sizeof(ar) / sizeof(ar[0]);
+ [x] size_ar = sizeof(ar) / sizeof(ar[1]);
+ [ ] size_ar = sizeof(double) / sizeof(ar);
+ [ ] size_ar = sizeof(*ar) / sizeof(ar);
+ [x] size_ar = sizeof(ar) / sizeof(double);
+ [x] size_ar = sizeof(ar) / sizeof(*ar);

### Подвиг 10 (на повторение). Выберите все верные утверждения, касающиеся двух следующих определений:

```c
char s[] = "Balakirev";
char* ptr_s = "Balakirev";
```

+ [x] массив s инициализируется строковым литералом, то есть, содержимое строки копируется в массив s
+ [x] в массиве s можно менять символы строки
+ [x] через указатель ptr_s строковый литерал изменить нельзя
+ [ ] указатель ptr_s ссылается на начало строки, которую можно менять через этот указатель
+ [x] указатель ptr_s ссылается на начало строки, которая располагается в неизменяемой области памяти
+ [ ] в массиве s символы строки изменить нельзя

# 9.10 Файловые потоки. Открытие и закрытие файлов. Режимы доступа

## Файловые потоки.

В языке С++ существует набор классов, упрощающих работу с файловыми потоками (или, попросту, с файлами). Они следующие:
+ ifstream – для чтения данных из файла;
+ ofstream – для записи данных в файл;
+ fstream – для записи и чтения данных из файла.

И аналогичные им классы с дополнительной буквой w, означающей работу с данными типа `wchar_t`:
+ wifstream – для чтения данных из файла;
+ wofstream – для записи данных в файл;
+ wfstream – для записи и чтения данных из файла.

В рамках этого курса мы ограничимся первыми тремя классами. Три других используются аналогичным образом.

Для их использования в программе вначале необходимо подключить заголовочный файл с именем `fstream`:

```c++
#include <fstream>
```

После этого можно создавать объекты этих классов. Например:

```c++
#include <iostream>
#include <fstream>
 
using std::cout;
using std::cin;
using std::endl;
 
int main() {
    std::ofstream ofs;
    std::ifstream ifs;
    return 0;
}
```

Чтобы связать выходной и входной потоки с определенными файлами, используется метод `open` следующим образом:

```c++
    ofs.open("ofs.dat");
    ifs.open("ifs.dat");
```

Здесь:
+ файл `ofs.dat` открывается на запись в текстовом режиме доступа;
+ файл `ifs.dat` – открывается на чтение также в текстовом режиме доступа. 

Что это за режим, я думаю, вы хорошо помните из курса по языку Си?

После запуска программы в текущем (рабочем) каталоге появится пустой файл с именем `ofs.dat`.

Также открытие файла можно делать сразу в момент создания объектов классов потоков следующим образом:

```c++
    std::ofstream ofs("ofs.dat");
    std::ifstream ifs("ifs.dat");
```

Результат будет аналогичным.

Далее, мы знаем, что после завершения работы с файлами их обязательно нужно закрывать. Для этого используется метод `close()` объектов `ofs` и `ifs`:

```c++
    ofs.close();
    ifs.close();
```

И последний важный штрих в этой схеме открытия и закрытия файлов. 

Нам нужно проверить, что файл был открыт успешно, прежде чем начинать что-либо в него записывать или считывать. Для этого предусмотрен метод `is_open()`. 

Я для его демонстрации запишу следующие строчки:

```c++
    cout << (ofs.is_open() ? "Файл ofs.dat открыт" : "Ошибка открытия файла ofs.dat") << endl;
    cout << (ifs.is_open() ? "Файл ifs.dat открыт" : "Ошибка открытия файла ifs.dat") << endl;
```

После запуска программы увидим в консоли сообщения:

```
Файл ofs.dat открыт
Ошибка открытия файла ifs.dat
```

То есть, на запись файл был открыт успешно, а на чтение – с ошибкой. И это логично, так как файла `ifs.dat` в рабочем каталоге не существует.

## Режимы доступа к файлам

Давайте теперь посмотрим, какие режимы доступа к файлам мы можем прописывать при их открытии. Основные, следующие:
+ `ios::in` – для чтения (только для объектов классов ifstream или fstream);
+ `ios::out` – для записи; прежние данные удаляются (только для объектов классов ofstream или fstream);
+ `ios::app` – для дозаписи; прежние данные не удаляются;
+ `ios::ate` – при открытии указатель файла смещается в конец;
+ `ios::binary` – открытие файла в бинарном режиме доступа.

Указанные флаги используются, как самостоятельно, так и в допустимых комбинациях с другими флагами. Например, мы можем указать открыть файл на дозапись:

```c++
int main() {
    using std::ios;
    std::ofstream ofs("ofs.dat");
    std::ifstream ifs("ifs.dat", ios::app);
    ...
    return 0;
}
```

Обратите внимание, что после выполнения программы файл `ifs.dat` создается и успешно открывается благодаря изменению режима открытия. Сам файл, конечно же, будет пустым.

Или можно записать следующую комбинацию флагов для открытия файлов в бинарном режиме доступа:

```c++
    std::ofstream ofs("ofs.dat", ios::out | ios::binary);
    std::ifstream ifs("ifs.dat", ios::app | ios::binary);
```

И так далее. Мы можем прописывать, как самостоятельные флаги, так и их допустимые комбинации. Допустимость можно определить с позиции здравого смысла. Либо, почитать в документации.

Итак, мы с вами разобрали, как открывать файлы в разных режимах, проверять корректность открытия файлового потока и закрывать его. На следующем занятии посмотрим, как непосредственно выполняются файловые операции чтения/записи через объекты классов `ifstream`, `ofstream`  и `fstream`.

Видео по теме [#9. Файловые потоки. Открытие и закрытие файлов. Режимы доступа](https://www.youtube.com/watch?v=wymgSfSteIY&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Установите соответствия между классами ввода/вывода и их описаниями.

![09](/Good_good_C_C++/img/09_15.PNG)

### Подвиг 2. Выберите все верные утверждения, связанные со следующей программой.

```c++
#include <iostream>
#include <fstream>

int main() {
    std::ifstream fs1("test_file_1.txt");
    std::ofstream fs2("test_file_2.txt");

    if(!fs1.is_open()) 
        return 1;
    if(!fs2.is_open()) 
        return 2;

    fs1.close();
    fs2.close();

    return 0;
}
```

+ [x] метод close() закрывает файловый поток и освобождает все связанные с ним ресурсы
+ [ ] файл "test_file_1.txt" открывается на запись в текстовом режиме доступа
+ [x] если файл "test_file_2.txt" не может быть открыт, то функция main завершается с кодом 2
+ [x] файл "test_file_1.txt" открывается на чтение в текстовом режиме доступа
+ [x] если файл "test_file_1.txt" не может быть открыт, то функция main завершается с кодом 1
+ [x] для работы с классами ifstream и ofstream в программе необходимо подключить заголовок fstream
+ [ ] для работы с классами ifstream и ofstream в программе необходимо подключить заголовок iostream
+ [x] файл "test_file_2.txt" открывается на запись в текстовом режиме доступа
+ [ ] файл "test_file_2.txt" открывается на чтение в текстовом режиме доступа

### Подвиг 3. Запишите команду для потока ifs, которая открывает файл с именем my_marks.dat, расположенный в подкаталоге study, только на чтение в текстовом режиме доступа.

P. S. Запись команды начинать с имени переменной ifs. В конце не забудьте поставить точку с запятой.

```c++
#include <fstream>

using std::ios;

int main() {
    std::ifstream ifs;
    // здесь будет располагаться введенная команда

    ifs.open("study\my_marks.dat");

    ifs.close();

    return 0;
}

```

### Подвиг 4. Установите соответствия между режимами доступа и их описаниями.

![09](/Good_good_C_C++/img/09_16.PNG)

### Подвиг 5. Запишите команду для потока ofs, которая открывает файл с именем my_table.txt, расположенный в текущем (рабочем) каталоге, только на дозапись в текстовом режиме доступа.

P. S. Запись команды начинать с имени переменной ofs. В конце не забудьте поставить точку с запятой.

```c++
#include <fstream>

using std::ios;

int main() {
    std::ofstream ofs;
    // здесь будет располагаться введенная команда

    ofs.open("my_table.txt", ios::app);

    ofs.close();

    return 0;
}
```

### Подвиг 6. Пусть в программе открыт файловый поток с использованием переменной (объекта) my_file_stream. Необходимо записать команду (с использованием метода) для проверки успешности открытия потока.

P. S. Записать нужно только команду без проверок каких-либо условий. Запись начинайте с объекта my_file_stream, в конце поставьте точку с запятой.

```c++
my_file_stream.is_open();
```

### Подвиг 7. Запишите комбинацию режимов для открытия файлового потока на чтение в бинарном режиме доступа. Предполагается, что в программе прописана конструкция:

```c++
using std::ios;
```

P. S. Записать нужно только режим, больше ничего.

```c++
ios::in | ios::binary
```

### Подвиг 8 (на повторение). Выберите все верные утверждения, касающиеся файловых потоков языка Си.

+ [x] новый файловый поток открывается с помощью функции fopen
+ [x] для работы с файловыми функциями необходимо подключить файл stdio.h
+ [x] на файловый поток ссылается указатель специального типа FILE
+ [x] каждый файловый поток (по умолчанию) имеет буфер приема или передачи данных
+ [x] функция fclose освобождает все ресурсы, связанные с открытым файловым потоком
+ [x] после работы с файловым потоком его следует закрыть функцией fclose

### Подвиг 9 (на повторение). Установите соответствия между режимами доступа к файлу в языке Си и их описаниями.

![09](/Good_good_C_C++/img/09_17.PNG)

# 9.11 Чтение и запись данных в файл в текстовом режиме

Продолжаем тему работы с файлами с помощью классов:
+ ifstream – для чтения данных из файла;
+ ofstream – для записи данных в файл;
+ fstream – для записи и чтения данных из файла.

Пусть в программе открывается файл на запись в текстовом режиме доступа:

```c++
#include <iostream>
#include <fstream>
 
using std::ios;
 
int main() {
    std::ofstream ofs("out_course.dat");    // открытие файла
 
    ofs.close();            // закрытие файла
    return 0;
}
```

Чтобы поместить в него какие-либо данные базовых типов, достаточно воспользоваться операцией `<<`, например, следующим образом:

```c++
    if(ofs.is_open()) {
        ofs << 10 << -5.34 << -34 << std::endl;
    }
```

Обратите внимание, что мы можем по цепочке прописывать сохраняемые в файл данные, а также использовать стандартную функцию `endl` для перевода строки и очистки буфера выходного файлового потока.

Если после выполнения программы посмотрим на содержимое файла `out_course.dat`, то увидим строку:

```
10-5.34-34
```

Как вы понимаете, эти данные будет сложно прочитать, так как между числами нет никакого разделения. Давайте добавим пробел:

```c++
    if(ofs.is_open()) {
        ofs << 10 << " " << -5.34 << " " << -34 << std::endl;
    }
```

Теперь данные в файле четко разделены между собой через пробел:

```
10 -5.34 -34
```

и их относительно просто можно прочитать. Для этого воспользуемся файловым потоком, открытым с помощью класса `ifstream`, следующим образом:

```c++
int main() {
    ...
 
    // ------------- чтение данных из файла --------------------------------
    int data_i1 {}, data_i2 {};
    double data_d1 {};
 
    std::ifstream ifs("out_course.dat");
    
    if(ifs.is_open()) {
        ifs >> data_i1 >> data_d1 >> data_i2;
    }
    std::cout << data_i1 << " " << data_d1 << " " << data_i2 << std::endl;
 
    ifs.close();            // закрытие файла
 
    return 0;
}
```

Как видите, для чтения данных произвольного типа используется операция `>>`, которую также можно вызывать по цепочке. 

При этом пробел автоматически воспринимается, как разделитель между данными, подобно тому, как это было для функции `scanf()` языка Си. 

И, разумеется, формат читаемых данных должен совпадать с типом переменных, в которые происходит чтение. Например, если совпадений по типам не будет:

```c++
    if(ifs.is_open()) {
        ifs >> data_i1 >> data_i2 >> data_d1;
    }
```

То данные будут прочитаны некорректно.

## Запись и чтение строк

Но это были числа. Что если нам нужно записывать и считывать строки целиком? Нет ничего проще. Запись строк происходит совершенно так же, как и запись чисел. Например:

```c++
    if(ofs.is_open()) {
        ofs << 10 << " " << -5.34 << " " << -34 << "\n";
        ofs << "I'm Sergey Balakirev" << std::endl;
    }
```

В выходном файле видим эту строку. А вот чтение имеет свои нюансы. Опять же, операция `>>` работает по аналогии с функцией `scanf()`, а значит, читает строку до первого пробела. Например:

```c++
    std::string str;
 
    if(ifs.is_open()) {
        ifs >> data_i1 >> data_d1 >> data_i2;
        ifs >> str;
    }
 
    std::cout << str << std::endl;
```

Увидим фрагмент:

```
I'm
```

Причем, обратите внимание, так как объект-строка `str` основывается на динамическом массиве, то выход за его пределы при чтении длинных строк происходить не будет. То есть, это безопасная операция. А вот если бы мы воспользовались обычным массивом символов:

```c++
char msg[100];
ifs >> msg;
```

то вполне можно выйти за его пределы и записать информацию в недопустимые ячейки памяти. Работа такой программы становится непредсказуемой. Об этом всегда следует помнить, при работе со строками.

Итак, вернем прежний вариант строки `str` и спрашивается, как же все-таки прочитать всю строку до символа перевода строки, либо до конца файла? Для этого можно воспользоваться уже знакомой нам функцией `getline()` следующим образом (не забываем прописать: `#include <string>`):

```c++
    if(ifs.is_open()) {
        ifs >> data_i1 >> data_d1 >> data_i2;
        std::getline(ifs, str);
        std::getline(ifs, str);
    }
```

Обратите внимание, мне пришлось дважды вызвать функцию getline() для чтения следующей строки. Дело в том, что после чтения числовых данных указатель файла ведет на символ переноса строки, поэтому первая функция его читает и выдает пустую строку, а следующая уже читает с новой строки все символы до следующего перевода строки. Поэтому, для пропуска всех пустых строк, можно записать следующую конструкцию:

```c++
    if(ifs.is_open()) {
        ifs >> data_i1 >> data_d1 >> data_i2;
        str = "";
        while(str.length() == 0)
            std::getline(ifs, str);
    }
```

На следующем занятии мы с вами посмотрим, как происходит работа с файлами в бинарном режиме и для каких данных его целесообразно применять.

Видео по теме [#10. Чтение и запись данных в файл в текстовом режиме](https://www.youtube.com/watch?v=oy5AbW4c3YM&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)


### Подвиг 1. Выберите все верные утверждения, связанные со следующей программой.

```c++
#include <iostream>
#include <fstream>

using std::ifstream;
using std::ofstream;

int main() {
    ofstream fs("my_marks.dat");

    if(!fs) {
        std::cout << "Невозможно открыть файл";
        return 0;
    }

    short marks[] = {3, 3, 2, 3, 4, 3, 2};
    for(int i = 0; i < sizeof(marks) / sizeof(*marks); ++i)
        fs << marks[i] << "; ";

    fs.close();

    return 0;
}
```

+ [ ] открывается файл на дозапись с именем my_marks.dat в текущем (рабочем) каталоге
+ [ ] после успешного выполнения программы файл my_marks.dat будет содержать строку: 3; 3; 2; 3; 4; 3; 2
+ [x] если файловый поток не был открыт, то в консоль выводится сообщение "Невозможно открыть файл" и функция main завершает свою работу
+ [x] после успешного выполнения программы файл my_marks.dat будет содержать строку: 3; 3; 2; 3; 4; 3; 2;
+ [x] в файл my_marks.dat происходит запись значений из массива marks
+ [x] открывается файл на запись с именем my_marks.dat в текущем (рабочем) каталоге

### Подвиг 2. Выберите все верные утверждения, связанные со следующей программой.

```c++
#include <iostream>
#include <fstream>

using std::ifstream;
using std::ofstream;

int main() {
    ifstream fs("my_marks.dat");

    if(!fs) {
        std::cout << "Невозможно открыть файл";
        return 0;
    }

    short marks[10] = {0};
    int count = 0;
    while(count < 10 && fs >> marks[count])
        count++;

    fs.close();

    for(const int& x : marks)
        std::cout << x << " ";

    return 0;
}
```

+ [x] если в файле my_marks.dat присутствует строка "3; 3; 2; 3; 4; 3; 2; ", то будет прочитано только первое число из этого файла
+ [x] в цикле while выполняется последовательное чтение данных, пока не будет прочитано 10 элементов, или операция чтения >> не вернет значение 0
+ [x] в конце программы выполняется поэлементный вывод значений всех элементов массива marks
+ [ ] если в файле my_marks.dat присутствует строка "3; 3; 2; 3; 4; 3; 2; ", то будут прочитаны все числа из этого файла
+ [x] открывается файл на чтение с именем my_marks.dat в текущем (рабочем) каталоге
+ [ ] в конце программы выполняется поэлементный вывод только прочитанных из файла значений элементов массива marks

### Подвиг 3. Имеется следующая программа:

```c
#include <iostream>
#include <fstream>

using std::ifstream;
using std::ofstream;

int main()
{
    short sh = 10;
    double d = -0.56;
    char ch = 'a';
    
    ofstream ofs("my_data.dat");

    if(!ofs) {
        std::cout << "Невозможно открыть файл";
        return 0;
    }

    // здесь будет располагаться записанная команда
    ofs << sh << " " << d << " " << ch;

    ofs.close();

    return 0;
}
```

Запишите в одну строчку команду для записи значений переменных sh, d, ch (именно в таком порядке) в файловый поток ofs в одну строчку через пробел.

### Подвиг 4. Имеется следующая программа:

```c++
#include <iostream>
#include <fstream>

using std::ifstream;
using std::ofstream;

int main() {
    short sh;
    double d;
    char ch;
    
    ifstream ifs("my_data.dat");

    if(!ifs) {
        std::cout << "Невозможно открыть файл";
        return 0;
    }

    // здесь будет располагаться записанная команда

    ifs >> sh >> d >> ch;

    ifs.close();

    return 0;
}
```

Запишите в одну строчку команду для чтения значений в переменные sh, d, ch (именно в таком порядке) из файлового потока ifs (данные записаны в одну строчку через пробел).

### Подвиг 5. Пусть в программе открыт файловый поток ifs на чтение данных из файла my_life.txt. Запишите команду для чтения из этого файла первой строки (целиком) в переменную:

```c++
std::string header;
```

Используйте для этого функцию getline. В конце не забудьте поставить точку с запятой.

```c++
getline(ifs, header);
```

### Подвиг 6. Пусть в программе открыт файловый поток fs на запись данных в файл my_life.txt. Запишите команду для записи в этот файл строки:

```c++
std::string header {"Краткая история языка С++"};
```

В конце не забудьте записать в файл перенос на новую строку с помощью функции `std::endl`.

```c++
fs << header << std::endl;
```

### Подвиг 7 (на повторение). Установите соответствия между функциями языка Си и их описаниями.

![09](/Good_good_C_C++/img/09_18.PNG)

### Подвиг 8 (на повторение). Выберите все верные утверждения, касающиеся потоков ввода/вывода языка Си.

+ [x] для использования макроса errno необходимо подключить заголовочный файл errno.h
+ [ ] функции perror, fseek, ftell определены в заголовочном файле stdfile.h
+ [ ] для использования макроса errno необходимо подключить заголовочный файл stdio.h
+ [x] предопределенное значение EOF означает конец данных в файловом потоке
+ [x] функции perror, fseek, ftell определены в заголовочном файле stdio.h
+ [x] макрос errno содержит код последней возникшей ошибки при работе с потоками ввода/вывода

### Подвиг 9 (на повторение). Установите соответствия между константами и их описаниями.

![09](/Good_good_C_C++/img/09_19.PNG)

# 9.12 Чтение и запись данных в файл в бинарном режиме

## Чтение и запись данных в файл в бинарном режиме

На данный момент мы с вами научились открывать файловые потоки, сохранять и читать данные базовых типов в текстовом режиме доступа. На этом занятии сделаем следующий шаг и посмотрим, как используется бинарный режим и зачем он нужен.

Итак, что такое бинарный режим? 

Мы с вами об этом подробно уже говорили на курсе по языку Си. 

Кратко напомню. Бинарный режим позволяет сохранять данные в файл в том же виде, в котором они представлены в ячейках памяти устройства. То есть, мы можем просто прочитать данные из памяти и перенести их в файл. 

И, наоборот, прочитать данные из файла и занести их в нужные ячейки памяти. В результате, сложные структуры данных достаточно просто можно сохранять и загружать из файла.

Давайте предположим, что нам в программе нужно сохранять массив из вещественных чисел в файл. Такие «не простые» наборы данных удобнее всего сохранять и, затем, читать в бинарном режиме доступа:

```c++
#include <iostream>
#include <fstream>
 
using std::ios;
 
int main() {
    double pow[] {4.3, -54.33, 0.01};
 
    std::ofstream ofs("out_course.dat", ios::out | ios::binary);
 
    if(ofs.is_open()) {
    }
 
    ofs.close();
    return 0;
}
```

Если сейчас попытаться сохранить массив `pow`, используя операцию `<<`:

```c++
    if(ofs.is_open()) {
        ofs << pow;
    }
```

то в файл запишется адрес массива в текстовом виде. Как же нам сохранить данные этого массива, перенеся данные из ячеек памяти, которые он занимает, в файл? 

Для этого следует воспользоваться методом `write()` следующим образом:

```c++
    if(ofs.is_open()) {
        ofs.write((char *)pow, sizeof(pow));
    }
```

Этот метод работает по аналогии с функцией `write()` языка Си. Первым аргументом передается адрес области памяти, которая переносится в файл, а вторым аргументом – размер сохраняемого фрагмента. В нашем случае – это размер массива `pow` в байтах.

После выполнения программы в выходном файле появится набор нечитаемых символов, соответствующих байтовому представлению массива `pow` в памяти устройства. Прочитать обратно эти данные в массив очень просто. Для этого откроем файл на чтение также в бинарном режиме и прочитаем байты с помощью метода `read()`:

```c++
    // ------------- чтение данных из файла --------------------------------
    double read_pow[5] {0};
 
    std::ifstream ifs("out_course.dat", ios::in | ios::binary);
 
    if(ifs.is_open()) {
        ifs.read((char *)read_pow, sizeof(pow));
    }
 
    for(double x : read_pow)
        std::cout << x << " ";
 
    ifs.close()
```

Метод `read()` работает по аналогии с функцией `read()` языка Си и позволяет заносить в указанную область памяти, прочитанные из файла данные. 

В данном случае, мы в массив `read_pow` заносим байты, ранее сохраненного массива `pow`. Разумеется, массив `read_pow` должен иметь тот же тип данных и размер не меньше, чем `pow`.

После запуска программы, увидим значения:

```
4.3 -54.33 0.01 0 0
```

Как видим, данные были успешно прочитаны.

## Чтение и запись структур в файл

Давайте, для лучшего понимания, приведу еще один практический пример использования бинарного режима доступа. Пусть у нас объявлена следующая структура:

```c++
struct person {
    char fio[100];
    short old;
    unsigned int salary;
    double weight;
};
```

И, затем, в программе выполняется сохранение массива таких структур и их последующее чтение следующим образом:

```c++
int main() {
    struct person ps[] {{"Sergey Balakirev", 102, 1000001, 82.6},
                        {"Bjarne Stroustrup", 56, 100001, 78.2},
                        {"Dennis Ritchie", 62, 10001, 88.9},
                        {"Kenneth Thompson", 58, 10002, 75.3},
                    };
 
    std::ofstream ofs("out_course.dat", ios::out | ios::binary);
 
    if(ofs.is_open()) {
        for(auto& p : ps)
            ofs.write((char *)&p, sizeof(p));
    }
 
    ofs.close();
 
    // ------------- чтение данных из файла --------------------------------
    struct person ps_r[10];
    int count = 0;
 
    std::ifstream ifs("out_course.dat", ios::in | ios::binary);
 
    if(ifs.is_open()) {
        while(ifs.read((char *)&ps_r[count], sizeof(person))) {
            count++;
        }
    }
 
    ifs.close();
 
    std::cout << count << std::endl;
    for(int i = 0; i < count; ++i) {
        std::cout << ps_r[i].fio << "\n";
        std::cout << ps_r[i].old << " " << ps_r[i].salary << " " << ps_r[i].weight << std::endl;
    }
 
    return 0;
}
```

Вначале мы перебираем поэлементно все элементы массива `ps` и с помощью метода `write()` записываем друг за другом в файл. После этого объявляем еще один массив таких же структур и в цикле поэлементно читаем данные из файла в этот новый массив.

Обратите внимание, как выполняется чтение данных. 

Условием окончания цикла `while` является возвращаемое значение метода `read()`. Этот метод вернет `0` (`false`), когда данные в файле закончатся. 

Таким образом, мы прочитаем ровно столько же порций данных, сколько было записано. Вывод результата в консоль это подтверждает.

Вот основные (базовые) возможности классов файловых потоков языка С++. Конечно, это далеко не все, на что они способны. Но для начального их использования этой информации вам будет вполне достаточно.

Видео по теме [#11. Чтение и запись данных в файл в бинарном режиме](https://www.youtube.com/watch?v=rVibENiJZeQ&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, касающиеся бинарного режима работы с файлами в С++.

+ [x] для чтения данных в бинарном режиме применяется метод (функция) read
+ [x] для открытия файлового потока в бинарном режиме следует указать флаг ios::binary
+ [x] в бинарном режиме данные записываются и читаются из файлов один в один без каких-либо искажений и пропусков
+ [x] для записи данных в бинарном режиме применяется метод (функция) write
+ [ ] для записи данных в бинарном режиме применяется метод (функция) read
+ [ ] для чтения данных в бинарном режиме применяется метод (функция) write

### Подвиг 2. Выберите все верные утверждения, касающиеся следующей программы:

```c++
#include <iostream>
#include <fstream>

using std::ios;

int main() {
    short marks[] = {3, 3, 4, 3, 2, 2};

    std::ofstream ofs("my_data.dat", ios::out | ios::binary);

    if(!ofs) {
        std::cout << "Невозможно открыть файл";
        return 1;
    }

    ofs << "hello" << std::endl;
    ofs.write((char *)marks, sizeof(marks));

    ofs.close();
    return 0;
}
```

+ [x] если после записи не закрыть файловый поток, то данные в файл могут полностью не записаться (произойдет потеря данных)
+ [x] команда ofs << "hello" записывает строку "hello" в файл my_data.dat
+ [ ] команда ofs << "hello" приведет к ошибке, т.к. файл открыт в бинарном режиме
+ [x] метод (функция) write побайтно записывает массив marks в файл my_data.dat
+ [x] приведение типов (char *)marks необходимо, т.к. первый параметр метода write ожидает указатель типа const char*
+ [x] работа с файлом my_data.data выполняется в бинарном режиме

### Подвиг 3. Запишите комбинированный флаг для открытия файлового потока на чтение в бинарном режиме.

```c++
ios::in | ios::binary
```

### Подвиг 4. Пусть имеется следующая программа:

```c++
#include <iostream>
#include <fstream>

using std::ios;

int main() {
    short marks[10];

    std::ifstream ifs("my_data.dat", ios::in | ios::binary);

    // здесь будет располагаться записанная команда (оператор)

    ifs.read((char *)marks, sizeof(marks));


    ifs.close();

    return 0;
}
```

Запишите команду (оператор) для побайтного считывания данных (записанных в бинарном виде) из файлового потока `ifs` в массив `marks`. Максимальный размер читаемых данных не должен превышать байтового размера массива `marks`.
 
### Подвиг 5. Пусть имеется следующая программа:

```c
#include <iostream>
#include <fstream>

using std::ios;

int main() {
    double digits[10] = {0.5, 0.3, 0.6};
    int count = 3;

    std::ofstream ofs("digits.dat", ios::out | ios::binary);

    // здесь будет располагаться записанная команда (оператор)
    
    ofs.write((char *)digits, sizeof(double) * count);

    ofs.close();

    return 0;
}
```

Запишите команду (оператор) для побайтной записи данных (в бинарном режиме) в файловый поток `ofs` первых count значений массива `digits`.

### Подвиг 6. Продолжите программу:

```c++
#include <iostream>
#include <fstream>

struct car {
    char model[50];
    unsigned short max_speed;
    double power;
    unsigned int weight;
};

int main() {
    car my_auto = {"BMW X5", 240, 215.6, 1743};
    std::ofstream ofs("autos.db", std::ios::out | std::ios::binary);

    // здесь будет располагаться записанная команда (оператор)
    ofs.write((char *)&my_auto, sizeof(car));

    ofs.close();
    return 0;
}
```

Запишите команду (оператор) для побайтной записи переменной `my_auto` (в бинарном режиме) в файловый поток `ofs`.

### Подвиг 7. Продолжите программу:

```c++
#include <iostream>
#include <fstream>

struct car {
    char model[50];
    unsigned short max_speed;
    double power;
    unsigned int weight;
};

int main() {
    car my_auto;
    std::ifstream ifs("autos.db", std::ios::in | std::ios::binary);

    // здесь будет располагаться записанная команда (оператор)

    ifs.read((char *)&my_auto, sizeof(car));

    ifs.close();
    return 0;
}
```

Запишите команду (оператор) для побайтного чтения данных (записанных в бинарном режиме) из файлового потока `ifs` в переменную `my_auto`.

### Подвиг 8 (на повторение). Установите соответствия между режимами доступа и их описаниями.

![09](/Good_good_C_C++/img/09_20.PNG)

### Подвиг 9 (на повторение). Выберите все верные (работающие) конструкции с константной переменной языка C++.

+ [ ] const char ch_cnst; ch_cnst = 12;
+ [x] long const lg = 10;
+ [x] const short sh = 100;
+ [ ] char const cnst_ch; cnst_ch = 12;
+ [x] const int a = 5; int b = a;
+ [ ] const int var;

### Подвиг 10 (на повторение). Выберите все верные утверждения, касающиеся следующего фрагмента программы языка Си стандарта C99:

```c
#include <stdio.h>

int main(void) {
    int n = 7;
    while(n-- > 0) {
        int n = 5;
        printf("%d\n", n);
        n++;
    }
    
    printf("%d\n", n);

    return 0;
}
```

+ [ ] при выполнении программы в консоли шесть раз отобразится число 5, а в конце число -1
+ [x] цикл while сработает ровно семь раз (семь итераций)
+ [x] при выполнении программы в консоли семь раз отобразится число 5, а в конце число -1
+ [ ] цикл while будет работать "вечно", т.к. значение n на каждой итерации устанавливается равным 5
+ [x] в теле цикла while переменная n каждый раз инициализируется значением 5
+ [ ] при выполнении программы в консоли восемь раз отобразится число 5, а в конце число 0

# 9.13 Перегрузка функций. Директива extern C

## Перегрузка функций.

Начиная с этого занятия, рассмотрим несколько значимых новшеств определения функций, которые появились в С++. 

Я не буду повторяться, что такое функции, как они объявляются и вызываются. Об этом мы с вами уже подробно говорили на курсе по языку Си. На этом занятии речь пойдет о перегрузке функций. Что это такое?

Давайте представим, что нам в программе нужна функция, которая бы вычисляла модуль чисел в диапазоне `[-10; 10]`. При этом, числа могут быть как целыми, так и вещественными (дробными). 

Если бы мы оставались в рамках языка Си, то было бы целесообразно объявить две функции: одна для целочисленных значений, а вторая – для вещественных. Например, так:

```c
int modul_int(int x) {
    cout << "modul(int)" << endl;
    if(x >= -10 && x <= 10)
        return (x > 0) ? x : -x;
    return x;
}
 
double modul_double(double x) {
    cout << "modul(double)" << endl;
    if(x >= -10 && x <= 10)
        return (x > 0) ? x : -x;
    return x;
}
```

То есть, имена у этих функций должны были бы различаться. Но С++ позволяет объявлять функции с одинаковыми именами, но разными типами входных параметров. И наш пример можно записать в следующем виде:

```c++
int modul(int x) ...
double modul(double x) ...
```

Это и есть пример перегрузки функции с именем `modul`, а точнее, перегрузки имени функции. То есть, когда одному имени функции соответствует несколько реализаций с разными типами входных параметров, то такая функция называется перегруженной.

Хорошо, но что нам это дает? Давайте вспомним, что на чистом Си имеются функции вида:

```c
long labs(long); // для вычисления модуля целых чисел;
double fabs(double); // для вычисления модуля вещественных чисел.
```

Соответственно, программист должен был запоминать все возможные вариации подобных функций. 

Теперь же, благодаря возможности перегрузки функций, в С++ вместо всего этого зоопарка имен достаточно запомнить одно определенное имя, например:

```c
int abs(int);
double abs(double);
```

Но как тогда компилятор поймет, какую функцию вызывать из всего множества различных вариантов? Давайте, я покажу это на примере нашей функции `modul()`. Вызовем ее следующими способами:

```c
int main() {
    double res_1 = modul(-0.5);  // modul(double)
    int res_2 = modul(-0.5);        // modul(double)
    double res_3 = modul(-5);    // modul(int)
    int res_4 = modul(-5);           // modul(int)
 
    return 0;
}
```

В консоли увидим:

```c
modul(double)
modul(double)
modul(int)
modul(int)
```

То есть, в первых двух случаях компилятор подставил функцию с параметром `double`, а во вторых двух – функцию с параметром `int`. 

При этом тип переменной, которой присваивается результат, никак не влияет на выбор той или иной функции. И это логично. 

Главное, вызвать функцию с наиболее подходящим набором параметров, а куда мы присвоим результат – это уже задача программиста, использующего эту перегруженную функцию. 

Таким образом, компилятор выбирает тот или иной вариант объявления, опираясь на типы передаваемых аргументов при вызове функции. 

Причем, типы можно указывать меньших размерностей, например, в параметр `double` передавать число типа `float`, или в параметр `int` число типа `short`. 

А вот при передаче больших размерностей компилятор выдаст сообщение об ошибке, т.к. в этом случае возможна потеря данных:

```c
int main() {
    double res_1 = modul(-0.5f);  // ok
    int res_2 = modul((long double)(-0.5));       // ошибка
    double res_3 = modul(-5L); // ошибка
    int res_4 = modul((short)-5);   // ok
 
    return 0;
}
```

Аналогичная картина будет и для функций со множеством параметров. Чтобы компилятор смог выбрать одну из них, все типы аргументов должны согласовываться с типами параметров одного из объявлений перегруженной функции. Если хотя бы один тип не совпадет, то в момент компиляции возникнет ошибка.

## Особенности перегрузки имен функций. Директива extern "C"

Формально, перегрузка функций относится к так называемому статическому полиморфизму. 

Умное слово полиморфизм здесь означает, что одному и тому же имени функции может соответствовать разная реализация. 

А другое умное слово статический означает, что реализации функций выбираются и подставляются компилятором непосредственно в итоговый машинный код. 

То есть, выбор той или иной функции для выполнения происходит не в момент выполнения программы, а в момент ее компиляции и не меняется в последующем.

Надо сказать, что механизм перегрузки функций в С++ повлек за собой некоторые особенности при сборке проектов в исполняемый файл. 

Ранее, когда создавался язык Си, то функции имели уникальные имена. 

Соответственно, компоновщик, встречая имя функции в объектном файле, подставлял вместо него соответствующий код вызова. Например, имя функция `modul_int()` в Си внутри объектного файла имела метку `modul_int`. 

Все просто. 

Но с перегрузкой имен функций все изменилось. Теперь мало просто указать ее имя, нужно дополнительно закодировать в объектном файле набор ее параметров, так как именно эта связка:

```
имя функции + параметры
```

дает уникальную метку. Проблема в том, что разные компиляторы языка С++ по разному выполняют это кодирование. Например, компилятор g++ для функции:

```c
int modul(int x);
```

сформирует метку вида:

```
_Z5moduli
```

Здесь `_Z` – это специальный префикс, означающий начало метки функции; число `5` – количество символов в имени функции; `i` – внутреннее обозначение стандартного типа `int`.

Повторюсь, другие компиляторы языка С++ и даже разные версии одного и того же компилятора, могут по разному строить эти метки. 

К чему это в итоге приводит? 

Все верно. Если у нас есть только объектные файлы какого-либо проекта, то не всегда нам удастся его собрать и получить конечный результат, например, в виде исполняемого файла. Мало того, если объектные файлы были созданы компилятором языка Си, в котором не подразумевается перегрузка функций, то кодирование меток точно будет неверным для компилятора С++.

Но вот эта последняя проблема все же решаема. Если мы пишем программу на языке Си и предполагаем использовать ее, в том числе, и на С++, то объявление функций следует поместить в тело директивы `extern "C"` следующим образом:

```c
extern "C" {
 
void show_msg(const char* msg) {
    puts("-----------------------");
    puts(msg);
    puts("-----------------------");
}
 
}
```

Или, если в блоке одна функция, то можно просто указать:

```c++
extern "C"
void show_msg(const char* msg) {
    puts("-----------------------");
    puts(msg);
    puts("-----------------------");
}
```

Разумеется, внутри директивы `extern "C"` не допускается определять перегруженные функции, т.к. метки будут формироваться и восприниматься компоновщиком в стиле языка Си.

В результате, мы имеем функцию `show_msg()`, которая в объектном файле будет представлена своим именем `show_msg` и успешно обрабатываться различными компиляторами языка С++. Однако директива `extern "C"` доступна в языке С++ и не существует в языке Си. Поэтому для полной универсальности кода, следует добавить следующие директивы условной компиляции:

```c++
#ifdef __cplusplus
extern "C" {
#endif
void show_msg(const char* msg) {
    puts("-----------------------");
    puts(msg);
    puts("-----------------------");
}
 
#ifdef __cplusplus
}
#endif
```

Здесь макросимвол `__cplusplus` всегда существует для компилятора С++ и изначально отсутствует в компиляторе языка Си. Поэтому язык Си «не увидит» директиву `extern "C"`, а С++ успешно ее обработает. 

В итоге, получаем универсальное объявление функции `show_msg()` для компиляторов обоих языков.

Конечно, это следует делать только в том случае, если мы, например, пишем библиотеку общую для Си и С++ или модуль, который предполагается использовать в этих языках. Тогда нужно добавлять директиву `extern "C"`. Если же программа пишется исключительно для Си или С++, то функции объявляются обычным образом.

Видео по теме [#12. Перегрузка функций. Директива extern C](https://www.youtube.com/watch?v=f9eb_54T4vY&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, касающиеся перегрузки функций в языке С++.

+ [ ] перегрузку функций можно отнести к одному из видов динамического полиморфизма (dynamic полиморфизм)
+ [x] выбор вызова той или иной перегруженной функции выполняется компилятором в момент компиляции программы
+ [ ] выбор вызова той или иной перегруженной функции выполняется в соответствии с типами входных аргументов в процессе работы программы
+ [x] перегрузку функций можно отнести к одному из видов статического полиморфизма (ad hoc полиморфизм)
+ [x] функции называются перегруженными, если они имеют одинаковое имя, но разные типы и/или количество входных параметров

### Подвиг 2. Пусть в программе изначально объявлена следующая функция:

```c
int func_overload(int x) {return 0;}
```

Выберите все верные варианты, соответствующие ее перегрузке.

+ [x] int func_overload(int x, int y) {return 1;}
+ [ ] double func_overload(int x) {return 3;}
+ [x] int func_overload(short x) {return 5;}
+ [x] int func_overload(double x) {return 2;}
+ [ ] int func_overload(const int x) {return 6;}
+ [ ] int func_overload(int y) {return 4;}
+ [x] int func_overload(unsigned int x) {return 7;}

### Подвиг 3. Пусть в программе объявлены следующие перегруженные функции:

```c++
int perimetr(unsigned a, unsigned b) {
    return 2 * (a + b);
}

float perimetr(float a, float b) {
    return 2.0f * (a + b);
}
```

Отметьте для каждого вызова номер вызываемой функции (1 - первая; 2 - вторая), либо ошибку вызова.

![09](/Good_good_C_C++/img/09_21.PNG)

### Подвиг 4. Объявите в программе две функции с именем get_perimetr, которые вычисляют периметр фигуры и возвращают целочисленные значения. Функции должны иметь следующие наборы параметров типа int:

+ у одной функции три параметра для вычисления периметра треугольника; вычисленный периметр возвращается;
+ у другой функции два параметра для вычисления периметра прямоугольника; вычисленный периметр возвращается.

Функцию main в программе объявлять не нужно.

P. S. Функции get_perimetr вызывать не нужно, только объявить. В консоль также ничего не выводится.

```c++
int get_perimetr(int a, int b, int c) {
    int res = a + b+ c;
    return res;
}
int get_perimetr(int a, int b) {
    int res = (a + b) * 2;
    return res;
}
```

### Подвиг 5. Объявите в программе две функции с именем get_square, которые вычисляют площадь фигуры и возвращают ее. Функции должны иметь следующие наборы параметров типа int:

у одной функции три параметра для вычисления площади треугольника; вычисленная площадь возвращается (тип double);
у другой функции два параметра для вычисления площадь прямоугольника; вычисленная площадь возвращается (тип int).
Напомню, что площадь треугольника по трем его сторонам можно вычислить по формуле Герона:

$S= \sqrt{p⋅(p−a)⋅(p−b)⋅(p−c)}$ 

где $p=(a+b+c)/2$ - полупериметр треугольника.

В функции `main` прочитайте из входного потока три первых целых числа для длин сторон треугольника, а вторые два - для длин сторон прямоугольника. Все числа во входном потоке записаны в одну строчку через пробел. Вызовите функции `get_square` для вычисления площади треугольника и прямоугольника. Выведите вычисленные значения площади треугольника и прямоугольника (именно в таком порядке) в консоль в одну строчку через пробел с точностью до десятых.

Sample Input:

6 4 9 10 15

Sample Output:

9.6 150.0

```c++
#include <cmath>
#include <iostream>

double get_square(int a, int b, int c) {
    double p = (a + b + c) / 2.0;
    double res = sqrt(p * (p - a) * (p - b) * (p - c));
    return res;
}

int get_square(int a, int b) {
    int res = a * b;
    return res;
}

int main() {
    int a, b, c, d, e;
    std::cin >> a >> b >> c >> d >> e;

    double tr_sq = get_square(a, b, c);
    int qr_sq = get_square(d, e);

    printf("%.1lf %.1lf", tr_sq, (double)qr_sq);

    return 0;
}
```

### Подвиг 6. Объявите в программе две функции с именем min2, которые возвращают минимальное из двух переданных чисел. Одна функция min2 должна иметь целочисленные параметры типа int и возвращать целочисленное значение, а вторая - вещественные типа double и возвращать вещественное значение.

В функции main прочитайте из входного потока два числа, записанных через пробел. Первое число целочисленное и должно быть сохранено в целочисленной переменной, а второе - вещественное (должно быть сохранено в вещественной переменной). Вызовите функцию min2, которая определена с двумя параметрами типа double и выведите в консоль возвращенное значение с точностью до десятых.

```c++
#include <cmath>
#include <iostream>

double min2(double a, double b) { return a < b ? a : b; }

int min2(int a, int b) { return a < b ? a : b; }

int main() {
    int a;
    double b;

    std::cin >> a >> b;

    double result = min2((double) a, b);

    printf("%.1lf", result);

    return 0;
}
```

### Подвиг 7. Выберите все верные утверждения, касающиеся директивы extern "C" языка С++.

+ [x] компилятор языка Си не воспринимает директиву extern "C" и ее наличие приведет к синтаксической ошибке
+ [x] директива extern "C" указывает компилятору С++ воспринимать (находить, определять) метку функции в объектных файлах исключительно по ее имени
+ [x] внутри директивы extern "C" нельзя прописывать перегрузку функций
+ [x] в программах на С++ доступно и предопределено макроимя __cplusplus, а в языке Си изначально его нет
+ [x] директива extern "C" указывает компилятору С++ кодировать метку функции в объектных файлах исключительно по ее имени (без набора типов параметров)
+ [x] из-за введения механизма перегрузки имен функций в С++ их метки в объектных файлах представляются именем функции и набором типов параметров

### Подвиг 8. Объявите в программе функцию через директиву extern "C" следующей сигнатуры:

```c
double mean_2(int a, int b);
```

которая вычисляет среднее арифметическое значений `a` и `b` и возвращает вычисленный результат. Программа должна быть составлена так, чтобы она компилировалась на Си и С++.

В функции `main` прочитайте из входного потока два целых значения, записанных через пробел, и вызовите для них функцию `mean_2`. Возвращенное значение выведите в консоль с точностью до десятых.

Sample Input:

54 37

Sample Output:

45.5

```c++
#ifdef __cplusplus
#include <iostream>
#else
#include <stdio.h>
#endif

double mean_2(int a, int b) {
    double res = (a + b) / (double)2;
    return res;
}

int main() {
    int a, b;

    scanf("%d %d", &a, &b);

    double result = mean_2(a, b);

    printf("%.1lf", result);

    return 0;
}
```

### Подвиг 9. Объявите в программе перегруженные функции get_mean со следующими сигнатурами:

```c++
double get_mean(const short* d, const size_t len);
double get_mean(const int* d, const size_t len);
double get_mean(const double* d, const size_t len);
```

Эти функции должны вычислять и возвращать среднее арифметическое переданного массива d длиной len элементов.

В функции main объявите массив с типом short, длиной 100 и прочитайте из входного потока целые числа, записанные через пробел. Вызовите для этого массива функцию get_mean и вычислите среднее арифметическое для прочитанных чисел из входного потока. Результат выведите в консоль с точностью до сотых.

Sample Input:

5 4 3 10 -12 9 8 34 2 13 11 7

Sample Output:

7.83

```c++
#include <iomanip>
#include <iostream>

enum { max_ar_len = 100 };

double get_mean(const short* d, const size_t len) {
    double res = 0;
    for (size_t i = 0; i < len; i++) {
        res += d[i];
    }
    return res / len;
}
double get_mean(const int* d, const size_t len) {
    double res = 0;
    for (size_t i = 0; i < len; i++) {
        res += d[i];
    }
    return res / len;
}
double get_mean(const double* d, const size_t len) {
    double res = 0;
    for (size_t i = 0; i < len; i++) {
        res += d[i];
    }
    return res / len;
}

int main() {
    short ar[max_ar_len];
    size_t count = 0;

    while (count < max_ar_len && std::cin >> ar[count]) count++;

    double result = get_mean(ar, count);

    std::cout << std::fixed << std::setprecision(1) << result << std::endl;

    return 0;
}
```

### Подвиг 10 (на повторение). Имеется следующая программа:

```c
#define TOTAL   1024

int main(void) {
    int total = 100;
    // здесь выполняются объявления

    return 0;
}
```

Выберите все верные (рабочие) варианты объявления массивов внутри функции `main()`.

+ [ ] long ar_5[0];
+ [x] unsigned short ar_1[100];
+ [ ] long long ar_6[0.5 * 2];
+ [x] double ar_2[5 * 3 - 2];
+ [x] signed char ar_4[total]; // (поддерживается не всеми компиляторами)
+ [x] short int ar_8[(int)(0.5 * 3)];
+ [x] float ar_3[sizeof(total) * 5];
+ [x] long double ar_7[TOTAL / 2];

# 9.14 Значения параметров функции по умолчанию

Следующей особенностью объявления функций в языке С++ является возможность определения параметров со значениями по умолчанию. Давайте, я сразу приведу простой пример такой функции:

```c++
#include <iostream>
 
using std::cout;
using std::cin;
using std::endl;
 
void show_data(int a=1, const char* str="Hi!", double b=-5.43) {
    cout << a << endl << str << endl << b << endl;
}
 
int main() {
    show_data();
    return 0;
}
```

Смотрите, функция `show_data()` объявлена с тремя параметрами и каждый сразу проиницализирован некоторым значением. Затем, эта функция вызывается в `main()` без передачи в нее каких-либо аргументов. В результате такого вызова все три параметра функции `show_data()` принимают предустановленные значения и в консоли отображаются следующие строчки:

```
1
Hi!
-5.43
```

Если же вызов прописать в виде:

```c
show_data(10);
```

то первый параметр изменит свое значение на `10`, а остальные два останутся без изменений:

```
10
Hi!
-5.43
```

Соответственно, можно прописать еще два таких вызова:

```c
show_data(10, "Hello!");
show_data(10, "Hello!", 3.1415);
```

Обратите внимание, что типы передаваемых значений должны соответствовать типам параметров в функции. Например, при следующем вызове компилятор выдаст сообщение об ошибке:

```c
show_data("Hello!");
```

так как строка не может быть приведена к целочисленному типу. Поэтому, если необходимо изменить значение второго параметра, то при вызове функции необходимо, как минимум, указать два аргумента:

```c
show_data(10, "Hello!");
```

и никак иначе.

В объявлениях функций мы можем комбинировать обычные параметры с теми, что принимают начальные значения. Делается это, например, следующим образом:

```c++
void show_data(const char* sep, int a=1, const char* str="Hi!", double b=-5.43) {
    cout << sep << endl;
    cout << a << endl << str << endl << b << endl;
}
```

Тогда, вызывая функцию `show_data()` мы обязаны передать ей первый аргумент:

```c
show_data("-----------------");
```

При этом параметры со значениями по умолчанию должны следовать после обычных параметров. Например, следующие объявления будут ошибочными:

```c++
int length(int a=0, int b, int c=0)  // ошибка
{
    return sqrt(a*a + b*b + c*c);
}
 
double length(double a=0, double b=0, double c)  // ошибка
{
    return sqrt(a*a + b*b + c*c);
}
```

Обязательно вначале должны идти параметры без значений и только в конце прописывать параметры со значениями:

```c++
int length(int a, int b, int c=0)  // ok
{
    return sqrt(a*a + b*b + c*c);
}
```

Также обратите внимание, что в практике программирования на С++ сами значения, которыми инициализируются по умолчанию параметры функции, рекомендуется задавать константами времени компиляции. 

Хотя, формально, можно использовать и вычисляемые выражения. Но я даже не буду приводить такой пример этой порочной практики программирования.

И, возможно, последний важный вопрос, зачем все это надо? 

В действительности параметры с начальными значениями применяются довольно часто. Например, мы описываем функцию, которая округляет вещественные числа. Объявить ее можно следующим образом:

```c++
#include <math.h>
 
double round_math(double x, int radix=0) {
    double p = pow(10, radix);
    return round(x * p) / p;
}
```

Здесь второй параметр определяет точность округления: `0` – до целых; `1` – до десятых; и так далее.

Чаще всего нам нужно округлить дробное число до целого, поэтому постоянно передавать второй аргумент, равным `0`, было бы неудобно. Но, прописав его с начальным значением 0, мы разрешили это неудобство. Теперь воспользоваться этой функцией можно следующим образом:

```c++
int main() {
    double res_1 = round_math(4.5634);  // 5
    double res_2 = round_math(4.5634, 1); // 4.6
    double res_3 = round_math(4.5634, 3); // 4.563
    cout << res_1 << "\n" << res_2 << "\n" << res_3 << endl;
    
    return 0;
}
```

Видите, как это удобно? И все благодаря параметру с начальным значением `0`!

Видео по теме [#13. Значения параметров функции по умолчанию](https://www.youtube.com/watch?v=WdHMhTmhnfM&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные объявления прототипов функций со значениями параметров по умолчанию.

+ [x] short min_2(short a = 0, short b = 0);
+ [ ] unsigned rand_pos(unsigned a = 10, unsigned b);
+ [ ] void set_struct_data(int val, short pos = 0, double weight);
+ [x] double normal(int mean, double sigma = 1.0);
+ [x] char* get_path(int count, const char sep='/', const char* path = "", const char *ext="");
+ [ ] bool is_fill(char fill = '0', const char* str);
+ [x] void set_coords(int x, int y, int z = -1);

### Подвиг 2. Имеется следующее объявление функции:

```c++
void set_struct_data(int val, const char* name, short pos = 0, double weight = 0.0) {
    // здесь тело функции
}
```

Выберите все верные варианты вызова этой функции.

+ [ ] set_struct_data(-1);
+ [x] set_struct_data(100, "Sergey");
+ [ ] set_struct_data();
+ [ ] set_struct_data("Страуструп", 76);
+ [x] set_struct_data(5, "Керниган", 54, 83.5);
+ [x] set_struct_data(6, "Ритчи", 76);

### Подвиг 3. Объявите функцию с именем get_rect_value, которая имеет следующие параметры (порядок важен):

+ два целочисленных параметра типа int (ширина и длина прямоугольника) без начальных значений;
+ параметр type (тип calc_type) с начальным значением calc_perimetr. 

Тип calc_type задается с помощью оператора using, как перечисление с константами calc_perimetr и calc_square. Если параметр type функции get_rect_value равен calc_perimetr, то функция должна возвращать периметр прямоугольника (в виде целого числа), а иначе - его площадь.

В функции main прочитайте из входного потока два целых числа (ширину и длину прямоугольника), записанных через пробел. Вызовите функцию get_rect_value с этими значениями для вычисления его периметра. Выведите в консоль полученное значение.

Sample Input:

34 57

Sample Output:

182

```c
#include <iostream>

using calc_type = enum { calc_perimetr, calc_square };

int get_rect_value(int w, int h, calc_type type = calc_perimetr) {
    int res = 0;
    switch (type) {
        case calc_square:
            res = w * h;
            break;

        case calc_perimetr:
            res = (w + h) * 2;
            break;

        default:
            puts("Invalid type");
            break;
    }
    return res;
}

int main() {
    int a, b;

    std::cin >> a >> b;

    int result = get_rect_value(a, b);

    std::cout << result << std::endl;

    return 0;
}
```

### Подвиг 4. Объявите функцию с именем check_password, которая первым параметром принимает корректную Си-строку (пароль), а вторым - строку chars с начальным значением в виде строки "$%!?@#". Функция должна проверять, есть ли в пароле хотя бы один символ из chars и что он (пароль) состоит минимум из 8 символов. Если проверка проходит, то функция check_password возвращает булево значение true, а иначе - false.

В функции main прочитайте пароль из входного потока (записанного в виде слова, без пробелов). Вызовите для прочитанной строки функцию check_password и выведите в консоль строку "yes", если пароль корректен, и "no" в противном случае.

Sample Input:

mypass!1234

Sample Output:

yes

```c++
#include <cstring>
#include <iostream>
#include <string>

bool check_password(char* str, const char* chars = "$%!?@#") {
    bool res = (strlen(str) >= 8 && strpbrk(str, chars) != nullptr);
    return res;
}

int main() {
    char str[100];

    scanf("%s", str);

    bool result = check_password(str);

    std::cout << (result ? "yes" : "no") << std::endl;

    return 0;
}
```

```c++
#include <iostream>
#include <string>

using std::cin;
using std::cout;
using std::string;

bool check_password(string password, string chars = "$%!?@#") {
    return password.size() >= 8 && password.find_first_of(chars) != string::npos;
}

int main() {
    string s;
    cin >> s;

    check_password(s) ? cout << "yes" : cout << "no";

    return 0;
}
```

### Подвиг 5. Продолжите программу. Объявите функцию с именем set_tag и следующими параметрами (порядок важен):
+ строка, которая заключается в тег (эта строка будет меняться в функции);
+ максимальная длина строки (целое число);
+ тег (строка), в который заключается переданная строка, с начальным значением "h1".
(Все строки в параметрах функции должны быть представлены массивами символов.)

Например, при передаче в функцию `set_tag` строки "Hello C++", заключаем ее (по умолчанию) в тег "h1". В результате, переданная строка после обработки должна иметь вид:

```
"<h1>Hello C++</h1>"
```

То есть, сначала прописывается открывающийся тег `<h1>`, а в конце строки - закрывающийся `</h1>`. И так для любых указанных тегов. При этом функция `set_tag` ничего не должна возвращать, только менять переданную строку, не выходя за пределы ее максимальной длины.

В функции `main` первый раз вызовите функцию `set_tag` только со строкой `title`, а второй раз - со строкой `title` (исходной) и `tag`. Полученные строки выведите в консоль каждую с новой строки. В начале и конце строк не должно быть пробелов.

Sample Input:

```
I love C
div
```

Sample Output:

```
<h1>I love C</h1>
<div>I love C</div>
```

ПЕрвоначальное чудо!
```c++
#include <string.h>

#include <iostream>
#include <string>

enum { tag_const = 5 };  // посчитаем <...> </...>

std::string char_copy(char* src) {
    std::string dest = "";
    size_t count = strlen(src);
    for (size_t i = 0; i < count; i++) {
        dest += src[i];
    }
    return dest;
}
void string_copy(char* dest, std::string src) {
    for (char ch : src) {
        *dest++ = ch;
    }
    *dest = '\0';
    return;
}

void set_tag(char str[], int len, char tag[] = "h1") {
    if ((int)(strlen(str) + strlen(tag) + tag_const) < len) {
        std::string res{"<" + char_copy(tag) + ">" + char_copy(str) + "</" + char_copy(tag) + ">"};
        string_copy(str, res);
    }

    return;
}

int main() {
    std::string title, tag;

    getline(std::cin, title);
    getline(std::cin, tag);

    char char_title_1[100];
    char char_title_2[100];
    char char_tag[100];
    string_copy(char_title_1, title);
    string_copy(char_title_2, title);
    string_copy(char_tag, tag);

    set_tag(char_title_1, 100);
    set_tag(char_title_2, 100, char_tag);

    std::cout << char_title_1 << std::endl;
    std::cout << char_title_2 << std::endl;

    return 0;
}
```

```c++
#include <string.h>

#include <iostream>
#include <string>

enum { tag_const = 5 };  // посчитаем <...> </...>

void set_tag(char str[], int len, char tag[20] = "h1") {
    if ((int)(strlen(str) + strlen(tag) + tag_const) < len) {
        char res[100];
        sprintf(res, "<%s>%s</%s>", tag, str, tag);
        strcpy(str, res);
    }

    return;
}

int main() {
    std::string title, tag;

    getline(std::cin, title);
    getline(std::cin, tag);

    char char_title_1[100];
    char char_title_2[100];
    char char_tag[100];

    strcpy(char_title_1, title.data());
    strcpy(char_title_2, title.data());
    strcpy(char_tag, tag.data());

    set_tag(char_title_1, 100);
    set_tag(char_title_2, 100, char_tag);

    std::cout << char_title_1 << std::endl;
    std::cout << char_title_2 << std::endl;

    return 0;
}
```

### Подвиг 6 (с повторением). Объявите перегруженные функции с именем get_rect, которые имеют следующие параметры (порядок важен):
+ два параметра типа (ширина и длина прямоугольника) без начальных значений;
+ параметр type (тип calc_type) с начальным значением calc_perimetr. 

Тип `calc_type` задается с помощью оператора `using`, как перечисление с константами `calc_perimetr` и `calc_square`. Если параметр type функции `get_rect_value` равен `calc_perimetr`, то функция должна возвращать периметр прямоугольника, а иначе - его площадь.

Одна функция `get_rect` должна иметь первые два целочисленные (тип `int`) параметры (ширину и длину), а другая - вещественные (тип `double`). Возвращать функции должны соответствующий тип данных.

P. S. В программе функцию `main` прописывать не нужно, а также что-либо выводить в консоль.

```c++
#include <iostream>

using calc_type = enum { calc_perimetr, calc_square };

int get_rect(int w, int h, calc_type type = calc_perimetr) {
    int res = 0;
    switch (type) {
        case calc_square:
            res = w * h;
            break;
        default:
            res = (w + h) * 2;
            break;
    }
    return res;
}
double get_rect(double w, double h, calc_type type = calc_perimetr) {
    double res = 0;
    switch (type) {
        case calc_square:
            res = w * h;
            break;
        default:
            res = (w + h) * 2;
            break;
    }
    return res;
}

int main() {
    int a, b;
    double c, d;

    std::cin >> a >> b >> c >> d;

    int result_1 = get_rect(a, b);
    double result_2 = get_rect(c, d);

    std::cout << result_1 << "\n" << result_2 << std::endl;

    return 0;
}
```

### Подвиг 7* (с повторением). Объявите функцию со следующей сигнатурой:

```c
int sort(short* ar, size_t len, type_sort type=sort_asc);
```

Данная функция должна выполнять сортировку элементов массива `ar` длиной `len` (элементов) в соответствии с параметром `type`. Если `type` равен `sort_asc`, то делается сортировка по возрастанию, а если type равен `sort_desc`, то по убыванию. Константы `sort_asc` и `sort_desc` должны быть объявлены с помощью перечисления с типом (перечисления) `type_sort`, который задается оператором `using`. Функция `sort` должна возвращать количество элементов, которые поменяли свое значение при сортировке. Например, при передаче массива:

3, 2, 4, 5

После сортировки по возрастанию имеем:

2, 3, 4, 5

и функция `sort` должна вернуть число 2, так как два элемента поменяли свое значение.

P. S. В программе функцию `main` прописывать не нужно, а также что-либо выводить в консоль.

```c++
#include <iostream>

using type_sort = enum { sort_asc, sort_desc };

void swap(short& a, short& b) {
    short tmp = a;
    a = b;
    b = tmp;
    return;
}

int sort(short* ar, size_t len, type_sort type = sort_asc) {
    int res = 0;
    int cpy[len];
    for (size_t i = 0; i < len; i++) {
        cpy[i] = ar[i];
    }
    for (size_t i = 0; i < len; i++) {
        for (size_t j = i + 1; j < len; j++) {
            if (type == sort_asc && ar[i] > ar[j]) {
                swap(ar[i], ar[j]);
            }
            if (type == sort_desc && ar[i] < ar[j]) {
                swap(ar[i], ar[j]);
            }
        }
    }
    for (size_t i = 0; i < len; i++) {
        if (cpy[i] != ar[i]) res++;
    }

    return res;
}

int main() {
    short ar[] = {-5, 4, 10, 0, -100, -1, -2, 98};

    int result = sort(ar, sizeof(ar) / sizeof(ar[0]));

    std::cout << result << std::endl;

    return 0;
}
```

```c
#include <algorithm>
#include <iostream>

enum type_sort { sort_asc, sort_desc };

int sort(short* ar, unsigned len, type_sort type = sort_asc) {
    short* b_arr = new short[len];
    std::copy_n(ar, len, b_arr);
    if (type)
        std::sort(ar, ar + len, [](short a, short b) { return a > b; });
    else
        std::sort(ar, ar + len);
    int cnt = 0;
    for (size_t i = 0; i < len; i++)
        if (ar[i] != b_arr[i]) cnt++;
    delete[] b_arr;
    return cnt;
}

int main() {
    short ar[] = {-5, 4, 10, 0, -100, -1, -2, 98};

    int result = sort(ar, sizeof(ar) / sizeof(ar[0]));

    std::cout << result << std::endl;

    return 0;
}
```

### Подвиг 8 (на повторение). Выберите все верные утверждения, связанные с типом (классом) std::string языка С++.

+ [x] в С++ можно по-прежнему использовать C-строки в виде массива символов
+ [ ] перед использованием типа (класса) std::string в программе следует подключить заголовок iostream
+ [ ] в С++ запрещено использовать C-строки в виде массива символов
+ [x] при использовании типа (класса) std::string можно не заботиться о максимальной длине строки (в разумных пределах)
+ [x] тип (класс) std::string предоставляет удобный инструмент для представления и обработки строк
+ [x] перед использованием типа (класса) std::string в программе следует подключить заголовок string
+ [x] тип (класс) std::string основан на динамическом массиве символов (char)

### Подвиг 9 (на повторение). Выберите все верные варианты объявления и инициализации объектов-строк.

+ [ ] std::string s_7 {"Sergey" + "Balakirev"};
+ [x] std::string s1 {"A"}, s2 {"B"}; std::string s_9 = s1 + s2;
+ [x] std::string s_3 {"Hello, C++"};
+ [x] const std::string s_4 ("Hello, C++");
+ [x] std::string str; std::string s_5 = str;
+ [x] const std::string s_2;
+ [x] const std::string str; std::string s_6 = str;
+ [x] std::string s_8 {"Sergey" "Balakirev"};
+ [x] std::string s_1;

### Подвиг 10 (на повторение). Пусть в программе объявлены следующие переменные:

```c
int var {-54};
int *ptr_v {&var};
short marks[] = {4, 3, 5, 2, 5};
```

Выберите все верные варианты объявления и инициализации ссылок.

+ [ ] int& lnk_3 (ptr_v);
+ [x] short& lnk_6 {*marks};
+ [ ] int& lnk_2 {&var};
+ [x] int& lnk_4 = *ptr_v;
+ [ ] int& lnk_8 = &ptr_v;
+ [x] int& lnk_1 = var;
+ [ ] short& lnk_5 = marks;
+ [x] short& lnk_7 {marks[3]};

# 9.15 inline-функции

Продолжаем тему функций языка С++ и следующее нововведение, что мы рассмотрим, касается `inline`-функций («подставляемые» функции). Что это такое? Давайте представим, что мы с вами в программе объявили функцию сложения двух целочисленных переменных с ее последующим вызовом:

```c++
#include <iostream>
 
using std::cout;
using std::cin;
using std::endl;
 
int sum2(int a, int b) {
    return a + b;
}
 
int main() {
    int x = 1, y = -5;
    int res = sum2(x, y);
    
    return 0;
}
```

Вспоминая все, что мы с вами говорили о вызовах функций, понимаем всю неэффективность полученной программы. 

Действительно, чтобы сложить две переменные между собой необходимо в стек функции поместить два значения, затем перейти и выполнить само тело функции, наконец, возвратить результат. 

И все ради суммы двух чисел, которую на уровне машинных кодов можно было бы записать двумя-тремя командами! 

Однако не все так драматично, как может показаться на первый взгляд. 

Современные компиляторы языков Си и С++ довольно умело оптимизируют программу и на уровне машинного кода вместо вызова таких функций они сразу подставляют их реализации (тела). 

Поэтому, просматривая машинный код нашего примера, мы бы не увидели вызова функции sum2(), а сразу бы обнаружили сложение переменных `x` и `y` и присвоения результата переменной `res`. 

Подобный подход компилятор пытается применить для всех простых в реализации функций. Часто это приводит к некоторому повышению производительности программы в целом. 

Однако если такая подстановка невозможна (например, для рекурсивных функций) или тело функции содержит довольно большой объем операторов, то компилятор формирует их обычный вызов с использованием стекового фрейма. Тем не менее, если программист понимает, что тело функции было бы разумно подставлять в местах ее формального вызова, то он может сообщить об этом компилятору, прописав перед заголовком функции ключевое слово `inline` следующим образом:

```c++
#include <math.h>
 
inline bool sqr_root(double a, double b, double c, double& x1, double& x2) {
    double D = b*b - 4*a*c;
    if(D < 0)
        return false;
    
    x1 = -(b + sqrt(D)) / (2*a);
    x2 = -(b - sqrt(D)) / (2*a);
    return true;
}
 
int main() {
    int x = 1, y = -5;
    int res = sum2(x, y);
 
    double a = 0.0, b = 0.0;
    bool res_root = sqr_root(3, 10, 5, a, b);
 
    if(res_root)
        cout << a << " " << b << endl;
 
    return 0;
}
```

В теле этой функции прописано множество операторов и, скорее всего, изначально компилятор будет создавать ее стандартный вызов. 

Но благодаря наличию ключевого слова `inline`, возможно, ее тело просто будет подставлено в место формального вызова. 

Хотя, это не гарантируется. 

Компилятор сам примет решение, исходя из формируемой программы на уровне машинных кодов. Тем не менее, ключевое слово `inline` может сыграть здесь значимую роль в выборе компилятором способа выполнения этой функции.

На самом деле, довольно часто функции, прописанные в заголовочных файлах, или внутри структур и классов, рассматриваются, как `inline`-функции, так как в заголовках, обычно, размещаются или прототипы функций или функции с короткими реализациями, а значит, они вполне могут быть преобразованы в `inline`-функции. 

То же самое и функции внутри классов и структур. Если их реализации прописаны непосредственно там, то это повод для компилятора рассматривать их как `inline`. И часто они именно так переводятся в машинный код, то есть, без реального вызова.

Видео по теме [#14. inline-функции](https://www.youtube.com/watch?v=hZ0TGBD9Opg&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, касающиеся inline-функций языка С++.

+ [x] inline-функция не вызываются, как обычная функция, ее тело просто подставляется (компилятором) в места вызовов
+ [x] функции с короткими реализациями (телами), прописанными в заголовочных файлах, часто рассматриваются компиляторами, как кандидаты в inline-функции
+ [ ] ключевое слово inline, прописанное у функций, гарантированно определяет inline-функцию
+ [x] ключевое слово inline, прописанное у функций, рассматривается компилятором лишь как рекомендация формирования inline-функции

### Подвиг 2. Выберите все верные варианты объявления inline-функций.

+ [ ] double abs_d(double x) inline;
+ [x] void inline set_x(int x);
+ [ ] inline set_y(int y);
+ [x] int inline get_max(int a, int b);
+ [x] inline int get_min(int a, int b);

### Подвиг 3. Объявите в программе inline-функцию с именем get_max_3, которая имеет три целочисленные параметра и возвращает наибольшее из трех переданных чисел. В функции main прочитайте из входного потока три целых числа, записанных через пробел, вызовите для них функцию get_max_3 и выведите в консоль возвращенное значение в виде целого числа.

Sample Input:

5 8 7

Sample Output:

8

```c++
#include <iostream>

inline int get_max_3(int a, int b, int c) {
    if (a > b) {
        if (a > c) return a;
    } else {
        if (b > c) return b;
    }
    return c;
}

int main() {
    int a, b, c;

    std::cin >> a >> b >> c;

    int result = get_max_3(a, b, c);

    std::cout << result << std::endl;
    return 0;
}
```

### Подвиг 4. Объявите в программе inline-функцию с именем sum_ar_int, которая имеет два параметра (порядок важен):
+ массив целочисленных значений (тип int);
+ длина переданного массива (число элементов).
Функция sum_ar_int должна вычислять сумму значений элементов переданного массива и возвращать ее в виде целого числа.

В функции main прочитайте из входного потока десять целочисленных значений, записанных через пробел, сохраните их в массиве и вызовите для него функцию sum_ar_int. Вычисленную сумму выведите в консоль в виде одного целого числа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/9.15.4

Sample Input:

1 2 3 4 5 6 7 8 9 -10

Sample Output:

35

```c++
#include <iostream>

enum { max_len = 10 };

inline int sum_ar_int(int ar[], size_t count) {
    int res = 0;
    for (size_t i = 0; i < count; i++) {
        res += ar[i];
    }
    return res;
}

int main() {
    int ar[max_len];

    for (size_t i = 0; i < max_len; i++) {
        std::cin >> ar[i];
    }

    int result = sum_ar_int(ar, max_len);

    std::cout << result << std::endl;
    return 0;
}
```

### Подвиг 5. Объявите в программе inline-функцию с именем range, которая имеет следующие параметры (порядок важен):
+ массив типа int;
+ максимальная длина массива;
+ три целочисленных параметра start, stop, step.
Функция `range` должна заносить в переданный массив значения арифметической прогрессии в порядке:

$start,start+step,start+2⋅step,...$

не включая последнее значение `stop` (доходя до него). Также нужно контролировать выход за пределы массива. При достижении последнего элемента генерацию последовательности завершать.

Например, при start=-5, stop=10, step=3 в массиве должны формироваться значения:

-5, -2, 1, 4, 7

P. S. В программе функцию main прописывать не нужно, а также что-либо вызывать и выводить в консоль.

```c++
#include <iostream>

enum { max_len = 10 };

inline void range(int ar[], int count, int start, int stop, int step) {
    for (int i = 0; i < count; i++) {
        int value = start + i * step;
        if (value < stop)
            ar[i] = value;
        else
            break;
    }
    return;
}

int main() {
    int ar[max_len] = {0}, a, b, c;

    std::cin >> a >> b >> c;

    range(ar, max_len, a, b, c);

    for (size_t i = 0; i < max_len; i++) {
        std::cout << ar[i] << " ";
    }

    std::cout << std::endl;
    return 0;
}
```

### Подвиг 6 (на повторение). Продолжите программу. В функции main из стандартного входного потока читаются целые числа. Необходимо все их сохранять в массиве marks (не более 20). То есть, чисел может быть и больше 20, но сохранять только первые 20 в порядке их считывания. 

Допишите функцию `sum_ar`, которая бы вычисляла сумму чисел переданного ей массива ar. Складывать следует только те числа, для которых переданная функция (через указатель) возвращает истину (не нулевое значение). Полученная сумма должна возвращаться функцией `sum_ar`. Указатель должен принимать функции с сигнатурой:

```c++
bool <имя функции>(int);
```

В функции `main` вызовите функцию `sum_ar` для массива `marks`, складывая только четные числа (проверка на четность выполняется дополнительной, вспомогательной функцией, которая, затем, передается последним аргументом в функцию `sum_ar`). Выведите в консоль целое значение, которое вернула функция `sum_ar`.

Sample Input:

1 2 3 4 5 6 -5 -4 -3 10 3 2 5

Sample Output:

20

```c++
#include <iostream>

enum { max_size = 20 };

bool is_even(int num) { return num % 2 == 0; }

using fn = bool (*)(int);

fn even = is_even;

int sum_ar(const int *ar, size_t len_ar, fn even) {
    int res = 0;
    for (size_t i = 0; i < len_ar; i++) {
        if (even(ar[i])) res += ar[i];
    }
    return res;
}

int main(void) {
    int marks[max_size] = {0};
    int x;
    size_t count = 0;
    while (count < max_size && std::cin >> x) {
        marks[count] = x;
        count++;
    }

    int result = sum_ar(marks, count, even);

    std::cout << result << std::endl;

    return 0;
}
```

### Подвиг 7 (на повторение). Продолжите программу. Объявите функцию с именем reverse, которая имеет два параметра (в порядке их указания):

+ указатель на обрабатываемый массив типа short;
+ число обрабатываемых элементов массива.

Функция reverse должна "переворачивать" переданный массив, то есть, значения должны идти в обратном порядке: от последнего к первому. 

Дополнительные массивы при этом создавать не нужно.

Вызовите функцию `reverse` в функции `main` для массива `digs`. Выведите в консоль первые count значений массива `digs` в одну строчку через пробел.

Sample Input:

1 -2 5 6 3

Sample Output:

3 6 5 -2 1

```c++
#include <iostream>

enum { max_size = 20 };

void reverse(short* ar, int count) {
    for (int i = 0; i < count / 2; i++) {
        short tmp = ar[i];
        ar[i] = ar[count - i - 1];
        ar[count - i - 1] = tmp;
    }
}

int main(void) {
    short digs[max_size];
    int count = 0;
    while (count < max_size && std::cin >> digs[count]) count++;

    reverse(digs, count);

    for (int i = 0; i < count; i++) {
        std::cout << digs[i] << " ";
    }

    return 0;
}
```

### Подвиг 8 (на повторение). Отметьте для переменных их вычисляемый тип данных.

![09](/Good_good_C_C++/img/09_22.PNG)

### Подвиг 9 (на повторение). Пусть в программе объявлены следующие переменные:

```c++
const char symbol_f = 'f';
const short* ptr_sh;
int count = 0;
const int& lnk = count;
```

Соберите для переменных var_1, ..., var_6 их вычисляемый тип данных. Например, для const int* нужно отметить три колонки: const, int, *.

![09](/Good_good_C_C++/img/09_23.PNG)

# 9.16 Лямбда-выражения. Объявление и вызов

## Лямбда-выражения.

В стандарте компилятора С++11 появились, так называемые, лямбда-функции (еще говорят лямбда-выражения или анонимные функции). 

Что это за функции и зачем они нужны? 

Если очень кратко, то лямбда-выражение позволяет создавать простой объект-функцию в любом допустимом месте программы. 

И одно из таких допустимых мест – аргумент обычной функции. 

Давайте я все детально поясню на конкретных примерах. А начнем, конечно же, со способа объявления и вызова таких лямбда-функций.

Общий синтаксис их определения следующий:

```c++
[] ([параметры]) { <операторы тела функции>}
```

Обратите внимание, что здесь отсутствует имя функции. Поэтому их иногда и называют анонимными. Как мы далее увидим, это имя здесь и не нужно.

В самом простом варианте лямбда-выражение можно записать в виде:

```c++
#include <iostream>
 
using std::cout;
using std::cin;
using std::endl;
 
int main() {
    [](int a) {
        cout << "Lambda-function: " << a << endl;
    };
 
    return 0;
}
```

Здесь в круглых скобках указан один параметр, а в фигурных – один оператор с выводом строки в выходной поток.

Если сейчас выполнить программу, то она успешно скомпилируется, но в консоль ничего выведено не будет. 

Почему так произошло? Да, по той причине, что мы объявили функцию, но не вызвали ее. 

Но как вызывать функцию, у которой нет имени? В самом простом варианте можно добавить вызов сразу после ее определения, например, так:

```c++
    [](int a) {
        cout << "Lambda-function: " << a << endl;
    } (10);
```

Но смысла от такой операции большого не будет. Поэтому на практике чаще всего созданный объект-функцию присваивают какой-либо переменной. Мы сделаем это следующим образом:

```c++
    auto r = [](int a) {
        cout << "Lambda-function: " << a << endl;
    };
 
    r(10);
```

Смотрите, как удобно здесь использовать вычисляемый тип для переменной `r`, вместо явного указания типа. 

В результате, переменная `r` представляет собой лямбда-выражение. 

Обратите внимание, `r` не ссылается на лямбда-функцию, а само является этой функцией, точнее, объектом-функцией. 

Мало того, далее, мы можем сделать и так:

```c++
auto s = r;
s(15);
```

При этом `s` будет уже другим объектом-функцией. В момент инициализации происходит копирование одного объекта в другой.

Или, эту же инициализацию можно прописать в виде:

```c++
auto s {r};
```

Или же, явно прописать еще одно лямбда-выражение:

```c++
    auto s { [](const char* msg, double& x) {
            cout << msg << endl;
            x++;
        } };
 
    double b = 0;
    s("increment", b);
```

Конечно, лямбда-выражение может возвращать произвольные данные с помощью оператора `return`, как это делают обычные функции. 

Например, ту же самую функцию `s` мы можем записать в виде:

```c++
    auto s { [](const char* msg, double x) {
            cout << msg << endl;
            return ++x;
        } };
 
    double b = s("increment", 4);
```

В результате, переменная `b` примет значение `5`.

Или, более простой пример:

```c++
auto sum2 { [](int a, int b) {return a+b;} };
```

Получили объект-функцию для сложения двух целых чисел. Если мы посмотрим на сформированный тип для переменной `sum2`, то увидим:

```c++
int sum2(int a, int b)
```

При необходимости, возвращаемый тип можно указывать явно. Для этого, после круглых скобок ставится оператор `->` с указанием нужного типа. Например:

```c++
auto sum2 { [](int a, int b) -> double {return a+b;} };
```
Получим вычисленный тип вида:

```c++
double sum2(int a, int b)
```

Начиная со стандарта С++14 в лямбда-выражениях можно использовать вычисляемые типы у параметров. Например:

```c++
auto sum2 { [](auto a, auto b) -> double {return a+b;} };
```

и, соответственно, вызывать функцию, например, так:

```c++
 double res_1 = sum2(3, 5);
 double res_2 = sum2(3.4, 5.3);
 cout << res_1 << " " << res_2 << endl;
```

Можно пойти еще дальше у всех типов прописать ключевое слово `auto`, получим:

```c++
auto sum2 { [](auto a, auto b) -> auto {return a+b;} };
```

В результате объект `sum2` можно прописывать для сложения любых допустимых данных. Например:

```c
std::string res_3 = sum2(std::string("hello, "), std::string("world!"));
cout << res_3 << endl;
```

## Лямбда-выражения в аргументах функций

Теперь, когда мы в целом познакомились с идеей лямбда-выражений, ответим на следующий вопрос, зачем все это нужно? 

Давайте, я приведу простой пример, где лямбда-функции могут быть удобнее обычных функций.

Объявим функцию с именем `show_ar`, которая выводит целочисленные значения переданного ей массива `ar` длиной `length`:

```c++
void show_ar(const int* ar, size_t length, bool (*filter_func)(int) = nullptr) {
    for(int i = 0;i < length; ++i) {
        if(filter_func != nullptr) {
            if(filter_func(ar[i]))
                cout << ar[i] << " ";
        }
        else
            cout << ar[i] << " ";
    }
}
```

Последний параметр представляет собой указатель на функцию со значением по умолчанию `nullptr`. В этом случае в консоль выводится весь массив от начала до конца. Например, так:

```c++
int main() {
    int data[] {1, 2, 3, 4, 5, 6, 7, 8};
    show_ar(data, sizeof(data)/sizeof(*data));
 
    return 0;
}
```

Но третьим аргументом можно передать функцию, которая позволит нам фильтровать данные и отображать только нужные значения массива, например, только четные. Для этого воспользуемся лямбда-выражением и пропишем его следующим образом прямо в момент вызова функции `show_ar()`:

```c++
show_ar(data, sizeof(data)/sizeof(*data), [](int x) {return x % 2 == 0;});
```

Анонимная функция возвращает истину для четных значений и ложь для нечетных. В итоге видим в консоли только четные значения элементов массива.

Видите, как удобно определять произвольные критерии выбора числовых значений с помощью лямбда-функций? 

В результате, функция `show_ar()` стала в некотором смысле универсальной. Ее можно вызвать для отображения массива целых чисел с любым критерием отбора. Например, всех чисел кратных трем:

```c++
show_ar(data, sizeof(data)/sizeof(*data), [](int x) {return x % 3 == 0;});
```

Преимущество лямбда-выражения в этом примере перед обычной функцией еще и в том, что это выражение для функции существует лишь при вызове `show_ar()` и автоматически пропадает после вызова. 

То есть, имеем экономию памяти и не нагромождаем программу лишними объявлениями функций.

На следующем занятии продолжим эту тему и увидим, зачем нужны квадратные скобки при определении лямбда-выражений.

Видео по теме [#15. Лямбда-выражения. Объявление и вызов](/Good_good_C_C++/img/09_23.PNG)

### Подвиг 1. Выберите все верные утверждения, касающиеся лямбда-выражений языка С++.

+ [ ] лямбда-выражение было введено в С++, начиная со стандарта С++14
+ [x] лямбда-выражение позволяет объявлять объект-функцию в произвольном месте программы
+ [x] лямбда-выражение вызывается с помощью оператора ()
+ [x] лямбда-выражение было введено в С++, начиная со стандарта С++11
+ [x] лямбда-выражение объявляется согласно синтаксису: [] ([параметры]) { <операторы тела функции>}
+ [ ] лямбда-выражение объявляется согласно синтаксису: ([параметры]) [] { <операторы тела функции>}

### Подвиг 2. Выберите все верные варианты объявления и вызова лямбда-функций.

+ [x] auto lmd = [] (int a, int b) { return 2 * (a + b); }; lmd(1, 2);
+ [x] auto lmd_2 = [] (const char* msg) { std::cout << msg; };
+ [x] [] (int x) { return (x < 0) ? -x : x; };
+ [ ] auto rec = [](int x) { if(x < 10) rec(x-1); };
+ [x] [] () { return -1; };
+ [x] [](double a) { (a > 0.0 && a < 10.0) ? std::cout << "yes" : std::cout << "no"; } (5);
+ [x] auto r = [](int x, int y = 0) { return x+y; }; r(1);
+ [x] auto lmd_3 = [] (int a, int b, int c) { int p = a + b + c; return p; };

### Подвиг 3. Допишите программу. В функции main объявите переменную с именем sq_tr и инициализируйте ее лямбда-выражением, которое принимает три целочисленных параметра (длины сторон треугольника) и по ним вычисляет площадь треугольника в соответствии с формулой Герона:

$S = \sqrt{p⋅(p−a)⋅(p−b)⋅(p−c)}$
​
где a, b, c - длины сторон треугольника; p = (a+b+c)/2 - полупериметр треугольника. Вычисленное значение должно возвращаться лямбда-выражением.

Вызовите лямбда-функцию для переменных a, b, c и выведите возвращенный результат в консоль с точностью до сотых.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/9.16.3

```c++
#include <cmath>
#include <iostream>

int main(void) {
    int a, b, c;
    std::cin >> a >> b >> c;

    auto sq_tr = [](int a, int b, int c) {
        double p = (a + b + c) / 2.0;
        return sqrt(p * (p - a) * (p - b) * (p - c));
    };

    printf("%.2lf", sq_tr(a, b, c));

    // __ASSERT_TESTS__
    return 0;
}
```

### Подвиг 4. Допишите программу. В функции main объявите массив с именем func_filter, который должен быть инициализирован следующими лямбда-выражениями (порядок важен):
+ принимает один целочисленный параметр; возвращает 1, если переданное значение четно, и 0 - если нечетно;
+ принимает один целочисленный параметр; возвращает 1, если переданное значение отрицательно, и 0 - если неотрицательно;
+ принимает один целочисленный параметр; возвращает 1, если переданное значение положительно (строго больше нуля), и 0 - иначе.

Прочитайте из входного потока целочисленное значение и выведите в консоль результат работы второй лямбда-функции массива func_filter.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/9.16.4

```c
#include <cmath>
#include <iostream>

using fn = bool (*)(int);

int main(void) {
    fn func_filter[] = {[](int x) { return x % 2 == 0; }, [](int x) { return x < 0; },
                        [](int x) { return x > 0; }};

    int a;

    std::cin >> a;

    printf("%d", func_filter[1](a));

    // __ASSERT_TESTS__
    return 0;
}
```

### Подвиг 5. Продолжите программу. Допишите функцию remove_elem, которая должна удалять все элементы из массива ar длиной len, для которых функция filter возвращает истинное значение. При этом значение переменной len должно быть равно количеству оставшихся значений в массиве ar.

В функции main вызовите функцию remove_elem для массива marks длиной count, а третьим аргументом пропишите лямбда-функцию для удаления из массива всех значений меньше 3. Результирующий массив marks (оставшиеся элементы после удаления) выведите в консоль по порядку в одну строчку через пробел.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/9.16.5

Sample Input:

5 4 3 2 -1 -100 6 7

Sample Output:

5 4 3 6 7

```c++
#include <iostream>

enum { max_length_ar = 20 };
using filter_func = bool (*)(short);

void remove_elem(short* ar, int& len, filter_func filter) {
    int shift = 0;
    for (int i = 0; i + shift < len; i++) {
        while (filter(ar[i + shift])) shift++;
        ar[i] = ar[i + shift];
        // printf("%d ", ar[i]);
    }
    len -= shift;
}

int main(void) {
    short marks[max_length_ar] = {0};
    int count = 0;
    while (count < max_length_ar && std::cin >> marks[count]) count++;

    remove_elem(marks, count, [](short x) { return x < 3; });

    for (int i = 0; i < count; i++) {
        std::cout << marks[i] << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

### Подвиг 6. Продолжите программу. Допишите функцию sum_elem, которая должна суммировать все значения элементов массива ar длиной len, для которых функция filter возвращает истинное значение. В функции main вызовите функцию sum_elem для массива marks длиной count, а третьим аргументом пропишите лямбда-функцию для суммирования всех значений элементов массива marks одновременно кратных 2 и 3 (делящихся нацело на 2 и на 3). Вычисленную сумму выведите в консоль в виде целого числа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/9.16.6

Sample Input:

3 4 5 6 7 8 9 10 11 12

Sample Output:

18

```c++
#include <iostream>

enum { max_length_ar = 20 };
using filter_func = bool (*)(int);

int sum_elem(const int* ar, size_t len, filter_func filter) {
    int res = 0;
    for (size_t i = 0; i < len; i++) {
        if (filter(ar[i])) res += ar[i];
    }
    return res;
}

int main(void) {
    int marks[max_length_ar] = {0};
    int count = 0;
    while (count < max_length_ar && std::cin >> marks[count]) count++;

    int result = sum_elem(marks, (size_t)count, [](int x) -> bool { return x % 6 == 0; });

    std::cout << result << std::endl;

    return 0;
}
```

### Подвиг 7. Продолжите программу. Допишите функцию sum_elem, которая должна суммировать все значения элементов массива ar длиной len, для которых функция filter возвращает истинное значение. В функции main вызовите функцию sum_elem для массива marks длиной count, а третьим аргументом пропишите лямбда-функцию для суммирования всех значений  элементов массива marks кратных 3, которые следуют непосредственно за четным значением. Например, для чисел:

1, 2, 3, 4, 5, 5, 7, 8, 9

суммирование должно осуществляться для чисел:

3, 9

Вычисленную сумму выведите в консоль в виде целого числа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/9.16.7

Sample Input:

3 4 5 6 7 8 9 10 11 12

Sample Output:

9

```c++
#include <iostream>

enum { max_length_ar = 20 };
using filter_func = bool (*)(int, int);

int sum_elem(const int* ar, size_t len, filter_func filter) {
    int res = 0;
    for (size_t i = 1; i < len; i++) {
        if (filter(ar[i - 1], ar[i])) res += ar[i];
    }
    return res;
}

int main(void) {
    int marks[max_length_ar] = {0};
    int count = 0;
    while (count < max_length_ar && std::cin >> marks[count]) count++;

    int result =
        sum_elem(marks, (size_t)count, [](int a, int b) -> bool { return a % 2 == 0 && b % 3 == 0; });

    std::cout << result << std::endl;

    return 0;
}
```

### Подвиг 8 (на повторение). Выберите все верные варианты полного перебора массива ar с помощью операторов цикла.

```c
long ar[] = {2, 4, 8, 16, 3, 9, 27, 81, -10, -100, -1000};
size_t len = sizeof(ar) / sizeof(*ar);
```

+ [x] int count = 0; while(count < len) printf("%d ", ar[count++]);
+ [ ] int count = 0; while(count < len) printf("%d ", ar[++count]);
+ [x] for(int i = 0; i < len; ++i) std::cout << ar[i] << " ";
+ [x] for(long x : ar) std::cout << x << " ";
+ [x] int count = 0; do { std::cout << ar[count++] << " "; } while(count < len);

### Подвиг 9 (на повторение). Какое числовое значение будет принимать переменная size_ar при выполнении следующего фрагмента программы:

```c
int ar[10];
int size_ar = sizeof(ar);
```

Полагается: тип int занимает 32 бит; размер указателя 32 бит.

$40$

### Подвиг 10 (на повторение). Выберите все верные утверждения, касающиеся следующего фрагмента программы:

```c
#include <stdio.h>
#define START_STEP  0

int get_step(int start)
{
    static int step = START_STEP;
    return start + step++;
}

int main(void)
{
    printf("step: %d\n", get_step(5));
    printf("step: %d\n", get_step(5));
    printf("step: %d\n", get_step(5));

    return 0;
}
```

+ [ ] статическую переменную нельзя складывать с обычной (автоматической) переменной
+ [x] в процессе выполнения программы в консоль будут выведены значения 5, 6, 7
+ [ ] в процессе выполнения программы в консоль будут выведены значения 5, 5, 5
+ [ ] к статической переменной недопустимо применять операции инкремента и декремента
+ [ ] в процессе выполнения программы в консоль будут выведены значения 6, 7, 8

# 9.17 Захват внешних значений в лямбда выражениях

## Захват внешних значений в лямбда выражениях

Пришло время нам узнать, для чего нужны и как используются квадратные скобки, стоящие вначале каждого лямбда-выражения. 

Во всех предыдущих примерах они у нас с вами были пустыми. Но, в действительности, через них можно передавать различные переменные из внешней области видимости, то есть, переменные, находящиеся за пределами тела лямбда-функции. 

Этот процесс в С++ называется захват переменных. И сейчас мы с вами подробно разберемся, как это работает.

Первое, что вытекает из необходимости захвата внешних значений, это недоступность переменных, объявленных за пределами лямбда-выражения. Действительно, компиляция следующего текста программы приведет к ошибке:

```c++
#include <iostream>
 
using std::cout;
using std::cin;
using std::endl;
 
const int max_size = 1000;
 
int main() {
    int data[] {1, 2, 3, 4, 5, 6, 7, 8};
    size_t sz = sizeof(data)/sizeof(*data);
                                               
    auto r = []() { 
        cout << sz << endl;         // ошибка, sz не существует
        cout << max_size << endl; 
        };
 
    r();
 
    return 0;
}
```

Внутри тела лямбда-функции локальные внешние переменные оказываются недоступными. Но не глобальные. Их по-прежнему можно использовать в любом месте текущего модуля, в том числе, и внутри лямбда-выражений.

Давайте поправим программу и сделаем так, чтобы в объекте r были доступны все локальные переменные функции `main()`. Для этого в квадратных скобках достаточно прописать символ `=` следующим образом:

```c++
    auto r = [=]() { 
        cout << sz << endl;         // ok
        cout << max_size << endl; 
        };
```

Этот символ означает, что мы копируем значения всех переменных в константные переменные, которые автоматически создаются внутри тела лямбда-функции с теми же самыми именами. 

В частности, `sz` – это новая константная переменная с копией значения переменной `sz` из функции `main()`. Поэтому, при выводе ее значения, мы видим число `8` и изменить ее уже нельзя. Следующий код не скомпилируется:

```c++
    auto r = [=]() {
        sz++;                              // ошибка, sz – константа
        cout << sz << endl;         // ok
        cout << max_size << endl; 
        };
```

Однако это поведение можно изменить, если после круглых скобок лямбда-выражения прописать ключевое слово `mutable` следующим образом:

```c++
    auto r = [=]() mutable {
        sz++;                             // ok
        cout << sz << endl;         // ok
        cout << max_size << endl; 
        };
```

Теперь мы имеем копии всех внешних переменных внутри объекта `r` с возможностью их изменения. Это же касается и более сложных данных, например, массивов:

```c++
    auto r = [=]() mutable {
        for(int& x : data) {
            x += 2;
            cout << x << " ";
        }
        cout << endl; 
    };
```

Если нам нужно передавать не все переменные, а лишь некоторые, то вместо символа `=` в квадратных скобках просто прописываются захватываемые переменные, например, так:

```c++
    auto r = [sz]() mutable {
        cout << sz << endl; 
    };
```

В результате, в теле лямбда-функции будет доступна только переменная `sz`. А если прописать так:

```c++
    auto r = [sz, data]() mutable {
        cout << sz << endl; 
        for(int x : data)
            cout << x << " ";
        cout << endl; 
    };
```

то обе переменные: `sz` и `data`. При этом за пределами лямбда-функции все переменные остаются неизменными.

## Захват переменных по ссылке и указателю

Если же нам нужно внутри лямбда-выражения оперировать непосредственно внешними локальными переменными, то их следует передавать либо по ссылке, либо через указатели. 

Начнем с захвата внешних переменных по ссылкам. Для этого в квадратных скобках вместо символа `=` прописывается символ ссылки `&` следующим образом:

```c++
    auto r = [&]() {
        cout << sz++ << endl; 
        for(int& x : data)
            cout << ++x << " ";
        cout << endl; 
    };
```

Переменные `sz` и `data` представляют собой ссылки на соответствующие переменные. Мы можем совершенно спокойно менять их внутри лямбда-функции, меняя и внешние переменные.

Также вместо символа `&` можно указывать отдельные захватываемые переменные. Например:

```c++
    auto r = [&sz, &data]() {
        cout << sz++ << endl; 
        for(int& x : data)
            cout << ++x << " ";
        cout << endl; 
    };
```

Здесь работа ведется только с двумя внешними переменными `sz` и `data` через соответствующие ссылки.

Наконец, похожего эффекта можно добиться, используя указатели на переменные. Например, так:

```c++
int main() {
    int data[] {1, 2, 3, 4, 5, 6, 7, 8};
    size_t sz = sizeof(data)/sizeof(*data);
    size_t *ptr_sz = &sz;
 
    auto r = [ptr_sz, &data]() {
        (*ptr_sz)++;
        cout << *ptr_sz << endl; 
        for(int& x : data)
            cout << ++x << " ";
        cout << endl; 
    };
 
    r();
 
    cout << sz << endl;
    for(int x : data)
        cout << x << " ";
    cout << endl;
 
    return 0;
}
```

В результате мы захватываем указатель `ptr_sz` и внутри тела лямбда-функции формируется константный указатель с тем же именем `ptr_sz`. Через этот указатель мы совершенно спокойно можем читать и менять значение переменной `sz`, но не можем менять адрес указателя `ptr_sz`, т.к. он константный.

Этот пример также показывает, что в квадратных скобках мы можем комбинировать запись через присваивание и через ссылки. Мало того, можно даже использовать и такие виды записей:

```c
[&a, b, &m, n]   // a и m – по ссылке; b и n – по значению
[=, &m, &n]      // все по значению; m и n – по ссылке
[&, m, n]           // все по ссылке; m и n – по значению
```

Вот так, относительно просто, можно объявлять, вызывать и использовать лямбда-выражения в языке С++.
Видео по теме [#16. Захват внешних значений в лямбда выражениях](https://www.youtube.com/watch?v=CFOIHo5aNTo&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, касающиеся лямбда-выражений языка С++.

+ [x] локальные переменные можно захватывать лямбда-выражением через указатели
+ [x] глобальные идентификаторы (например, переменные) всегда доступны внутри лямбда-выражения
+ [ ] глобальные идентификаторы (например, переменные) также нужно захватывать, чтобы они стали доступны внутри лямбда-выражения
+ [x] локальные переменные можно захватывать лямбда-выражением через механизм ссылок
+ [x] локальные переменные можно захватывать лямбда-выражением путем их копирования
+ [x] через квадратные скобки лямбда-выражения можно передавать (захватывать) локальные переменные и использовать внутри лямбда-функции

### Подвиг 2. Выберите все верные утверждения, касающиеся захвата переменных лямбда-выражениями.

+ [x] выполнение выражение вида [a, b] ([параметры]) mutable { a++; --b; } приведет к изменению переменных a и b только внутри лямбда-функции и не затронет внешние локальные переменные a и b
+ [x] выполнение выражение вида [var_i]([параметры]) {var_i += 1;} приведет к ошибке, т.к. переменная var_i является константной
+ [ ] выполнение выражение вида [a, b] ([параметры]) mutable { a++; --b; } приведет к изменению переменных a и b и это изменение затронет внешние локальные переменные a и b
+ [x] выражение вида [=]([параметры]) {[операторы]} позволяет в теле лямбда-функции только читать значения из копий любых локальных переменных
+ [ ] при захвате массива int d[10]; [d] ([параметры]) mutable {[операторы]} изменение значений его элементов в лямбда-функции приведет также к изменению внешнего массива d
+ [x] при захвате массива int d[10]; [d] ([параметры]) mutable {[операторы]} изменение значений его элементов в лямбда-функции не приведет к изменению внешнего массива d

### Подвиг 3. Выберите все верные утверждения, касающиеся захвата переменных лямбда-выражениями.

+ [ ] допустимо использовать запись вида [&, &a] ([параметры]) {[операторы]}
+ [x] выполнение выражение вида [&var_i] ([параметры]) mutable {var_i += 1;} приведет к изменению внешней переменной var_i
+ [x] допустимо использовать запись вида [=, &a, &b] ([параметры]) {[операторы]}
+ [ ] выполнение выражение вида [&var_i]([параметры]) {var_i += 1;} приведет к ошибке, т.к. переменная var_i является константной ссылкой
+ [x] выполнение выражение вида [&var_i]([параметры]) {var_i += 1;} приведет к изменению внешней переменной var_i
+ [x] допустимо использовать запись вида [&, a, b] ([параметры]) {[операторы]}
+ [x] выражение вида [&]([параметры]) {[операторы]} выполняет захват всех локальных переменных по ссылке
+ [ ] допустимо использовать запись вида [&, =] ([параметры]) {[операторы]}

### Подвиг 4. Пусть в программе имеются следующие локальные переменные:

```c
char msg[] = "hello";
int count = 0;
int& lnk = count;
char* ptr = msg;
```

Выберите все верные (работающие) варианты объявления лямбда-выражений.

+ [x] auto lmd_1 = [msg, count, lnk, ptr] () { return count + 1; };
+ [x] auto lmd_5 = [ptr] (int step) { *ptr += step; };
+ [x] auto lmd_2 = [=] () { std::cout << msg; };
+ [ ] auto lmd_7 = [lnk] (int step) { lnk += step; };
+ [x] auto lmd_3 = [&count] (int step) { count += step; };
+ [x] auto lmd_4 = [&lnk] (int step) { lnk += step; };
+ [ ] auto lmd_6 = [*ptr] (int step) { *ptr += step; };

### Подвиг 5. Выберите все верные утверждения, связанные со следующей программой:

```c++
#include <iostream>

int main(void)
{
    int count = 1;
    int& lnk = count;

    auto r = [lnk] (int step) mutable { lnk += step; };

    r(5);
    std::cout << count << std::endl;

    return 0;
}
```

+ [x] при выполнении программа выведет в консоль значение 1
+ [ ] при захвате ссылки lnk в теле лямбда-выражения также формируется ссылка lnk на внешнюю переменную count
+ [ ] при выполнении программа выведет в консоль значение 6
+ [x] при захвате ссылки lnk в теле лямбда-выражения формируется переменная (не ссылка) lnk со значением 1
+ [x] если в лямбда-выражении не указывать ключевое слово mutable, то переменная lnk была бы константной и неизменяемой

### Подвиг 6. Продолжите программу. Необходимо в функции main прочитать два целых числа из входного потока, записанных через пробел, в переменные w и h. Объявить лямбда-выражение, которое захватывает переменные w, h, складывает их и возвращает результат. Сама лямбда-функция не должна иметь никаких параметров. С лямбда-выражением должна быть связана переменная sum_ab. Вызовите лямбда-функцию sum_ab и выведите в консоль возвращенное значение.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/9.17.6

Sample Input:

5 10

Sample Output:

15

```c++
#include <iostream>

int main(void) {
    int w, h;
    std::cin >> w >> h;

    auto sum_ab = [w, h]() { return w + h; };

    int result = sum_ab();

    std::cout << result << std::endl;

    // __ASSERT_TESTS__
    return 0;
}
```

### Подвиг 7. В программе ниже замените функцию get_line эквивалентным лямбда-выражением. Лямбда-выражение следует объявлять внутри функции main и связать с переменной gl. Лямбда-выражение должно захватывать массив str и не иметь параметров. Вызовите в функции main лямбда-функцию gl и выведите в консоль строку str.

Sample Input:

I love C++

Sample Output:

I love C++

```c++
#include <iostream>
#include <string>

void get_line(char* buff, size_t max_buff) {
    std::string line;
    getline(std::cin, line);

    int i = 0;
    for (; i < line.length() && i < max_buff - 1; ++i) buff[i] = line[i];
    buff[i] = '\0';
}

int main(void) {
    char str[100];
    //  get_line(str, sizeof(str));

    auto gl = [&str]() {
        size_t max_buff = sizeof(str);
        std::string line;
        getline(std::cin, line);

        size_t i = 0;
        for (; i < line.length() && i < max_buff - 1; ++i) str[i] = line[i];
        str[i] = '\0';
    };

    gl();

    std::cout << str << std::endl;
    return 0;
}
```

```c++
#include <iostream>
#include <string>

int main(void)
{
    char str[100];
    auto gl = [&str]{
        std::string line;
        getline(std::cin, line);
        std::copy_n(line.c_str(), line.size()+1, str);
    };
    gl();
    std::cout << str;

    return 0;
}
```

### Подвиг 8. В программе ниже замените функцию is_verify эквивалентным лямбда-выражением. Лямбда-выражение следует объявлять внутри функции main и связать с переменной is_v. Лямбда-выражение должно захватывать массив pg и иметь два целочисленных параметра x, y - индексы проверяемой клетки. Замените вызов функции is_verify на вызов is_v.

P. S. В консоль ничего выводить не нужно.

```c++
#include <cmath>
#include <iostream>

enum {size_pole = 10};

int is_verify(char (*pg)[size_pole], int x, int y)
{
    for(int i = -1; i <= 1; ++i)
        for(int j = -1; j <= 1; ++j) {
            int xx = x+i, yy = y+j;
            if(xx < 0 || xx >= size_pole || yy < 0 || yy >= size_pole)
                continue;
            if(pg[xx][yy] == '*') return 0;
        }
    return 1;
}

int main(void)
{
    char pg[size_pole][size_pole] = {0};
    
    auto is_v = [&pg](int x, int y) {
        for (int phi = 0; phi < 360; phi += 45) {
            int i = round(cos(phi * 3.14159265 / 180));
            int j = round(sin(phi * 3.14159265 / 180));
            int xx = x + i, yy = y + j;
            if (xx < 0 || xx >= size_pole || yy < 0 || yy >= size_pole) continue;
            if (pg[xx][yy] == '*') return 0;
        }
        return 1;
    };    

    int mines = 0;
    do {
        int i = rand() % size_pole;
        int j = rand() % size_pole;
        if(is_verify(pg, i, j)) {
            pg[i][j] = '*';
            mines++;
        }
    } while(mines < 12);

/*
//----------- вывод поля в консоль ---------------------------------
    for(int i = 0;i < size_pole; ++i) {
        for(int j = 0;j < size_pole; ++j)
            printf("%c ", (pg[i][j] == 0) ? '#' : '*');
        putchar('\n');
    }
//----------- завершение вывода поля в консоль ----------------------
*/

    __ASSERT_TESTS__ // макроопределение для тестирования (не убирать и должно идти непосредственно перед return 0)
    return 0;
}
```

### Подвиг 9 (на повторение). Выберите все верные объявления прототипов функций со значениями параметров по умолчанию.

+ [x] short min_2(short a = 0, short b = 0);
+ [ ] bool is_fill(char fill = '0', const char* str);
+ [ ] void set_struct_data(int val, short pos = 0, double weight);
+ [x] double normal(int mean, double sigma = 1.0);
+ [x] char* get_path(int count, const char sep='/', const char* path = "", const char *ext="");
+ [x] void set_coords(int x, int y, int z = -1);
+ [ ] unsigned rand_pos(unsigned a = 10, unsigned b);

### Подвиг 10 (на повторение). Выберите все верные утверждения, касающиеся ссылок языка С++.

+ [ ] ссылки в С++ полностью заменяют собой традиционные указатели языка Си
+ [x] ссылки - это безопасный инструмент, так как они могут быть связаны только с корректным lvalue-выражением (области памяти с данными)
+ [x] ссылку можно воспринимать как второе имя переменной, с которой она связана (инициализирована)
+ [x] ссылки удобно использовать при передаче объемных данных в параметры функций
+ [x] ссылки - это, по сути, скрытый указатель, который хранит адрес переменной (lvalue-выражения), указанного при инициализации
