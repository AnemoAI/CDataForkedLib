# 10. Структуры в C++. Работа с памятью

## 10.1 Структуры в С++, как обновленный тип данных

Начиная с этого занятия мы с вами сделаем первый маленький шажок в мир ООП языка С++ и начнем со структур. 

Да, да, структуры в языке С++ преобразились и стали, фактически, классами. Но обо всем по порядку.

Понятие структур нам уже известно по языку Си. В С++ они формально объявляются похожим образом. Например, так:

```c++
struct point {
    int x, y;
};
```

То есть, пишется ключевое слово `struct`, затем, имя типа структуры – `point`, в фигурных скобках прописываются поля (переменные) структуры и в конце ставится точка с запятой.

Первое важное отличие такой структуры в С++ от аналогичной в языке Си, заключается в том, что имя `point` здесь является полноценным типом, а не просто тегом структуры, как это было в Си. 

То есть, далее по программе мы можем объявить переменную типа `point` следующим образом:

```c++
int main() {
    point pt;
    return 0;
}
```

Тогда как в Си нам необходимо было прописывать:

```c
struct point pt;
```

Кстати, в языке С++ допустимы обе формы записи типа структуры. Сделано это было для обратной совместимости с языком Си. Однако, если мы пишем программу исключительно для компилятора С++, то слово `struct` при объявлении переменных опускают.

Далее, мы можем инициализировать поля этой структуры следующим образом:

```c++
struct point pt {};  // инициализация нулями
struct point pt {1}; // инициализация x=1, y=0
struct point pt {1, 2};  // инициализация x=1, y=2
```

## Функции-члены (методы)

Следующее ключевое отличие структур языка С++ - это возможность объявление функций непосредственно внутри структуры. Например, так:

```c++
struct point {
    int x, y;
 
    double length() { return sqrt(x*x + y*y); }
};
```

Функция `length()` вычисляет длину радиус-вектора и возвращает вычисленное значение. 

Такие функции получили название функции-члены или, чаще всего говорят, методы.

Особенностью методов является прямой доступ к переменным объекта, для которого этот метод был вызван. Например, следующий фрагмент программы вычисляет с помощью метода `length()` длины двух разных объектов `point`:

```c++
int main() {
    struct point pt {1, 2};
    struct point pt_2 {3, 4};
 
    cout << pt.length() << endl;
    cout << pt_2.length() << endl;
    return 0;
}
```

Давайте детальнее разберемся, как это работает. При объявлении метода `length()` мы просто записали имена переменных `x` и `y`, объявленных внутри структуры. 

Но у каждого объекта `pt` и `pt_2` свои локальные переменные `x` и `y` со своими значениями. 

Так откуда же метод `length()` «знает» какие переменные использовать и как получает к ним доступ? 

В действительности, каждому методу автоматически и неявно передается специальный указатель с именем `this`. 

Его так и называют – неявный указатель на объект. А раз так, то мы, по идее, можем обратиться из метода к локальным переменным текущего объекта, следующим образом:

```c++
struct point {
    int x, y;
 
    double length() { return sqrt(this->x*this->x + this->y*this->y); }
};
```

И, действительно, это будет эквивалентом предыдущей записи. 

На самом деле, когда явно не прописывается параметр `this`, то он подразумевается при обращении к полям структуры. 

Именно так метод `length()` получает доступ к нужным переменным для вычисления длины радиус-вектора. Как видите, все просто.

Конечно, неявный указатель `this` имеет тот же тип, что и текущая структура. 

В нашем примере – это тип `point*`. Он доступен практически в любом методе структуры, за исключением статических методов. 

Например, если мы попробуем записать такой метод и обратиться через указатель `this` к полю структуры, то получим ошибку:

```c++
struct point {
    int x, y;
 
    double length() { return sqrt(this->x*this->x + this->y*this->y); }
    static void show_coords() {cout << this->x; }  // ошибка, this не существует
};
```

И это логично, так как статические методы не связаны с конкретным объектом, а просто являются функцией внутри области видимости структуры.

Вообще через указатель `this` мы можем обращаться к любым полям структуры, даже если это другие методы. Например, так:

```c++
struct point {
    int x, y;
 
    double length() { return sqrt(this->get_x()*this->get_x() + this->get_y()*this->get_y()); }
    int get_x() { return x; }
    int get_y() { return y; }
};
```

Или, без ключевого слова `this`:

```c++
struct point {
    int x, y;
 
    double length() { return sqrt(get_x()*get_x() + get_y()*get_y()); }
    int get_x() { return x; }
    int get_y() { return y; }
};
```

Но тогда оно подразумевается.

Конечно, это несколько искусственный пример. В данном случае было бы правильнее обращаться напрямую к переменным `x` и `y`. Это лишь демонстрация возможности указателя `this`.

На следующем занятии мы продолжим эту тему и увидим, какие еще возможности появились у структур языка С++.

Видео по теме [#17. Структуры в С++, как обновленный тип данных](https://www.youtube.com/watch?v=YIE0tnADkHU&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, связанные со структурами языка С++.

+ [x] идентификатор структуры является именем типа (например, struct data {}; data - тип данных)
+ [ ] для структуры struct obj {}; переменные можно объявлять только как obj s1;
+ [x] внутри структур допускается объявление функций, которые называются методами
+ [x] в целом, инициализация структур в С++ выполняется так же, как и в языке Си
+ [x] для структуры struct obj {}; переменные можно объявлять как obj s1; а также как struct obj s1;

### Подвиг 2. Выберите все верные утверждения, касающиеся следующей программы:

```c++
#include <iostream>

struct vector3D {
    double x, y, z;

    double get_x() { return this->x; }
    double get_y() { return y; }
    static double norm2(double a, double b) { return a*a + b*b; }
};

int main(void)
{
    vector3D v1 {0.5, 2.0, -5.4};

    std::cout << v1.get_x() << std::endl;
    std::cout << v1.norm2(1, 2) << std::endl;

    return 0;
}
```

+ [x] неявный указатель this в методах структуры vector3D имеет тип vector3D*
+ [x] при вызове v1.get_x() указатель this ссылается на объект v1
+ [x] в теле метода get_y при доступе к переменной y указатель this подразумевается
+ [x] при вызове v1.norm2(1, 2) указатель this в метод norm2 не передается
+ [x] в каждый обычный (не статический) метод структуры автоматически передается указатель this
+ [x] из статического метода norm2 нет прямого доступа к полям x, y, z структуры vector3D
+ [ ] при вызове v1.norm2() указатель this в теле метода norm2 ссылается на объект v1

### Подвиг 3. Объявите в программе структуру с идентификатором (типом) volume с тремя целочисленными полями width, height, depth (ширина, высота, глубина). Объявите в структуре метод с именем get_volume, который возвращает объем (целое число), вычисленный по формуле:

$V = width\cdot height\cdot depth$

В функции `main` объявите переменную `data` типа `volume` и занесите в поля `width`, `height`, `depth` целые числа, прочитанные из входного потока (по порядку, числа следуют через пробел). С помощью метода `get_volume` вычислите объем и выведите его в консоль.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/10.1.3

```c++
#include <iostream>

struct volume {
    double width, height, depth;
    double get_volume() { return width * height * depth; }
};

int main(void) {
    volume data;

    std::cin >> data.width >> data.height >> data.depth;
    double result = data.get_volume();
    std::cout << result << std::endl;

    return 0;
}
```

### Подвиг 4. Объявите в программе структуру с идентификатором (типом) book (книга) и следующими полями:
+ title: название книги; строка, максимальной длины 200 символов;
+ author: автор; строка, максимальной длины 100 символов;
+ price: цена; целое число;
+ npages: число страниц; целое число.

Объявите в структуре `book` метод с именем `price_per_page`, который возвращает цену за одну страницу (вещественное число), вычисленную по формуле:

$price/npages$

В функции main объявите массив `lib` с типом `book` длиной `10` элементов. Прочитайте из входного потока данные в массив `lib` (по порядку), представленные в формате:

<название книги><br>
<автор><br>
<цена> <число страниц><br>

Выведите в консоль в одну строчку через пробел цену за одну страницу прочитанных книг с точностью до сотых.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/10.1.4

```c
#include <iostream>
#include <string>

using std::cin;
using std::cout;
using std::endl;
using std::getline;
using std::string;

enum { lib_size = 10 };
struct book {
    string title;
    string author;
    int price;
    int npages;
    double price_per_page() { return price / (double)npages; }
};

int main(void) {
    book lib[lib_size];
    size_t count = 0;
    while (count < lib_size) {
        if (getline(cin, lib[count].title)) {
            // cout << lib[count].title << "\n";
            getline(cin, lib[count].author);
            cin >> lib[count].price >> lib[count].npages;
            char ch;
            scanf("%c", &ch);
            cout << (count == 0 ? "" : " ");
            printf("%.2lf", lib[count].price_per_page());
            count++;
        } else {
            // cout << endl;
            break;
        }
    }
    // cout << count;
    __ASSERT_TESTS__
    return 0;
}
```

```c++
#include <iostream>
#include <iomanip>
#include <string.h>
using namespace std; 

struct book {
    char title[200];
    char author[100];
    int price;
    int npages;

    double price_per_page() { return double(price) / npages; }
};

int main(void) {
    book lib[10];

    int count = 0;
    string s;
    while (count < 10 && getline(cin, s)) {
        strncpy(lib[count].title, s.data(), sizeof(lib[count].title));
        getline(cin, s);
        strncpy(lib[count].author, s.data(), sizeof(lib[count].author));
        cin >> lib[count].price >> lib[count].npages;
        getchar();
        ++count;
    }

    for (int i = 0; i < count; ++i)
        cout << fixed << setprecision(2) << lib[i].price_per_page() << ' ';
    
    __ASSERT_TESTS__
        
    return 0;
}
```

```c++
#include <iostream>
#include <iomanip>          // std::fixed, std::setprecision(2)

struct book {
    char title[200];
    char author[100];
    int price;
    int npages;
    double price_per_page() {
        return (double)price/(double)npages;
    }
};

int main(void)
{
    book lib[10];
    int count = 0;
    while (count < 10 && std::cin.getline(lib[count].title, 200))
    {
        std::cin.getline(lib[count].author, 100);
        std::cin >> lib[count].price >> lib[count].npages;
        std::cin.ignore();    // игнорируем '\n', оставшийся после предыдущего ввода
        count++;
    }

    for (int i = 0; i < count; i++)
        std::cout << std::fixed << std::setprecision(2) << lib[i].price_per_page() << ' ';

    __ASSERT_TESTS__
    return 0;
}
```

### Подвиг 5. Объявите в программе структуру с идентификатором (типом) vector4D и вещественными полями x, y, z, t. Объявите в этой структуре следующие методы:

+ void read_data(FILE* stream, char sep=' '); // для чтения из входного потока stream данных в переменные x, y, z, t, записанных через разделитель sep
+ double `length()`; // для вычисления длины радиус вектора по формуле 

$ \sqrt{x^2 + y^2 + z^2 + t^2}$​
 
В функции `main` объявите две переменные `v1` и `v2` типа `vector4D`. Прочитайте для них (сначала для `v1`, а затем, для `v2`) из входного потока `stdin` с помощью метода `read_data` вещественные значения, записанные через точку с запятой. Выведите в консоль в одну строчку через пробел значения длин векторов `v1` и `v2` (именно в таком порядке), вычисленных с помощью метода `length`. Вещественные числа должны быть выведены с точностью до тысячных.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/10.1.5

Sample Input:

4.1; 2.3; 10.0; -3.0

-2.4; 3.6; 9.8; 7.4

Sample Output:

11.450 13.020

```c++
#include <cmath>
#include <iostream>

enum { lib_size = 10 };
struct vector4D {
    double x, y, z, t;
    void read_data(FILE* stream, char sep = ' ') {
        fscanf(stream, "%lf %c %lf %c %lf %c %lf", &x, &sep, &y, &sep, &z, &sep, &t);
        return;
    }
    double length() { return sqrt(x * x + y * y + z * z + t * t); }
};

int main(void) {
    vector4D v1, v2;
    char sep = ' ';
    v1.read_data(stdin, sep);
    v2.read_data(stdin, sep);

    printf("%.3lf %.3lf", v1.length(), v2.length());

    return 0;
}
```

### Подвиг 6 (на повторение). Продолжите программу. Выше в тексте программы объявлена переменная price_100 структуры tag_price (она скрыта, но она существует). В функции main необходимо объявить переменную с именем pr той же структуры tag_price и скопировать данные из переменной price_100 в переменную pr. Выведите в консоль значения всех полей переменной pr (в виде целых чисел, кроме первого поля name) в одну строчку через пробел в порядке их описания в структуре tag_price.

```c++
#include <iostream>

struct tag_price {
    char name[100];
    unsigned int rubs;
    unsigned char kops;
    unsigned int foreign_key;
};
tag_price price_100{"123", 1, 2, 3};

int main(void) {
    tag_price pr = price_100;

    printf("%s %d %d %d", pr.name, pr.rubs, pr.kops, pr.foreign_key);
    return 0;
}
```

### Подвиг 7 (с повторением). Продолжите программу. В структуре tag_time объявите метод со следующей сигнатурой:

```c++
char* get_time(char* str, size_t max_length);
```

Этот метод должен в переданную строку `str` записывать время в формате:

```
hh:mm:ss
```

и возвращать ее (адрес этой строки). Например, для переменных `hours=12`, `minutes=8`, `seconds=43` должны получать строку:

```
12:08:43
```

Обратите внимание на наличие незначащего нуля перед числами меньше `10`. Также нужно контролировать возможный выход за пределы строки `str` (длина строки `max_length`).

В структуре `tag_time` объявите еще один статический метод с сигнатурой:

```c++
static tag_time sum_time(const tag_time& t1, const tag_time& t2);
```

Этот метод должен формировать и возвращать новую структуру с суммой времен `t1` и `t2`. Причем время нужно складывать так, чтобы минуты и секунды не выходили из пределов `[0; 59]`.

В функции `main` объявите две переменные `tm1` и `tm2` структуры `tag_time`. Значения их полей (шесть целых неотрицательных чисел, записанных в одну строчку через пробел) прочитайте из входного потока. Выполните сложение времен `tm1` и `tm2` с помощью метода `sum_time` и сохраните результат в переменной `time_res`. Выведите в консоль время переменной `time_res` в виде строки, сформированной методом `get_time`.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/10.1.7

Sample Input:

12 45 16 4 23 48

Sample Output:

17:09:04

```c++
#include <iostream>

struct tag_time {
    unsigned char hours;
    unsigned char minutes;
    unsigned char seconds;
    char* get_time(char* str, size_t max_length) {
        if (max_length > 9) {
            sprintf(str, "%02d:%02d:%02d", hours, minutes, seconds);
        }
        return str;
    }
    static tag_time sum_time(const tag_time& t1, const tag_time& t2) {
        tag_time res;
        unsigned char over = 0;
        res.seconds = time_sum(t1.seconds, t2.seconds, over, 60);
        res.minutes = time_sum(t1.minutes, t2.minutes, over, 60);
        res.hours = time_sum(t1.hours, t2.hours, over, 24);
        return res;
    }
    static unsigned char time_sum(unsigned char t1, unsigned char t2, unsigned char& over,
                                  unsigned char limit) {
        unsigned char res = (t1 + t2 + over) % limit;
        over = (t1 + t2 + over) / limit;
        return res;
    }
};

void read_time(tag_time& tm) {
    int hours;
    int minutes;
    int seconds;
    std::cin >> hours >> minutes >> seconds;
    tm.hours = hours;
    tm.minutes = minutes;
    tm.seconds = seconds;
}

int main(void) {
    tag_time tm1;
    tag_time tm2;

    read_time(tm1);
    read_time(tm2);

    tag_time time_res;

    time_res = tag_time::sum_time(tm1, tm2);

    char str[10];
    time_res.get_time(str, sizeof(str));
    std::cout << str << std::endl;
    // __ASSERT_TESTS__
    return 0;
}
```

### Подвиг 8 (на повторение). Объявите в программе структуру с идентификатором tag_point_3d и полями x, y, z типа int (координаты точки в трехмерном пространстве). В функции main объявите массив points структуры tag_point_3d размером total_points. Константа total_points должна быть объявлена через перечисление и равна 100. Из входного потока (в функции main) читайте целые числа (записанные в одну строчку через пробел) и последовательно записывайте в массив points. То есть, первый элемент массива points будет содержать первые три числа из входного потока, второй элемент points - следующие три числа, и так далее. Если на каком-либо этапе читается меньше трех чисел, то считывание завершается и неполные данные (менее трех чисел) в очередной элемент массива points не заносятся. В переменной total должно содержаться общее число корректно сформированных элементов массива points. Выведите в консоль в одну строчку через пробел значения координат x, y, z первого элемента массива points, в который производилась запись.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/10.1.8

Sample Input:

1 2 3 3 4 5 7 8 9

Sample Output:

1 2 3

```c++
#include <iostream>

enum { total_points = 100 };

struct tag_point_3d {
    int x, y, z;
};

int main(void) {
    tag_point_3d points[total_points];

    size_t total = 0;

    while (total < total_points &&
           scanf("%d %d %d", &points[total].x, &points[total].y, &points[total].z) == 3)
        total++;

    printf("%d %d %d", points[0].x, points[0].y, points[0].z);

    // __ASSERT_TESTS__
    return 0;
}
```

### Подвиг 9 (на повторение). Выберите все верные варианты инициализации полей структуры tag_thing языка Си стандарта C99:

```c++
struct tag_thing {
    unsigned int id;
    char name[50];
    double weight;
    double price;
};
```

+ [x] struct tag_thing thing_5 = {.price=103.5, .weight = 5.45};
+ [x] struct tag_thing thing_1 = {1, "book", 0.5, 3500.0};
+ [x] struct tag_thing thing_3 = {};
+ [x] struct tag_thing thing_2 = {1, "book"};
+ [x] struct tag_thing thing_4 = {.id = 5, .name="toy"};

### Подвиг 10 (на повторение). Выберите все верные варианты присвоения значений переменной d типа VAR (на структуру):

```c
typedef struct {
    int var_i;
    double var_d;
} VAR;

VAR d;
```

+ [x] d = (VAR){.var_d = 0.5, .var_i = -5};
+ [x] d.var_i = 10;
+ [x] d.var_d = -0.12;
+ [x] d = (VAR){.var_d = 0.5};
+ [x] d = (VAR){10};
+ [ ] d = 10;

# 10.2 Структуры. Режимы доступа. Сеттеры и геттеры

Продолжаем тему структур языка С++. На прошлом занятии мы с вами увидели, что в структурах можно объявлять методы и вызывать их через объект-структуру (переменные структуры):

```c++
#include <iostream>
#include <math.h>
 
using std::cout;
using std::endl;
 
struct point {
    int x, y;
 
    double length() { return sqrt(x*x + y*y); }
};
 
int main() {
    struct point pt {1, 2};
    cout << pt.length() << endl;
    return 0;
}
```

Причем, значения полей `x` и `y` мы можем задавать, как при инициализации, так и через переменную `pt`, ровно так, как это было и в языке Си:

```c
    pt.x = 10;
    pt.y = 20;
```

Однако это не всегда желаемое поведение. Например, у нас может быть ограничение, что точка типа `point` принимает значения координат из строго заданного диапазона. Для примера возьмем его `[-100; 100]`. Тогда непосредственное изменение состояния объекта `pt` через переменные `x` и `y` легко может привести к нарушению этого требования. Например:

```c
pt.x = 153;  // за пределами [-100; 100]
```

Как же быть? Для этого в структурах и классах языка С++ дополнительно можно определять режимы доступа к тем или иным полям структуры (класса). На данный момент мы рассмотрим два таких режима:
+ `public` – публичный доступ к переменным и методам;
+ `private` – частный (закрытый) доступ к переменным и методам.

Например, если нам нужно закрыть прямой доступ извне для каких-либо полей структуры, то достаточно объявить их как `private` следующим образом:

```c
struct point {
private:
    int x, y;
public:
    double length() { return sqrt(x*x + y*y); }
};
```

То есть, пишется ключевое слово `private` и ставится двоеточие. 

Все, что следует ниже, попадает в раздел `private` до тех пор, пока не встретится какой-либо другой режим доступа. Так как мы хотим, чтобы метод `length()` был общедоступным, то необходимо явно прописать режим `public` после `private`.

Давайте посмотрим, к чему это приведет. Теперь мы не можем выполнять инициализацию объекта `pt`, так как инициализируемые поля `x` и `y` скрыты от внешнего доступа. Также мы не можем изменять значения этих полей, обращаясь к ним напрямую через объект `pt`:

```c
pt.x = 153;  // ошибка
```

А вот вызывать метод `length()` по-прежнему можно:

```c
double res = pt.length(); // ok
```

Причем, внутри метода `length()` обращение к приватным переменным `x` и `y` разрешено. 

То есть, режим доступа `private` запрещает работать с переменными `x` и `y` напрямую извне структуры `point`, но не запрещает делать это изнутри. 

А режим `public` позволяет прямое обращение как извне структуры, так и внутри нее. 

По умолчанию все поля структуры помечаются как `public`. Именно поэтому на прошлом занятии мы даже не подозревали о существовании каких-то режимов доступа.

Конечно, защита на уровне `private` отдельных полей структуры – это защита для программиста от своих собственных случайных ошибок. 

Если что-либо помечено как `private`, значит, напрямую к этим переменным или методам обращаться не следует. 

Хотя, конечно, обойти эту защиту достаточно просто. Поэтому мы здесь закрывает поля не от злоумышленников, а для корректного написания кода, уменьшая собственные возможные ошибки.

И еще одно важное замечание. Защита `private` определяется на уровне типа данных – структуры целиком, а не на уровне отдельных объектов. 

О чем здесь речь? Смотрите, если в нашей структуре `point` объявить еще один метод, например, `sum()` для сложения одного вектора с другим:

```c++
struct point {
private:
    int x, y;
public:
    double length() { return sqrt(x*x + y*y); }
    void sum(const point& pt)
    {
        this->x += pt.x;
        this->y += pt.y;
    }
};
```

То внутри метода `sum` мы можем совершенно спокойно обращаться к переменным `x` и `y` через переданный объект `pt`. И все благодаря тому, что функция-член `sum()` принадлежит типу данных `point`. Она находится, как бы, внутри него. А раз, так, то автоматически получает доступ ко всем приватным полям этой структуры, даже если они берутся из другого объекта. Поэтому и говорят, что защита действует на уровне типа данных, а не на уровне объектов.

Конечно, полученная структура `point`, на данный момент не пригодна для практического использования. 

Мы не можем задавать нужные нам координаты и читать их. 

Самый очевидный шаг, как это можно было бы поправить – это определить соответствующие публичные методы. Например, следующим образом:

```c++
struct point {
private:
    int x, y;
public:
    double length() { return sqrt(x*x + y*y); }
    void sum(const point& pt) {
        this->x += pt.x;
        this->y += pt.y;
    }
 
    void set_coords(int x, int y) { 
        if(x < -100 || x > 100 || y < -100 || y > 100)
            return;
 
        this->x = x; 
        this->y = y; 
    }
 
    void get_coords(int& x, int& y) {x = this->x; y = this->y; }
    int get_x() { return this->x; }
    int get_y() { return this->y; }
};
```

Обратите внимание, что в методах `set_coords()` и `get_coords()` для обращения к переменным `x` и `y` текущего объекта необходимо использовать неявный указатель `this`. 

Если бы мы прописали просто `x`, то это соответствовало бы локальному параметру `x` функции, а не переменной объекта. 

Поэтому в таких случаях, когда локальные переменные внутри метода совпадают по именам с полями структуры, для обращения к полям необходимо использовать указатель `this` на текущий объект.

Теперь мы можем передавать координаты и читать их, используя публичные методы:

```c++
int main() {
    struct point pt;
    
    pt.set_coords(1, 2);
    cout << pt.get_x() << " " << pt.get_y() << endl;
 
    double res = pt.length();
    cout << res << endl;
    
    return 0;
}
```

В ООП методы, которые служат для установки значений переменных объекта, получили название сеттеры (от префикса `set`, который часто записывается вначале таких методов), а методы, с помощью которых читаются значения переменных объекта – геттерами (от префикса `get`).

Однако и в такой реализации структура `point` все еще остается недоработанной. Это связано с тем, что когда мы создаем объект `pt`, то его начальное состояние оказывается неопределенным из-за неизвестных значений координат `x` и `y`. Но следующие улучшения мы будем делать уже на следующем занятии.

Видео по теме [#18. Структуры. Режимы доступа. Сеттеры и геттеры](https://www.youtube.com/watch?v=Bjqrje_g_Yk&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, касающиеся режимов доступа в структурах языка С++.

+ [ ] если поле помечено как public, то обратиться к нему напрямую вне структуры запрещено
+ [x] по умолчанию все поля структуры имеют режим доступа public
+ [x] если поле помечено как private, то обратиться к нему напрямую вне структуры запрещено
+ [x] если поле помечено как public, то к нему можно напрямую обращаться и вне структуры и внутри нее
+ [x] режим public предоставляет полный (публичный) доступ к полям структуры
+ [x] режим private задает частный (приватный) доступ к полям структуры только внутри нее
+ [ ] если поле помечено как private, то к нему можно напрямую обращаться и вне структуры и внутри нее

### Подвиг 2. Выберите все верные утверждения, касающиеся следующей программы:

```c++
#include <iostream>

struct complex {
private:
    double re, im;

public:
    double get_real() { return re; }
    double get_imag() { return im; }
};

int main(void) {
    complex cmp_1;
    complex cmp_2 {0.5, 4};

    double re = cmp_2.get_real();
    double im = cmp_2.im;
    
    return 0;
}
```

+ [x] переменная cmp_2 объявлена с ошибкой, т.к. поля re и im нельзя инициализировать извне
+ [x] команда cmp_2.im приведет к ошибке, т.к. выполняется обращение к приватному полю im
+ [ ] вызов публичного метода cmp_2.get_real() невозможен, т.к. он имеет режим доступа public
+ [x] доступ к методам get_real и get_imag возможен и внутри и вне структуры complex
+ [x] переменная cmp_1 имеет неопределенное состояние, т.к. неизвестны значения полей re и im
+ [x] доступ к полям re и im возможен только внутри структуры complex

### Подвиг 3. Выберите все верные утверждения, касающиеся сеттеров и геттеров структур языка С++.

+ [x] особенность применения сеттеров и геттеров в том, что они перед присваиванием/считыванием данных могут реализовывать различные алгоритмы проверки этих данных
+ [ ] сеттеры - это публичные методы, которые возвращают значения, как правило, приватных полей (переменных)
+ [x] геттеры - это публичные методы, которые возвращают значения, как правило, приватных полей (переменных)
+ [ ] геттеры - это публичные методы, которые заносят данные, как правило, в приватные поля (переменные)
+ [x] сеттеры - это публичные методы, которые заносят данные, как правило, в приватные поля (переменные)

### Подвиг 4. Объявите в программе структуру с именем (типом) thing и следующими приватными полями:

+ id: идентификатор; целое беззнаковое число;
+ price: цена; вещественное число;
+ weight: вес; вещественное число.

Объявите в этой же структуре следующие публичные методы:

+ unsigned get_id(): возвращает значение поля id;
+ void get_data(double& price, double& weight): передает по ссылкам price и weight значения соответствующих полей;
+ void set_data(unsigned id, double price, double weight): заносит в приватные поля id, price, weight переданные значения.

P. S. Функцию main в программе прописывать не нужно, только объявить структуру.

```c++
#include <iostream>

struct thing {
   private:
    unsigned int id;
    double price;
    double weight;

   public:
    unsigned get_id() { return this->id; }
    void get_data(double& price, double& weight) {
        price = this->price;
        weight = this->weight;
        return;
    }
    void set_data(unsigned id, double price, double weight) {
        this->id = id;
        this->price = price;
        this->weight = weight;
        return;
    }
};
```

### Подвиг 5. Объявите в программе структуру с именем (типом) point и следующими приватными полями:
+ x, y: целочисленные координаты точки.

Объявите в этой же структуре следующие публичные методы:
+ int get_x(): возвращает значение координаты x;
+ int get_y(): возвращает значение координаты y;
+ void get_coords(int& x, int& y): возвращает через ссылки значение координат x и y;
+ void set_coords(int x, int y): записывает в поля x, y переданные значения;
+ static point sum(point& p1, point& p2): выполняет суммирование координат p1 и p2 (отдельно для x и отдельно для y) и возвращает результат суммирования в виде новой структуры point.

В функции main объявите две переменные типа point. Прочитайте из входного потока координаты (четыре целых числа, записанных через пробел) в эти структуры: первые два числа - это координаты x, y первой точки, а вторые два числа - координаты x, y второй точки. Затем, с помощью функции sum выполните суммирование координат этих точек и выведите в консоль результат суммирования в виде двух чисел, записанных через пробел, в формате:

<координата x> <координата y>

Sample Input:

5 7 -3 10

Sample Output:

2 17

```c++
#include <iostream>

struct point {
   private:
    int x, y;

   public:
    int get_x() { return this->x; }
    int get_y() { return this->y; }
    void get_coords(int& x, int& y) {
        x = this->x;
        y = this->y;
        return;
    }
    void set_coords(int x, int y) {
        this->x = x;
        this->y = y;
        return;
    }
    static point sum(point& p1, point& p2) {
        point res;
        res.set_coords(p1.get_x() + p2.get_x(), p1.get_y() + p2.get_y());
        return res;
    }
};

int main(void) {
    point p1, p2;
    int x1, y1, x2, y2;
    std::cin >> x1 >> y1 >> x2 >> y2;

    p1.set_coords(x1, y1);
    p2.set_coords(x2, y2);

    point res = point::sum(p1, p2);

    printf("%d %d", res.get_x(), res.get_y());

    return 0;
}
```

### Подвиг 6. Продолжите программу. В структуре point добавьте следующие публичные методы:

+ `void set_coords(int x, int y, int z)` - перегруженный сеттер для записи координат в массив `coords` в поле `v_int` (переменная `type` должна быть изменена на значение `data_int`);
+ `void set_coords(double x, double y, double z)` - перегруженный сеттер для записи координат в массив `coords` в поле `v_double` (переменная `type` должна быть изменена на значение `data_double`);
+ `data_type get_type()` - метод возвращает значение переменной `type`;
+ `int get_size()` - метод возвращает значение константы `max_coords`;
+ `bool get_coords(int& x, int& y, int& z)` - перегруженный геттер для записи по ссылкам `x`, `y`, `z` значений из массива `coords` поля `v_int`; если при этом `type` не равен `data_int`, то запись не производится и возвращается `false`, иначе данные записываются (по ссылкам) и возвращается `true`;
+ `bool get_coords(double& x, double& y, double& z)` - перегруженный геттер для записи по ссылкам `x`, `y`, `z` значений из массива `coords` поля `v_double`; если при этом `type` не равен `data_double`, то запись не производится и возвращается `false`, иначе данные записываются (по ссылкам) и возвращается `true`.
В функции `main` объявите переменную `pt` и занесите в нее целочисленные координаты:

5, -8, 34

В зависимости от значения поля `type` (воспользуйтесь методом `get_type`) выведите в консоль либо целочисленные координаты в одну строчку через пробел, либо вещественные (так же в одну строчку через пробел с точностью до десятых).

```c++
#include <iostream>

enum data_type { data_none = 1, data_int, data_double };

struct point {
   private:
    enum { max_coords = 3 };

    union {
        int v_int;
        double v_double;
    } coords[max_coords];

    data_type type = data_none;

   public:
    void set_coords(int x, int y, int z) {
        this->coords[0].v_int = x;
        this->coords[1].v_int = y;
        this->coords[2].v_int = z;
        this->type = data_int;
    }
    void set_coords(double x, double y, double z) {
        this->coords[0].v_double = x;
        this->coords[1].v_double = y;
        this->coords[2].v_double = z;
        this->type = data_double;
    }
    data_type get_type() { return type; }

    int get_size() { return max_coords; }

    bool get_coords(int& x, int& y, int& z) {
        if (type == data_int) {
            x = this->coords[0].v_int;
            y = this->coords[1].v_int;
            z = this->coords[2].v_int;
            return true;
        }
        return false;
    }
    bool get_coords(double& x, double& y, double& z) {
        if (type == data_double) {
            x = this->coords[0].v_double;
            y = this->coords[1].v_double;
            z = this->coords[2].v_double;
            return true;
        }
        return false;
    }
};

int main(void) {
    point pt;
    pt.set_coords(5, -8, 34);

    if (pt.get_type() == data_int) {
        int x, y, z;
        pt.get_coords(x, y, z);
        printf("%d %d %d", x, y, z);
    }
    if (pt.get_type() == data_double) {
        double xd, yd, zd;
        pt.get_coords(xd, yd, zd);
        printf("%.1lf %.1lf %.1lf", xd, yd, zd);
    }

    // __ASSERT_TESTS__
    return 0;
}
```

### Подвиг 7 (на повторение). Объявите в программе структуру с идентификатором tag_point и полями x, y типа float (координаты точки на плоскости). В функции main объявите массив ps из total_points структур tag_point. Константа total_points должна быть объявлена через перечисление и равна 128. Для всех элементов массива ps сгенерируйте случайные координаты x, y в виде вещественных чисел в диапазоне [-100; 100]. Вычислите среднее арифметическое отдельно для координаты x и координаты y. Сохраните вычисленные средние значения в переменных mean_x и mean_y типа double.

P. S. В консоль ничего выводить не нужно.

```c++
#include <iostream>

enum { total_points = 128 };

struct tag_point {
    float x, y;
};

int main(void) {
    tag_point ps[total_points];
    double mean_x = 0, mean_y = 0;

    for (size_t i = 0; i < total_points; i++) {
        ps[i].x = (float)(rand()) / RAND_MAX * (200) - 100;
        mean_x += ps[i].x;
        ps[i].y = (float)(rand()) / RAND_MAX * (200) - 100;
        mean_y += ps[i].y;
    }
    mean_x /= total_points;
    mean_y /= total_points;
    // __ASSERT_TESTS__
    return 0;
}
```

### Подвиг 8 (на повторение). Выберите все верные утверждения, касающиеся перечислимого типа языка C/C++.

+ [x] перечисления позволяют задавать числовые константы времени компиляции
+ [ ] перечисления позволяют задавать числовые константы времени выполнения программы (не компиляции)
+ [x] константы перечисления можно использовать в метках case оператора switch
+ [x] константы перечисления связаны с целыми числами и не имеют скрытого поведения, как например, директивы
+ [ ] константы перечисления нельзя использовать в метках case оператора switch

### Подвиг 9 (на повторение). Выберите все верные объявления перечислений.

+ [x] enum {v2=2, v3=3, v4=4} vector_dim;
+ [x] enum window_styles {border=2, caption=4, sizeable=8} style;
+ [x] enum {black=0, red=0xCC0000, green = 0x00CC00, blue=0x0000CC, white=255};
+ [x] enum types {type_int, type_double, type_long};
+ [x] enum sizes {width=1280, height=720};

### Подвиг 10 (на повторение). Выберите все верные утверждения, касающиеся следующего фрагмента программы:

```c
float global_ar[1000000];

int main(void) {
    double ar[1000000];
    return 0;
}
```

+ [x] массив ar располагается в стековом фрейме в момент вызова функции main
+ [ ] массив global_ar располагается в стековом фрейме
+ [x] массив global_ar располагается вне стекового фрейма
+ [ ] массив ar располагается в стековом фрейме в момент загрузки программы (до вызова функции main)
+ [ ] если размера стекового фрейма недостаточно для хранения массива ar, то часть данных массива ar теряется (неопределенное поведение)
+ [x] если размера стекового фрейма недостаточно для хранения массива ar, то возникает ошибка Stack Overflow

# 10.3 Структуры. Конструкторы и деструкторы

Продолжаем тему структур языка С++. На прошлом занятии мы с вами получили следующую структуру:

```c++ 
#include <iostream>
#include <math.h>
 
using std::cout;
using std::endl;
 
struct point {
private:
    int x, y;
public:
    double length() { return sqrt(x*x + y*y); }
    void sum(const point& pt) { 
        this->x += pt.x;
        this->y += pt.y;
    }
 
    void set_coords(int x, int y) { 
        if(x < -100 || x > 100 || y < -100 || y > 100)
            return;
 
        this->x = x; 
        this->y = y; 
    }
 
    void get_coords(int& x, int& y) {x = this->x; y = this->y; }
    int get_x() { return this->x; }
    int get_y() { return this->y; }
};
 
int main() {
    struct point pt;
    
    return 0;
}
```


И, как говорили, в момент создания объекта `pt` его локальные переменные `x` и `y` принимают неопределенные значения. 

Это нарушает один из основополагающих принципов ООП – не делать никаких предположений о внутреннем состоянии объектов. 

То есть, объекты должны вести себя предсказуемым образом. В частности, было бы правильно для новых создаваемых объектов инициализировать поля `x` и `y` нулевыми значениями.

## Конструкторы

Но, как это сделать? Как раз для этих целей предусмотрены специальные методы структур и классов, которые называются конструкторами:
+ имя конструктора всегда должно совпадать с именем типа данных, в нашем случае с именем структуры point;
+ конструктор никогда не возвращает никаких значений, поэтому возвращаемый тип не прописывается вовсе;
+ конструктор может иметь произвольное число параметров;
+ конструктор всегда вызывается при создании каждого нового объекта.

Учитывая все это, объявим конструктор в структуре point следующим образом:

```c++
struct point {
private:
    int x, y;
public:
    point()  // конструктор объекта
        { x = 0; y = 0; }
    ...
};
```

Теперь, при создании нового объекта, его локальные переменные `x` и `y` будут принимать предсказуемое нулевое значение:

```c++
int main() {
    struct point pt;
    cout << pt.get_x() << " " << pt.get_y() << endl;
    return 0;
}
```

Таким образом, мы с вами устранили неопределенность в состоянии объекта `pt`. Однако выполнять его инициализацию в момент создания произвольными значениями по-прежнему нельзя:

```c++
struct point pt(1, 2); // ошибка
```

Очевидно, для добавления такой возможности нам нужен еще один конструктор с двумя параметрами. Объявим его следующим образом:

```c++
struct point {
private:
    int x, y;
public:
    point() { x = 0; y = 0; }
    point(int x, int y) { this->x = x; this->y = y; }
    ...
};
```

Это называется перегрузкой конструкторов. Компилятор выбирает тот или иной в зависимости от набора и типов аргументов, указанных при создании объектов. Теперь мы совершенно спокойно можем выполнять команды вида:

```c++
struct point pt(1, 2); // ok
```

Или даже делать так:

```c++
double res = point(10, 20).length();
```

Здесь создается временный объект типа `point` с координатами `(10; 20)` и вычисляется длина радиус-вектора. После вычислений временный объект автоматически уничтожается (освобождается память, которую он занимал).

## Деструкторы

На данном этапе мы не будем углубляться дальше в тему конструкторов – это предмет отдельного разговора курса по ООП языка С++. Сейчас главная цель показать отличия и основные возможности структур в С++. Поэтому перейдем к следующему шагу и поговорим о методе, который вызывается в момент уничтожения объекта. Такой метод называется деструктором и обладает следующим свойствами:
+ имя метода называется также, как и тип данных с тильдой (‘~’) вначале;
+ деструктор ничего не возвращает;
+ деструктор не имеет параметров.

Например, мы можем объявить следующий деструктор в структуре `point`:

```c++
struct point {
private:
    int x, y;
public:
    point() { x = 0; y = 0; }
    point(int x, int y) { this->x = x; this->y = y; }
 
    ~point()  // деструктор
        { cout << "вызов деструктора объекта" << endl; }
    ...
};
```

При выполнении программы мы увидим вызовы деструкторов для временного объекта и для объекта `pt`.

Спрашивается, зачем нужны деструкторы, какие задачи они выполняют? 

Общий ответ достаточно прост. 

Деструкторы служат для освобождения ресурсов, захваченных текущим объектом. Например, если бы в структуре `point` динамически выделялась память для какого-либо массива, то в деструкторе ее следовало бы освободить:

```c++
struct point {
private:
    int x, y;
    short* coords;
public:
    point() { x = 0; y = 0; coords = (short *)malloc(2 * sizeof(short)); }
    point(int x, int y) { this->x = x; this->y = y; coords = (short *)malloc(2 * sizeof(short)); }
 
    ~point()  // деструктор
    { 
        cout << "вызов деструктора объекта" << endl; 
        free(coords);
    }
    ...
};
```

Иначе, при каждом новом объекте `point` память под массив будет постоянно выделяться, но не освобождаться при уничтожении объекта структуры. 

Это привело бы к утечке памяти. 

Как раз эту проблему решает деструктор, освобождая все захваченные текущим объектом ресурсы. 

Причем, деструктор гарантированно вызывается всегда при уничтожении объекта. 

Компиляторы это очень хорошо отслеживают и в нужный момент добавляют вызов деструктора. 

В результате, при создании объекта один раз срабатывает конструктор, а при уничтожении этого объекта – один раз срабатывает деструктор. В этом мы можем быть уверены.

Видео по теме [#19. Структуры. Конструкторы и деструкторы](https://www.youtube.com/watch?v=DINtoGSCEM4&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, касающиеся конструкторов структур языка С++.

+ [ ] конструктор всегда имеет тип void и может принимать произвольное число параметров
+ [x] в одной структуре можно объявить несколько перегруженных конструкторов
+ [x] конструктор ничего не возвращает и может принимать произвольное число параметров
+ [x] конструктор всегда вызывается непосредственно при создании каждого нового объекта
+ [x] конструктор служит для начальной инициализации создаваемого объекта
+ [x] имя конструктора всегда должно совпадать с именем типа данных

### Подвиг 2. Выберите все верные утверждения, касающиеся деструкторов структур языка С++.

+ [x] компилятор всегда при создании объекта вызывает один конструктор и непосредственно перед удалением один деструктор
+ [x] деструктор вызывается непосредственно перед удалением объекта из памяти
+ [x] имя деструктора совпадает с типом данных и дополнительно вначале ставится символ тильда '~'
+ [x] деструктор служит для освобождения всех захваченных объектом ресурсов
+ [ ] деструктор ничего не возвращает и может принимать произвольное число параметров
+ [x] деструктор ничего не возвращает и не принимает никаких параметров

### Подвиг 3. Объявите в программе структуру с именем (типом) money так, чтобы ее объекты можно было создавать следующим образом:
+ money my_money(100);
+ money you_money(1000);
При создании объектов указывается количество денег, которое должно сохраняться в приватном целочисленном (int) поле total_money каждого объекта.

Объявите в структуре money два публичных метода:
+ `int get_money()`: возвращает количество денег (значение поля `total_money`);
+ `void set_money(int volume)`: задает количество денег (в поле `total_money`).

В функции `main` создайте переменную `rubs` типа money с количеством денег `100` (задается при инициализации). Выведите в консоль количество денег, хранимое в объекте `rubs` в виде одного целого числа.

```c++
#include <iostream>

struct money {
   private:
    int total_money;

   public:
    money() { total_money = 0; }
    money(int x) { total_money = x; }
    int get_money() { return total_money; }
    void set_money(int volume) { total_money = volume; }
};

int main(void) {
    money rubs(100);
    std::cout << rubs.get_money() << std::endl;
    // __ASSERT_TESTS__
    return 0;
}
```

### Подвиг 4. Объявите в программе структуру с именем (типом) triangle так, чтобы ее объекты (треугольники) можно было создавать следующим образом:

```c
triangle tr_init;
triangle tr(5, 8, 6);
```
При создании объектов указывается целочисленные длины сторон треугольника, которые должны сохраняться в приватных целочисленных (`int`) переменных `a`, `b`, `c`. Если никакие значения не передаются, то переменные `a`, `b`, `c` должны принимать нулевые значения.

Объявите в структуре `triangle` следующие публичные методы:
+ `bool is_triangle()`: возвращает истину (`true`), если длины сторон `a`, `b`, `c` могут являться длинами сторон треугольника, и `false` - в противном случае;
+ `void get_lengths(int& a, int& b, int& c)`: возвращает значения длин сторон из приватных переменных `a`, `b`, `c`;
+ `void set_lengths(int a, int b, int c)`: задает значения приватных переменных `a`, `b`, `c`.

В функции `main` создайте переменную `tr_1` типа `triangle` без указания длин сторон и переменную `tr_2` со сторонами `7`, `4`, `8` (задаются при инициализации).

P. S. В консоль ничего выводить не нужно.

```c++
#include <iostream>

struct triangle {
   private:
    int a, b, c;

   public:
    triangle() { a = 0, b = 0, c = 0; }
    triangle(int a, int b, int c) {
        this->a = a;
        this->b = b;
        this->c = c;
    }
    bool is_triangle() { return ((a + b) > c) * ((a + c) > b) * ((c + b) > a); }
    void get_lengths(int& a, int& b, int& c) {
        a = this->a;
        b = this->b;
        c = this->c;
    }
    void set_lengths(int a, int b, int c) {
        this->a = a;
        this->b = b;
        this->c = c;
    }
};

int main(void) {
    triangle tr_1;
    triangle tr_2(7, 4 , 8);
    
    // __ASSERT_TESTS__
    return 0;
}
```

### Подвиг 5. Объявите в программе структуру с именем (типом) point3D так, чтобы ее объекты можно было создавать следующим образом:
+ `point3D pt_null`;
+ `point3D pt_end(8, -5, 11)`;

При создании объектов указывается целочисленные координаты точки в трехмерном пространстве, 
которые должны сохраняться в приватных целочисленных (`int`) переменных, например, `x`, `y`, `z`. Если никакие значения не передаются, то переменные `x`, `y`, `z` должны принимать нулевые значения.

Объявите в структуре `point3D` следующие публичные методы:
+ `void get_coords(int& x, int& y, int& z)`: возвращает значения координат из приватных переменных `x`, `y`, `z`.

Объявите в программе еще одну структуру с именем (типом) `line3D` так, чтобы ее объекты можно было создавать, следующим образом:

```c
line3D line(point3D(0, 1, 2), point3D(10, 43, -21));
```

При создании объектов `line3D` передаются объекты структур `point3D`, которые должны сохраняться в приватных переменных, например, `start_pt`, `end_pt`. А в момент удаления объекта в консоль следует выводить строку (в конце должен быть символ переноса на новую строку '\n'):

```
"Deleted line: (x0, y0, z0) (x1, y1, z1)"
```

где (`x0`, `y0`, `z0`) - координаты начала; (`x1`, `y1`, `z1`) - координаты конца линии. Например, при удалении объекта `line` должна формироваться строка:

```
"Deleted line: (0, 1, 2) (10, 43, -21)"
```

Объявите в структуре `line3D` следующие публичные методы:

+ `double length()`: возвращает длину линии; вычисляется по формуле: $ L = \sqrt{(x_0 − x_1)^2 + (y_0 − y_1)^2 + (z_0 − z_1)^2}$
+ `const point3D& get_coords_start()`: возвращает константную ссылку на приватную переменную `start_pt`;
+ `const point3D& get_coords_end()`: возвращает константную ссылку на приватную переменную `end_pt`.

В функции `main` создайте объект `line` типа `line3D` с координатами:

```c
start_pt = (-5, 100, 45), end_pt = (0, 32, -42)
```

P. S. Только создать объект, больше ничего делать не нужно.

```c++
#include <cmath>
#include <iostream>

struct point3D {
   private:
    int x, y, z;

   public:
    point3D() { x = 0, y = 0, z = 0; }
    point3D(int x, int y, int z) {
        this->x = x;
        this->y = y;
        this->z = z;
    }
    void get_coords(int& x, int& y, int& z) {
        x = this->x;
        y = this->y;
        z = this->z;
    }
    void set_coords(int x, int y, int z) {
        this->x = x;
        this->y = y;
        this->z = z;
    }
};

struct line3D {
   private:
    point3D p0, p1;

   public:
    line3D() {
        this->p0 = {0, 0, 0};
        this->p1 = {0, 0, 0};
    }
    line3D(point3D p0, point3D p1) {
        this->p0 = p0;
        this->p1 = p1;
    }
    ~line3D() {
        int x0, y0, z0, x1, y1, z1;
        p0.get_coords(x0, y0, z0);
        p1.get_coords(x1, y1, z1);
        printf("Deleted line: (%d, %d, %d) (%d, %d, %d)", x0, y0, z0, x1, y1, z1);
    }
    double length() {
        int x0, y0, z0, x1, y1, z1;
        p0.get_coords(x0, y0, z0);
        p1.get_coords(x1, y1, z1);
        double res = sqrt((x0 - x1) * (x0 - x1) + (y0 - y1) * (y0 - y1) + (z0 - z1) * (z0 - z1));
        return res;
    }
    const point3D& get_coords_start() const { return this->p0; }
    const point3D& get_coords_end() const { return this->p1; }
};

int main(void) {
    point3D start_pt = {-5, 100, 45};
    point3D end_pt = {0, 32, -42};
    line3D line(start_pt, end_pt);

    // __ASSERT_TESTS__
    return 0;
}
```

### Подвиг 6 (с повторением). Объявите в программе структуру с именем (типом) dtime так, чтобы объекты можно было создавать следующим образом (достаточно прописать один конструктор):

```c
dtime tm_null;
dtime tm_1(12);
dtime tm_2(12, 45);
dtime tm_3(12, 45, 8);
```

При создании объектов указывается параметры типа `unsigned char` в порядке:

`hours` - часы; `minutes` - минуты; `seconds` - секунды.

Эти значения должны сохраняться в приватных переменных (тип `unsigned char`), например, с именами: `hs`, `ms`, `sc`. Если какие-либо значения не передаются, то они принимаются равными нулю.

Объявите в структуре `dtime` следующие публичные методы:

+ `std::string get_time();` - возвращает объект-строку `std::string` с содержимым (строкой):
`hh:mm:ss`

Например, для переменных `hs=12`, `ms=8`, `sc=43` строка должна содержать:

`12:08:43`

Следующий метод:

+ `void set_time(unsigned char hours, unsigned char minutes, unsigned char seconds);` - задает время (записывает данные в переменные `hs`, `ms`, `sc`).

И, наконец, статический метод:

+ `static dtime sum_time(const dtime& t1, const dtime& t2);`
Формирует и возвращает новую структуру с суммой времен `t1` и `t2`.

В функции `main` объявите две переменные `tm1` и `tm2` структуры `dtime`. Значения их полей (шесть целых неотрицательных чисел, записанных в одну строчку через пробел) прочитайте из входного потока (в порядке `h1`, `m1`, `s1` - для первого времени и `h2`, `m2`, `s2` - для второго времени). 

Выполните сложение времен `tm1` и `tm2` с помощью метода `sum_time` и сохраните результат в переменной `time_res`. Выведите в консоль время переменной `time_res` в виде строки, сформированной методом `get_time`.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/10.3.8

Sample Input:

12 45 16 4 23 48

Sample Output:

17:09:04

```c++
#include <iostream>
#include <string>

struct dtime {
   private:
    unsigned char hs;
    unsigned char ms;
    unsigned char sc;

   public:
    dtime(unsigned char hs = 0, unsigned char ms = 0, unsigned char sc = 0) {
        this->hs = hs;
        this->ms = ms;
        this->sc = sc;
    }
    std::string get_time() {
        char str[10];
        sprintf(str, "%02d:%02d:%02d", hs, ms, sc);
        std::string res(str);
        return res;
    }

    void set_time(unsigned char hours, unsigned char minutes, unsigned char seconds) {
        this->hs = hours;
        this->ms = minutes;
        this->sc = seconds;
    }

    static dtime sum_time(const dtime& t1, const dtime& t2) {
        dtime res;
        unsigned char over = 0;
        res.sc = time_sum(t1.sc, t2.sc, over, 60);
        res.ms = time_sum(t1.ms, t2.ms, over, 60);
        res.hs = time_sum(t1.hs, t2.hs, over, 24);
        return res;
    }
    static unsigned char time_sum(unsigned char t1, unsigned char t2, unsigned char& over,
                                  unsigned char limit) {
        unsigned char res = (t1 + t2 + over) % limit;
        over = (t1 + t2 + over) / limit;
        return res;
    }
};

void read_time(dtime& tm) {
    int hours;
    int minutes;
    int seconds;
    std::cin >> hours >> minutes >> seconds;
    tm.set_time(hours, minutes, seconds);
}

int main(void) {
    dtime tm1;
    dtime tm2;

    read_time(tm1);
    read_time(tm2);

    dtime time_res;

    time_res = dtime::sum_time(tm1, tm2);

    std::string res = time_res.get_time();
    std::cout << res << std::endl;
    // __ASSERT_TESTS__
    return 0;
}
```

### Подвиг 7 (на повторение). Выберите все верные утверждения, касающиеся арифметических операций языка C/C++.

+ [x] приоритет унарной операции всегда выше бинарной
+ [ ] в выражении -1*2 + 3*4*5 порядок вычисления слагаемых (-1*2 и 3*4*5) выполняется строго слева-направо
+ [x] для изменения приоритетов арифметических операций используются круглые скобки
+ [x] порядок вычисления арифметических операций одного приоритета (например: 2-3+6) выполняется строго слева-направо
+ [ ] приоритет унарной операции всегда ниже бинарной
+ [x] в выражении -1*2 + 3*4*5 порядок вычисления слагаемых (-1*2 и 3*4*5) не определен стандартом языка C/C++
+ [x] приоритет операций сложения и вычитания ниже, чем умножения и деления
+ [ ] порядок вычисления арифметических операций одного приоритета (например: 2-3+6) не определен стандартом языка C/C++

### Подвиг 8 (на повторение). Пусть имеется следующий фрагмент программы:

```c
signed char byte = -55;
double res = byte + 1;
```

Выберите все верные утверждения, касающиеся этого фрагмента.

+ [x] в момент присваивания переменной res вычисленное значение приводится к типу double
+ [x] так как приоритет операции присваивания наименьший, то сначала выполняется сложение, а затем, присваивание
+ [x] при сложении значение переменной byte преобразуется к типу int
+ [ ] при сложении число 1 приводится к типу signed char

# 10.4 Операторы new / delete и new [] / delete []

## Операторы new / delete

Итак, на предыдущих занятиях мы с вами увидели, каким богатым функционалом стали обладать структуры в языке С++. 

В них появились
+ методы-члены,
+ конструкторы и
+ деструкторы, а также
+ режимы ограничения доступа к полям структуры. 

В связи с этим возникают некоторые особенности их динамического создания в памяти устройства.

Я напомню, что в языке Си мы изучали функции `malloc()`, `calloc()`, `realloc()` и `free()` для динамического выделения и освобождения ранее выделенной области памяти. 

В частности, память под структуру могли выделить следующим образом:

```c
#include <iostream>
#include <math.h>
 
using std::cout;
using std::endl;
 
struct point {
private:
    int x, y;
public:
    point() { 
        cout << "вызов конструктора объекта" << endl; 
        x = 0; y = 0;
    }
    point(int x, int y) { 
        cout << "вызов конструктора объекта" << endl; 
        this->x = x; this->y = y;
    }
 
    ~point()  // деструктор
    { 
        cout << "вызов деструктора объекта" << endl; 
    }
 
    double length() { return sqrt(x*x + y*y); }
    void sum(const point& pt) {
        this->x += pt.x;
        this->y += pt.y;
    }
 
    void set_coords(int x, int y) { 
        if(x < -100 || x > 100 || y < -100 || y > 100)
            return;
 
        this->x = x; 
        this->y = y; 
    }
 
    void get_coords(int& x, int& y) {x = this->x; y = this->y; }
    int get_x() { return this->x; }
    int get_y() { return this->y; }
};
 
int main() {
    struct point* pt;
    
    pt = (point *)malloc(sizeof(point));
    // что то делаем
    free(pt);
 
    return 0;
}
```

Однако если запустить программу, то ни конструктор, ни деструктор структуры `point` вызван не будет. 

Функции `malloc()` и `free()` лишь выделяют нужное число байт для хранения объекта структуры и, затем, освобождают эту память. 

Никаких дополнительных действий не выполняется. 

В ряде случаев – это то, что нужно. 

И в языке Си этого достаточно для размещения объекта структуры в памяти. 

Но не в С++. Здесь дополнительно следует вызвать конструктор непосредственно после создания объекта и деструктор – непосредственно перед удалением объекта. Для этого Бьёрн Страуструп ввел в С++ два новых оператора:
+ `new` – для выделения памяти под указанный тип данных с автоматическим вызовом конструктора;
+ `delete` – освобождение памяти с автоматическим вызовом деструктора.

В нашем примере ими можно воспользоваться следующим образом:

```c++ 
int main() {
    struct point* pt;
 
    pt = new point;
    // что то делаем
    delete pt;
 
    return 0;
}
```

После выполнения программы в консоли увидим строчки:

вызов конструктора объекта
вызов деструктора объекта

Они появились благодаря тому, что компилятор, при использовании оператора `new`, добавил в машинный код вызов функции-конструктора сразу после создания объекта, и вызов функции-деструктора перед его удалением. 

Также обратите внимание, что нам не требуется прописывать приведение типов у оператора `new`, так как он возвращает указатель на тип данных, для которого выполняется выделение памяти.

Вообще, в С++ рекомендуется (по возможности) использовать эти новые операторы `new` и `delete` вместо прежних `malloc()` и `free()`. 

Мало того, крайне не рекомендуется их смешивать. Например, выделить память с помощью `new`, а освободить с помощью `free()`. Это плохая практика, которая может привести к непредсказуемым результатам работы программы.

Но вернемся к нашей программе. При выполнении команды:

```c++
pt = new point;
```

вызывается конструктор без параметров (конструктор по умолчанию). И если вывести координаты `x` и `y` в консоль:

```c++
cout << pt->get_x() << " " << pt->get_y() << endl;
```

то увидим нули. 

А что если в момент создания нового объекта мы хотим сразу передать ему некоторые координаты? Для этого после типа `point` ставятся круглые скобки и прописываются параметры, например, так:

```c++
pt = new point(10, 20);
```

В этом случае будет вызван другой конструктор с двумя параметрами. Кстати, если указать только один аргумент при создании объекта:

```c++
pt = new point(10); // ошибка
```

то получим ошибку при компиляции программы, т.к. в структуре `point` не объявлен конструктор с одним параметром.

Интересно, что операторы `new` и `delete` в С++ можно использовать и с базовыми типами. Например, так:

```c++
int *ptr_int = new int;
delete ptr_int;
```

Будет создан, а затем, удален целочисленный объект `int` в памяти устройства с неопределенным значением. Но у этого объекта есть конструктор, через который можно инициализировать переменную `int` следующим образом:

```c++
int *ptr_int = new int(-123);
```

Тогда начальное значение будет равно `-123`. И так можно делать с любыми другими базовыми типами языка С++.

## Операторы new[] и delete[]

Давайте теперь посмотрим, как можно динамически создавать массивы из объектов определенного типа данных. Для этого в С++ применяются похожие операторы:
+ `new []` – для выделения памяти под указанное число объектов;
+ `delete []` – для освобождения памяти массива объектов.

Например:

```c++
int main() {
    point* pt = new point[3];
    // что то делаем
    delete [] pt;
 
    return 0;
}
```

После запуска программы в консоли увидим:

```
вызов конструктора объекта
вызов конструктора объекта
вызов конструктора объекта
вызов деструктора объекта
вызов деструктора объекта
вызов деструктора объекта
```

То есть, было выделена непрерывная область памяти под три объекта типа `point` и для каждого объекта был вызван конструктор по умолчанию (без параметров). При удалении с помощью оператора `delete []`, также для каждого объекта был вызван деструктор. Именно в этом ключевое отличие операторов `new []` и `delete []` от операторов `new`/`delete`. Например, если последний оператор `delete[]` заменить на `delete`:

```c++
delete pt;
```

то будет вызван только один деструктор для первого объекта массива. Для остальных элементов деструкторы уже не вызываются. Как вы понимаете, это может привести к утечке памяти, так как в деструкторах, обычно, происходит освобождение ресурсов, захваченных текущим объектом (структурой). Поэтому, при выделении памяти с помощью оператора `new[]` обязательно нужно ее освобождать оператором `delete[]` и комбинировать их вызовы с другими операторами недопустимо.

Далее, с массивом `pt` мы можем работать абсолютно так же, как с любым динамическим массивом. Например, перебрать и вывести координаты объектов:

```c++
    for(int i = 0; i < 3; ++i)
        cout << pt[i].get_x() << " " << pt[i].get_y() << endl;
```

Обратите внимание, что использовать цикл:

```c++
for(const point& p : pt) …
```

не получится, так как `pt` – это обычный указатель на первый элемент массива и сам по себе не считается массивом языка Си или С++.

Те же самые операции мы можем выполнять и с любым другим типом данных:

```c++
    double* vector3 = new double[3];
    delete [] vector3;
```

Вот так работают операторы `new`/`delete` и `new[]`/`delete[]` в языке С++.

Видео по теме [#20. Операторы new / delete и new [] / delete []](https://www.youtube.com/watch?v=ECeoy6VjV4w&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, касающиеся создания объектов структур в языке С++.

+ [x] при динамическом удалении объектов-структур с помощью оператора delete (например, delete pt;) компилятор языка С++ автоматически добавляет в код вызов деструктора
+ [x] при динамическом создании объектов-структур с помощью оператора new (например, point* pt = new point;) компилятор языка С++ автоматически добавляет в код вызов конструктора
+ [x] при создании объектов-структур в виде обычных переменных (например, point pt;) компилятор языка С++ автоматически добавляет в код вызов конструктора и деструктора
+ [ ] при динамическом создании объектов-структур с помощью функции malloc (например, point* pt = (point *)malloc(sizeof(point);) компилятор языка С++ автоматически добавляет в код вызов конструктора)
+ [ ] при динамическом удалении объектов-структур с помощью функции free (например, free(pt);) компилятор языка С++ автоматически добавляет в код вызов деструктора

### Подвиг 2. Объявите в программе структуру с именем (типом) thing и следующими публичными полями:

+ `id`: идентификатор (целое число, тип unsigned long);
+ `name`: название (строка, массив символов длиной 50 элементов);
+ `price`: цена (целое число, тип unsigned int);
+ `weight`: вес (вещественное число, тип double).

Объекты структуры thing допустимо создавать следующим образом:

```c++
thing th_1;
thing th_2("book");
thing th_3("mouse", 1024);
thing th_4("mouse", 1024, 0.2);
```

Если какие-либо значения не переданы, соответствующие поля должны быть равны нулю (или пустая строка). Также при создании каждого нового объекта идентификатор id должен автоматически увеличиваться на единицу и для первого созданного в программе объекта thing принимать значение 1.

В функции main прочитайте из входного потока данные, представленные в формате:

<название (одно слово)> <цена (целое число)> <вес (вещественное число)>

Например:

Клавиатура 4300 0.34

Объявите указатель ptr_th с типом thing и создайте объект, используя оператор new. Выведите в консоль цену предмета. В конце удалите объект (освободите память), используя оператор delete.

Sample Input:

Mouse 834 0.12

Sample Output:

834

```c++
#include <string.h>

#include <iostream>
#include <string>

static unsigned long global_id = 1;
enum { name_max_len = 50 };

struct thing {
    unsigned long id;
    char name[name_max_len];
    unsigned int price;
    double weight;

    thing(char* name = "", unsigned int price = 0, double weight = 0) {
        id = global_id++;
        strcpy(this->name, name);
        this->price = price;
        this->weight = weight;
    }
};

int main(void) {
    thing* ptr_th;
    char name[name_max_len];
    unsigned int price;
    double weight;
    std::cin >> name >> price >> weight;
    ptr_th = new thing(name, price, weight);

    std::cout << ptr_th->price << std::endl;

    delete ptr_th;

    // __ASSERT_TESTS__
    return 0;
}
```

```c++
#include <iostream>
#include <cstring>

#define SIZEARR (50)

struct thing {
 private:
    static unsigned long next_id;
/*  
    Статическое поле принадлежит самому типу thing, а не отдельному объекту. 
    Это позволяет использовать одно и то же значение next_id при создании любого объекта thing.  
*/

 public:
    unsigned long id;
    char name[SIZEARR];
    unsigned int price;
    double weight;
    
    // универсальный конструктор
    thing(const char* n = "", unsigned int p = 0, double w = 0.0) : id(next_id++), price(p), weight(w) {
        strncpy(name, n, SIZEARR-1);
        name[SIZEARR-1] = '\0';
    }
    
    ~thing() {} // деструктор
};

unsigned long thing::next_id = 1;

int main() {

    char name[50];
    unsigned int price;
    double weight;

    std::cin >> name >> price >> weight;
    thing * ptr_th = new thing(name, price, weight);

    std::cout << ptr_th->price << std::endl;

    delete ptr_th;
    
    __ASSERT_TESTS__ 
    return 0;
}
```

```c++
#include <iostream>
#include <string.h>
using namespace std;

struct thing {
    static unsigned long counter;
    unsigned long id;
    char name[50];
    unsigned price;
    double weight;

    thing(const char* name = "", unsigned price = 0, double weight = 0.0)
        : id (++counter), price(price), weight(weight) {
        strncpy(this->name, name, 50);
    }
};

unsigned long thing::counter;

int main(void) {
    char name[50];
    unsigned price;
    double weight;
    cin >> name >> price >> weight;

    thing* ptr_th = new thing(name, price, weight);
    cout << ptr_th->price << endl;
    
    __ASSERT_TESTS__ 

    delete ptr_th;
        
    return 0;
}
```

### Подвиг 3. Объявите в программе структуру с именем (типом) rectangle и следующими приватными полями:

`x0`, `y0`, `x1`, `y1` - целочисленные (`int`) координаты верхнего левого угла (`x0`, `y0`) прямоугольника и координаты нижнего правого угла (`x1`, `y1`) прямоугольника.

![10](/Good_good_C_C++/img/10_01.png)

Объекты структуры `rectangle` допустимо создавать следующим образом:

```c++
rectangle r_1;
rectangle r_2(1, 2, 10, 20);
```

Если координаты не указаны, то все они принимаются равными нулю. 

Дополнительно в структуре `rectangle` объявите следующие публичные методы:

+ `bool is_in_rect(int x, int y);` // проверяет попадание точки (`x`, `y`) внутрь прямоугольника; `true` - если попадает (включая границы), `false` - если не попадает
+ `void set_coords(int x0, int y0, int x1, int y1);` // задает новые координаты прямоугольника
+ `void get_coords(int& x0, int& y0, int& x1, int& y1);` // возвращает текущие координаты прямоугольника

В функции `main` объявите указатель `ptr_r` с типом `rectangle` и с помощью оператора `new` создайте объект `rectangle` с координатами `(-5, 4)`, `(8, 32)`. 

Прочитайте из входного потока два целых числа `(x, y)`, записанных через пробел, и путем вызова метода `is_in_rect` определите принадлежность точки с прочитанными координатами прямоугольнику, на который ссылается указатель `ptr_r`. Выведите в консоль строку "yes", если точка попадает (принадлежит), и "no" - в противном случае.

P. S. Не забудьте в конце освободить память для созданного объекта с помощью оператора `delete`.

Sample Input:

-4 5

Sample Output:

yes

```c++
#include <iostream>

struct rectangle {
    int x0, y0, x1, y1;

    rectangle(int x0 = 0, int y0 = 0, int x1 = 0, int y1 = 0) {
        this->x0 = x0;
        this->y0 = y0;
        this->x1 = x1;
        this->y1 = y1;
    }
    bool is_in_rect(int x, int y) { return (x >= x0 && x <= x1) && (y >= y0 && y <= y1); }
    void set_coords(int x0, int y0, int x1, int y1) {
        this->x0 = x0;
        this->y0 = y0;
        this->x1 = x1;
        this->y1 = y1;
    }
    void get_coords(int& x0, int& y0, int& x1, int& y1) {
        x0 = this->x0;
        y0 = this->y0;
        x1 = this->x1;
        y1 = this->y1;
    }
};

int main(void) {
    rectangle* ptr_r = new rectangle(-5, 4, 8, 32);

    int x, y;

    std::cin >> x >> y;

    std::cout << (ptr_r->is_in_rect(x, y) ? "yes" : "no") << std::endl;

    // __ASSERT_TESTS__
    delete ptr_r;
    return 0;
}
```

```c++
#include <iostream>
using namespace std;

struct rectangle {
private:
    int x0, y0;
    int x1, y1;

public:
    rectangle()
        : x0(0), y0(0), x1(0), y1(0) {}

    rectangle(int x0, int y0, int x1, int y1)
        : x0(x0), y0(y0), x1(x1), y1(y1) {}

    bool is_in_rect(int x, int y) {
        return x >= x0 && x <= x1 && y >= y0 && y <= y1;
    }

    void set_coords(int x0, int y0, int x1, int y1) {
        this->x0 = x0;
        this->y0 = y0;
        this->x1 = x1;
        this->y1 = y1;
    }

    void get_coords(int& x0, int& y0, int& x1, int& y1) {
        x0 = this->x0;
        y0 = this->y0;
        x1 = this->x1;
        y1 = this->y1;
    }
};

int main(void) {
    rectangle* ptr_r = new rectangle(-5, 4, 8, 32);

    int x, y;
    cin >> x >> y;

    cout << (ptr_r->is_in_rect(x, y) ? "yes" : "no") << endl;

    delete ptr_r;

    return 0;
}
```

### Подвиг 4. Предположим, что статический массив создан командой:

```c++
double *ptr_d = new double[10];
```

Выберите правильную команду для освобождения памяти из под этого массива.

+ [ ] delete ptr_d;
+ [x] delete[] ptr_d;
+ [ ] delete(ptr_d);
+ [ ] delete(*ptr_d);
+ [ ] delete[] *ptr_d;
+ [ ] delete *ptr_d;

### Подвиг 5. Объявите в функции main указатель с именем ptr_ar типа short и инициализируйте его массивом, созданным с помощью оператора new и состоящий из 15 элементов типа short. Затем, во все элементы занесите значение -1. После этого в пятый по счету элемент (счет начинается с единицы) запишите число 100. 

P. S. Освобождать память из под массива не нужно. В консоль ничего выводить не нужно.

```c++
#include <iostream>

int main(void) {
    short *ptr_ar = new short[15];

    for (size_t i = 0; i < 15; i++) {
        ptr_ar[i] = -1;
    }
    ptr_ar[4] = 100;

    // __ASSERT_TESTS__
    return 0;
}
```

### Подвиг 6. Ниже приведена программа по реализации односвязного списка, то есть, списка из объектов, ссылающихся друг на друга в соответствии со следующим рисунком:

![10](/Good_good_C_C++/img/10_02.png)

Модифицируйте приведенный текст программы реализации односвязного списка так, чтобы в него можно было максимум добавлять 10 элементов (со значениями типа `double`). При попытке добавления 11-го список не должен никак меняться, т.е. такая операция должна игнорироваться.

Названия структур и методов не менять. Также неизменными оставлять сигнатуру методов (возвращаемый тип и набор параметров).

P.S. В программе добавить только указанную модификацию, более ничего делать не нужно (в том числе, что-либо выводить на экран и объявлять функцию `main()`).

Пример использования структуры `OneLinkedList` (односвязного списка) (это в программе писать не нужно, приведено для лучшего понимания):

```c++
int main(void)
{
	OneLinkedList lst;
	lst.push_front(1);
	lst.push_back(2);
	
	Node* n = lst.getAt(0);
	double d = (n != NULL) ? n->data : 0;
	std::cout << d << std::endl;

	lst.erase(1);
	lst.insert(0, 5);
	lst.insert(0, 2);

	for (Node* node = lst.head; node != NULL; node = node->next) {
		std::cout << node->data << " ";
	}

	return 0;
}
```
# TODO

### Подвиг 7. Модифицируйте приведенный текст программы реализации односвязного списка (взято из занятия) так, чтобы в его элементах можно было хранить данные по книгам в виде следующей структуры:

```c++
typedef struct {
	char author[50];	// автор
	char title[100];	// заголовок
	short year;		// год издания
} BOOK;
```

В функции `main()` создайте объект этого односвязного списка с именем `lib`, используя команду:

```c++
OneLinkedList lib;
```
и добавьте последовательно в него следующие книги:

```
Пушкин А.С.; Пиковая дама; 2007
Тургенев И.С.; Муму; 2011
Толстой А.Н.; Аэлита; 1995
Балакирев С.М.; Моя жизнь, мои достижения; 2045
```

То есть, в 1-м элементе списка должна храниться первая запись (книга), во 2-м - вторая запись и т.д.

Названия классов и методов не менять. Также неизменными оставлять сигнатуру методов (возвращаемый тип и набор параметров), кроме параметра `data`.

P. S. На экран выводить ничего не нужно, только реализовать односвязный список и заполнить его указанным содержимым.

```c++
#include <iostream>

struct Node {
public:
	double data;
	Node* next;

public:
	Node(double data) {
		this->data = data;
		this->next = NULL;
	}
};

struct OneLinkedList {
public:
	Node* head, * tail;

public:
	OneLinkedList() {
		this->head = this->tail = NULL;
	}

	~OneLinkedList() {
		while (head != NULL) pop_front();
	}

	void pop_front() {
		if (head == NULL) return;
		if (head == tail) {
			delete tail;
			head = tail = NULL;
			return;
		}

		Node* node = head;
		head = node->next;
		delete node;
	}

	void push_back(double data) {
		Node* node = new Node(data);
		if (head == NULL) head = node;
		if (tail != NULL) tail->next = node;
		tail = node;
	}

	void push_front(double data) {
		Node* node = new Node(data);
		node->next = head;
		head = node;
		if (tail == NULL) tail = node;
	}

	void pop_back() {
		if (tail == NULL) return;
		if (head == tail) {
			delete tail;
			head = tail = NULL;
			return;
		}

		Node* node = head;
		for (; node->next != tail; node = node->next);

		node->next = NULL;
		delete tail;
		tail = node;
	}

	Node* getAt(int k) {
		if (k < 0) return NULL;

		Node* node = head;
		int n = 0;
		while (node && n != k && node->next) {
			node = node->next;
			n++;
		}

		return (n == k) ? node : NULL;
	}

	void insert(int k, double data) {
		Node* left = getAt(k);
		if (left == NULL) return;

		Node* right = left->next;
		Node* node = new Node(data);

		left->next = node;
		node->next = right;
		if (right == NULL) tail = node;
	}

	void erase(int k) {
		if (k < 0) return;
		if (k == 0) {
			pop_front();
			return;
		}

		Node* left = getAt(k - 1);
		Node* node = left->next;
		if (node == NULL) return;

		Node* right = node->next;
		left->next = right;
		if (node == tail) tail = left;
		delete node;
	}
};

int main(void)
{
    using namespace std;
    // здесь пишите программу

    __assertion_tests(lib);    // эту строчку не убирать (должна стоять перед return 0)
    return 0;
}
```

# TODO

### Подвиг 8 (на повторение). Выберите все верные утверждения, касающиеся захвата переменных лямбда-выражениями.

+ [ ] при захвате массива int d[10]; [d] ([параметры]) mutable {[операторы]} изменение значений его элементов в лямбда-функции приведет также к изменению внешнего массива d
+ [x] выражение вида [=]([параметры]) {[операторы]} позволяет в теле лямбда-функции только читать значения из копий любых локальных переменных
+ [ ] выполнение выражение вида [a, b] ([параметры]) mutable { a++; --b; } приведет к изменению переменных a и b и это изменение затронет внешние локальные переменные a и b
+ [x] выполнение выражение вида [a, b] ([параметры]) mutable { a++; --b; } приведет к изменению переменных a и b только внутри лямбда-функции и не затронет внешние локальные переменные a и b
+ [x] при захвате массива int d[10]; [d] ([параметры]) mutable {[операторы]} изменение значений его элементов в лямбда-функции не приведет к изменению внешнего массива d
+ [x] выполнение выражение вида [var_i]([параметры]) {var_i += 1;} приведет к ошибке, т.к. переменная var_i является константной

### Подвиг 9 (на повторение). Пусть в программе имеются следующие локальные переменные:

```c++
char msg[] = "hello";
int count = 0;
int& lnk = count;
char* ptr = msg;
```
Выберите все верные (работающие) варианты объявления лямбда-выражений.

+ [x] auto lmd_2 = [=] () { std::cout << msg; };
+ [x] auto lmd_4 = [&lnk] (int step) { lnk += step; };
+ [x] auto lmd_3 = [&count] (int step) { count += step; };
+ [x] auto lmd_1 = [msg, count, lnk, ptr] () { return count + 1; };
+ [x] auto lmd_5 = [ptr] (int step) { *ptr += step; };
+ [ ] auto lmd_7 = [lnk] (int step) { lnk += step; };
+ [ ] auto lmd_6 = [*ptr] (int step) { *ptr += step; };

### Подвиг 10 (на повторение). Выберите все верные утверждения, касающиеся следующего фрагмента программы:

```c++
int module_id = -1;

namespace params {
int global_result = 0;
}

namespace triangle {
double square(int a, int b, int c)
{
    double p = (a+b+c) / 2.0;
    return sqrt(p*(p-a)*(p-b)*(p-c));
}
}

namespace params {
typedef union {
    int res_int;
    double res_dbl;
} RESULT;
}
```

+ [x] в пространстве params описана переменная global_result и тип RESULT
+ [ ] в пространстве имен нельзя определять типы данных, поэтому последнее определение params приведет к ошибке
+ [x] обращение к переменной module_id в теле функций можно записывать в виде module_id или в виде ::module_id
+ [x] в пространстве triangle присутствует функция с именеме square
+ [x] обращение к типу RESULT следует записывать в виде params::RESULT
+ [x] обращение к функции square следует прописывать в виде triangle::square
+ [x] символ :: называется символом раскрытия области видимости
+ [ ] в пространстве params будет содержаться только тип RESULT

# 10.5 Особенности работы new и delete

## Особенности работы new

На предыдущем занятии мы с вами познакомились с новыми операторами:

+ `new` / `new []` – для выделения памяти с автоматическим вызовом конструктора объекта;
+ `delete` / `delete []` – для освобождения памяти с автоматическим вызовом деструктора объекта.

И увидели, что их можно применять для самых разных типов языка С++. Но, как всегда, здесь есть свои нюансы. Например, объявим в программе очень простую структуру:

```c++
#include <iostream>
 
using std::cout;
using std::endl;
 
struct volume {
    int width, height, depth;
};
```

А, затем, в функции `main` создадим объекты этой структуры следующим образом:

```c++
int main(void) {
    volume* v_1 = new volume;
    volume* v_2 {new volume};
    volume* v_3 = new volume();
    volume* v_4 {new volume{1, 2, 3}};
 
    cout << v_1->width << " " << v_1->height << " " << v_1->depth << endl;
    cout << v_3->width << " " << v_3->height << " " << v_3->depth << endl;
    cout << v_4->width << " " << v_4->height << " " << v_4->depth << endl;
 
    delete v_1;
    delete v_2;
    delete v_3;
    delete v_4;
 
    return 0;
}
```

После запуска этой программы в консоли увидим строчки:

```
17635152 17629376 1601069417
0 0 0
1 2 3
```

Смотрите, как это сработало.

Во-первых, объект структуры `volume` был успешно создан в памяти с помощью оператора `new`. Но мы знаем, что `new` предполагает автоматический вызов конструктора, которого в структуре `volume` прописано не было.<br> 
Откуда же он взялся?<br> 
В действительности, при объявлении любой структуры в С++ компилятор автоматически добавляет несколько конструкторов, в том числе и тот, который необходим для создания нового объекта. Параметров у такого конструктора по умолчанию нет. И то же самое с деструктором. Если он явно не описан, то добавляется деструктор по умолчанию.<br>
Но, обратите внимание, если мы явно пропишем хоть один конструктор внутри структуры, то компилятор не станет добавлять ни одного по умолчанию. Подробнее об этом, конечно, следует говорить в курсе по ООП языка С++.

Вернемся к нашей программе создания объектов структуры `volume`. Мы видим, если после оператора `new` прописать тип данных `volume` без круглых скобок, то никакой инициализации полей не происходит. Переменные `width`, `height`, `depth` принимают произвольные (неопределенные) значения. 

Если же круглые скобки указаны, то все поля структуры инициализируются нулями. Наконец, допустимо создавать объект (`v_4`) и прописывать инициализатор для полей этой структуры:

```c++
volume* v_4 {new volume {1, 2, 3}};
```

Однако если мы в структуре `volume` пропишем хотя бы один свой конструктор, например:

```c++
struct volume {
    volume() { cout << "constructor" << endl; }
 
    int width, height, depth;
};
```

то компилятор не станет автоматически добавлять какие-либо другие. В частности, это приведет к тому, что команда:

```c++
volume* v_4 {new volume {1, 2, 3}};
```

не скомпилируется, т.к. теперь в структуре `volume` нет подходящего конструктора для такой операции.

Сейчас мы не станем углубляться в тему конструкторов, их видов, способов определения и так далее. Главное, что сейчас важно запомнить – это то, что любой тип данных языка С++ подразумевает использование этих специальных методов: конструкторов и деструктора. 

В частности, это означает, что с любым примитивным типом данных мы можем выполнять все те же самые действия, что и со структурами. Например:

```c++
int main(void) {
    int* p1 = new int;
    double* p2 {new double()};
    short* p3 {new short{-5}};
    unsigned* p4 {new unsigned(11)};
 
    cout << *p1 << " " << *p2 << " " << *p3 << " " << *p4 << endl;
 
    delete p1;
    delete p2;
    delete p3;
    delete p4;
 
    return 0;
}
```

Аналогичные операции выделения памяти можно производить и с массивами:

```c++
int main(void) {
    int* ar_1 {new int[7] {}}; // int* ar_1 = new new int[7] {};
    int* ar_2 {new int[4] ()}; // int* ar_2 = new new int[7] ();
    short* ar_3 {new short[11] { 1, 2 }};  // 1, 2, 0, 0
 
    delete ar_1;
    delete ar_2;
    delete ar_3;
 
    return 0;
}
```

## Особенности работы оператора delete

Я думаю, что в целом порядок работы оператора `new` вам понятен. Осталось сказать пару слов об операторе `delete`. 

Как мы с вами уже знаем, он освобождает ранее выделенную память, и автоматически прописывает вызов деструктора объекта. 

Это так же может быть деструктор по умолчанию или деструктор, прописанный явным образом. Единственно на что следует обращать пристальное внимание – это однократное освобождение занятой памяти. Например, если мы дважды освободим память для одной и той же области памяти:

```c++
delete p1;
delete p1;
```

то программа может завершиться аварийно из-за нарушения целостности динамической памяти.

Чтобы этого избежать, хорошей практикой считается присвоение значения нулевого указателя `nullptr`, когда какой-либо указатель не ссылается на выделенную область. Например:

```c++
delete p1;
p1 = nullptr;
delete p1;
```

В этом случае повторный вызов оператора `delete` не приведет к каким-либо последствиям, т.к. для нулевого указателя он не выполняет никаких действий.

На следующих занятиях мы с вами увидим приемы, которые позволяют минимизировать проблемы, связанные с динамическим выделением памяти.

Видео по теме [#21. Особенности работы new и delete](https://www.youtube.com/watch?v=Hxpke1vi0pM&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные (работающие) команды, которые создают объекты структуры point на языке С++.

```c++
struct point {
    int x, y;
};
```

+ [x] point* p6 = new point();
+ [x] struct point* p2 (new point);
+ [x] point* p5 = new point {};
+ [ ] point* p3 {new point(1, 2)};
+ [x] point* p4 {new point {1, 2}};
+ [x] point* p1 = new point;

### Подвиг 2. Выберите все верные утверждения, касающиеся процесса создания объектов структур в С++ с помощью операторов new и delete.

+ [ ] непосредственно после удаления объекта структуры с помощью оператора delete компилятор автоматически добавляет вызов деструктора этой структуры
+ [x] непосредственно после создания объекта структуры с помощью оператора new компилятор автоматически добавляет вызов конструктора этой структуры
+ [x] непосредственно перед удалением объекта структуры с помощью оператора delete компилятор автоматически добавляет вызов деструктора этой структуры
+ [ ] непосредственно перед созданием объекта структуры с помощью оператора new компилятор автоматически добавляет вызов конструктора этой структуры

### Подвиг 3. Выберите все верные утверждения, касающиеся конструкторов и деструкторов структур в С++.

+ [x] если в структуре прописан хотя бы один конструктор, то ни один конструктор по умолчанию добавлен не будет
+ [x] если в структуре явно не объявлено никакого деструктора, то используются деструктор по умолчанию
+ [x] если в структуре объявлен деструктор, то именно он используется при удалении объекта
+ [x] если в структуре явно не объявлено никаких конструкторов, то используются конструкторы по умолчанию
+ [ ] если в структуре явно не объявлено никаких конструкторов, то структура не имеет никаких конструкторов

### Подвиг 4. Продолжите программу. Объявите указатель с именем vc на массив типа complex длиной 7 элементов. Инициализируйте значения полей re и im этих элементов нулями. В конце программы не забудьте освободить память из под этого массива.

P. S. В консоль ничего выводить не нужно.

```c++
#include <iostream>

struct complex {
    double re, im;
};

int main(void) {
    complex* vc{new complex[7]{}};

    for (size_t i = 0; i < 7; i++) {
        printf("%.1lf %.1lf ", vc[i].im, vc[i].re);
    }

    // __ASSERT_TESTS__
    delete[] vc;
    return 0;
}
```

### Подвиг 5. Продолжите программу. Объявите в структуре box два конструктора для возможности создания объектов следующими командами:

```c++
box b1;
box b2(5, 3, 10);
box *p_b2 = new box();
box *p_b3 = new box(88, 32, 12);
```

Если при создании объекта аргументы не передаются, то должен срабатывать конструктор без параметров и выводить в консоль строку:

```
"Empty box"
```

Если же передается три аргумента, то должен срабатывать конструктор с тремя параметрами, значения которых сохраняются в полях a, b, c и в консоль выводится строка:

```
"Box: <значение a>, <значение b>, <значение c>"
```

Например, при a = 6, b = 1, c = 8, должна формироваться строка:

```
"Box: 6, 1, 8"
```

В конце и начале строк не должно быть пробелов и выполняться перевод на следующую строку.

В функции `main` объявите указатель с именем `ar_box` типа `box` и с помощью оператора `new` сформируйте массив длиной `5` из элементов типа `box` со следующей начальной инициализацией полей `a`, `b`, `c`:

```
1, 2, 3
6, 2, 1
0, 0, 0
11, 13, 19
23, 5, 7
```

P. S. Не забудьте в конце освободить память из под массива.

```c++
#include <iostream>

struct box {
    unsigned short a, b, c;
    box() {
        a = b = c = 0;
        puts("Empty box");
    }
    box(int a, int b, int c) {
        this->a = a;
        this->b = b;
        this->c = c;
        printf("Box: %d, %d, %d\n", a, b, c);
    }
};

int main(void) {
    box* ar_box(new box[5]{{1, 2, 3}, {6, 2, 1}, {0, 0, 0}, {11, 13, 19}, {23, 5, 7}});

    // __ASSERT_TESTS__

    delete[] ar_box;

    return 0;
}
```

### Подвиг 6. Продолжите программу. В функции main объявите указатель с именем ar_long типа long и инициализируйте его динамическим массивом (создается с помощью оператора new) длиной 1000 элементов типа long. Все элементы этого массива следует инициализировать нулями. В пятый по счету элемент (счет начинается с единицы) занесите значение -7.

P. S. В консоль ничего выводить не нужно.

```c++
#include <iostream>

int main(void) {
    long* ar_long{new long[1000]{}};

    ar_long[4] = -7;

    // __ASSERT_TESTS__

    delete[] ar_long;

    return 0;
}
```

### Подвиг 7. Напишите программу, в которой объявляется структура с именем (типом) vector, содержащая следующие поля:
+ x, y, z - координаты радиус-вектора; тип `int`.

Объявите в этой структуре деструктор, который бы выводил в консоль следующую строку:

```
"Deleted vector: <значение x>, <значение y>, <значение z>"
```

Перед и после строки не должно быть никаких пробелов, а в конце стоять символ перевода на новую строку. Например, при x = 6, y = -3, z = 2 должна выводиться строка:

```
"Deleted vector: 6, -3, 2"
```

В функции `main` прочитайте из входного потока три целых числа, записанных через пробел. С помощью оператора new создайте объект структуры `vector`, занесите в поля x, y, z этого объекта прочитанные значения (по порядку: первое число в x, второе - в y, третье - в z). Затем, освободите память из под этого объекта.


```c++
#include <iostream>

struct vector {
    int x, y, z;

    ~vector() { printf("Deleted vector: %d, %d, %d\n", x, y, z); }
};

int main(void) {
    int x, y, z;
    std::cin >> x >> y >> z;
    vector *volume{new vector{x, y, z}};

    delete volume;

    return 0;
}
```

### Подвиг 8 (на повторение). Учитывая приведенный фрагмент программы, выберите все верные варианты определения алиасов (псевдонимов) с помощью оператора using языка С++.

```c++
int global_var = 1;

namespace test {
typedef union {
    char ch;
    int vi;
    double vd;
} VAR;

int odd(int x) {
    return x % 2 != 0;
}
}
```

+ [x] using UINT = unsigned int;
+ [x] using PTR_STR = char*;
+ [x] using DATA = test::VAR;
+ [ ] using TEST = test;
+ [ ] using ptr_func = test::odd;
+ [ ] using GVAR = global_var;
+ [x] using VOLUME = struct {int width, height, depth;};
+ [x] using AR_INT = int[10];

# 10.6 Smart-указатели типа unique_ptr

## Smart-указатели

Как я уже неоднократно отмечал, все базовые операторы и функции выделения/освобождения памяти, строго говоря, являются небезопасными:

`new`, `delete`, `malloc()`, `calloc()`, `realloc()`, `free()`

Наиболее часто, в практике программирования, можно столкнуться со следующими ситуациями:
+ память была выделена, но не освобождена (утечка памяти);
+ память была освобождена, но работа с ней продолжается так, словно она остается выделенной;
+ память не была выделена, но в нее выполняется запись данных;
+ попытка несколько раз освободить одну и ту же область памяти.

К сожалению, даже при строгом контроле порядка вызовов операторов или функций выделения и освобождения памяти, вероятность возникновения приведенных ситуаций остается довольно высокой. 

Спрашивается, как минимизировать подобные ошибки, а еще лучше совсем их избежать? 

Для этого в языках высокого уровня, таких как Java, Python, C#, предусмотрен механизм «сборки мусора», который отслеживает неиспользуемую память и автоматически ее освобождает. 

Но в языке C++ нет такого сборщика мусора, т.к. это низкоуровневый язык программирования и сами сборщики пишутся зачастую на нем. 

Однако некоторые решения все же есть. 

Это использование, так называемых, умных (smart) указателей. 

Они на примитивном уровне подобны сборщику мусора и сами контролируют процесс освобождения памяти. То есть, вручную освобождать память уже не требуется, она освободится сама (автоматически), когда станет ненужной.

На этом и следующем занятиях мы как раз познакомимся с двумя видами smart-указателей:
+ `unique_ptr` – «уникальный» (в единственном числе) `smart-указатель`, ссылающийся на выделенную область памяти (или принимающий значение `nullptr`);
+ `shared_ptr` – `smart-указатель`, допускающий множественные адресации на одну и ту же выделенную область памяти.

Начнем с первого типа указателя `unique_ptr`.

Для использования в программе на языке C++ «умных» указателей необходимо вначале подключить заголовок:

```c++
#include <memory>
```

После этого в пространстве имен `std` появится класс `unique_ptr`. Теперь мы можем объявлять `smart-указатели` этого типа следующим образом:

```c++
std::unique_ptr<int> ptr;
std::unique_ptr<int> ptr_2 {};
std::unique_ptr<int> ptr_3 {nullptr};
```

Здесь сразу бросаются в глаза угловые скобки после класса `unique_ptr`. В них мы должны прописать тот тип данных, с которым будет работать указатель. 

В данном случае – это примитивный тип `int`. 

Вообще, забегая вперед, отмечу, что угловые скобки, стоящие после имени класса, – это пример использования шаблонного класса. 

То есть, класс `unique_ptr` определен так, чтобы его можно было использовать с произвольными типами данных. 

И благодаря этому достигается универсальность объявления `smart-указателей` типа `unique_ptr`. 

На данный момент достаточно просто запомнить, что после имени класса нужно прописать угловые скобки с типом данных, с которым в дальнейшем будет работать `smart-указатель`.

Итак, во всех трех приведенных вариантах объявления указателей, их значения равны `nullptr`, то есть, не ссылаются ни на какую выделенную область памяти. Поэтому, если сейчас попытаться вывести значение данных, на которые ссылается указатель `ptr`:

```c++
std::cout << *ptr << std::endl;
```

то программа завершится аварийно. 

Нельзя в языке С++ читать данные через указатель со значением `nullptr`. 

Правильнее вначале было бы проверить, что значение указателя не равно `nullptr`, то есть, он ссылается на выделенную область памяти. Это можно сделать следующим образом:

```c++
if(ptr)
    std::cout << *ptr << std::endl;
```

Обратите внимание, как записана проверка: `nullptr` – это эквивалент `false`, а не `nullptr` – это эквивалент `true`. 

Также обратите внимание, что чтение данных из памяти, на которую ссылается `smart-указатель`, синтаксически осуществляется так же, как и для обычного указателя.

Давайте теперь пропишем обратную проверку и если указатель `ptr` равен `nullptr`, то выделим для него область памяти. Начиная со стандарта C++14, делается это следующим образом:

```c++
    if(!ptr)
        ptr = std::make_unique<int>(10);
 
    std::cout << *ptr << std::endl;
```

То есть, вызывается специальная шаблонная функция `make_unique`, в угловых скобках прописывается тип данных, под который выделяется память, а в качестве аргумента передается начальное значение `10`. Теперь программа отработает без каких-либо проблем и в консоль будет выведено число `10`.

Используя «умный» указатель, можно изменить значение данных в области памяти, на которую он ссылается:

```c++
*ptr = -7;
```

То есть, работа со `smart-указателями` осуществляется так же, как и с обычными указателями языка C++.

А что будет, если мы попробуем еще раз для этого же указателя выделить память с помощью функции `make_unique`:

```c++
ptr = std::make_unique<int>(10);
ptr = std::make_unique<int>(11);
```

Возникнет ли здесь «утечка памяти»? В действительности, нет, не возникнет. В классе `unique_ptr` операция присваивания переопределена и в момент присвоения нового адреса, прежняя область автоматически освобождается. Поэтому указатель `ptr` будет вести на новую область со значением `11`.

Вообще, в практике программирования на C++, «умные» указатели довольно часто инициализируются сразу в момент объявления. Например:

```c++
std::unique_ptr<int> ptr {std::make_unique<int>()};
```

Причем, до стандарта C++14 эта инициализация прописывалась с помощью стандартного оператора new следующим образом:

```c++
std::unique_ptr<int> ptr_2 {new int {-6}};
```

Но теперь так делать не рекомендуется, хотя синтаксически и допустимо. Как минимум, по двум причинам:

1. Во-первых, области памяти, выделяемые под сам указатель `ptr_2` и объект данных (`int`), могут располагаться независимо друг от друга. Тогда как по стандарту функции `make_unique()` рекомендуется располагать область данных `smart-указателя` и область данных, на которые он ссылается, непосредственно друг за другом. Это несколько ускоряет работу `smart-указателя`.

2. Во-вторых, при создании `smart-указателя` в аргументах какой-либо функции, оператор `new` и создание самого указателя могут происходить в разные моменты времени. В некоторых случаях такое рассогласование может приводить к непредвиденным ошибкам.

Итак, запомним, что выделение памяти для `smart-указателей` типа `unique_ptr` следует выполнять с помощью функции `make_unique()`.

Далее, если у нас имеется два указателя типа `unique_ptr`, то мы не можем присваивать один другому. Например, команда:

```
ptr_3 = ptr_2;
```

приведет к ошибке на этапе компиляции. Это связано с тем, что указатель типа `unique_ptr` может ссылаться на ту или иную область памяти только в единственном числе. И никакой другой `smart-указатель` инициализировать или присвоить на эту же область уже не получится. В этом смысл «уникальности» `smart-указателей` этого типа. Хотя, «обмануть» компилятор все же возможно, если использовать такую конструкцию:

```c++
int* p = new int(5);
std::unique_ptr<int> ptr_2{ p };
std::unique_ptr<int> ptr_3{ p };
```

Программа скомпилируется, но может завершиться аварийно, так как оба `smart-указателя` ведут на одну и ту же область и дважды освобождают ее, что, в общем случае, недопустимо. Поэтому `smart-указатели` все же не панацея от всех возможных программных вариаций и программист должен грамотно и ответственно подходить к их использованию.

`Smart-указатели` типа `unique_ptr` имеют ряд полезных методов:
+ get() – возвращает «сырой» указатель на выделенную область памяти;
+ release() – возвращает указатель на выделенную область памяти и «отвязывает» `smart-указатель` от нее;
+ reset() – меняет значение указателя на другую область памяти, либо на значение `nullptr`, если ничего не указано;
+ swap() – выполняет обмен адресами `smart-указателей` между собой.

Давайте посмотрим на их работу. Первый метод `get()` достаточно прост. Он возвращает обычный (сырой) указатель, если в программе он требуется по каким-либо причинам:

```c++
int* p = ptr.get();
std::cout << p << " " << *p << std::endl;
```

Следующий метод `release` также возвращает сырой указатель на выделенную область, но сам `smart-указатель` «отвязывает» от этой области:

```c++
int* p = ptr.release();
std::cout << ptr.get() << " " << p << " " << *p << std::endl;
```

Если нам нужно изменить ресурс, на который ссылается «умный» указатель, то это делается с помощью метода `reset`:

```c++
ptr.reset(); // меняем на значение nullptr
```

или
```c++
ptr.reset(new int {143}); // меняем на новую область памяти
std::cout << ptr.get() << " " << *ptr << std::endl;
```

Обратите внимание, что здесь допустимо использовать оператор `new`, но не функцию `make_unique()` в чистом виде.

Наконец, последний метод `swap()` просто меняет адреса двух `smart-указателей`:

```c++
ptr.swap(ptr_2);
std::cout << *ptr << " " << *ptr_2 << std::endl;
```

## Указатели типа unique_ptr на массивы

В заключение этого занятия отмечу, что указатели `unique_ptr` можно определять и на массивы. Например:

```c++
#include <iostream>
#include <memory>
 
using std::cout;
using std::endl;
 
int main(void) {
    unsigned total {10};
    std::unique_ptr<int[]> ar {std::make_unique<int[]>(total)};
    auto ar_2 {std::make_unique<int[]>(7)};
    std::unique_ptr<int[]> ar_3 {nullptr};
 
    return 0;
}
```

Затем, через `ar`, `ar_2`, `ar_3` мы можем обращаться к элементам соответствующих массивов привычным нам образом:

```c++
    for(int i = 0; i < total; ++i)
        cout << ar[i] << " ";
```

Увидим все нули. Это говорит о том, что при создании массивов с помощью функции `make_unique()` значения всех элементов автоматически инициализируются нулями.

Соответственно, можем записать какие-либо другие значения в массив следующим образом:

```c++
    for(int i = 0; i < total; ++i)
        ar[i] = i*i;
```

То есть, работа выполняется абсолютно так же, как и с обычными массивами языка С++.

Видео по теме [#22. Smart-указатели типа unique_ptr](https://www.youtube.com/watch?v=AAM2S91jU4w&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, касающиеся проблем использования базовых функций и операторов выделения/освобождения памяти на языке C/C++.

+ [x] память была выделена, но не освобождена (утечка памяти)
+ [ ] на одну и ту же область памяти ссылается несколько указателей
+ [x] память не была выделена, но в нее выполняется запись данных
+ [x] память была освобождена, но работа с ней продолжается так, словно она остается выделенной
+ [x] попытка несколько раз освободить одну и ту же область памяти

### Подвиг 2. Выберите все верные утверждения, касающиеся smart-указателей языка С++.

+ [ ] класс shared_ptr определяет smart-указатель, который в единственном числе может ссылаться на определенную, выделенную область памяти
+ [ ] класс unique_ptr определяет smart-указатель, который во множественном числе может ссылаться на одну и ту же выделенную область памяти
+ [x] класс shared_ptr определяет smart-указатель, который во множественном числе может ссылаться на одну и ту же выделенную область памяти
+ [x] для использования smart-указателей в программе необходимо подключить заголовок memory
+ [x] как только указатель unique_ptr перестает существовать, область памяти на которую он ссылается, автоматически освобождается
+ [x] класс unique_ptr определяет smart-указатель, который в единственном числе может ссылаться на определенную, выделенную область памяти

### Подвиг 3. Выберите все верные утверждения, касающиеся следующей программы:

```c
#include <iostream>
#include <memory>

struct point {
    int x, y;
};

int main(void) {
    std::unique_ptr<point> ptr_1;
    std::unique_ptr<point> ptr_2 {std::make_unique<point>()};
    std::unique_ptr<point> ptr_3 {new point {1, 2}};

    ptr_2 = ptr_3;
    ptr_3 = std::make_unique<point>();

    return 0;
}
```

+ [x] команда ptr_2 = ptr_3; приведет к ошибке, т.к. один указатель типа unique_ptr не может быть присвоен другому такому же указателю
+ [ ] при выполнении команды ptr_3 = std::make_unique<point>(); произойдет "утечка" памяти
+ [x] указатель ptr_2 ссылается на объект типа point, созданный с помощью функции make_unique
+ [x] указатель ptr_3 ссылается на объект типа point, созданный с помощью оператора new
+ [x] при выполнении команды ptr_3 = std::make_unique<point>(); прежняя область памяти автоматически освобождается
+ [x] для указателей unique_ptr создание объектов рекомендуется выполнять с помощью функции make_unique
+ [x] указатель ptr_1 ссылается на тип данных point и принимает значение nullptr

### Подвиг 4. Продолжите программу. В функции main объявите smart-указатель типа unique_ptr с именем p_int, который работает с данными типа int. Выделите область памяти для типа int и присвойте ее адрес указателю p_int. Занесите прочитанное из входного потока значение переменной x в выделенную область памяти с помощью указателя p_int. Выведите в консоль значение, на которое ссылается указатель p_int.

Sample Input:

123

Sample Output:

123

```c++
#include <iostream>
#include <memory>

int main(void) {
    int x;
    std::cin >> x;

    std::unique_ptr<int> p_int{std::make_unique<int>()};

    *p_int = x;

    std::cout << *p_int << std::endl;

    // __ASSERT_TESTS__
    return 0;
}
```

### Подвиг 5. Продолжите программу. В функции main объявите smart-указатель unique_ptr с именем p_th, который должен работать с типом данных thing. Создайте объект thing и его адрес присвойте указателю p_th. Через указатель p_th занесите в объект структуры следующие данные:

1 (в uid); 10 (width); 43 (height); 108 (depth)

P. S. В консоль ничего выводить не нужно.

```c++
#include <iostream>
#include <memory>

struct thing {
    unsigned long uid;
    unsigned width, height, depth;
};

int main(void)
{
    std::unique_ptr<thing> p_th;
    p_th = std::make_unique<thing>();

    p_th->uid = 1;
    p_th->width = 10;
    p_th->height = 43;
    p_th->depth = 108;

    // __ASSERT_TESTS__
    return 0;
}
```

### Подвиг 6. Продолжите программу. В структуре object объявите следующие публичные методы:
+ `object(short d)` - конструктор для инициализации поля `data = d` и указателя `next = nullptr`;
+ `object* get_next()` - геттер, возвращающий значение указателя `next`;
+ `short get_data()` - геттер, возвращающий значение поля `data`;
+ `void set_next(object* ptr)` - сеттер, записывающий в указатель `next` значение адреса указателя `ptr`;
+ `void set_data(short d)` - сеттер, записывающий в поле `data` значение `d`.

В функции `main` объявите два `smart-указателя` `unique_ptr` с именами `top` и `ptr` (объявление можно сделать в одну строчку). Затем, сформируйте два объекта типа `object` (с помощью функции `make_unique`) так, чтобы указатель `ptr` ссылался на первый объект, а указатель `top` - на второй. Свяжите через внутренний указатель `next` эти объекты по цепочке:

`top -> ptr`

То есть, второй объект (`top`) должен ссылаться на первый (`ptr`) с помощью внутреннего указателя `next`. Указатель `next` первого объекта (`ptr`) должен принимать значение `nullptr`.

В первый объект (`ptr`) в поле `data` занесите значение `1`, а во второй (`top`) - значение `2`.

P. S. В консоль ничего выводить не нужно.

```c++
#include <iostream>
#include <memory>

struct object {
   private:
    short data;
    object* next;

   public:
    object(short d) {
        this->data = d;
        next = nullptr;
    }
    object* get_next() { return this->next; }
    short get_data() { return this->data; }
    void set_next(object* ptr) { this->next = ptr; }
    void set_data(short d) { this->data = d; }
};

int main(void) {
    std::unique_ptr<object> top;
    std::unique_ptr<object> ptr;

    ptr = std::make_unique<object>(1);
    top = std::make_unique<object>(2);
    top->set_next(ptr.get());

    // __ASSERT_TESTS__
    return 0;
}
```

### Подвиг 7* (развитие подвига 6). Продолжите программу. Скопируйте из предыдущего подвига структуру object со всеми объявленными публичными методами:

+ object(short d) - конструктор для инициализации поля data = d и указателя next = nullptr;
+ object* get_next() - геттер, возвращающий значение указателя next;
+ short get_data() - геттер, возвращающий значение поля data;
+ void set_next(object* ptr) - сеттер, записывающий в указатель next значение адреса указателя ptr;
+ void set_data(short d) - сеттер, записывающий в поле data значение d.

Допишите реализацию функции `push`, которая бы добавляла новый объект структуры `object` на вершину стека, формируя следующую цепочку:

![10](/Good_good_C_C++/img/10_03.png)

Указатель `top` после добавления нового объекта должен ссылаться на самый верхний объект (добавленный). Значение поля `data` нового объекта должно быть равно переданному значению через параметр `data` функции `push`. Самый последний (нижний) объект стека должен иметь значение указателя next равным `nullptr`.

В функции `main` выведите в одну строчку через пробел значения поля `data` объектов стека по порядку, начиная с самого верхнего.

# TODO

### Подвиг 8 (на повторение). Выберите все верные утверждения, касающиеся следующей программы:

```c++
#include <iostream>
#include <fstream>

using std::ios;

int main() {
    short marks[] = {3, 3, 4, 3, 2, 2};

    std::ofstream ofs("my_data.dat", ios::out | ios::binary);

    if(!ofs) {
        std::cout << "Невозможно открыть файл";
        return 1;
    }

    ofs << "hello" << std::endl;
    ofs.write((char *)marks, sizeof(marks) / sizeof(*marks));

    ofs.close();
    return 0;
}
```

+ [x] команда `ofs << "hello"` записывает строку `"hello"` в файл `my_data.dat`
+ [x] приведение типов `(char *)marks` необходимо, т.к. первый параметр метода `write` ожидает указатель типа `const char*`
+ [ ] команда `ofs << "hello"` приведет к ошибке, т.к. файл открыт в бинарном режиме
+ [x] если после записи не закрыть файловый поток, то данные в файл могут полностью не записаться (произойдет потеря данных)
+ [x] работа с файлом `my_data.data` выполняется в бинарном режиме
+ [x] метод (функция) `write` побайтно записывает массив `marks` в файл `my_data.dat`

# 10.7 Smart-указатели типа shared_ptr

На предыдущем занятии мы с вами подробно разобрали `smart-указатели` типа `unique_ptr`, которые могут только в единственном числе ссылаться на выделенную область памяти и автоматически ее освобождать, значительно уменьшая риск утечки памяти. 

Однако в практике программирования чаще используются указатели вида `shared_ptr`, которые также автоматически освобождают неиспользуемую память, но в отличие от `unique_ptr` могут ссылаться на нее во множественном числе:

![10](/Good_good_C_C++/img/10_04.png)

Указатели типа `shared_ptr` объявляются в программе по аналогии с указателями `unique_ptr`. Вначале также нужно подключить заголовок:

```c++
#include <memory>
```

После чего в пространстве имен `std` появится класс `shared_ptr`:

```c++
std::shared_ptr<int> ptr;
std::shared_ptr<int> ptr_2 {};
std::shared_ptr<int> ptr_3 {nullptr};
std::shared_ptr<int> ptr_4 {ptr};
```

Во всех случаях объявляются указатели со значением `nullptr`. Причем, последний указатель `ptr_4` инициализирован адресом указателя `ptr`. Как мы помним, с типом `unique_ptr` такая конструкция приводила к ошибке на этапе компиляции. Здесь же никаких ошибок нет, т.к. `shared_ptr` предполагает множество разных `smart-указателей` на одну и ту же область памяти.

Если нам нужно сразу в инициализаторе указателя типа `shared_ptr` выделить некоторую область памяти, то это следует делать с помощью функции `make_shared()`:

```c++
std::shared_ptr<int> ptr {std::make_shared<int>(3)};
```

В результате `ptr` будет ссылаться на область памяти для хранения целочисленного значения `3` типа `int`.

Пользоваться указателем `ptr` можно абсолютно так же, как и обычным указателем на тип `int`. Например:

```c++
ptr_2 = ptr; // присвоение адреса указателя ptr указателю ptr_2
*ptr = 10;  // запись числа 10 по адресу указателя ptr
cout << ptr_2 << *ptr_2 << endl;  // чтение и вывод в консоль значения по указателю ptr_2
```

Обратите внимание, что операция взятия адреса указателя `shared_ptr` делается просто по его имени (без вызова метода `get`).

А вот выполнять операции адресной арифметики с такими указателями не получится. При выполнении следующих команд получим ошибки на этапе компиляции:

```c++
ptr_3 += 10;
auto res = ptr_3 - ptr_4;
```

Это их отличает от обычных (классических) указателей языка C/C++.

## Контроль памяти указателей типа shared_ptr

Давайте теперь детальнее посмотрим, как указатели типа `shared_ptr` осуществляют контроль за памятью. Предположим, указатель `ptr` инициализируется на некоторую область памяти:

```c++
std::shared_ptr<int> ptr_1 {std::make_shared<int>(3)};
```

В результате формируется объект самого указателя `ptr_1`, область памяти для хранения целочисленного значения типа `int`, а также специальный счетчик `counter` указателей на выделенную область памяти:

![10](/Good_good_C_C++/img/10_05.png)

Если объявить еще один указатель на эту же область:

```c++
std::shared_ptr<int> ptr_2 {ptr_1};
```

то счетчик counter автоматически увеличивается до двух:

![10](/Good_good_C_C++/img/10_06.png)

И так далее. С увеличением числа указателей типа `shared_ptr` на эту область памяти, счетчик `counter` будет все время увеличиваться.

Предположим теперь, что указатель `ptr_2` меняет свой адрес. Например, в результате выполнения такой команды:

```c++
ptr_2 = std::make_shared<int>(10);
```

![10](/Good_good_C_C++/img/10_07.png)

Тогда счетчик для предыдущей области памяти (с `int(3)`) уменьшится на единицу, а указатель `ptr_2` будет ссылаться на другую область памяти со своим счетчиком, у которого значение также будет равно единице.

Далее, если указатель `ptr_1` «отвязать» от текущей области памяти:

```c++
ptr_1 = ptr_2;
```

то счетчик на первую область будет равен нулю, а на вторую – два:

![10](/Good_good_C_C++/img/10_08.png)

И как только для какой-либо выделенной области счетчик `counter` устанавливается в ноль, эта область памяти автоматически освобождается. Так реализован контроль за памятью для указателей `shared_ptr`. Кроме того, смешивать разные типы `smart-указателей` между собой также запрещено. Например, следующая конструкция приведет к ошибке на этапе компиляции:

```c++
std::unique_ptr<int> ptr_u {std::make_unique<int>(-1)};
std::shared_ptr<int> ptr_1 {ptr_u};  // ошибка
```

Или конструкция вида:

```c++
ptr_1 = ptr_u; // ошибка
```

также приведет к ошибке. То есть, мы можем работать либо с указателями `unique_ptr`, либо с указателями `shared_ptr`, не смешивая их.

## Методы указателей shared_ptr

Следующим шагом рассмотрим методы, которые имеются у `smart-указателей` типа `shared_ptr`. Основные из них следующие:
+ `get()` – получение «сырого» указателя на выделенную область памяти;
+ `reset()` – меняет значение указателя на другую область памяти, либо на значение `nullptr`, если ничего не указано;
+ `swap()` – меняет адреса двух указателей между собой;
+ `unique()` – возвращает `true` (1), если на выделенную область ссылается только один указатель, и `false` (0) – в противном случае;
+ `use_count()` – возвращает текущее значение счетчика `conter` для текущей области памяти.

Давайте посмотрим, как работают эти методы. С первым `get()` мы уже знакомы по предыдущему `smart-указателю`. Здесь все то же самое:

```c++
std::shared_ptr<int> ptr_1 {std::make_shared<int>(3)};
std::shared_ptr<int> ptr_2 {ptr_1};
 
int* p = ptr_1.get();
```

Следующий метод `reset` позволяет заменять одну область памяти на другую. Например:

```c++
    ptr_2.reset(new int[5] {1, 2, 3});
    int* ar = ptr_2.get();
 
    for(int i = 0;i < 5;++i)
        cout << ar[i] << " ";
```

Обратите внимание, мы выделили новую область памяти с помощью оператора `new` для массива в `5` элементов. После этого получили стандартный указатель на начало этого массива и с его помощью прочитали и вывели значения в консоль.

К сожалению, указатели типа `shared_ptr` могут работать с массивами, только начиная с версии языка C++20. До этого придется использовать оператор `new`.

Оставшиеся методы работают очевидным образом. Например:

```c++
    ptr_2.reset(new int[5] {1, 2, 3});
    ptr_2.swap(ptr_1);
 
    cout << *ptr_2 << " " << ptr_1.use_count() << endl;
    cout << ptr_1.unique() << endl;
```

В консоли увидим:

```
3 1
1
```

А если убрать строчку с `reset`, то вывод будет таким:

```
3 2
0
```

## Работа smart-указателей типа shared_ptr с массивами в стандарте C++20

Начиная со стандарта C++20 указатели `shared_ptr` можно инициализировать и использовать с динамическими массивами. Делается это по аналогии с указателями `unique_ptr` следующим образом:

```c++
unsigned total = 10;
std::shared_ptr<int> ar_1 {std::make_shared<int[]>(total)};
```

После этого через указатель `ar_1` можно работать как с массивом привычным нам образом:

```c++
    ar_1[0] = 10;
    
    for(unsigned i = 0;i < total; ++i)
        cout << ar_1[i] << " ";
```

## Заключение

Вот основные возможности «умных» указателей `unique_ptr` и `shared_ptr`. Сейчас в практике программирования на C/C++ они крайне рекомендуются при написании программ различного уровня сложности, так как существенно уменьшают проблемы, связанные с утечкой памяти, ее повторным освобождением, доступом к невыделенной памяти и так далее. 

Поэтому вместо применения операторов `new`/`delete` по возможности следует применять тот или иной вид `smart-указателей`.

Видео по теме [#23. Smart-указатели типа shared_ptr](https://www.youtube.com/watch?v=Lap-egF2Afk&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, касающиеся smart-указателей shared_ptr языка С++.

+ [x] с каждой выделенной областью памяти для указателей shared_ptr связан счетчик таких указателей
+ [x] указатель типа shared_ptr можно инициализировать указателем такого же типа shared_ptr
+ [x] память автоматически освобождается, когда на нее нет указателей shared_ptr (счетчик указателей равен 0)
+ [x] разным указателям типа shared_ptr разрешено ссылаться на одну и ту же область памяти
+ [ ] указателю типа shared_ptr можно напрямую присваивать значение указателя типа unique_ptr
+ [ ] указатель типа shared_ptr можно инициализировать указателем типа unique_ptr

### Подвиг 2. Выберите все верные варианты инициализации smart-указателей shared_ptr.

+ [ ] std::shared_ptr<float> p_2 = new float();
+ [ ] std::shared_ptr<short> p_5 {std::make_shared<int>()};
+ [x] std::shared_ptr<float> p_3 {new float()};
+ [x] std::shared_ptr<double> p_1;
+ [x] std::shared_ptr< unsigned char > p_6 {std::make_shared< unsigned char >('a')};
+ [ ] std::shared_ptr<double> p_1; std::shared_ptr<int> p_4 {p_1};

### Подвиг 3. Выберите все верные утверждения, касающиеся следующей программы:

```c++
#include <iostream>
#include <memory>

int main(void) {
    std::shared_ptr<char> p_1;
    std::shared_ptr<int> p_2 {std::make_shared<int>(-1)};
    std::shared_ptr<int> p_3 {p_2};

    p_1 = (char *)p_2;
    p_2 = std::make_shared<int>(10);

    *p_3 = 1;
    std::cout << *p_1 << " " << *(p_1+1) << " " << *(p_1+2) << " " << *(p_1+3) << std::endl;
    
    return 0;
}
```

+ [x] указатели p_2 и p_3 изначально ссылаются на одну и ту же область памяти
+ [x] при выполнении команды p_2 = std::make_shared<int>(10); указатель p_2 меняет адрес и на прежнюю область ссылается только один указатель p_3
+ [ ] команда p_1 = (char *)p_2; присваивает адрес указателя p_2 указателю p_1
+ [ ] операция *(p_1+1) позволяет прочитать с помощью указателя p_1 следующий байт
+ [x] команда *p_3 = 1; заносит 1 в область памяти, на которую ссылается указатель p_3

### Подвиг 4. Установите соответствия между методами класса shared_ptr и их описаниями.

![10](/Good_good_C_C++/img/10_09.PNG)

### Подвиг 5. Продолжите программу. Объявите указатель shared_ptr с именем p_val для типа данных short. Выделите область памяти для хранения данных типа short и присвойте адрес этой области указателю p_val. Занесите в эту область значение переменной x. Выведите в консоль значения байт выделенной области памяти (на которую ссылается p_val) в одну строчку через пробел в виде беззнаковых десятичных чисел.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/10.7.5

Sample Input:

4545

Sample Output:

193 17 

```c++
#include <iostream>
#include <memory>

int main(void) {
    int x;
    std::cin >> x;

    std::shared_ptr<short> p_val;
    p_val = std::make_shared<short>((short)x);

    unsigned char* ptr_ch = (unsigned char*)p_val.get();

    printf("%d %d", *ptr_ch, *(ptr_ch + 1));
    // __ASSERT_TESTS__
    return 0;
}
```

### Подвиг 6. Продолжите программу в стандарте C++20. В функции sum_ar добавьте реализацию по вычислению суммы элементов переданного массива ar длиной len элементов. Функция sum_ar должна возвращать вычисленное значение суммы.
В функции main прочитайте из входного потока целые числа (не более max_size_ar, т.е. их может быть и больше, но читать только первые max_size_ar значений), записанные в одну строчку через пробел, в массив ar. Вызовите для массива ar функцию ar_sum и вычислите сумму прочитанных из входного потока значений. Полученное значение суммы выведите в консоль в виде одного целого числа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/10.7.6

Sample Input:

5 4 2 -10 8 7

Sample Output:

16

```c++
#include <iostream>
#include <memory>

enum { max_size_ar = 10 };

using shared_ari_ptr = std::shared_ptr<int[]>;

int sum_ar(const shared_ari_ptr& ar, size_t len) {
    int res = 0;
    for (size_t i = 0; i < len; i++) {
        res += ar[i];
    }
    return res;
}

int main(void) {
    shared_ari_ptr ar{new int[max_size_ar]{0}};
    unsigned count = 0;

    while (count < max_size_ar && std::cin >> ar[count]) count++;

    std::cout << sum_ar(ar, count);

    return 0;
}
```

# TODO

### Подвиг 7*. Нужно продолжить программу, которая реализует логику работы односвязного списка следующей структуры:

![10](/Good_good_C_C++/img/10_10.png)

Каждый объект списка представляется структурой `object`, в которой имеется поле `data` с данными и поле `next` - указатель на следующий объект списка. Указатель `next` последнего объекта односвязного списка должен принимать значение `nullptr`.

Допишите реализации следующих функций:
+ `push_back` - для добавления нового объекта в конец односвязного списка с записью в его поле `data` значения параметра `data`;
+ `pop_front` - для удаления последнего объекта из односвязного списка;
+ `show` - для отображения поля `data` объектов односвязного списка по порядку (от `head` до `tail`) в одну строчку через пробел.

В функции `main` объявите два `smart-указателя` `head` и `tail` типа `shared_obj_ptr` с начальными значениями `nullptr` (пустой список). Эти указатели следует передавать в функции `push_back` и `pop_front`. В свою очередь функции `push_back` и `pop_front` должны корректно менять значения указателей `head` и `tail` так, чтобы `head` всегда указывал на первый элемент односвязного списка, а `tail` - на последний. Если в списке один элемент, то `head` и `tail` ссылаются на один и тот же объект. Если в списке отсутствуют элементы, то `head` и `tail` должны быть равны `nullptr`.

В функции main добавьте в список с помощью функции `push_back` четыре элемента со значениями поля `data` 1, 2, 3, 4 (по порядку, от `head` до `tail`). Отобразите созданный односвязный список с помощью функции `show()`.

```c++
#include <iostream>
#include <memory>

struct object {
    int data;
    std::shared_ptr<object> next;
};

using shared_obj_ptr = std::shared_ptr<object>;

void push_back(shared_obj_ptr& head, shared_obj_ptr& tail, int data) {
    // добавление в конец нового объекта односвязного списка
}

void pop_front(shared_obj_ptr& head, shared_obj_ptr& tail) {
    // удаление последнего объекта из односвязного списка
}

void show(const shared_obj_ptr& head) {
    // отображение поля data объектов односвязного списка по порядку (от head до tail) в одну строчку через пробел
}

int main(void) {
    // здесь продолжайте функцию main

    __ASSERT_TESTS__ // макроопределение для тестирования (не убирать и должно идти непосредственно перед return 0)
    return 0;
}
```

