# 4. Операторы циклов. Указатели

# 4.1 Оператор цикла while

На этом занятии начнем знакомиться с еще одной ключевой конструкцией – циклами. Вначале, давайте я на простом примере покажу, о чем идет речь. Представим, что пользователь вводит с клавиатуры целое положительное значение n и нам нужно вычислить следующую сумму:

$1^2 + 2^2 + 3^2 + 4^2 + ... + n^2$

Понятно, что мы не можем заранее прописать всю эту сумму, так как значение `n` попросту неизвестно на момент написания программы. Переменная `n` принимает конкретное значение только в процессе выполнения программы. Поэтому реализовать такую конструкцию можно только с помощью операторов циклов.

В общем случае циклы позволяют реализовывать некие повторяющиеся действия. Например, предположим, что маленькие панды прыгают с горки в течение часа, пока мама-панда не позовет всех к столу – кушать. Формализовать это можно, например, так:

```
цикл (пока не прошел час):
      прыгаем с горки
```

То есть, пока истинно условие, цикл работает, как только условие становится ложным (прошел час) цикл завершается. Ровно так работает цикл `while`, о котором и пойдет речь на этом занятии. Он имеет, следующее определение (синтаксис):

```c
while(<условие>)
    оператор;
```

или

```c
while(<условие>) {
    оператор 1;
    ...
    оператор N;
}
```

В программировании оператор или блок операторов, выполняющихся в цикле, называют телом цикла. А один проход выполнения оператора цикла – итерацией. Сам цикл `while` относится к циклам с предусловием, т.к. сначала проверяется условие цикла и только после этого (при истинности условия) выполняется текущая итерация.

Давайте вернемся к исходной задаче – вычисления суммы квадратов целых чисел от `1` до `n` и посмотрим, как здесь можно использовать цикл `while`:

```c
#include <stdio.h>
 
int main(void) {
         int n;
         int s = 0;
 
         if(scanf("%d", &n) != 1) {
                   printf("Error input\n");
                   return 0;
         }
 
         while(n > 0) {
                   s += n*n;
                   n--;
         }
 
         printf("s = %d\n", s);
         
         return 0;
}
```

Вначале мы объявили две переменные `n` и `s`, причем, в `s` будет храниться сумма и она принимает начальное значение `0`. Затем, запрашивается ввод в переменную `n` и если он некорректен, то программа завершается. Иначе запускается цикл `while`. В круглых скобках прописано условие продолжения цикла: пока `n` больше нуля. А в теле цикла определены два оператора: сначала к переменной `s` прибавляем квадрат наибольшего значения `n`, а потом, уменьшаем переменную `n` на единицу. В результате у нас будет образовываться следующая сумма:

$s = n^2 + (n-1)^2 + … + 1^2$

Как только значение `n` становится равным `0`, условие цикла становится ложным и оператор `while` прекращает свою работу. Управление переходит к следующему оператору `printf()`.

Давайте теперь несколько изменим нашу программу и запишем цикл `while` следующим образом:

```c
         while(n-- > 0)
                   s += n*n;
```

Будет ли это тем же самым или программа станет работать по другому? Проверим это. Запустим и введем число 4. Получим сумму:

```c
s = 14
```

Очевидно это не вся прежняя сумма:

$s = 1^2 + 2^2 + 3^2 + 4^2 = 30$

У нас не хватает последнего слагаемого $4^2 = 16$. 

Почему так произошло? 

Все просто. Сначала выполняется сравнение переменной `n` с нулем (4 > 0) и после этого операция декремента. То есть, когда выполнение программы переходит к оператору `s += n*n;` тела цикла переменная `n` уже на единицу меньше. Возможно, некоторых из вас это удивит, так как операция декремента записана в постфиксной форме (после имени переменной), а значит, она должна выполняться в последнюю очередь. 

Но логика работы здесь несколько иная. 

Любое выражение, которое прописывается в условии, сначала полностью вычисляется и только затем осуществляется переход к телу цикла. 

И это всегда так. 

Этот важный момент нужно запомнить и знать. Именно поэтому переменная `n` гарантированно будет уменьшена на единицу при переходе к оператору `s += n*n;`.

Кстати, последнее слагаемое в нашем примере будет `0^2 = 0`. Поэтому (если ноль нам не нужен) правильнее было бы прописать эту условие так:

```c
         while(--n > 0)
                   s += n*n;
```

Префиксная форма записи операции декремента сначала уменьшит значение `n` на единицу и только после этого будет осуществляться сравнение с нулем.

Давайте теперь немного усложним программу и сделаем ограничение на максимальное значение `n` на тот случай, если пользователь введет слишком большое число. Например, сделаем так, чтобы слагаемых было не больше `10`:

```c
         int i = 0;
         while(++i <= n && i <= 10)
                   s += i*i;
```

Условие в цикле `while` пришлось переписать с использованием дополнительной вспомогательной переменной `i`, которая, по сути, является счетчиком итераций. Ее первое значение при подсчете суммы будет равно `1`, затем, `2` и так пока либо не дойдет до `n`, либо до `10`.

Давайте внимательнее посмотрим на условие. Вначале записана операция инкремента в префиксной форме. 

Это означает, что значение переменной `i` увеличится на единицу и только потом выполнится операция сравнения. 

Мало того, здесь мы можем точно гарантировать, что операция инкремента (в любой форме записи: префиксной или постфиксной) отработает до перехода к следующей проверке `i <= 10`. Так заложено в стандарте языка Си. И это правило справедливо для всех логических связок:

`&&` и `||`

где бы они ни использовались: в операторах циклов или условных операторах.

Благодаря этому мы можем четко понимать, как отработает данный цикл. Вначале обязательно увеличится значение переменной `i` на единицу, затем, проверится условие `i <= n` и только после этого (при необходимости) будет проверяться второе подусловие `i <= 10`.

Вообще, в качестве условия цикла `while` можно записывать любое выражение.

Например, мы хотим считывать целые числа с клавиатуры, пока пользователь не введет `0`. Сделать это можно следующим образом:

```c
#include <stdio.h>
 
int main(void) {
         int s = 0;
         int x = 1;
 
         while(scanf("%d", &x) == 1 && x != 0)
                   s += x;
 
         printf("s = %d\n", s);
         
         return 0;
}
```

Здесь цикл `while` будет работать до тех пор, пока пользователь либо вводит корректные данные (целые числа), либо введет число `0`. В самом цикле выполняется суммирование введенных числовых значений, а после цикла отображение полученного результата с помощью функции `printf()`.

Или можно немного усложнить пример и выполнять суммирование только четных чисел (или только положительных). Для этого достаточно внутри цикла `while` указать нужное нам условие, например, следующим образом:

```c
    while(scanf("%d", &x) == 1 && x != 0)
        if(x % 2 == 0)
            s += x;
```

То есть, в теле цикла `while` можно прописывать абсолютно любые операторы языка Си. И, обратите внимание, в данном случае мы не указывали фигурные скобки, т.к. в теле цикла формально записан один оператор `if`, а для одного оператора фигурные скобки не обязательны. Хотя, при желании их можно записать:

```c
    while(scanf("%d", &x) == 1 && x != 0) {
        if(x % 2 == 0)
            s += x;
    }
```

Программа от этого не изменится.

В заключение занятия отмечу один важный момент использования операторных фигурных скобок. Обычная переменная, объявленная внутри них, например:

```c
    while(scanf("%d", &x) == 1 && x != 0) {
        int res = x % 2;
        if(res == 0)
            s += x;
    }
```

существует только в пределах этих операторных скобок и перестает существовать, когда выполнение программы перейдет к следующему оператору за пределами этих фигурных скобок. То есть, если мы захотим вывести значение переменной `res` после цикла `while`:

```c
printf("res = %d\n", res);
```

то при компиляции возникнет ошибка, что переменная `res` не определена.

На самом деле, это очень полезное поведение, заложенное в язык Си. На практике часто внутри фигурных скобок объявляют временные переменные, необходимые для отработки внутренней логики. Потом они просто автоматически исчезают и не мешают работе остальной программы. Обо всем этом мы еще подробнее будем с вами говорить, когда речь пойдет о локальных и глобальных переменных.

На этом завершим первое занятие по циклам. Из него вам должно быть понятно для чего вообще нужны циклы и как работает оператор цикла `while`.

Видео по теме [#22. Оператор цикла while](https://www.youtube.com/watch?v=_xBLgSOGnU0&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, касающиеся оператора цикла while.

+ [ ] оператор while проверяет условие цикла после выполнения очередной итерации
+ [x] каждое выполнение операторов тела цикла называется итерацией цикла
+ [x] цикл while работает пока истинно условие цикла
+ [x] операторы, которые выполняются каждый цикл, образуют тело цикла
+ [x] оператор while проверяет условие цикла до выполнения очередной итерации
+ [ ] цикл while работает пока ложно условие цикла

### Подвиг 2. Чему будет равна переменная s после выполнения следующей программы?

P.S. Ответ вычислить без программирования и запуска программы.

```c
#include <stdio.h>

int main(void) {
    int count = 0;
    int s = 0;

    while (count++ <= 5) s += count;

    printf("%d", s);

    return 0;
}
```

$21$

### Подвиг 3. Напишите программу, которая последовательно читает из входного потока stdin целые числа, записанные через пробел, пока не встретится число 0. Вывести на экран все читаемые значения возведенные в квадрат в одну строчку через пробел. В программе следует использовать только одну целочисленную переменную.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.1.3

```c
#include <stdio.h>

int main(void) {
    int x;

    while (scanf("%d", &x) == 1 && x != 0) printf("%d ", x * x);

    return 0;
}
```

### Подвиг 4. Напишите программу, которая читает из входного потока натуральное число n (целое, положительное). Вычислите с помощью цикла while сумму ряда:

$S = \dfrac{1}{1^2} + \dfrac{1}{2^2} + \dfrac{1}{3^2} +...+ \dfrac{1}{n^2}$ 

Выведите результат в консоль в виде вещественного числа с точностью до тысячных.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.1.4

```c
#include <stdio.h>

int main(void) {
    int x;
    double sum;

    scanf("%d", &x);

    while (x > 0) {
        sum += 1.0 / (x * x);
        x--;
    }

    printf("%.3lf", sum);

    return 0;
}
```

### Подвиг 5. Напишите программу, которая читает из входного потока натуральное число n (целое, положительное), которое содержит от 2-х и более цифр. Используя цикл while, вычислить сумму цифр числа n. Результат вывести в консоль в виде одного целого числа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.1.5

```c
#include <stdio.h>

int main(void) {
    int x, sum;

    scanf("%d", &x);

    while (x > 0) {
        sum += x % 10;
        x /= 10;
    }

    printf("%d", sum);

    return 0;
}
```

```c
#include <stdio.h>
int main() {
    int n, s = 0;
    while(scanf("%1d", &n)==1) s += n;
    printf("%d", s);
    return 0;
}
```

### Подвиг 6. Последовательность Фибоначчи образуется так: первые два числа равны 1 и 1, а каждый следующий равен сумме двух предыдущих. То есть, имеем последовательность вида: 1, 1, 2, 3, 5, 8, 13, ... Вычислите последовательность Фибоначчи длиной n (n - натуральное число, читаемое из входного потока). Выведите числа полученной последовательности в одну строку через пробел.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.1.6

```c
#include <stdio.h>

int main() {
    int x, num0 = 0, num1 = 1, num = 1, counter = 0;

    scanf("%d", &x);

    while (counter != x) {
        printf("%d ", num);
        num = num0 + num1;
        num0 = num1;
        num1 = num;
        counter++;
    }

    return 0;
}
```

### Подвиг 7. Напишите программу, которая читает из входного потока два натуральных числа n и m, записанных через пробел, причем n < m. Выведите в консоль в одну строчку через пробел все числа кратные 3 (нацело делятся на 3) из интервала [n, m].

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.1.7

```c
#include <stdio.h>

int main() {
    int n, m;

    scanf("%d %d", &n, &m);

    while (n <= m) {
        if (n % 3 == 0) printf("%d ", n);
        n++;
    }

    return 0;
}
```

### Подвиг 8. Напишите программу, которая среди всех натуральных трехзначных чисел (числа с тремя цифрами) находит те, которые при делении на 47 дают целый остаток 6 или при делении на 53 - целый остаток 45. Выведите в консоль все найденные трехзначные числа в порядке возрастания в одну строчку через пробел.

```c
#include <stdio.h>
#define LEFT 100
#define RIGHT 999

int main() {
    int n = LEFT;

    while (n <= RIGHT) {
        if (n % 47 == 6 || n % 53 == 45) printf("%d ", n);
        n++;
    }

    return 0;
}
```

### Подвиг 9. Напишите программу, которая читает натуральное число, содержащее одну и более цифр. Определить, что это число является палиндромом, то есть, оно не меняет своего значения при просмотре слева-направо и справа-налево. Например: 121, 23032, 11 и т.п. Если число является палиндромом, то в консоль вывести строку "yes", иначе - строку "no".

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.1.9

```c
#include <math.h>
#include <stdio.h>

int main() {
    int count = 0, n;

    scanf("%d", &n);

    // посчитаем количество знаков в числе
    int ncopy = n;

    while (ncopy > 0) {
        ncopy /= 10;
        count++;
    }

    count--;

    char res = 1;

    while (n >= 10) {
        // вычислим первую и последнюю цифры и сравним их
        int a = n / pow(10, count);
        int b = n % 10;
        // printf("%d %d\n", a, b); // проверочная печать
        if (a != b) { // если не равны выходим из цикла с res = 0
            res = 0;
            break; 
        }
        // откидываем от n первую и последнюю цифры
        n -= a * pow(10, count);
        n /= 10;
        // printf("%d\n", n); // проверочная печать
        // уменьшаем счетчик знаков
        count -= 2;
    }
    // печатаем через тернарный оператор ответ
    printf("%s", res ? "yes" : "no");

    return 0;
}
```

```c
#include <stdio.h>

int main(void)
{    
    int num_o;
    scanf("%d", &num_o);
    
    int reversed = 0;
    int num = num_o;
    while(num != 0){
        int r = num % 10;
        reversed = reversed * 10 + r;
        num /=10;
    }   
    (num_o == reversed) ? printf("yes") : printf("no");
    
    return 0;
}
```

### Подвиг 10*. Напишите программу, которая вычисляет наибольший общий делитель (НОД) двух натуральных чисел a, b по алгоритму Евклида. Алгоритм реализуется по следующей схеме:

Шаг 1. Читаем из входного потока два натуральных числа a, b, записанных в одну строчку через пробел.
Шаг 2. Определяем наименьшее из двух чисел a, b
Шаг 3. Делаем цикл: пока меньшее число больше 0
Шаг 4.         большему числу присваиваем целый остаток от деления на меньшее число; (используется операция %)
Шаг 5.         большее число становится меньшим, а меньшее - большим
Шаг 6. Большее число выводим в консоль в виде одного числа.

```c
#include <stdio.h>

int main() {
    int a, b;

    scanf("%d %d", &a, &b);

    while (b > 0) {
        if (a > b) {
            int tmp = a;
            a = b;
            b = tmp;
        }
        b %= a;
    }

    printf("%d", a);
    return 0;
}
```

# 4.2 Оператор цикла for

На прошлом занятии мы рассмотрели работу цикла while, на этом занятии речь пойдет об операторе for. Оба этих оператора образуют циклы с предусловием, то есть, сначала проверяется условие цикла и если оно истинно, то выполняется текущая итерация. И здесь возникает вопрос, зачем понадобился еще один оператор цикла с предусловием?

Смотрите, в практике программирования очень часто возникают задачи, когда нужно организовать циклы по следующей схеме:

![03](/Good_good_C_C++/img/03_20.png)

То есть, перед циклом мы выполняет некоторую инициализацию переменных, используемых затем в цикле. Далее идет условие цикла, если оно истинно, то выполняются операторы, записанные внутри цикла. И в конце после основной группы операторов, выполняются некоторые изменения переменных для новой итерации. Например, ранее мы использовали эту схему в цикле `while` следующим образом:

```c
/* Инициализация */
int n;
int s = 0;
 
/* Цикл с предусловием */
while(n > 0) {
         s += n*n;    /* Операторы тела цикла */
         n--;         /* Изменение значений */
}
```

Так вот, чтобы иметь возможность в программах записывать подобные циклы в более краткой форме, и был введен оператор `for`, который имеет следующий синтаксис:

```c
for([инициализация]; [условие]; [изменение значений])
    оператор;
```

или

```c
for([инициализация]; [условие]; [изменение значений]) {
    операторы;
}
```

Как видите, сразу в этом операторе можно прописать инициализацию переменных перед запуском цикла, условие цикла и порядок изменения значений после выполнения каждой итерации цикла.

Обратите внимание, все эти элементы являются не обязательными, то есть, мы можем не прописывать инициализацию, условие и изменение значений. 

Также видим, что все эти элементы внутри цикла `for` разделены между собой точкой с запятой. Это, наверное, единственный оператор языка Си, который в своем определении использует символ точку с запятой как разделитель.

Давайте перепишем программу выше с циклом `while` через оператор `for`. Получим:

```c
#include <stdio.h>
 
int main(void) {
         /* Объявление переменных */
         int n, s;
 
         scanf("%d", &n);
 
         /* Цикл с предусловием for */
         for(s = 0; n > 0; --n)
                   s += n*n;    /* Операторы тела цикла */
 
         printf("s = %d\n", s);
         
         return 0;
}
```

Как видите, сам цикл имеет довольно краткую запись и визуально мы сразу можем выделить блок инициализации, блок проверки условия и блок изменения переменной. 

Если вам сейчас такая запись кажется несколько странной, то с опытом к ней очень быстро привыкаешь. И благодаря удобству оператор цикла `for` используется гораздо чаще оператора цикла `while`.

Давайте я приведу еще один пример с оператором цикла `for` для вычисления факториала числа:

```c
#include <stdio.h>
 
int main(void) {
    int n = 5, p = 1;

    for(int i = 1; i <= n; ++i)
        p = p * i;

    printf("p = %d\n", p);
    
    return 0;
}
```

Я напомню, что:

$n! = 1 ∙ 2 ∙ 3 ∙ … ∙ n$

В программе мы определяем `n = 5` и через цикл `for` находим факториал этого числа. 

Для этого задается вспомогательная переменная `p` с начальным значением `1` и в цикле `for` счетчик (переменная) `i` также с начальным значением `1`. 

Обратите внимание, внутри блока инициализации допустимо объявлять переменную, которая ранее нигде не существовала. 

Причем, используемый мной компилятор `gcc`, создает эту переменную исключительно внутри цикла `for` и за его пределами она не существует. 

Однако другие компиляторы, работающие по другим стандартам, вполне могут определять такие переменные за пределами оператора `for`. 

Соответственно, доступ к ним сохраняется после выполнения цикла. Но для нас сейчас важно лишь то, что в блоке инициализации можно объявлять переменные и использовать их в теле цикла данного оператора.

Работает цикл очень просто. Сначала проверяется условие цикла, т.к. оно истинно, то выполняется текущая итерация – оператор `p = p * i;`.

После этого происходит увеличение счетчика `i` на единицу и снова проверяется условие цикла. В результате, мы получаем значение переменной p равное:

```
p = 1 ∙ 2 ∙ 3 ∙ 4 ∙ 5 = 120
```

А вот еще несколько вариаций записи этого же цикла:

```c
         int i, p;
         for(i = 1, p = 1; i <= n; ++i)
                   p = p * i;
```

Здесь использована новая операция запятая для инициализации двух переменных. Или:

```c
         int n = 5;
         int i = 1, p = 1;
         
         for(; i <= n; ++i)
                   p = p * i;
```

Здесь пустой блок инициализации, т.к. она прописана до оператора цикла. Или:

```c
         int n = 5;
         int i = 1, p = 1;
 
         for(; i <= n;) {
                   p = p * i;
                   ++i;
         }
```

Здесь два пустых блока: инициализации и изменения значений. Или:

```c
         int n = 5, i, p;
         for(i = 1, p = 1; i <= n; p = p * i, ++i)
                   { }
```

Вся логика вычислений прописана внутри оператора цикла `for`. Соответственно, в теле цикла ничего прописывать не нужно, но формально там все же должен быть указан хотя бы один оператор. 

Точка с запятой, как раз и воспринимается компилятором как оператор, который ничего не делает. 

Также в блоке изменения значений прописаны две операции, разделенные запятой. При этом сначала выполнится первая операция `p = p * i` и только потом вторая `++i`. 

Это поведение для операции запятая строго определено в стандарте языка Си. 

Вычисление выражений, разделенных запятой, происходит слева-направо и никак иначе.

Начинающий программист, глядя на все это разнообразие форм записей одного и того же оператора для решения одной и той же задачи, может задаться вполне резонным вопросом: какой же вариант лучше? 

В действительности, следует выбирать тот, который проще воспринимать и модифицировать (при необходимости). 

Компилятор все эти вариации переведет в машинный код примерно одинаковым образом. 

Лично я выбрал бы здесь первый вариант записи, т.к. он хорошо отражает логику работы программы.

Раз уж мы затронули вопрос различных вариаций записей оператора цикла `for`, то приведу еще одну без каких-либо блоков:

```c
for( ; ; );
```

Так тоже можно записывать. В этом случае цикл будет работать «вечно» пока мы или операционная система не прервет выполнение программы.

Вообще цикл `for` используют не только для формирования каких-либо арифметических последовательностей в программах. 

Спектр его применения куда шире. 

Здесь следует исходить из того, что в блоках инициализации и изменения значений можно прописывать любые допустимые конструкции. Например, такие:

```c
#include <stdio.h>
#include <stdlib.h>
 
int main(void) {
         for(int x = rand() % 10; x != 0; x = rand() % 10)
                   printf("x = %d\n", x);
 
         return 0;
}
```

Как видите, в блоке инициализации формируется первое псевдослучайное значение в диапазоне `[0; 9]`, а в блоке изменения следующее псевдослучайное значение из этого же диапазона. На каждой итерации на экран выводится полученное числовое значение, пока `x` не станет равен нулю.

На этом мы завершим первое знакомство с оператором цикла `for`. На следующем продолжим эту тему и поговорим об операторе цикла с постусловием `do-while`.

### Подвиг 1. Выберите все верные утверждения, касающиеся оператора цикла for языка Си стандарта C99 и выше.

+ [x] цикл for работает, пока истинно условие цикла
+ [x] в блоке инициализации цикла for можно объявлять и инициализировать новые переменные
+ [ ] цикл for работает, пока ложно условие цикла
+ [ ] цикл for сначала выполняет итерацию, а затем, проверяет условие продолжения цикла
+ [x] цикл for записывается по синтаксису: for([инициализация]; [условие]; [изменение значений]) оператор;
+ [x] цикл for сначала проверяет условие, а затем, выполняет очередную итерацию
+ [x] блок "изменение значений" выполняется сразу после очередной итерации тела цикла

### Подвиг 2. Замените в приведенной программе цикл while на цикл for с сохранением логики работы программы.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.2.2

```c
#include <stdio.h>

int main(void) {
    int s = 0, n = 0;

    scanf("%d", &n);
    
    for (int i = 5; i++ <= n; s += i)
        ;
        
    printf("%d", s);

    return 0;
}
```
### Подвиг 3. Продолжите программу, которая должна вычислять первые n членов арифметической прогрессии и выводить их по порядку в одну строчку через пробел. Члены прогрессии вычисляются по следующей схеме:

a0 - первый член;
a0 + d - второй член;
a0 + 2d - третий член;
...
a0 + (n-1)*d - n-й член

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.2.3

```c
#include <stdio.h>

int main(void) {
    int a0, d, n;
    scanf("%d; %d; %d", &a0, &d, &n);

    for (int i = 0; i < n; i++) {
        int res = a0 + i * d;
        printf("%d ", res);
    }

    return 0;
}
```

### Подвиг 4. Продолжите программу, которая должна вычислять первые n членов геометрической прогрессии и выводить их по порядку в одну строчку через пробел. Члены прогрессии вычисляются по следующей схеме:

b0 - первый член;<br>
b0 * q - второй член;<br>
b0 * q^2 - третий член;<br>
...<br>
b0 * q^(n-1) - n-й член<br>

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.2.4

```c
#include <math.h>
#include <stdio.h>

int main(void) {
    int b0, q, n;
    scanf("%d; %d; %d", &b0, &q, &n);

    for (int i = 0; i < n; i++) {
        int res = b0 * pow(q, i);
        printf("%d ", res);
    }

    return 0;
}
```

### Подвиг 5. Напишите программу, которая читает из входного потока натуральное число n. Необходимо вывести в консоль "линию" в виде n символов '='. Например, если вводится n = 5, то на выходе должны получить:

=====

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.2.5


```c
#include <math.h>
#include <stdio.h>

int main(void) {
    int n;
    scanf("%d", &n);

    for (int i = 0; i < n; i++) {
        printf("=");
    }

    return 0;
}
```

### Подвиг 6. Напишите программу, которая читает из входного потока два целых числа n, m, записанных в одну строчку через пробел, причем n < m. Выведите в консоль в одну строчку через пробел все четные числа в диапазоне [n; m], используя цикл for.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.2.6

```c
#include <stdio.h>

int main(void) {
    int n, m;
    scanf("%d %d", &n, &m);

    for (int i = n; i <= m; i++) {
        if (i % 2 == 0) printf("%d ", i);
    }

    return 0;
}
```

### Подвиг 7. Напишите программу, которая читает из входного потока натуральное число n. С помощью цикла for найти все делители этого числа (то есть, натуральные числа, которые нацело делят число n, включая числа 1 и n). Все найденные делители вывести по порядку (начиная с наименьшего) в одну строчку через пробел.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.2.7

```c
#include <stdio.h>

int main(void) {
    int n;
    scanf("%d", &n);

    for (int i = 1; i <= n / 2; i++) {
        if (n % i == 0) printf("%d ", i);
    }
    printf("%d ", n);

    return 0;
}
```

### Подвиг 8. Напишите программу, которая читает из входного потока натуральное число n. Вычислить сумму всех натуральных чисел (больше 1 и меньше n), которые кратны или 3 или 5. Результат (сумму) вывести в консоль в виде одного целого числа. 

Пример: n = 10, имеем числа: 3, 5, 6, 9. Их сумма равна 23.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.2.8

```c
#include <stdio.h>

int main(void) {
    int n, res = 0;
    scanf("%d", &n);

    for (int i = 1; i < n; i++) {
        if (i % 3 == 0 || i % 5 == 0) res +=i;
    }
    printf("%d", res);

    return 0;
}
```

### Подвиг 9 (на повторение). Напишите следующую программу. Из входного потока читаются цифры (от 1 до 9), пока не встретится число 0. На основе этих цифр сформировать единое число. Например, если на вход поступают цифры:

5 2 9 3 0

то должно формироваться число:

5293

Выведите полученное число в консоль.

Если цифра 0 встречается сразу (первая), то формируемая переменная должна принимать значение 0.

P.S. Программу следует реализовать с использованием только текущих знаний (без массивов).

Тесты: hhttps://github.com/selfedu-rus/c-tests/tree/main/4.2.9

```c
#include <stdio.h>

int main(void) {
    int n, res = 0;

    while (scanf("%d", &n) == 1 && n != 0) {
        res = res * 10 + n;
    }

    printf("%d", res);

    return 0;
}
```

### Подвиг 10 (на повторение). Напишите программу, которая читает из входного потока натуральное число n. На его основе нужно сформировать другое число m, в котором цифры числа n будут идти в обратном порядке. Например, при n = 235, получаем m = 532. Или, при n = 1, получаем m = 1.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.2.10

```c
#include <stdio.h>

int main(void) {
    int n, res = 0;

    scanf("%d", &n);

    while (n > 0) {
        res = res * 10 + n % 10;
        n /= 10;
    }

    printf("%d", res);

    return 0;
}
```

### Подвиг 11 (на повторение). Напишите программу, которая читает из входного потока шестизначное натуральное число n. Определить, является ли оно счастливым. (Счастливым называют такое шестизначное число, в котором сумма его первых трех цифр равна сумме его последних трех цифр.). Вывести в консоль "yes", если счастливое и "no" - в противном случае.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.2.11

```c
#include <stdio.h>

int main(void) {
    int a, b, c, d, e, f;

    scanf("%1d %1d %1d %1d %1d %1d", &a, &b, &c, &d, &e, &f);

    char res = (a + b + c) == (d + e + f);

    printf("%s", res ? "yes" : "no");

    return 0;
}
```

# 4.3 Цикл do-while с постусловием. Вложенные циклы

## Цикл do-while с постусловием

На этом занятии рассмотрим последний такой оператор – цикл с постусловием `do-while`, который имеет следующий синтаксис:

```c
do {
    [оператор (один или несколько)]
} while(<условие>);
```

Фигурные скобки при записи этого оператора строго обязательны, даже если в них будет находиться всего один оператор. Также после ключевого слова `while` должна стоять точка с запятой.

Само название этого оператора говорит, что цикл `do-while` отличается от цикла `while`, фактически, только тем, что сначала выполняется итерация, а затем, проверяется условие для продолжения цикла. При этом цикл `do-while` работает пока истинно условие. 

Соответственно, как только условие становится ложным, цикл завершается и управление передается следующему оператору в программе.

Давайте рассмотрим пример, где использование такого типа цикла оправдано. Предположим, пользователь должен ввести кодовое число, чтобы получить доступ к чему-либо. Для этого вначале нужно попросить его ввести числовое значение и только после этого проверить, совпадает ли ввод с кодовым числом. Если совпадает, то предоставить доступ, а иначе попросить ввести код еще раз. Эту логику проще всего реализовать с помощью оператора цикла `do-while` следующим образом:

```c
#include <stdio.h>

int main(void) {
    int pass_code = 13;
    int enter_code;

    do {
        printf("Please enter the secret code: ");
        scanf("%d", &enter_code);
    } while (enter_code != pass_code);

    printf("Access is allowed\n");

    return 0;
}
```

Сначала будет выполнена итерация цикла, то есть, операторы, записанные в теле цикла. В результате пользователь получает возможность ввести кодовое значение. А затем, в цикле выполняется обратная проверка на неравенство значений. 

Почему так? 

Потому что мы здесь прописываем условие продолжения цикла. И цикл должен продолжаться, пока пользователь не введет верное кодовое число. В этом случае условие становится ложным и управление передается следующему оператору `printf()`, записанному после цикла `do-while`.

Как видите, цикл с постусловием полезен, когда нам в программе нужно вначале выполнить некоторые повторяющиеся действия и только после этого решить, продолжать цикл или завершить. В действительности, это не частая ситуация и по этой причине оператор цикла `do-while` на практике применяется реже двух остальных: `while` и `for`, о которых мы с вами уже говорили на предыдущих занятиях.

Также обратите внимание, как записан в тексте программы этот оператор цикла. Ключевое слово `while` стоит в одной строчке с закрывающейся фигурной скобкой.

Так принято делать, чтобы визуально подчеркнуть, что `while` здесь – это завершение конструкции, которая начинается с ключевого слова `do`. И чтобы не спутать этот `while` с другим таким же оператором уже цикла с предусловием. Например, давайте усовершенствуем нашу программу, и будем очищать буфер входного потока `stdin` после каждого ввода:

```c
#include <stdio.h>

int main(void) {
    int pass_code = 13;
    int enter_code;
    int c;

    do {
        printf("Please enter the secret code: ");
        scanf("%d", &enter_code);

        while ((c = getchar()) != '\n' && c != EOF) {
        }
    } while (enter_code != pass_code);

    printf("Access is allowed\n");

    return 0;
}
```
Я здесь использую цикл `while` с вызовом функции `getchar()`, которая читает один байт из потока `stdin`. Цикл останавливается, если прочитан символ переноса строки (`\n`) или конца файла (`EOF`). 

Это простейший вариант очистки буфера входного потока.

И, смотрите, в тексте программы идут друг за другом два слова `while`. Но, тем не менее, они легко различаются, так как имеются отступы у операторов тела цикла.

Или может быть ситуация, когда после цикла `do-while` идет цикл `while`:

```c
#include <stdio.h>

int main(void) {
    int pass_code = 13;
    int enter_code;
    int c;

    do {
        printf("Please enter the secret code: ");
        scanf("%d", &enter_code);

        while ((c = getchar()) != '\n' && c != EOF) {
        }
    } while (enter_code != pass_code);

    while ((c = getchar()) != '\n' && c != EOF) {
    }

    printf("Access is allowed\n");

    return 0;
}
```

При нашем способе оформления текста программы все три цикла хорошо различимы и не возникает никакой путаницы. Именно поэтому рекомендуется оператор `do-while` записывать в таком виде.

## Вложенные циклы
Из последних примеров вы видели, что в один оператор цикла можно заключать другой. В программировании такая конструкция называется вложенными циклами. И ее можно реализовывать с любыми операторами циклов. Давайте подробнее посмотрим, как она работает.

Чаще всего вложенные циклы можно увидеть с операторами `for`. Поэтому в нашем примере будут фигурировать именно они. А сам пример будет следующим. Представим, что нам нужно выполнить полный перебор документов (файлов), лежащих в нескольких ящиках (box). В каждом ящике одинаковое число файлов, а всего ящиков пусть будет три.

![03](/Good_good_C_C++/img/03_21.png)

Для решения этой задачи воспользуемся вложенными циклами `for` следующим образом:

```c
#include <stdio.h>

int main(void) {
    int total_boxs = 3;
    int total_files = 6;

    for (int i = 0; i < total_boxs; ++i) {
        for (int j = 0; j < total_files; ++j) {
            printf("Box %d, file %d\n", i + 1, j + 1);
        }
    }
    
    return 0;
}
```
Смотрите, сначала срабатывает первый (внешний) цикл со счетчиком (переменной) `i`, который содержит номер текущего просматриваемого ящика. Затем, запускается итерация этого внешнего цикла (выполняются операторы, записанные в теле цикла). В результате запускается второй (внутренний) цикл, который перебирает документы текущего ящика. Для каждого документа выводится информация в формате:

```
Box<номер ящика>, file<номер документа>
```

В результате, после просмотра всех документов первого ящика на экране появятся строчки:

```
Box 1, file 1
Box 1, file 2
Box 1, file 3
Box 1, file 4
Box 1, file 5
Box 1, file 6
```

После этого работа внутреннего цикла завершается и управление передается внешнему циклу. В нем происходит увеличение счетчика `i` на единицу и проверяется условие цикла. Так как оно истинно, то запускается вторая итерация и снова срабатывает внутренний цикл, но уже для перебора документов второго ящика. И так для всех трех ящиков.

Вот общий принцип работы вложенных циклов. Конечно, пример с ящиками и файлами – это лишь частный пример. В общем случае подобным образом можно перебирать пиксели двумерного изображения, ячейки игрового поля, вычислять вложенные суммы и так далее.

![03](/Good_good_C_C++/img/03_22.png)

Мало того, при необходимости, мы можем увеличивать число вложений операторов циклов и осуществлять перебор элементов не только в плоскости, но и в объеме и вообще в Nмерном пространстве. Хотя, на практике слишком увлекаться этим не стоит, т.к. сложность понимания и восприятия программы растет с числом этих вложений. Обычно, ограничиваются двумя, тремя уровнями. При правильной организации логики программы этого оказывается вполне достаточно.

Чтобы закрепить этот материал предлагаю самостоятельно написать программу для вычисления следующей суммы:

![03](/Good_good_C_C++/img/03_23.png)

Если все правильно сделаете, то должны получить ответ 2750.

```c
#include <stdio.h>

int main(void) {
    int res = 0;

    for (int i = -3; i <= 7; ++i) {
        for (int j = 1; j <= 5; ++j) {
            for (int k = 2; k <= 4; ++k) {
                res += (i + j - k) * (i + j - k);
            }
        }
    }
    printf("%d", res);
    return 0;
}
```

### Подвиг 1. Выберите все верные утверждения, касающиеся цикла do-while.

+ [x] оператор do-while относится к циклам с постусловием
+ [ ] оператор do-while сначала проверяет условие продолжения цикла, а затем выполняет итерацию
+ [x] оператор do-while сначала выполняет итерацию, а затем проверяет условие продолжения цикла
+ [ ] оператор do-while относится к циклам с предусловием
+ [ ] цикл do-while описывается согласно синтаксису: do-while {[тело цикла]} (<условие>);
+ [x] цикл do-while описывается согласно синтаксису: do {[тело цикла]} while(<условие>);

### Подвиг 2. Перепишите следующую программу с использованием цикла do-while, сохранив логику работы программы.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.3.2

```c
#include <stdio.h>

int main(void) {
    int p = 1, n, i = 1;

    scanf("%d", &n);

    do {
        p *= i;
    } while (i++ < n);

    printf("%d", p);

    return 0;
}
```

### Подвиг 3. Напишите программу с использованием цикла do-while, которая читает из входного потока целые числа (по одному) до тех пор, пока не встретится число 13. Все положительные прочитанные числа просуммировать (включая число 13) и вывести полученную сумму в виде одного целого числа в консоль.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.3.3

```c
#include <stdio.h>
#define LAST_DIGIT 13

int main(void) {
    int res = 0, n;

    do {
        scanf("%d", &n);
        if (n > 0) res += n;
    } while (n != LAST_DIGIT);

    printf("%d", res);

    return 0;
}
```

### Подвиг 4. Напишите программу, которая читает из входного потока натуральное число n (целое, положительное). Затем, с помощью цикла do-while вычислить сумму следующего ряда:

$S = 1 + \dfrac{1}{2} + \dfrac{1}{3} +...+ \dfrac{1}{n}$

Значение суммы вывести в консоль в виде вещественного числа с точностью до сотых.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.3.4

```c
#include <stdio.h>

int main(void) {
    int n, i = 1;
    double res = 0;

    scanf("%d", &n);

    do {
        res += 1 / (double)n;
    } while (++i <= n);

    printf("%.2lf", res);

    return 0;
}
```

### Подвиг 5*. Напишите программу игры "Угадай число". Задуманное целое число x в диапазоне [1; 1000] считывается из входного потока. Начальный диапазон сохраняется в переменных a = 1, b = 1000. Затем, генерируется случайное целое значение m в диапазоне [a; b]. Далее, рассматриваются три возможных исхода:

1. Если m == x, то программа завершается и в консоль выводится найденное значение x.
2. Если m < x, то корректируется интервал возможных значений a = m, b - без изменений.
3. Если m > x, то корректируется интервал возможных значений a - без изменений, b = m.

Процесс генерации продолжается (по циклу do-while), пока не будет угадано число x. Угаданное значение вывести в консоль в виде целого числа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.3.5

```c
#include <stdio.h>
#include <stdlib.h>

#define FIRST_DIGIT 1
#define LAST_DIGIT 1000

int main(void) {
    int a = FIRST_DIGIT;
    int b = LAST_DIGIT;
    int x, m;

    scanf("%d", &x);

    do {
        m = rand() % (b - a + 1) + a;
        if (m < x) a = m;
        if (m > x) b = m;
    } while (m != x);

    printf("%d", m);

    return 0;
}
```

```c
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    int x, m, a = 1, b = 1000;
    if(scanf("%d", &x) != 1)
    {
        printf("Error input.\n");
        return 0;
    }
    do{
        m = rand() % (b - a + 1) + a;
        m < x && (a = m);
        m > x && (b = m);
    } while (x != m);
    printf("%d",x);
    return 0;
}
```

### Подвиг 6. Используя вложенные циклы (любые), вывести в консоль из звездочек (*) следующую фигуру (пробелы не использовать):

*
**
***
****

Число выводимых строк определяется целочисленной переменной n (натуральное число), значение которой считывается из входного потока.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.3.6

```c
#include <stdio.h>

int main(void) {
    int n;

    scanf("%d", &n);

    for (int i = 0; i < n; i++) {
        for (int j = i; j >= 0; j--) {
            printf("*");
        }
        printf("\n");
    }

    return 0;
}
```

Вложенные циклы - это квадратичная сложность.

```c
#include <stdio.h>

char st[100];

int main(void) {
    int n = 0;

    scanf("%d", &n);

    for (int i = 0; i < n; i++) {
        st[i] = '*';
        st[i + 1] = '\n';
        printf(st);
    }
    return 0;
}
```

```c
#include <stdio.h>

int main(void) {
    int lines, cnt = 0;
    scanf("%d", &lines);
    while (cnt++ < lines) {
        for (int i = 0; i < cnt; i++) {
            putchar(0x2A);
        }
        putchar(0x0A);
    }
}
```

### Подвиг 7. Используя вложенные циклы (любые), вывести в консоль из звездочек (*) следующую симметричную фигуру:

   *
  ***
 *****
*******

Число выводимых строк определяется целочисленной переменной n (натуральное число), значение которой считывается из входного потока. Перед звездочками (в начале строк) прописываются пробелы (кроме последней строки). После звездочек никаких пробелов не должно быть.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.3.7

```c
#include <stdio.h>

int main(void) {
    int n;

    scanf("%d", &n);

    for (int i = 0; i <= n; i++) {
        for (int j = 0; j <= n - i - 1; j++) {
            printf(" ");
        }
        for (int j = i * 2 - 1; j > 0; j--) {
            printf("*");
        }
        printf("\n");
    }

    return 0;
}
```

```c
#include <stdio.h>

char sp[100];

int main(void) {
    int n = 0;
    memset(sp, ' ', 100);
    scanf("%d", &n);

    for (int i = 0; i < n; i++) {
        sp[n - 1 + i] = '*';
        sp[n - 1 - i] = '*';
        sp[n + i] = '\n';
        sp[n + i + 1] = 0x00;
        printf(sp);
    }
    return 0;
}
```

```c
/*
------*
-----***
----*****
---*******
--*********
-***********
*************
n=7

номер  число    число
строки пробелов звезд
1       6       2-1=1
2       5       4-1=3
3       4       6-1=5
4       3       8-1=7
5       2       10-1=9
6       1       12-1=11
7       0       14-1=13
*/

#include <stdio.h>
int main() {
    int n;
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n - i; j++) printf(" ");
        for (int j = 1; j <= 2 * i - 1; j++) printf("*");
        printf("\n");
    }
    return 0;
}
```

### Подвиг 8 (на повторение). Напишите программу, которая среди целых положительных трехзначных чисел в диапазоне от a до b включительно, выбирает только те, у которых все цифры разные. Значения a, b читаются из входного потока, записанные в одну строчку через пробел. Выведите в консоль все найденные числа с неповторяющимися цифрами в одну строчку через пробел в порядке возрастания.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.3.8

```c
#include <stdio.h>

int main(void) {
    int m, n;

    scanf("%d %d", &m, &n);

    for (int i = m; i <= n; i++) {
        int a = i / 100;
        int b = (i - a * 100) / 10;
        int c = i % 10;

        if (a != b && a != c && c != b) {
            printf("%d ", i);
        }
    }
    return 0;
}
```

### Подвиг 9. Напишите программу, которая читает из входного потока два натуральных числа m, n (m < n), записанных в одну строчку через пробел. Необходимо вывести в консоль в одну строчку через пробел все найденные числа-палиндромы в диапазоне [m; n]. Число-палиндром - это число, которое не меняет своего значения при чтении слева-направо и справа-налево. Например, числа 121, 1, 11, 43034 - палиндромы.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.3.9

```c
#include <stdio.h>

int main(void) {
    int m, n;

    scanf("%d %d", &m, &n);

    for (int i = m; i <= n; i++) {
        int icopy = i, reverse = 0;

        while (icopy) {
            reverse = reverse * 10 + icopy % 10;
            icopy /= 10;
        }

        if (i == reverse) {
            printf("%d ", i);
        }
    }
    return 0;
}
```

### Подвиг 10. Напишите программу, которая читает из входного потока натуральные числа m, n, k, записанные в одну строчку через пробел. Используя их, необходимо вычислить следующую сумму ряда:

![04](/Good_good_C_C++/img/04_01.png)

```c
#include <math.h>
#include <stdio.h>

int main(void) {
    int m, n, k;

    scanf("%d %d %d", &m, &n, &k);

    double sum = 0;

    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            for (int t = 1; t <= k; t++) {
                sum += j * j / (double)(pow(i + t, 3) - t);
            }
        }
    }
    sum /= m + n + k;

    printf("%.4lf", sum);

    return 0;
}
```

# 4.4 Операторы break, continue и goto

На прошлых занятиях мы подробно разобрали работу трех операторов цикла: `while`, `for` и `do-while`. Также увидели как можно формировать вложенные циклы и примеры задач, где это может пригодиться. На этом заключительном занятии по циклам разберем следующие управляющие операторы, которые можно использовать в любом операторе цикла:
+ `break` – досрочное прерывание работы оператора цикла;
+ `continue` – пропуск итерации тела цикла;
+ `goto` – безусловный переход по метке.

## Оператор break

Начнем с оператора `break`. Предположим, нам нужно написать программу подсчета суммы вещественных чисел, пока пользователь вводит положительные числа. Как только он введет отрицательное значение, подсчет суммы завершается с выводом результата на экран. Такую программу можно реализовать следующим образом:

```c
#include <stdio.h>

int main(void) {
    double x, s = 0.0;

    while (scanf("%lf", &x) == 1) {
        if (x < 0) break;

        s += x;
    }

    printf("s = %.2f\n", s);

    return 0;
}
```

Вначале объявляются две вспомогательные переменные:
+ x – для ввода текущего вещественного значения;
+ s – для подсчета суммы вещественных положительных чисел. 

Далее запускается цикл `while`, который работает, пока вводятся корректные числовые значения. В теле цикла идет проверка, если введенное значение `x` отрицательное, то срабатывает оператор `break`. Этот оператор завершает работу цикла `while` и управление передается следующему оператору `printf()`. Если же введенное число неотрицательное, то выполняется подсчет суммы.

Как видите, все предельно просто. Для примера, если в этой программе убрать условие и записать оператор `break` в теле цикла, то цикл `while` гарантированно будет прерываться на первой же итерации.

Конечно, эту же программу можно было бы записать и без оператора break, изменив условие цикла:

```c
    while(scanf("%lf", &x) == 1 && x >= 0) {
        s += x;
    }
```

Возможно, даже любую программу можно составить без оператора `break`. Но его использование может заметно облегчить написание и понимание логики программы. Именно с этой целью он и введен в язык Си, да и во многие другие языки высокого уровня.

Отмечу здесь еще один распространенный способ прерывания работы цикла. Если вместо `break` записать оператор `return`:

```c
    while(scanf("%lf", &x) == 1) {
        if(x < 0) return 0;
        s += x;
    }
```

то для цикла `while` эффект будет такой же, как и от оператора `break`. 

Но, правда, есть и существенное отличие. 

Как мы уже знаем, оператор `return` завершает выполнение функции. 

В данном случае функции `main()`. Поэтому, как только пользователь введет отрицательное число, то программа просто завершится, результат на экран выведен не будет, так как все операторы после `while` уже не сработают. 

В этом ключевое отличие между `break` и `return`. 

Оператор `break` позволяет продолжить выполнение функции, и управление передается следующему оператору после цикла. 

А при `return` текущая функция завершается сразу. 

На самом деле, оператор `return` завершает работу функции и лишь, как следствие, прерывает работу цикла. По той же логике оператор `return` можно для завершения работы оператора `switch`, о котором мы с вами ранее уже говорили. И вообще, с помощью `return` можно прервать работу чего угодно в пределах функции.

## Оператор continue

Следующий оператор `continue` прерывает лишь текущую итерацию цикла. Давайте я покажу принцип его работы на конкретном примере. Пусть мы также вводим с клавиатуры целые числа и хотим вычислить сумму только нечетных чисел. Сделать это можно следующим образом:

```c
#include <stdio.h>

int main(void) {
    int x, s = 0;

    while (scanf("%d", &x) == 1 && x != 0) {
        if (x % 2 == 0) continue;

        s += x;
    }

    printf("s = %d\n", s);

    return 0;
}
```

Начало вам уже знакомо, а дальше записан цикл `while`, который работает пока пользователь вводит корректные данные или не введет число `0`. Затем, в теле цикла стоит проверка на четность введенного числа x и если оно четно, то выполняется оператор `continue`. Как только встретился этот оператор, все остальные после него операторы тела цикла пропускаются и мы переходим к следующей итерации цикла `while`. В результате, сумма будет вычисляться только для нечетных значений.

Конечно, опят же, эту программу можно было бы реализовать и без оператора `continue`, например, так:
```c
    while(scanf("%d", &x) == 1 && x != 0) {
        if(x % 2 != 0) s += x;
    }
```

И это вполне рабочий вариант. Здесь все как и с оператором `break`. Оператор `continue` введен для удобства программирования и его следует использовать тогда, когда он позволяет упростить логику программы и сделать ее более читабельной.

Оператор `continue`, равно как и оператор `break` можно использовать не только в цикле `while`, но и в циклах `for` и `do-while`. Например, если нам нужно из диапазона целых чисел `[1; 100]` отобразить только те, что кратны `3` и `5` одновременно, то это можно сделать следующим образом:

```c
#include <stdio.h>

int main(void) {
    for (int i = 1; i <= 100; ++i) {
        if (i % 3 != 0 || i % 5 != 0) continue;

        printf("%d ", i);
    }

    return 0;
}
```

Это учебный пример. В этой задаче использование оператора `continue` избыточно и проще было бы вызывать функцию `printf()` по обратному условию. Я лишь показываю, что операторы `continue` и `break` допустимо применять с любыми операторами циклов.

## Оператор goto

Последний оператор, который мы рассмотрим на этом занятии, это `goto`. Он позволяет передать управление любому другому оператору по указанной метке в пределах текущей функции (в пределах той функции, в которой вызывается данный оператор).

На многих обучающих курсах и учебной литературе по языку Си сразу оговаривается, что оператор `goto` не следует использовать в своих программах, особенно, начинающим программистам. 
И я с этим полностью согласен! 

Но, существует, по крайне мере, одна ситуация, когда применение этого оператора оправданно. Это прерывание работы вложенных циклов. Давайте я детально поясню о чем здесь речь, а позже отмечу, почему все же оператор `goto` лучше не использовать в своих программах.

Итак, предположим, что мы вычисляем двойную сумму вида:

![04](/Good_good_C_C++/img/04_02.png)

и хотим прервать вычисления как только слагаемое `i-j` будет больше нуля. Такую программу можно реализовать следующим образом:

```c
#include <stdio.h>

int main(void) {
    int s = 0;
    for (int i = 1; i <= 10; ++i)
        for (int j = 7; j >= 5; --j) {
            if (i - j > 0) goto exit_sum;
            s += i - j;
        }

exit_sum:
    printf("s = %d\n", s);

    return 0;
}
```

Смотрите, здесь два цикла, один вложен в другой. В теле второго цикла выполняется проверка на положительность значения `i-j`. 

Если это так, то по условию задания нам нужно прервать работу обоих циклов и завершить подсчет суммы. Как раз для этого удобно воспользоваться оператором `goto` и по метке `exit_sum` (имя мы придумываем сами) переходим к оператору `printf()`, стоящему после этих циклов. В результате такого перехода работа циклов будет завершена.

Возможно, некоторые из вас сейчас в недоумении смотрят на эту программу и задаются вопросом: а почему бы здесь не использовать оператор `break`, он же как раз и позволяет прервать цикл? Все верно, цикл (один цикл) он может прервать и если записать программу в виде:

```c
    for(int i = 1; i <= 10; ++i) {
        for(int j = 7; j >= 5; --j) {
            if(i-j > 0) break;
            s += i - j;
        }
    }
```
то по условию завершится работа внутреннего цикла, но внешний продолжит работать и на новой итерации опять запустит внутренний цикл. 

Очевидно, это не то, что нам нужно. 

Запомните, оператор `break` прерывает только один текущий цикл и не более того. 

Начинающие программисты здесь часто делают ошибку. Поэтому в нашей задаче вместо `break` используется оператор `goto` и, как мы видели, он позволяет прервать и два и три и более вложенных циклов при переходе по метке за их пределы, но в пределах текущей функции.

Это тот редкий случай, когда применение этого оператора оправданно. Но почему тогда к этому оператору такое негативное отношение со стороны программистского сообщества языка Си? 

Все очень просто. 

Если злоупотреблять использованием этого оператора, то логика работы программы очень быстро становится очень запутанной, настолько, что даже сам автор перестанет в ней ориентироваться. 

Соответственно читать и редактировать такие программы чрезвычайно сложно.

Второй момент связан с компиляцией. Если программа написана без операторов `goto`, то, скорее всего, при более-менее грамотном подходе к программированию, на выходе получим качественный машинный код, который будет выполняться предельно быстро. Если же в программе присутствуют постоянные переходы `goto`, то никто не даст гарантии качественной трансляции такого текста в машинный код. 

Соответственно, главный плюс языка Си сходит на нет: исполняемый файл не оптимизирован для быстрого выполнения на текущей архитектуре компьютера.

Чтобы гарантированно избежать этих недостатков при построении программ, стоит совсем отказаться от применения оператора `goto`. Исключение может составлять необходимость прерывания сразу нескольких вложенных циклов. Хотя и здесь мы могли бы обойтись без этого оператора. Часто логику вложенных циклов реализуют в отдельных функциях. И как только появляется необходимость прервать их работу, завершают функцию оператором `return`. Это более частый вариант по сравнению с оператором `goto`. Именно так я рекомендую поступать при проектировании своих программ.

Видео по теме [#25. Операторы break, continue и goto](https://www.youtube.com/watch?v=E_yEgucuFyw&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Установите соответствия между операторами и их описаниями.

![04](/Good_good_C_C++/img/04_03.PNG)

### Подвиг 2. Допишите программу, в которой проверяется, что текущие координаты x, y не выходят за диапазон [1; n] - для x и [1; m] - для y. Если условие не выполняется (хотя бы одна координата выходит из диапазона), то функция printf() не должна выполняться. Реализовать эту логику с использованием оператора continue.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.4.2

```c
#include <stdio.h>

int main(void) {
    int n = 5, m = 7;
    int total = 5;

    for (int i = 0; i < total; ++i) {
        int x, y;
        scanf("%d, %d", &x, &y);

        if (x >= 1 && x <= n && y >= 1 && y <= m) {
            printf("(%d, %d)\n", x, y);
        } else
            continue;
    }

    return 0;
}
```

### Подвиг 3. На каждой итерации цикла из входного потока читается по одному целому числу. Необходимо подсчитать произведение только положительных чисел, до тех пор, пока не встретится число 0. Реализовать пропуск вычислений (для отрицательных чисел) с помощью оператора continue, а также использовать цикл while или do-while. Если нет ни одного положительного значения, то произведение должно быть равно 1. Результат произведения вывести в консоль в виде одного целого числа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.4.3

```c
#include <stdio.h>

int main(void) {
    int n, res = 1;

    while (scanf("%d", &n) == 1 && n != 0) {
        if (n < 0)
            continue;
        else
            res *= n;
    }
    printf("%d", res);
    return 0;
}
```

### Подвиг 4. Написать программу, которая читает из входного потока натуральное число n. Вывести в консоль в одну строчку через пробел все целые числа, начиная с 1, квадраты которых меньше числа n. Прерывание цикла реализовать с помощью оператора break.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.4.4

```c
#include <stdio.h>

int main(void) {
    int n;

    scanf("%d", &n);

    for (int i = 1; i < n; i++) {
        if (i * i >= n) break;
        printf("%d ", i);
    }
    return 0;
}
```

### Подвиг 5. Напишите программу, которая читает из входного потока натуральное число n. Вычислите у этого числа все его простые множители (разложить число по простым множителям) и выведите их в порядке возрастания (неубывания) в одну строчку через пробел.

Например, число 140 = 2 * 2 * 5 * 7. В консоли должно отображаться 2 2 5 7.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.4.5

```c
#include <stdio.h>

int main(void) {
    int n, i = 2;

    scanf("%d", &n);
    while (n != 1) {
        while (n % i == 0) {
            n /= i;
            printf("%d ", i);
        }
        i++;
    }
    return 0;
}
```

### Подвиг 6. Напишите программу, которая читает из входного потока два натуральных числа n, m, записанных в одну строчку через пробел, и вычисляет следующую сумму:

![04](/Good_good_C_C++/img/04_04.png)

Сумма должна вычисляться до тех пор, пока слагаемое `i+j` меньше `10`. Как только `i+j` окажется равно или больше `10`, прервать подсчет суммы с помощью оператора `goto` и вывести результат (полученную сумму) в консоль в виде одного целого числа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.4.6

```c
#include <stdio.h>

int main(void) {
    int n, m, sum = 0;

    scanf("%d %d", &n, &m);
    for (int i = 0; i <= n; i++) {
        for (int j = 0; j <= m; j++) {
            if (i + j >= 10) goto end_of_sum;
            sum += i + j;
        }
    }
end_of_sum:
    printf("%d", sum);
    return 0;
}
```

### Подвиг 7. Повторите программу из предыдущего 6-го подвига, только прерывание вложенного цикла выполните с помощью оператора break. (Прерывается только вложенный цикл, не внешний.) Оцените, как при этом изменится логика работы программы.

Еще раз формулировка подвига. Напишите программу, которая читает из входного потока два натуральных числа n, m и вычисляет следующую сумму:

![04](/Good_good_C_C++/img/04_04.png)

Сумма должна вычисляться до тех пор, пока слагаемое i+j меньше 10. Как только i+j окажется равно или больше 10, прервать подсчет суммы с помощью оператора break и вывести результат (полученную сумму) в консоль в виде одного целого числа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.4.7

```c
#include <stdio.h>

int main(void) {
    int n, m, sum = 0;

    scanf("%d %d", &n, &m);
    for (int i = 0; i <= n; i++) {
        for (int j = 0; j <= m; j++) {
            if (i + j >= 10) break;
            sum += i + j;
        }
    }

    printf("%d", sum);
    return 0;
}
```

### Подвиг 8. Напишите программу, которая читает из входного потока натуральное число n. Определить, является ли число n простым (то есть, делится нацело только на само себя и на 1). Вывести на экран "yes", если n простое и "no" - в противном случае.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.4.8

```c
#include <math.h>
#include <stdio.h>

int main(void) {
    int n;

    scanf("%d", &n);

    char res = 1;
    // проверим ввод на 1 и 2
    if (n == 1 || n == 2)
        ;
    // откинем все четные числа
    else if (n % 2 == 0) {
        res = 0;
    } else {
    // проверять будем от 3 до квадратного корня из числа с шагом 2
        for (int i = 3; i < sqrt(n); i += 2) {
            if (n % i == 0) {
                res = 0;
                break;
            }
        }
    }

    printf("%s", res ? "yes" : "no");
    return 0;
}
```

### Подвиг 9 (на повторение). Выберите все верные утверждения для следующего фрагмента программы:

```c
#include <stdio.h>

#define MUL(X, Y) X* Y
#define ADD(X, Y) ((X) + (Y))
#define T_ADD(X, Y) "Adding two values " #X " and " #Y
#define RES_N(RES) res_##RES

int main(void) {
    int a = 2, b = 5;
    int res_1 = MUL(7, b);
    int res_2 = MUL(a + 2, b - 1);
    int res_3 = ADD(7, b * 2);
    printf(T_ADD(i, j) "\n");
    printf("%d %d %d", RES_N(1), RES_N(2), RES_N(3));

    return 0;
}
```

+ [ ] вызов макрос-функции T_ADD(i <> 2, j == 3) приведет к синтаксической ошибке
+ [x] операция # возвращает текстовое представление лексемы X
+ [x] вызов макро-функции ADD(X, Y) всегда будет давать корректные результаты сложения двух числовых выражений
+ [x] действие макроопределений распространяется только на текущий модуль
+ [x] операция ## служит для склейки двух лексем в одну
+ [x] макрос-функция T_ADD(i <> 2, j == 3) вернет строку "Adding two values i <> 2 and j == 3"
+ [ ] вызов макро-функции MUL(7, b) приведет к не верным результатам вычисления произведения 7 * b
+ [x] вызов макро-функции MUL(a + 2, b - 1) приведет к не верным результатам вычисления произведения (a+2) * (b-1)

### Подвиг 10 (на повторение). Выберите все верные утверждения, касающиеся макроопределений.

+ [x] имена макросов принято записывать заглавными буквами
+ [x] макроопределение формально должно быть записано в одну строчку (до символа переноса строки)
+ [x] макроопределения обрабатываются до непосредственной компиляции программы
+ [x] при компиляции программы текстовый препроцессор вместо имени макроса подставляет его определение (тело макроса)
+ [ ] директива #undef создает макроопределение, а директива #define отменяет существующее макроопределение
+ [ ] макроопределения обрабатываются после компиляции программы (перевода в машинный код)
+ [x] директива #define создает макроопределение, а директива #undef отменяет существующее макроопределение

# 4.5 Указатели. Проще простого