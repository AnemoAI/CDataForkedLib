# 4. Операторы циклов. Указатели

## 4.1 Оператор цикла while

На этом занятии начнем знакомиться с еще одной ключевой конструкцией – циклами. Вначале, давайте я на простом примере покажу, о чем идет речь. Представим, что пользователь вводит с клавиатуры целое положительное значение n и нам нужно вычислить следующую сумму:

$1^2 + 2^2 + 3^2 + 4^2 + ... + n^2$

Понятно, что мы не можем заранее прописать всю эту сумму, так как значение `n` попросту неизвестно на момент написания программы. Переменная `n` принимает конкретное значение только в процессе выполнения программы. Поэтому реализовать такую конструкцию можно только с помощью операторов циклов.

В общем случае циклы позволяют реализовывать некие повторяющиеся действия. Например, предположим, что маленькие панды прыгают с горки в течение часа, пока мама-панда не позовет всех к столу – кушать. Формализовать это можно, например, так:

```
цикл (пока не прошел час):
      прыгаем с горки
```

То есть, пока истинно условие, цикл работает, как только условие становится ложным (прошел час) цикл завершается. Ровно так работает цикл `while`, о котором и пойдет речь на этом занятии. Он имеет, следующее определение (синтаксис):

```c
while(<условие>)
    оператор;
```

или

```c
while(<условие>) {
    оператор 1;
    ...
    оператор N;
}
```

В программировании оператор или блок операторов, выполняющихся в цикле, называют телом цикла. А один проход выполнения оператора цикла – итерацией. Сам цикл `while` относится к циклам с предусловием, т.к. сначала проверяется условие цикла и только после этого (при истинности условия) выполняется текущая итерация.

Давайте вернемся к исходной задаче – вычисления суммы квадратов целых чисел от `1` до `n` и посмотрим, как здесь можно использовать цикл `while`:

```c
#include <stdio.h>
 
int main(void) {
         int n;
         int s = 0;
 
         if(scanf("%d", &n) != 1) {
                   printf("Error input\n");
                   return 0;
         }
 
         while(n > 0) {
                   s += n*n;
                   n--;
         }
 
         printf("s = %d\n", s);
         
         return 0;
}
```

Вначале мы объявили две переменные `n` и `s`, причем, в `s` будет храниться сумма и она принимает начальное значение `0`. Затем, запрашивается ввод в переменную `n` и если он некорректен, то программа завершается. Иначе запускается цикл `while`. В круглых скобках прописано условие продолжения цикла: пока `n` больше нуля. А в теле цикла определены два оператора: сначала к переменной `s` прибавляем квадрат наибольшего значения `n`, а потом, уменьшаем переменную `n` на единицу. В результате у нас будет образовываться следующая сумма:

$s = n^2 + (n-1)^2 + … + 1^2$

Как только значение `n` становится равным `0`, условие цикла становится ложным и оператор `while` прекращает свою работу. Управление переходит к следующему оператору `printf()`.

Давайте теперь несколько изменим нашу программу и запишем цикл `while` следующим образом:

```c
         while(n-- > 0)
                   s += n*n;
```

Будет ли это тем же самым или программа станет работать по другому? Проверим это. Запустим и введем число 4. Получим сумму:

```c
s = 14
```

Очевидно это не вся прежняя сумма:

$s = 1^2 + 2^2 + 3^2 + 4^2 = 30$

У нас не хватает последнего слагаемого $4^2 = 16$. 

Почему так произошло? 

Все просто. Сначала выполняется сравнение переменной `n` с нулем (4 > 0) и после этого операция декремента. То есть, когда выполнение программы переходит к оператору `s += n*n;` тела цикла переменная `n` уже на единицу меньше. Возможно, некоторых из вас это удивит, так как операция декремента записана в постфиксной форме (после имени переменной), а значит, она должна выполняться в последнюю очередь. 

Но логика работы здесь несколько иная. 

Любое выражение, которое прописывается в условии, сначала полностью вычисляется и только затем осуществляется переход к телу цикла. 

И это всегда так. 

Этот важный момент нужно запомнить и знать. Именно поэтому переменная `n` гарантированно будет уменьшена на единицу при переходе к оператору `s += n*n;`.

Кстати, последнее слагаемое в нашем примере будет `0^2 = 0`. Поэтому (если ноль нам не нужен) правильнее было бы прописать эту условие так:

```c
         while(--n > 0)
                   s += n*n;
```

Префиксная форма записи операции декремента сначала уменьшит значение `n` на единицу и только после этого будет осуществляться сравнение с нулем.

Давайте теперь немного усложним программу и сделаем ограничение на максимальное значение `n` на тот случай, если пользователь введет слишком большое число. Например, сделаем так, чтобы слагаемых было не больше `10`:

```c
         int i = 0;
         while(++i <= n && i <= 10)
                   s += i*i;
```

Условие в цикле `while` пришлось переписать с использованием дополнительной вспомогательной переменной `i`, которая, по сути, является счетчиком итераций. Ее первое значение при подсчете суммы будет равно `1`, затем, `2` и так пока либо не дойдет до `n`, либо до `10`.

Давайте внимательнее посмотрим на условие. Вначале записана операция инкремента в префиксной форме. 

Это означает, что значение переменной `i` увеличится на единицу и только потом выполнится операция сравнения. 

Мало того, здесь мы можем точно гарантировать, что операция инкремента (в любой форме записи: префиксной или постфиксной) отработает до перехода к следующей проверке `i <= 10`. Так заложено в стандарте языка Си. И это правило справедливо для всех логических связок:

`&&` и `||`

где бы они ни использовались: в операторах циклов или условных операторах.

Благодаря этому мы можем четко понимать, как отработает данный цикл. Вначале обязательно увеличится значение переменной `i` на единицу, затем, проверится условие `i <= n` и только после этого (при необходимости) будет проверяться второе подусловие `i <= 10`.

Вообще, в качестве условия цикла `while` можно записывать любое выражение.

Например, мы хотим считывать целые числа с клавиатуры, пока пользователь не введет `0`. Сделать это можно следующим образом:

```c
#include <stdio.h>
 
int main(void) {
         int s = 0;
         int x = 1;
 
         while(scanf("%d", &x) == 1 && x != 0)
                   s += x;
 
         printf("s = %d\n", s);
         
         return 0;
}
```

Здесь цикл `while` будет работать до тех пор, пока пользователь либо вводит корректные данные (целые числа), либо введет число `0`. В самом цикле выполняется суммирование введенных числовых значений, а после цикла отображение полученного результата с помощью функции `printf()`.

Или можно немного усложнить пример и выполнять суммирование только четных чисел (или только положительных). Для этого достаточно внутри цикла `while` указать нужное нам условие, например, следующим образом:

```c
    while(scanf("%d", &x) == 1 && x != 0)
        if(x % 2 == 0)
            s += x;
```

То есть, в теле цикла `while` можно прописывать абсолютно любые операторы языка Си. И, обратите внимание, в данном случае мы не указывали фигурные скобки, т.к. в теле цикла формально записан один оператор `if`, а для одного оператора фигурные скобки не обязательны. Хотя, при желании их можно записать:

```c
    while(scanf("%d", &x) == 1 && x != 0) {
        if(x % 2 == 0)
            s += x;
    }
```

Программа от этого не изменится.

В заключение занятия отмечу один важный момент использования операторных фигурных скобок. Обычная переменная, объявленная внутри них, например:

```c
    while(scanf("%d", &x) == 1 && x != 0) {
        int res = x % 2;
        if(res == 0)
            s += x;
    }
```

существует только в пределах этих операторных скобок и перестает существовать, когда выполнение программы перейдет к следующему оператору за пределами этих фигурных скобок. То есть, если мы захотим вывести значение переменной `res` после цикла `while`:

```c
printf("res = %d\n", res);
```

то при компиляции возникнет ошибка, что переменная `res` не определена.

На самом деле, это очень полезное поведение, заложенное в язык Си. На практике часто внутри фигурных скобок объявляют временные переменные, необходимые для отработки внутренней логики. Потом они просто автоматически исчезают и не мешают работе остальной программы. Обо всем этом мы еще подробнее будем с вами говорить, когда речь пойдет о локальных и глобальных переменных.

На этом завершим первое занятие по циклам. Из него вам должно быть понятно для чего вообще нужны циклы и как работает оператор цикла `while`.

Видео по теме [#22. Оператор цикла while](https://www.youtube.com/watch?v=_xBLgSOGnU0&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, касающиеся оператора цикла while.

+ [ ] оператор while проверяет условие цикла после выполнения очередной итерации
+ [x] каждое выполнение операторов тела цикла называется итерацией цикла
+ [x] цикл while работает пока истинно условие цикла
+ [x] операторы, которые выполняются каждый цикл, образуют тело цикла
+ [x] оператор while проверяет условие цикла до выполнения очередной итерации
+ [ ] цикл while работает пока ложно условие цикла

### Подвиг 2. Чему будет равна переменная s после выполнения следующей программы?

P.S. Ответ вычислить без программирования и запуска программы.

```c
#include <stdio.h>

int main(void) {
    int count = 0;
    int s = 0;

    while (count++ <= 5) s += count;

    printf("%d", s);

    return 0;
}
```

$21$

### Подвиг 3. Напишите программу, которая последовательно читает из входного потока stdin целые числа, записанные через пробел, пока не встретится число 0. Вывести на экран все читаемые значения возведенные в квадрат в одну строчку через пробел. В программе следует использовать только одну целочисленную переменную.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.1.3

```c
#include <stdio.h>

int main(void) {
    int x;

    while (scanf("%d", &x) == 1 && x != 0) printf("%d ", x * x);

    return 0;
}
```

### Подвиг 4. Напишите программу, которая читает из входного потока натуральное число n (целое, положительное). Вычислите с помощью цикла while сумму ряда:

$S = \dfrac{1}{1^2} + \dfrac{1}{2^2} + \dfrac{1}{3^2} +...+ \dfrac{1}{n^2}$ 

Выведите результат в консоль в виде вещественного числа с точностью до тысячных.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.1.4

```c
#include <stdio.h>

int main(void) {
    int x;
    double sum;

    scanf("%d", &x);

    while (x > 0) {
        sum += 1.0 / (x * x);
        x--;
    }

    printf("%.3lf", sum);

    return 0;
}
```

### Подвиг 5. Напишите программу, которая читает из входного потока натуральное число n (целое, положительное), которое содержит от 2-х и более цифр. Используя цикл while, вычислить сумму цифр числа n. Результат вывести в консоль в виде одного целого числа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.1.5

```c
#include <stdio.h>

int main(void) {
    int x, sum;

    scanf("%d", &x);

    while (x > 0) {
        sum += x % 10;
        x /= 10;
    }

    printf("%d", sum);

    return 0;
}
```

```c
#include <stdio.h>
int main() {
    int n, s = 0;
    while(scanf("%1d", &n)==1) s += n;
    printf("%d", s);
    return 0;
}
```

### Подвиг 6. Последовательность Фибоначчи образуется так: первые два числа равны 1 и 1, а каждый следующий равен сумме двух предыдущих. То есть, имеем последовательность вида: 1, 1, 2, 3, 5, 8, 13, ... Вычислите последовательность Фибоначчи длиной n (n - натуральное число, читаемое из входного потока). Выведите числа полученной последовательности в одну строку через пробел.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.1.6

```c
#include <stdio.h>

int main() {
    int x, num0 = 0, num1 = 1, num = 1, counter = 0;

    scanf("%d", &x);

    while (counter != x) {
        printf("%d ", num);
        num = num0 + num1;
        num0 = num1;
        num1 = num;
        counter++;
    }

    return 0;
}
```

### Подвиг 7. Напишите программу, которая читает из входного потока два натуральных числа n и m, записанных через пробел, причем n < m. Выведите в консоль в одну строчку через пробел все числа кратные 3 (нацело делятся на 3) из интервала [n, m].

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.1.7

```c
#include <stdio.h>

int main() {
    int n, m;

    scanf("%d %d", &n, &m);

    while (n <= m) {
        if (n % 3 == 0) printf("%d ", n);
        n++;
    }

    return 0;
}
```

### Подвиг 8. Напишите программу, которая среди всех натуральных трехзначных чисел (числа с тремя цифрами) находит те, которые при делении на 47 дают целый остаток 6 или при делении на 53 - целый остаток 45. Выведите в консоль все найденные трехзначные числа в порядке возрастания в одну строчку через пробел.

```c
#include <stdio.h>
#define LEFT 100
#define RIGHT 999

int main() {
    int n = LEFT;

    while (n <= RIGHT) {
        if (n % 47 == 6 || n % 53 == 45) printf("%d ", n);
        n++;
    }

    return 0;
}
```

### Подвиг 9. Напишите программу, которая читает натуральное число, содержащее одну и более цифр. Определить, что это число является палиндромом, то есть, оно не меняет своего значения при просмотре слева-направо и справа-налево. Например: 121, 23032, 11 и т.п. Если число является палиндромом, то в консоль вывести строку "yes", иначе - строку "no".

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.1.9

```c
#include <math.h>
#include <stdio.h>

int main() {
    int count = 0, n;

    scanf("%d", &n);

    // посчитаем количество знаков в числе
    int ncopy = n;

    while (ncopy > 0) {
        ncopy /= 10;
        count++;
    }

    count--;

    char res = 1;

    while (n >= 10) {
        // вычислим первую и последнюю цифры и сравним их
        int a = n / pow(10, count);
        int b = n % 10;
        // printf("%d %d\n", a, b); // проверочная печать
        if (a != b) { // если не равны выходим из цикла с res = 0
            res = 0;
            break; 
        }
        // откидываем от n первую и последнюю цифры
        n -= a * pow(10, count);
        n /= 10;
        // printf("%d\n", n); // проверочная печать
        // уменьшаем счетчик знаков
        count -= 2;
    }
    // печатаем через тернарный оператор ответ
    printf("%s", res ? "yes" : "no");

    return 0;
}
```

```c
#include <stdio.h>

int main(void)
{    
    int num_o;
    scanf("%d", &num_o);
    
    int reversed = 0;
    int num = num_o;
    while(num != 0){
        int r = num % 10;
        reversed = reversed * 10 + r;
        num /=10;
    }   
    (num_o == reversed) ? printf("yes") : printf("no");
    
    return 0;
}
```

### Подвиг 10*. Напишите программу, которая вычисляет наибольший общий делитель (НОД) двух натуральных чисел a, b по алгоритму Евклида. Алгоритм реализуется по следующей схеме:

Шаг 1. Читаем из входного потока два натуральных числа a, b, записанных в одну строчку через пробел.
Шаг 2. Определяем наименьшее из двух чисел a, b
Шаг 3. Делаем цикл: пока меньшее число больше 0
Шаг 4.         большему числу присваиваем целый остаток от деления на меньшее число; (используется операция %)
Шаг 5.         большее число становится меньшим, а меньшее - большим
Шаг 6. Большее число выводим в консоль в виде одного числа.

```c
#include <stdio.h>

int main() {
    int a, b;

    scanf("%d %d", &a, &b);

    while (b > 0) {
        if (a > b) {
            int tmp = a;
            a = b;
            b = tmp;
        }
        b %= a;
    }

    printf("%d", a);
    return 0;
}
```

# 4.2 Оператор цикла for

