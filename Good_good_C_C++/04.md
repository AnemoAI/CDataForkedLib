# 4. Операторы циклов. Указатели

# 4.1 Оператор цикла while

На этом занятии начнем знакомиться с еще одной ключевой конструкцией – циклами. Вначале, давайте я на простом примере покажу, о чем идет речь. Представим, что пользователь вводит с клавиатуры целое положительное значение n и нам нужно вычислить следующую сумму:

$1^2 + 2^2 + 3^2 + 4^2 + ... + n^2$

Понятно, что мы не можем заранее прописать всю эту сумму, так как значение `n` попросту неизвестно на момент написания программы. Переменная `n` принимает конкретное значение только в процессе выполнения программы. Поэтому реализовать такую конструкцию можно только с помощью операторов циклов.

В общем случае циклы позволяют реализовывать некие повторяющиеся действия. Например, предположим, что маленькие панды прыгают с горки в течение часа, пока мама-панда не позовет всех к столу – кушать. Формализовать это можно, например, так:

```
цикл (пока не прошел час):
      прыгаем с горки
```

То есть, пока истинно условие, цикл работает, как только условие становится ложным (прошел час) цикл завершается. Ровно так работает цикл `while`, о котором и пойдет речь на этом занятии. Он имеет, следующее определение (синтаксис):

```c
while(<условие>)
    оператор;
```

или

```c
while(<условие>) {
    оператор 1;
    ...
    оператор N;
}
```

В программировании оператор или блок операторов, выполняющихся в цикле, называют телом цикла. А один проход выполнения оператора цикла – итерацией. Сам цикл `while` относится к циклам с предусловием, т.к. сначала проверяется условие цикла и только после этого (при истинности условия) выполняется текущая итерация.

Давайте вернемся к исходной задаче – вычисления суммы квадратов целых чисел от `1` до `n` и посмотрим, как здесь можно использовать цикл `while`:

```c
#include <stdio.h>
 
int main(void) {
         int n;
         int s = 0;
 
         if(scanf("%d", &n) != 1) {
                   printf("Error input\n");
                   return 0;
         }
 
         while(n > 0) {
                   s += n*n;
                   n--;
         }
 
         printf("s = %d\n", s);
         
         return 0;
}
```

Вначале мы объявили две переменные `n` и `s`, причем, в `s` будет храниться сумма и она принимает начальное значение `0`. Затем, запрашивается ввод в переменную `n` и если он некорректен, то программа завершается. Иначе запускается цикл `while`. В круглых скобках прописано условие продолжения цикла: пока `n` больше нуля. А в теле цикла определены два оператора: сначала к переменной `s` прибавляем квадрат наибольшего значения `n`, а потом, уменьшаем переменную `n` на единицу. В результате у нас будет образовываться следующая сумма:

$s = n^2 + (n-1)^2 + … + 1^2$

Как только значение `n` становится равным `0`, условие цикла становится ложным и оператор `while` прекращает свою работу. Управление переходит к следующему оператору `printf()`.

Давайте теперь несколько изменим нашу программу и запишем цикл `while` следующим образом:

```c
         while(n-- > 0)
                   s += n*n;
```

Будет ли это тем же самым или программа станет работать по другому? Проверим это. Запустим и введем число 4. Получим сумму:

```c
s = 14
```

Очевидно это не вся прежняя сумма:

$s = 1^2 + 2^2 + 3^2 + 4^2 = 30$

У нас не хватает последнего слагаемого $4^2 = 16$. 

Почему так произошло? 

Все просто. Сначала выполняется сравнение переменной `n` с нулем (4 > 0) и после этого операция декремента. То есть, когда выполнение программы переходит к оператору `s += n*n;` тела цикла переменная `n` уже на единицу меньше. Возможно, некоторых из вас это удивит, так как операция декремента записана в постфиксной форме (после имени переменной), а значит, она должна выполняться в последнюю очередь. 

Но логика работы здесь несколько иная. 

Любое выражение, которое прописывается в условии, сначала полностью вычисляется и только затем осуществляется переход к телу цикла. 

И это всегда так. 

Этот важный момент нужно запомнить и знать. Именно поэтому переменная `n` гарантированно будет уменьшена на единицу при переходе к оператору `s += n*n;`.

Кстати, последнее слагаемое в нашем примере будет `0^2 = 0`. Поэтому (если ноль нам не нужен) правильнее было бы прописать эту условие так:

```c
         while(--n > 0)
                   s += n*n;
```

Префиксная форма записи операции декремента сначала уменьшит значение `n` на единицу и только после этого будет осуществляться сравнение с нулем.

Давайте теперь немного усложним программу и сделаем ограничение на максимальное значение `n` на тот случай, если пользователь введет слишком большое число. Например, сделаем так, чтобы слагаемых было не больше `10`:

```c
         int i = 0;
         while(++i <= n && i <= 10)
                   s += i*i;
```

Условие в цикле `while` пришлось переписать с использованием дополнительной вспомогательной переменной `i`, которая, по сути, является счетчиком итераций. Ее первое значение при подсчете суммы будет равно `1`, затем, `2` и так пока либо не дойдет до `n`, либо до `10`.

Давайте внимательнее посмотрим на условие. Вначале записана операция инкремента в префиксной форме. 

Это означает, что значение переменной `i` увеличится на единицу и только потом выполнится операция сравнения. 

Мало того, здесь мы можем точно гарантировать, что операция инкремента (в любой форме записи: префиксной или постфиксной) отработает до перехода к следующей проверке `i <= 10`. Так заложено в стандарте языка Си. И это правило справедливо для всех логических связок:

`&&` и `||`

где бы они ни использовались: в операторах циклов или условных операторах.

Благодаря этому мы можем четко понимать, как отработает данный цикл. Вначале обязательно увеличится значение переменной `i` на единицу, затем, проверится условие `i <= n` и только после этого (при необходимости) будет проверяться второе подусловие `i <= 10`.

Вообще, в качестве условия цикла `while` можно записывать любое выражение.

Например, мы хотим считывать целые числа с клавиатуры, пока пользователь не введет `0`. Сделать это можно следующим образом:

```c
#include <stdio.h>
 
int main(void) {
         int s = 0;
         int x = 1;
 
         while(scanf("%d", &x) == 1 && x != 0)
                   s += x;
 
         printf("s = %d\n", s);
         
         return 0;
}
```

Здесь цикл `while` будет работать до тех пор, пока пользователь либо вводит корректные данные (целые числа), либо введет число `0`. В самом цикле выполняется суммирование введенных числовых значений, а после цикла отображение полученного результата с помощью функции `printf()`.

Или можно немного усложнить пример и выполнять суммирование только четных чисел (или только положительных). Для этого достаточно внутри цикла `while` указать нужное нам условие, например, следующим образом:

```c
    while(scanf("%d", &x) == 1 && x != 0)
        if(x % 2 == 0)
            s += x;
```

То есть, в теле цикла `while` можно прописывать абсолютно любые операторы языка Си. И, обратите внимание, в данном случае мы не указывали фигурные скобки, т.к. в теле цикла формально записан один оператор `if`, а для одного оператора фигурные скобки не обязательны. Хотя, при желании их можно записать:

```c
    while(scanf("%d", &x) == 1 && x != 0) {
        if(x % 2 == 0)
            s += x;
    }
```

Программа от этого не изменится.

В заключение занятия отмечу один важный момент использования операторных фигурных скобок. Обычная переменная, объявленная внутри них, например:

```c
    while(scanf("%d", &x) == 1 && x != 0) {
        int res = x % 2;
        if(res == 0)
            s += x;
    }
```

существует только в пределах этих операторных скобок и перестает существовать, когда выполнение программы перейдет к следующему оператору за пределами этих фигурных скобок. То есть, если мы захотим вывести значение переменной `res` после цикла `while`:

```c
printf("res = %d\n", res);
```

то при компиляции возникнет ошибка, что переменная `res` не определена.

На самом деле, это очень полезное поведение, заложенное в язык Си. На практике часто внутри фигурных скобок объявляют временные переменные, необходимые для отработки внутренней логики. Потом они просто автоматически исчезают и не мешают работе остальной программы. Обо всем этом мы еще подробнее будем с вами говорить, когда речь пойдет о локальных и глобальных переменных.

На этом завершим первое занятие по циклам. Из него вам должно быть понятно для чего вообще нужны циклы и как работает оператор цикла `while`.

Видео по теме [#22. Оператор цикла while](https://www.youtube.com/watch?v=_xBLgSOGnU0&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, касающиеся оператора цикла while.

+ [ ] оператор while проверяет условие цикла после выполнения очередной итерации
+ [x] каждое выполнение операторов тела цикла называется итерацией цикла
+ [x] цикл while работает пока истинно условие цикла
+ [x] операторы, которые выполняются каждый цикл, образуют тело цикла
+ [x] оператор while проверяет условие цикла до выполнения очередной итерации
+ [ ] цикл while работает пока ложно условие цикла

### Подвиг 2. Чему будет равна переменная s после выполнения следующей программы?

P.S. Ответ вычислить без программирования и запуска программы.

```c
#include <stdio.h>

int main(void) {
    int count = 0;
    int s = 0;

    while (count++ <= 5) s += count;

    printf("%d", s);

    return 0;
}
```

$21$

### Подвиг 3. Напишите программу, которая последовательно читает из входного потока stdin целые числа, записанные через пробел, пока не встретится число 0. Вывести на экран все читаемые значения возведенные в квадрат в одну строчку через пробел. В программе следует использовать только одну целочисленную переменную.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.1.3

```c
#include <stdio.h>

int main(void) {
    int x;

    while (scanf("%d", &x) == 1 && x != 0) printf("%d ", x * x);

    return 0;
}
```

### Подвиг 4. Напишите программу, которая читает из входного потока натуральное число n (целое, положительное). Вычислите с помощью цикла while сумму ряда:

$S = \dfrac{1}{1^2} + \dfrac{1}{2^2} + \dfrac{1}{3^2} +...+ \dfrac{1}{n^2}$ 

Выведите результат в консоль в виде вещественного числа с точностью до тысячных.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.1.4

```c
#include <stdio.h>

int main(void) {
    int x;
    double sum;

    scanf("%d", &x);

    while (x > 0) {
        sum += 1.0 / (x * x);
        x--;
    }

    printf("%.3lf", sum);

    return 0;
}
```

### Подвиг 5. Напишите программу, которая читает из входного потока натуральное число n (целое, положительное), которое содержит от 2-х и более цифр. Используя цикл while, вычислить сумму цифр числа n. Результат вывести в консоль в виде одного целого числа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.1.5

```c
#include <stdio.h>

int main(void) {
    int x, sum;

    scanf("%d", &x);

    while (x > 0) {
        sum += x % 10;
        x /= 10;
    }

    printf("%d", sum);

    return 0;
}
```

```c
#include <stdio.h>
int main() {
    int n, s = 0;
    while(scanf("%1d", &n)==1) s += n;
    printf("%d", s);
    return 0;
}
```

### Подвиг 6. Последовательность Фибоначчи образуется так: первые два числа равны 1 и 1, а каждый следующий равен сумме двух предыдущих. То есть, имеем последовательность вида: 1, 1, 2, 3, 5, 8, 13, ... Вычислите последовательность Фибоначчи длиной n (n - натуральное число, читаемое из входного потока). Выведите числа полученной последовательности в одну строку через пробел.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.1.6

```c
#include <stdio.h>

int main() {
    int x, num0 = 0, num1 = 1, num = 1, counter = 0;

    scanf("%d", &x);

    while (counter != x) {
        printf("%d ", num);
        num = num0 + num1;
        num0 = num1;
        num1 = num;
        counter++;
    }

    return 0;
}
```

### Подвиг 7. Напишите программу, которая читает из входного потока два натуральных числа n и m, записанных через пробел, причем n < m. Выведите в консоль в одну строчку через пробел все числа кратные 3 (нацело делятся на 3) из интервала [n, m].

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.1.7

```c
#include <stdio.h>

int main() {
    int n, m;

    scanf("%d %d", &n, &m);

    while (n <= m) {
        if (n % 3 == 0) printf("%d ", n);
        n++;
    }

    return 0;
}
```

### Подвиг 8. Напишите программу, которая среди всех натуральных трехзначных чисел (числа с тремя цифрами) находит те, которые при делении на 47 дают целый остаток 6 или при делении на 53 - целый остаток 45. Выведите в консоль все найденные трехзначные числа в порядке возрастания в одну строчку через пробел.

```c
#include <stdio.h>
#define LEFT 100
#define RIGHT 999

int main() {
    int n = LEFT;

    while (n <= RIGHT) {
        if (n % 47 == 6 || n % 53 == 45) printf("%d ", n);
        n++;
    }

    return 0;
}
```

### Подвиг 9. Напишите программу, которая читает натуральное число, содержащее одну и более цифр. Определить, что это число является палиндромом, то есть, оно не меняет своего значения при просмотре слева-направо и справа-налево. Например: 121, 23032, 11 и т.п. Если число является палиндромом, то в консоль вывести строку "yes", иначе - строку "no".

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.1.9

```c
#include <math.h>
#include <stdio.h>

int main() {
    int count = 0, n;

    scanf("%d", &n);

    // посчитаем количество знаков в числе
    int ncopy = n;

    while (ncopy > 0) {
        ncopy /= 10;
        count++;
    }

    count--;

    char res = 1;

    while (n >= 10) {
        // вычислим первую и последнюю цифры и сравним их
        int a = n / pow(10, count);
        int b = n % 10;
        // printf("%d %d\n", a, b); // проверочная печать
        if (a != b) { // если не равны выходим из цикла с res = 0
            res = 0;
            break; 
        }
        // откидываем от n первую и последнюю цифры
        n -= a * pow(10, count);
        n /= 10;
        // printf("%d\n", n); // проверочная печать
        // уменьшаем счетчик знаков
        count -= 2;
    }
    // печатаем через тернарный оператор ответ
    printf("%s", res ? "yes" : "no");

    return 0;
}
```

```c
#include <stdio.h>

int main(void)
{    
    int num_o;
    scanf("%d", &num_o);
    
    int reversed = 0;
    int num = num_o;
    while(num != 0){
        int r = num % 10;
        reversed = reversed * 10 + r;
        num /=10;
    }   
    (num_o == reversed) ? printf("yes") : printf("no");
    
    return 0;
}
```

### Подвиг 10*. Напишите программу, которая вычисляет наибольший общий делитель (НОД) двух натуральных чисел a, b по алгоритму Евклида. Алгоритм реализуется по следующей схеме:

Шаг 1. Читаем из входного потока два натуральных числа a, b, записанных в одну строчку через пробел.
Шаг 2. Определяем наименьшее из двух чисел a, b
Шаг 3. Делаем цикл: пока меньшее число больше 0
Шаг 4.         большему числу присваиваем целый остаток от деления на меньшее число; (используется операция %)
Шаг 5.         большее число становится меньшим, а меньшее - большим
Шаг 6. Большее число выводим в консоль в виде одного числа.

```c
#include <stdio.h>

int main() {
    int a, b;

    scanf("%d %d", &a, &b);

    while (b > 0) {
        if (a > b) {
            int tmp = a;
            a = b;
            b = tmp;
        }
        b %= a;
    }

    printf("%d", a);
    return 0;
}
```

# 4.2 Оператор цикла for

На прошлом занятии мы рассмотрели работу цикла while, на этом занятии речь пойдет об операторе for. Оба этих оператора образуют циклы с предусловием, то есть, сначала проверяется условие цикла и если оно истинно, то выполняется текущая итерация. И здесь возникает вопрос, зачем понадобился еще один оператор цикла с предусловием?

Смотрите, в практике программирования очень часто возникают задачи, когда нужно организовать циклы по следующей схеме:

![03](/Good_good_C_C++/img/03_20.png)

То есть, перед циклом мы выполняет некоторую инициализацию переменных, используемых затем в цикле. Далее идет условие цикла, если оно истинно, то выполняются операторы, записанные внутри цикла. И в конце после основной группы операторов, выполняются некоторые изменения переменных для новой итерации. Например, ранее мы использовали эту схему в цикле `while` следующим образом:

```c
/* Инициализация */
int n;
int s = 0;
 
/* Цикл с предусловием */
while(n > 0) {
         s += n*n;    /* Операторы тела цикла */
         n--;         /* Изменение значений */
}
```

Так вот, чтобы иметь возможность в программах записывать подобные циклы в более краткой форме, и был введен оператор `for`, который имеет следующий синтаксис:

```c
for([инициализация]; [условие]; [изменение значений])
    оператор;
```

или

```c
for([инициализация]; [условие]; [изменение значений]) {
    операторы;
}
```

Как видите, сразу в этом операторе можно прописать инициализацию переменных перед запуском цикла, условие цикла и порядок изменения значений после выполнения каждой итерации цикла.

Обратите внимание, все эти элементы являются не обязательными, то есть, мы можем не прописывать инициализацию, условие и изменение значений. 

Также видим, что все эти элементы внутри цикла `for` разделены между собой точкой с запятой. Это, наверное, единственный оператор языка Си, который в своем определении использует символ точку с запятой как разделитель.

Давайте перепишем программу выше с циклом `while` через оператор `for`. Получим:

```c
#include <stdio.h>
 
int main(void) {
         /* Объявление переменных */
         int n, s;
 
         scanf("%d", &n);
 
         /* Цикл с предусловием for */
         for(s = 0; n > 0; --n)
                   s += n*n;    /* Операторы тела цикла */
 
         printf("s = %d\n", s);
         
         return 0;
}
```

Как видите, сам цикл имеет довольно краткую запись и визуально мы сразу можем выделить блок инициализации, блок проверки условия и блок изменения переменной. 

Если вам сейчас такая запись кажется несколько странной, то с опытом к ней очень быстро привыкаешь. И благодаря удобству оператор цикла `for` используется гораздо чаще оператора цикла `while`.

Давайте я приведу еще один пример с оператором цикла `for` для вычисления факториала числа:

```c
#include <stdio.h>
 
int main(void) {
    int n = 5, p = 1;

    for(int i = 1; i <= n; ++i)
        p = p * i;

    printf("p = %d\n", p);
    
    return 0;
}
```

Я напомню, что:

$n! = 1 ∙ 2 ∙ 3 ∙ … ∙ n$

В программе мы определяем `n = 5` и через цикл `for` находим факториал этого числа. 

Для этого задается вспомогательная переменная `p` с начальным значением `1` и в цикле `for` счетчик (переменная) `i` также с начальным значением `1`. 

Обратите внимание, внутри блока инициализации допустимо объявлять переменную, которая ранее нигде не существовала. 

Причем, используемый мной компилятор `gcc`, создает эту переменную исключительно внутри цикла `for` и за его пределами она не существует. 

Однако другие компиляторы, работающие по другим стандартам, вполне могут определять такие переменные за пределами оператора `for`. 

Соответственно, доступ к ним сохраняется после выполнения цикла. Но для нас сейчас важно лишь то, что в блоке инициализации можно объявлять переменные и использовать их в теле цикла данного оператора.

Работает цикл очень просто. Сначала проверяется условие цикла, т.к. оно истинно, то выполняется текущая итерация – оператор `p = p * i;`.

После этого происходит увеличение счетчика `i` на единицу и снова проверяется условие цикла. В результате, мы получаем значение переменной p равное:

```
p = 1 ∙ 2 ∙ 3 ∙ 4 ∙ 5 = 120
```

А вот еще несколько вариаций записи этого же цикла:

```c
         int i, p;
         for(i = 1, p = 1; i <= n; ++i)
                   p = p * i;
```

Здесь использована новая операция запятая для инициализации двух переменных. Или:

```c
         int n = 5;
         int i = 1, p = 1;
         
         for(; i <= n; ++i)
                   p = p * i;
```

Здесь пустой блок инициализации, т.к. она прописана до оператора цикла. Или:

```c
         int n = 5;
         int i = 1, p = 1;
 
         for(; i <= n;) {
                   p = p * i;
                   ++i;
         }
```

Здесь два пустых блока: инициализации и изменения значений. Или:

```c
         int n = 5, i, p;
         for(i = 1, p = 1; i <= n; p = p * i, ++i)
                   { }
```

Вся логика вычислений прописана внутри оператора цикла `for`. Соответственно, в теле цикла ничего прописывать не нужно, но формально там все же должен быть указан хотя бы один оператор. 

Точка с запятой, как раз и воспринимается компилятором как оператор, который ничего не делает. 

Также в блоке изменения значений прописаны две операции, разделенные запятой. При этом сначала выполнится первая операция `p = p * i` и только потом вторая `++i`. 

Это поведение для операции запятая строго определено в стандарте языка Си. 

Вычисление выражений, разделенных запятой, происходит слева-направо и никак иначе.

Начинающий программист, глядя на все это разнообразие форм записей одного и того же оператора для решения одной и той же задачи, может задаться вполне резонным вопросом: какой же вариант лучше? 

В действительности, следует выбирать тот, который проще воспринимать и модифицировать (при необходимости). 

Компилятор все эти вариации переведет в машинный код примерно одинаковым образом. 

Лично я выбрал бы здесь первый вариант записи, т.к. он хорошо отражает логику работы программы.

Раз уж мы затронули вопрос различных вариаций записей оператора цикла `for`, то приведу еще одну без каких-либо блоков:

```c
for( ; ; );
```

Так тоже можно записывать. В этом случае цикл будет работать «вечно» пока мы или операционная система не прервет выполнение программы.

Вообще цикл `for` используют не только для формирования каких-либо арифметических последовательностей в программах. 

Спектр его применения куда шире. 

Здесь следует исходить из того, что в блоках инициализации и изменения значений можно прописывать любые допустимые конструкции. Например, такие:

```c
#include <stdio.h>
#include <stdlib.h>
 
int main(void) {
         for(int x = rand() % 10; x != 0; x = rand() % 10)
                   printf("x = %d\n", x);
 
         return 0;
}
```

Как видите, в блоке инициализации формируется первое псевдослучайное значение в диапазоне `[0; 9]`, а в блоке изменения следующее псевдослучайное значение из этого же диапазона. На каждой итерации на экран выводится полученное числовое значение, пока `x` не станет равен нулю.

На этом мы завершим первое знакомство с оператором цикла `for`. На следующем продолжим эту тему и поговорим об операторе цикла с постусловием `do-while`.

### Подвиг 1. Выберите все верные утверждения, касающиеся оператора цикла for языка Си стандарта C99 и выше.

+ [x] цикл for работает, пока истинно условие цикла
+ [x] в блоке инициализации цикла for можно объявлять и инициализировать новые переменные
+ [ ] цикл for работает, пока ложно условие цикла
+ [ ] цикл for сначала выполняет итерацию, а затем, проверяет условие продолжения цикла
+ [x] цикл for записывается по синтаксису: for([инициализация]; [условие]; [изменение значений]) оператор;
+ [x] цикл for сначала проверяет условие, а затем, выполняет очередную итерацию
+ [x] блок "изменение значений" выполняется сразу после очередной итерации тела цикла

### Подвиг 2. Замените в приведенной программе цикл while на цикл for с сохранением логики работы программы.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.2.2

```c
#include <stdio.h>

int main(void) {
    int s = 0, n = 0;

    scanf("%d", &n);
    
    for (int i = 5; i++ <= n; s += i)
        ;
        
    printf("%d", s);

    return 0;
}
```
### Подвиг 3. Продолжите программу, которая должна вычислять первые n членов арифметической прогрессии и выводить их по порядку в одну строчку через пробел. Члены прогрессии вычисляются по следующей схеме:

a0 - первый член;
a0 + d - второй член;
a0 + 2d - третий член;
...
a0 + (n-1)*d - n-й член

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.2.3

```c
#include <stdio.h>

int main(void) {
    int a0, d, n;
    scanf("%d; %d; %d", &a0, &d, &n);

    for (int i = 0; i < n; i++) {
        int res = a0 + i * d;
        printf("%d ", res);
    }

    return 0;
}
```

### Подвиг 4. Продолжите программу, которая должна вычислять первые n членов геометрической прогрессии и выводить их по порядку в одну строчку через пробел. Члены прогрессии вычисляются по следующей схеме:

b0 - первый член;<br>
b0 * q - второй член;<br>
b0 * q^2 - третий член;<br>
...<br>
b0 * q^(n-1) - n-й член<br>

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.2.4

```c
#include <math.h>
#include <stdio.h>

int main(void) {
    int b0, q, n;
    scanf("%d; %d; %d", &b0, &q, &n);

    for (int i = 0; i < n; i++) {
        int res = b0 * pow(q, i);
        printf("%d ", res);
    }

    return 0;
}
```

### Подвиг 5. Напишите программу, которая читает из входного потока натуральное число n. Необходимо вывести в консоль "линию" в виде n символов '='. Например, если вводится n = 5, то на выходе должны получить:

=====

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.2.5


```c
#include <math.h>
#include <stdio.h>

int main(void) {
    int n;
    scanf("%d", &n);

    for (int i = 0; i < n; i++) {
        printf("=");
    }

    return 0;
}
```

### Подвиг 6. Напишите программу, которая читает из входного потока два целых числа n, m, записанных в одну строчку через пробел, причем n < m. Выведите в консоль в одну строчку через пробел все четные числа в диапазоне [n; m], используя цикл for.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.2.6

```c
#include <stdio.h>

int main(void) {
    int n, m;
    scanf("%d %d", &n, &m);

    for (int i = n; i <= m; i++) {
        if (i % 2 == 0) printf("%d ", i);
    }

    return 0;
}
```

### Подвиг 7. Напишите программу, которая читает из входного потока натуральное число n. С помощью цикла for найти все делители этого числа (то есть, натуральные числа, которые нацело делят число n, включая числа 1 и n). Все найденные делители вывести по порядку (начиная с наименьшего) в одну строчку через пробел.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.2.7

```c
#include <stdio.h>

int main(void) {
    int n;
    scanf("%d", &n);

    for (int i = 1; i <= n / 2; i++) {
        if (n % i == 0) printf("%d ", i);
    }
    printf("%d ", n);

    return 0;
}
```

### Подвиг 8. Напишите программу, которая читает из входного потока натуральное число n. Вычислить сумму всех натуральных чисел (больше 1 и меньше n), которые кратны или 3 или 5. Результат (сумму) вывести в консоль в виде одного целого числа. 

Пример: n = 10, имеем числа: 3, 5, 6, 9. Их сумма равна 23.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.2.8

```c
#include <stdio.h>

int main(void) {
    int n, res = 0;
    scanf("%d", &n);

    for (int i = 1; i < n; i++) {
        if (i % 3 == 0 || i % 5 == 0) res +=i;
    }
    printf("%d", res);

    return 0;
}
```

### Подвиг 9 (на повторение). Напишите следующую программу. Из входного потока читаются цифры (от 1 до 9), пока не встретится число 0. На основе этих цифр сформировать единое число. Например, если на вход поступают цифры:

5 2 9 3 0

то должно формироваться число:

5293

Выведите полученное число в консоль.

Если цифра 0 встречается сразу (первая), то формируемая переменная должна принимать значение 0.

P.S. Программу следует реализовать с использованием только текущих знаний (без массивов).

Тесты: hhttps://github.com/selfedu-rus/c-tests/tree/main/4.2.9

```c
#include <stdio.h>

int main(void) {
    int n, res = 0;

    while (scanf("%d", &n) == 1 && n != 0) {
        res = res * 10 + n;
    }

    printf("%d", res);

    return 0;
}
```

### Подвиг 10 (на повторение). Напишите программу, которая читает из входного потока натуральное число n. На его основе нужно сформировать другое число m, в котором цифры числа n будут идти в обратном порядке. Например, при n = 235, получаем m = 532. Или, при n = 1, получаем m = 1.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.2.10

```c
#include <stdio.h>

int main(void) {
    int n, res = 0;

    scanf("%d", &n);

    while (n > 0) {
        res = res * 10 + n % 10;
        n /= 10;
    }

    printf("%d", res);

    return 0;
}
```

### Подвиг 11 (на повторение). Напишите программу, которая читает из входного потока шестизначное натуральное число n. Определить, является ли оно счастливым. (Счастливым называют такое шестизначное число, в котором сумма его первых трех цифр равна сумме его последних трех цифр.). Вывести в консоль "yes", если счастливое и "no" - в противном случае.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.2.11

```c
#include <stdio.h>

int main(void) {
    int a, b, c, d, e, f;

    scanf("%1d %1d %1d %1d %1d %1d", &a, &b, &c, &d, &e, &f);

    char res = (a + b + c) == (d + e + f);

    printf("%s", res ? "yes" : "no");

    return 0;
}
```

# 4.3 Цикл do-while с постусловием. Вложенные циклы

## Цикл do-while с постусловием

На этом занятии рассмотрим последний такой оператор – цикл с постусловием `do-while`, который имеет следующий синтаксис:

```c
do {
    [оператор (один или несколько)]
} while(<условие>);
```

Фигурные скобки при записи этого оператора строго обязательны, даже если в них будет находиться всего один оператор. Также после ключевого слова `while` должна стоять точка с запятой.

Само название этого оператора говорит, что цикл `do-while` отличается от цикла `while`, фактически, только тем, что сначала выполняется итерация, а затем, проверяется условие для продолжения цикла. При этом цикл `do-while` работает пока истинно условие. 

Соответственно, как только условие становится ложным, цикл завершается и управление передается следующему оператору в программе.

Давайте рассмотрим пример, где использование такого типа цикла оправдано. Предположим, пользователь должен ввести кодовое число, чтобы получить доступ к чему-либо. Для этого вначале нужно попросить его ввести числовое значение и только после этого проверить, совпадает ли ввод с кодовым числом. Если совпадает, то предоставить доступ, а иначе попросить ввести код еще раз. Эту логику проще всего реализовать с помощью оператора цикла `do-while` следующим образом:

```c
#include <stdio.h>

int main(void) {
    int pass_code = 13;
    int enter_code;

    do {
        printf("Please enter the secret code: ");
        scanf("%d", &enter_code);
    } while (enter_code != pass_code);

    printf("Access is allowed\n");

    return 0;
}
```

Сначала будет выполнена итерация цикла, то есть, операторы, записанные в теле цикла. В результате пользователь получает возможность ввести кодовое значение. А затем, в цикле выполняется обратная проверка на неравенство значений. 

Почему так? 

Потому что мы здесь прописываем условие продолжения цикла. И цикл должен продолжаться, пока пользователь не введет верное кодовое число. В этом случае условие становится ложным и управление передается следующему оператору `printf()`, записанному после цикла `do-while`.

Как видите, цикл с постусловием полезен, когда нам в программе нужно вначале выполнить некоторые повторяющиеся действия и только после этого решить, продолжать цикл или завершить. В действительности, это не частая ситуация и по этой причине оператор цикла `do-while` на практике применяется реже двух остальных: `while` и `for`, о которых мы с вами уже говорили на предыдущих занятиях.

Также обратите внимание, как записан в тексте программы этот оператор цикла. Ключевое слово `while` стоит в одной строчке с закрывающейся фигурной скобкой.

Так принято делать, чтобы визуально подчеркнуть, что `while` здесь – это завершение конструкции, которая начинается с ключевого слова `do`. И чтобы не спутать этот `while` с другим таким же оператором уже цикла с предусловием. Например, давайте усовершенствуем нашу программу, и будем очищать буфер входного потока `stdin` после каждого ввода:

```c
#include <stdio.h>

int main(void) {
    int pass_code = 13;
    int enter_code;
    int c;

    do {
        printf("Please enter the secret code: ");
        scanf("%d", &enter_code);

        while ((c = getchar()) != '\n' && c != EOF) {
        }
    } while (enter_code != pass_code);

    printf("Access is allowed\n");

    return 0;
}
```
Я здесь использую цикл `while` с вызовом функции `getchar()`, которая читает один байт из потока `stdin`. Цикл останавливается, если прочитан символ переноса строки (`\n`) или конца файла (`EOF`). 

Это простейший вариант очистки буфера входного потока.

И, смотрите, в тексте программы идут друг за другом два слова `while`. Но, тем не менее, они легко различаются, так как имеются отступы у операторов тела цикла.

Или может быть ситуация, когда после цикла `do-while` идет цикл `while`:

```c
#include <stdio.h>

int main(void) {
    int pass_code = 13;
    int enter_code;
    int c;

    do {
        printf("Please enter the secret code: ");
        scanf("%d", &enter_code);

        while ((c = getchar()) != '\n' && c != EOF) {
        }
    } while (enter_code != pass_code);

    while ((c = getchar()) != '\n' && c != EOF) {
    }

    printf("Access is allowed\n");

    return 0;
}
```

При нашем способе оформления текста программы все три цикла хорошо различимы и не возникает никакой путаницы. Именно поэтому рекомендуется оператор `do-while` записывать в таком виде.

## Вложенные циклы
Из последних примеров вы видели, что в один оператор цикла можно заключать другой. В программировании такая конструкция называется вложенными циклами. И ее можно реализовывать с любыми операторами циклов. Давайте подробнее посмотрим, как она работает.

Чаще всего вложенные циклы можно увидеть с операторами `for`. Поэтому в нашем примере будут фигурировать именно они. А сам пример будет следующим. Представим, что нам нужно выполнить полный перебор документов (файлов), лежащих в нескольких ящиках (box). В каждом ящике одинаковое число файлов, а всего ящиков пусть будет три.

![03](/Good_good_C_C++/img/03_21.png)

Для решения этой задачи воспользуемся вложенными циклами `for` следующим образом:

```c
#include <stdio.h>

int main(void) {
    int total_boxs = 3;
    int total_files = 6;

    for (int i = 0; i < total_boxs; ++i) {
        for (int j = 0; j < total_files; ++j) {
            printf("Box %d, file %d\n", i + 1, j + 1);
        }
    }
    
    return 0;
}
```
Смотрите, сначала срабатывает первый (внешний) цикл со счетчиком (переменной) `i`, который содержит номер текущего просматриваемого ящика. Затем, запускается итерация этого внешнего цикла (выполняются операторы, записанные в теле цикла). В результате запускается второй (внутренний) цикл, который перебирает документы текущего ящика. Для каждого документа выводится информация в формате:

```
Box<номер ящика>, file<номер документа>
```

В результате, после просмотра всех документов первого ящика на экране появятся строчки:

```
Box 1, file 1
Box 1, file 2
Box 1, file 3
Box 1, file 4
Box 1, file 5
Box 1, file 6
```

После этого работа внутреннего цикла завершается и управление передается внешнему циклу. В нем происходит увеличение счетчика `i` на единицу и проверяется условие цикла. Так как оно истинно, то запускается вторая итерация и снова срабатывает внутренний цикл, но уже для перебора документов второго ящика. И так для всех трех ящиков.

Вот общий принцип работы вложенных циклов. Конечно, пример с ящиками и файлами – это лишь частный пример. В общем случае подобным образом можно перебирать пиксели двумерного изображения, ячейки игрового поля, вычислять вложенные суммы и так далее.

![03](/Good_good_C_C++/img/03_22.png)

Мало того, при необходимости, мы можем увеличивать число вложений операторов циклов и осуществлять перебор элементов не только в плоскости, но и в объеме и вообще в Nмерном пространстве. Хотя, на практике слишком увлекаться этим не стоит, т.к. сложность понимания и восприятия программы растет с числом этих вложений. Обычно, ограничиваются двумя, тремя уровнями. При правильной организации логики программы этого оказывается вполне достаточно.

Чтобы закрепить этот материал предлагаю самостоятельно написать программу для вычисления следующей суммы:

![03](/Good_good_C_C++/img/03_23.png)

Если все правильно сделаете, то должны получить ответ 2750.

```c
#include <stdio.h>

int main(void) {
    int res = 0;

    for (int i = -3; i <= 7; ++i) {
        for (int j = 1; j <= 5; ++j) {
            for (int k = 2; k <= 4; ++k) {
                res += (i + j - k) * (i + j - k);
            }
        }
    }
    printf("%d", res);
    return 0;
}
```

### Подвиг 1. Выберите все верные утверждения, касающиеся цикла do-while.

+ [x] оператор do-while относится к циклам с постусловием
+ [ ] оператор do-while сначала проверяет условие продолжения цикла, а затем выполняет итерацию
+ [x] оператор do-while сначала выполняет итерацию, а затем проверяет условие продолжения цикла
+ [ ] оператор do-while относится к циклам с предусловием
+ [ ] цикл do-while описывается согласно синтаксису: do-while {[тело цикла]} (<условие>);
+ [x] цикл do-while описывается согласно синтаксису: do {[тело цикла]} while(<условие>);

### Подвиг 2. Перепишите следующую программу с использованием цикла do-while, сохранив логику работы программы.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.3.2

```c
#include <stdio.h>

int main(void) {
    int p = 1, n, i = 1;

    scanf("%d", &n);

    do {
        p *= i;
    } while (i++ < n);

    printf("%d", p);

    return 0;
}
```

### Подвиг 3. Напишите программу с использованием цикла do-while, которая читает из входного потока целые числа (по одному) до тех пор, пока не встретится число 13. Все положительные прочитанные числа просуммировать (включая число 13) и вывести полученную сумму в виде одного целого числа в консоль.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.3.3

```c
#include <stdio.h>
#define LAST_DIGIT 13

int main(void) {
    int res = 0, n;

    do {
        scanf("%d", &n);
        if (n > 0) res += n;
    } while (n != LAST_DIGIT);

    printf("%d", res);

    return 0;
}
```

### Подвиг 4. Напишите программу, которая читает из входного потока натуральное число n (целое, положительное). Затем, с помощью цикла do-while вычислить сумму следующего ряда:

$S = 1 + \dfrac{1}{2} + \dfrac{1}{3} +...+ \dfrac{1}{n}$

Значение суммы вывести в консоль в виде вещественного числа с точностью до сотых.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.3.4

```c
#include <stdio.h>

int main(void) {
    int n, i = 1;
    double res = 0;

    scanf("%d", &n);

    do {
        res += 1 / (double)n;
    } while (++i <= n);

    printf("%.2lf", res);

    return 0;
}
```

### Подвиг 5*. Напишите программу игры "Угадай число". Задуманное целое число x в диапазоне [1; 1000] считывается из входного потока. Начальный диапазон сохраняется в переменных a = 1, b = 1000. Затем, генерируется случайное целое значение m в диапазоне [a; b]. Далее, рассматриваются три возможных исхода:

1. Если m == x, то программа завершается и в консоль выводится найденное значение x.
2. Если m < x, то корректируется интервал возможных значений a = m, b - без изменений.
3. Если m > x, то корректируется интервал возможных значений a - без изменений, b = m.

Процесс генерации продолжается (по циклу do-while), пока не будет угадано число x. Угаданное значение вывести в консоль в виде целого числа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.3.5

```c
#include <stdio.h>
#include <stdlib.h>

#define FIRST_DIGIT 1
#define LAST_DIGIT 1000

int main(void) {
    int a = FIRST_DIGIT;
    int b = LAST_DIGIT;
    int x, m;

    scanf("%d", &x);

    do {
        m = rand() % (b - a + 1) + a;
        if (m < x) a = m;
        if (m > x) b = m;
    } while (m != x);

    printf("%d", m);

    return 0;
}
```

```c
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    int x, m, a = 1, b = 1000;
    if(scanf("%d", &x) != 1)
    {
        printf("Error input.\n");
        return 0;
    }
    do{
        m = rand() % (b - a + 1) + a;
        m < x && (a = m);
        m > x && (b = m);
    } while (x != m);
    printf("%d",x);
    return 0;
}
```

### Подвиг 6. Используя вложенные циклы (любые), вывести в консоль из звездочек (*) следующую фигуру (пробелы не использовать):

*
**
***
****

Число выводимых строк определяется целочисленной переменной n (натуральное число), значение которой считывается из входного потока.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.3.6

```c
#include <stdio.h>

int main(void) {
    int n;

    scanf("%d", &n);

    for (int i = 0; i < n; i++) {
        for (int j = i; j >= 0; j--) {
            printf("*");
        }
        printf("\n");
    }

    return 0;
}
```

Вложенные циклы - это квадратичная сложность.

```c
#include <stdio.h>

char st[100];

int main(void) {
    int n = 0;

    scanf("%d", &n);

    for (int i = 0; i < n; i++) {
        st[i] = '*';
        st[i + 1] = '\n';
        printf(st);
    }
    return 0;
}
```

```c
#include <stdio.h>

int main(void) {
    int lines, cnt = 0;
    scanf("%d", &lines);
    while (cnt++ < lines) {
        for (int i = 0; i < cnt; i++) {
            putchar(0x2A);
        }
        putchar(0x0A);
    }
}
```

### Подвиг 7. Используя вложенные циклы (любые), вывести в консоль из звездочек (*) следующую симметричную фигуру:

   *
  ***
 *****
*******

Число выводимых строк определяется целочисленной переменной n (натуральное число), значение которой считывается из входного потока. Перед звездочками (в начале строк) прописываются пробелы (кроме последней строки). После звездочек никаких пробелов не должно быть.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.3.7

```c
#include <stdio.h>

int main(void) {
    int n;

    scanf("%d", &n);

    for (int i = 0; i <= n; i++) {
        for (int j = 0; j <= n - i - 1; j++) {
            printf(" ");
        }
        for (int j = i * 2 - 1; j > 0; j--) {
            printf("*");
        }
        printf("\n");
    }

    return 0;
}
```

```c
#include <stdio.h>

char sp[100];

int main(void) {
    int n = 0;
    memset(sp, ' ', 100);
    scanf("%d", &n);

    for (int i = 0; i < n; i++) {
        sp[n - 1 + i] = '*';
        sp[n - 1 - i] = '*';
        sp[n + i] = '\n';
        sp[n + i + 1] = 0x00;
        printf(sp);
    }
    return 0;
}
```

```c
/*
------*
-----***
----*****
---*******
--*********
-***********
*************
n=7

номер  число    число
строки пробелов звезд
1       6       2-1=1
2       5       4-1=3
3       4       6-1=5
4       3       8-1=7
5       2       10-1=9
6       1       12-1=11
7       0       14-1=13
*/

#include <stdio.h>
int main() {
    int n;
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n - i; j++) printf(" ");
        for (int j = 1; j <= 2 * i - 1; j++) printf("*");
        printf("\n");
    }
    return 0;
}
```

### Подвиг 8 (на повторение). Напишите программу, которая среди целых положительных трехзначных чисел в диапазоне от a до b включительно, выбирает только те, у которых все цифры разные. Значения a, b читаются из входного потока, записанные в одну строчку через пробел. Выведите в консоль все найденные числа с неповторяющимися цифрами в одну строчку через пробел в порядке возрастания.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.3.8

```c
#include <stdio.h>

int main(void) {
    int m, n;

    scanf("%d %d", &m, &n);

    for (int i = m; i <= n; i++) {
        int a = i / 100;
        int b = (i - a * 100) / 10;
        int c = i % 10;

        if (a != b && a != c && c != b) {
            printf("%d ", i);
        }
    }
    return 0;
}
```

### Подвиг 9. Напишите программу, которая читает из входного потока два натуральных числа m, n (m < n), записанных в одну строчку через пробел. Необходимо вывести в консоль в одну строчку через пробел все найденные числа-палиндромы в диапазоне [m; n]. Число-палиндром - это число, которое не меняет своего значения при чтении слева-направо и справа-налево. Например, числа 121, 1, 11, 43034 - палиндромы.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.3.9

```c
#include <stdio.h>

int main(void) {
    int m, n;

    scanf("%d %d", &m, &n);

    for (int i = m; i <= n; i++) {
        int icopy = i, reverse = 0;

        while (icopy) {
            reverse = reverse * 10 + icopy % 10;
            icopy /= 10;
        }

        if (i == reverse) {
            printf("%d ", i);
        }
    }
    return 0;
}
```

### Подвиг 10. Напишите программу, которая читает из входного потока натуральные числа m, n, k, записанные в одну строчку через пробел. Используя их, необходимо вычислить следующую сумму ряда:

![04](/Good_good_C_C++/img/04_01.png)

```c
#include <math.h>
#include <stdio.h>

int main(void) {
    int m, n, k;

    scanf("%d %d %d", &m, &n, &k);

    double sum = 0;

    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            for (int t = 1; t <= k; t++) {
                sum += j * j / (double)(pow(i + t, 3) - t);
            }
        }
    }
    sum /= m + n + k;

    printf("%.4lf", sum);

    return 0;
}
```

# 4.4 Операторы break, continue и goto

На прошлых занятиях мы подробно разобрали работу трех операторов цикла: `while`, `for` и `do-while`. Также увидели как можно формировать вложенные циклы и примеры задач, где это может пригодиться. На этом заключительном занятии по циклам разберем следующие управляющие операторы, которые можно использовать в любом операторе цикла:
+ `break` – досрочное прерывание работы оператора цикла;
+ `continue` – пропуск итерации тела цикла;
+ `goto` – безусловный переход по метке.

## Оператор break

Начнем с оператора `break`. Предположим, нам нужно написать программу подсчета суммы вещественных чисел, пока пользователь вводит положительные числа. Как только он введет отрицательное значение, подсчет суммы завершается с выводом результата на экран. Такую программу можно реализовать следующим образом:

```c
#include <stdio.h>

int main(void) {
    double x, s = 0.0;

    while (scanf("%lf", &x) == 1) {
        if (x < 0) break;

        s += x;
    }

    printf("s = %.2f\n", s);

    return 0;
}
```

Вначале объявляются две вспомогательные переменные:
+ x – для ввода текущего вещественного значения;
+ s – для подсчета суммы вещественных положительных чисел. 

Далее запускается цикл `while`, который работает, пока вводятся корректные числовые значения. В теле цикла идет проверка, если введенное значение `x` отрицательное, то срабатывает оператор `break`. Этот оператор завершает работу цикла `while` и управление передается следующему оператору `printf()`. Если же введенное число неотрицательное, то выполняется подсчет суммы.

Как видите, все предельно просто. Для примера, если в этой программе убрать условие и записать оператор `break` в теле цикла, то цикл `while` гарантированно будет прерываться на первой же итерации.

Конечно, эту же программу можно было бы записать и без оператора break, изменив условие цикла:

```c
    while(scanf("%lf", &x) == 1 && x >= 0) {
        s += x;
    }
```

Возможно, даже любую программу можно составить без оператора `break`. Но его использование может заметно облегчить написание и понимание логики программы. Именно с этой целью он и введен в язык Си, да и во многие другие языки высокого уровня.

Отмечу здесь еще один распространенный способ прерывания работы цикла. Если вместо `break` записать оператор `return`:

```c
    while(scanf("%lf", &x) == 1) {
        if(x < 0) return 0;
        s += x;
    }
```

то для цикла `while` эффект будет такой же, как и от оператора `break`. 

Но, правда, есть и существенное отличие. 

Как мы уже знаем, оператор `return` завершает выполнение функции. 

В данном случае функции `main()`. Поэтому, как только пользователь введет отрицательное число, то программа просто завершится, результат на экран выведен не будет, так как все операторы после `while` уже не сработают. 

В этом ключевое отличие между `break` и `return`. 

Оператор `break` позволяет продолжить выполнение функции, и управление передается следующему оператору после цикла. 

А при `return` текущая функция завершается сразу. 

На самом деле, оператор `return` завершает работу функции и лишь, как следствие, прерывает работу цикла. По той же логике оператор `return` можно для завершения работы оператора `switch`, о котором мы с вами ранее уже говорили. И вообще, с помощью `return` можно прервать работу чего угодно в пределах функции.

## Оператор continue

Следующий оператор `continue` прерывает лишь текущую итерацию цикла. Давайте я покажу принцип его работы на конкретном примере. Пусть мы также вводим с клавиатуры целые числа и хотим вычислить сумму только нечетных чисел. Сделать это можно следующим образом:

```c
#include <stdio.h>

int main(void) {
    int x, s = 0;

    while (scanf("%d", &x) == 1 && x != 0) {
        if (x % 2 == 0) continue;

        s += x;
    }

    printf("s = %d\n", s);

    return 0;
}
```

Начало вам уже знакомо, а дальше записан цикл `while`, который работает пока пользователь вводит корректные данные или не введет число `0`. Затем, в теле цикла стоит проверка на четность введенного числа x и если оно четно, то выполняется оператор `continue`. Как только встретился этот оператор, все остальные после него операторы тела цикла пропускаются и мы переходим к следующей итерации цикла `while`. В результате, сумма будет вычисляться только для нечетных значений.

Конечно, опят же, эту программу можно было бы реализовать и без оператора `continue`, например, так:
```c
    while(scanf("%d", &x) == 1 && x != 0) {
        if(x % 2 != 0) s += x;
    }
```

И это вполне рабочий вариант. Здесь все как и с оператором `break`. Оператор `continue` введен для удобства программирования и его следует использовать тогда, когда он позволяет упростить логику программы и сделать ее более читабельной.

Оператор `continue`, равно как и оператор `break` можно использовать не только в цикле `while`, но и в циклах `for` и `do-while`. Например, если нам нужно из диапазона целых чисел `[1; 100]` отобразить только те, что кратны `3` и `5` одновременно, то это можно сделать следующим образом:

```c
#include <stdio.h>

int main(void) {
    for (int i = 1; i <= 100; ++i) {
        if (i % 3 != 0 || i % 5 != 0) continue;

        printf("%d ", i);
    }

    return 0;
}
```

Это учебный пример. В этой задаче использование оператора `continue` избыточно и проще было бы вызывать функцию `printf()` по обратному условию. Я лишь показываю, что операторы `continue` и `break` допустимо применять с любыми операторами циклов.

## Оператор goto

Последний оператор, который мы рассмотрим на этом занятии, это `goto`. Он позволяет передать управление любому другому оператору по указанной метке в пределах текущей функции (в пределах той функции, в которой вызывается данный оператор).

На многих обучающих курсах и учебной литературе по языку Си сразу оговаривается, что оператор `goto` не следует использовать в своих программах, особенно, начинающим программистам. 
И я с этим полностью согласен! 

Но, существует, по крайне мере, одна ситуация, когда применение этого оператора оправданно. Это прерывание работы вложенных циклов. Давайте я детально поясню о чем здесь речь, а позже отмечу, почему все же оператор `goto` лучше не использовать в своих программах.

Итак, предположим, что мы вычисляем двойную сумму вида:

![04](/Good_good_C_C++/img/04_02.png)

и хотим прервать вычисления как только слагаемое `i-j` будет больше нуля. Такую программу можно реализовать следующим образом:

```c
#include <stdio.h>

int main(void) {
    int s = 0;
    for (int i = 1; i <= 10; ++i)
        for (int j = 7; j >= 5; --j) {
            if (i - j > 0) goto exit_sum;
            s += i - j;
        }

exit_sum:
    printf("s = %d\n", s);

    return 0;
}
```

Смотрите, здесь два цикла, один вложен в другой. В теле второго цикла выполняется проверка на положительность значения `i-j`. 

Если это так, то по условию задания нам нужно прервать работу обоих циклов и завершить подсчет суммы. Как раз для этого удобно воспользоваться оператором `goto` и по метке `exit_sum` (имя мы придумываем сами) переходим к оператору `printf()`, стоящему после этих циклов. В результате такого перехода работа циклов будет завершена.

Возможно, некоторые из вас сейчас в недоумении смотрят на эту программу и задаются вопросом: а почему бы здесь не использовать оператор `break`, он же как раз и позволяет прервать цикл? Все верно, цикл (один цикл) он может прервать и если записать программу в виде:

```c
    for(int i = 1; i <= 10; ++i) {
        for(int j = 7; j >= 5; --j) {
            if(i-j > 0) break;
            s += i - j;
        }
    }
```
то по условию завершится работа внутреннего цикла, но внешний продолжит работать и на новой итерации опять запустит внутренний цикл. 

Очевидно, это не то, что нам нужно. 

Запомните, оператор `break` прерывает только один текущий цикл и не более того. 

Начинающие программисты здесь часто делают ошибку. Поэтому в нашей задаче вместо `break` используется оператор `goto` и, как мы видели, он позволяет прервать и два и три и более вложенных циклов при переходе по метке за их пределы, но в пределах текущей функции.

Это тот редкий случай, когда применение этого оператора оправданно. Но почему тогда к этому оператору такое негативное отношение со стороны программистского сообщества языка Си? 

Все очень просто. 

Если злоупотреблять использованием этого оператора, то логика работы программы очень быстро становится очень запутанной, настолько, что даже сам автор перестанет в ней ориентироваться. 

Соответственно читать и редактировать такие программы чрезвычайно сложно.

Второй момент связан с компиляцией. Если программа написана без операторов `goto`, то, скорее всего, при более-менее грамотном подходе к программированию, на выходе получим качественный машинный код, который будет выполняться предельно быстро. Если же в программе присутствуют постоянные переходы `goto`, то никто не даст гарантии качественной трансляции такого текста в машинный код. 

Соответственно, главный плюс языка Си сходит на нет: исполняемый файл не оптимизирован для быстрого выполнения на текущей архитектуре компьютера.

Чтобы гарантированно избежать этих недостатков при построении программ, стоит совсем отказаться от применения оператора `goto`. Исключение может составлять необходимость прерывания сразу нескольких вложенных циклов. Хотя и здесь мы могли бы обойтись без этого оператора. Часто логику вложенных циклов реализуют в отдельных функциях. И как только появляется необходимость прервать их работу, завершают функцию оператором `return`. Это более частый вариант по сравнению с оператором `goto`. Именно так я рекомендую поступать при проектировании своих программ.

Видео по теме [#25. Операторы break, continue и goto](https://www.youtube.com/watch?v=E_yEgucuFyw&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Установите соответствия между операторами и их описаниями.

![04](/Good_good_C_C++/img/04_03.PNG)

### Подвиг 2. Допишите программу, в которой проверяется, что текущие координаты x, y не выходят за диапазон [1; n] - для x и [1; m] - для y. Если условие не выполняется (хотя бы одна координата выходит из диапазона), то функция printf() не должна выполняться. Реализовать эту логику с использованием оператора continue.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.4.2

```c
#include <stdio.h>

int main(void) {
    int n = 5, m = 7;
    int total = 5;

    for (int i = 0; i < total; ++i) {
        int x, y;
        scanf("%d, %d", &x, &y);

        if (x >= 1 && x <= n && y >= 1 && y <= m) {
            printf("(%d, %d)\n", x, y);
        } else
            continue;
    }

    return 0;
}
```

### Подвиг 3. На каждой итерации цикла из входного потока читается по одному целому числу. Необходимо подсчитать произведение только положительных чисел, до тех пор, пока не встретится число 0. Реализовать пропуск вычислений (для отрицательных чисел) с помощью оператора continue, а также использовать цикл while или do-while. Если нет ни одного положительного значения, то произведение должно быть равно 1. Результат произведения вывести в консоль в виде одного целого числа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.4.3

```c
#include <stdio.h>

int main(void) {
    int n, res = 1;

    while (scanf("%d", &n) == 1 && n != 0) {
        if (n < 0)
            continue;
        else
            res *= n;
    }
    printf("%d", res);
    return 0;
}
```

### Подвиг 4. Написать программу, которая читает из входного потока натуральное число n. Вывести в консоль в одну строчку через пробел все целые числа, начиная с 1, квадраты которых меньше числа n. Прерывание цикла реализовать с помощью оператора break.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.4.4

```c
#include <stdio.h>

int main(void) {
    int n;

    scanf("%d", &n);

    for (int i = 1; i < n; i++) {
        if (i * i >= n) break;
        printf("%d ", i);
    }
    return 0;
}
```

### Подвиг 5. Напишите программу, которая читает из входного потока натуральное число n. Вычислите у этого числа все его простые множители (разложить число по простым множителям) и выведите их в порядке возрастания (неубывания) в одну строчку через пробел.

Например, число 140 = 2 * 2 * 5 * 7. В консоли должно отображаться 2 2 5 7.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.4.5

```c
#include <stdio.h>

int main(void) {
    int n, i = 2;

    scanf("%d", &n);
    while (n != 1) {
        while (n % i == 0) {
            n /= i;
            printf("%d ", i);
        }
        i++;
    }
    return 0;
}
```

### Подвиг 6. Напишите программу, которая читает из входного потока два натуральных числа n, m, записанных в одну строчку через пробел, и вычисляет следующую сумму:

![04](/Good_good_C_C++/img/04_04.png)

Сумма должна вычисляться до тех пор, пока слагаемое `i+j` меньше `10`. Как только `i+j` окажется равно или больше `10`, прервать подсчет суммы с помощью оператора `goto` и вывести результат (полученную сумму) в консоль в виде одного целого числа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.4.6

```c
#include <stdio.h>

int main(void) {
    int n, m, sum = 0;

    scanf("%d %d", &n, &m);
    for (int i = 0; i <= n; i++) {
        for (int j = 0; j <= m; j++) {
            if (i + j >= 10) goto end_of_sum;
            sum += i + j;
        }
    }
end_of_sum:
    printf("%d", sum);
    return 0;
}
```

### Подвиг 7. Повторите программу из предыдущего 6-го подвига, только прерывание вложенного цикла выполните с помощью оператора break. (Прерывается только вложенный цикл, не внешний.) Оцените, как при этом изменится логика работы программы.

Еще раз формулировка подвига. Напишите программу, которая читает из входного потока два натуральных числа n, m и вычисляет следующую сумму:

![04](/Good_good_C_C++/img/04_04.png)

Сумма должна вычисляться до тех пор, пока слагаемое i+j меньше 10. Как только i+j окажется равно или больше 10, прервать подсчет суммы с помощью оператора break и вывести результат (полученную сумму) в консоль в виде одного целого числа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.4.7

```c
#include <stdio.h>

int main(void) {
    int n, m, sum = 0;

    scanf("%d %d", &n, &m);
    for (int i = 0; i <= n; i++) {
        for (int j = 0; j <= m; j++) {
            if (i + j >= 10) break;
            sum += i + j;
        }
    }

    printf("%d", sum);
    return 0;
}
```

### Подвиг 8. Напишите программу, которая читает из входного потока натуральное число n. Определить, является ли число n простым (то есть, делится нацело только на само себя и на 1). Вывести на экран "yes", если n простое и "no" - в противном случае.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.4.8

```c
#include <math.h>
#include <stdio.h>

int main(void) {
    int n;

    scanf("%d", &n);

    char res = 1;
    // проверим ввод на 1 и 2
    if (n == 1 || n == 2)
        ;
    // откинем все четные числа
    else if (n % 2 == 0) {
        res = 0;
    } else {
    // проверять будем от 3 до квадратного корня из числа с шагом 2
        for (int i = 3; i < sqrt(n); i += 2) {
            if (n % i == 0) {
                res = 0;
                break;
            }
        }
    }

    printf("%s", res ? "yes" : "no");
    return 0;
}
```

### Подвиг 9 (на повторение). Выберите все верные утверждения для следующего фрагмента программы:

```c
#include <stdio.h>

#define MUL(X, Y) X* Y
#define ADD(X, Y) ((X) + (Y))
#define T_ADD(X, Y) "Adding two values " #X " and " #Y
#define RES_N(RES) res_##RES

int main(void) {
    int a = 2, b = 5;
    int res_1 = MUL(7, b);
    int res_2 = MUL(a + 2, b - 1);
    int res_3 = ADD(7, b * 2);
    printf(T_ADD(i, j) "\n");
    printf("%d %d %d", RES_N(1), RES_N(2), RES_N(3));

    return 0;
}
```

+ [ ] вызов макрос-функции T_ADD(i <> 2, j == 3) приведет к синтаксической ошибке
+ [x] операция # возвращает текстовое представление лексемы X
+ [x] вызов макро-функции ADD(X, Y) всегда будет давать корректные результаты сложения двух числовых выражений
+ [x] действие макроопределений распространяется только на текущий модуль
+ [x] операция ## служит для склейки двух лексем в одну
+ [x] макрос-функция T_ADD(i <> 2, j == 3) вернет строку "Adding two values i <> 2 and j == 3"
+ [ ] вызов макро-функции MUL(7, b) приведет к не верным результатам вычисления произведения 7 * b
+ [x] вызов макро-функции MUL(a + 2, b - 1) приведет к не верным результатам вычисления произведения (a+2) * (b-1)

### Подвиг 10 (на повторение). Выберите все верные утверждения, касающиеся макроопределений.

+ [x] имена макросов принято записывать заглавными буквами
+ [x] макроопределение формально должно быть записано в одну строчку (до символа переноса строки)
+ [x] макроопределения обрабатываются до непосредственной компиляции программы
+ [x] при компиляции программы текстовый препроцессор вместо имени макроса подставляет его определение (тело макроса)
+ [ ] директива #undef создает макроопределение, а директива #define отменяет существующее макроопределение
+ [ ] макроопределения обрабатываются после компиляции программы (перевода в машинный код)
+ [x] директива #define создает макроопределение, а директива #undef отменяет существующее макроопределение

# 4.5 Указатели. Проще простого

## Указатели

Прежде чем двигаться дальше, изучать массивы, строки, функции и т.п., нужно вначале познакомиться с самым прекрасным, сакраментальным и основополагающим знанием – концепцией указателей. 

Это невероятно простая тема, вводящая многих в трепетный ужас. 

С чем это связано? Не знаю. Для меня это загадка. Чтобы преодолеть «проклятие» понимания указателей, я, на этом занятии, расскажу о них предельно подробно, красочно и ёмко. 

А начнем, как всегда, с самого начала.

Из предыдущих серий вы уже знаете, что вычислительная техника снабжена оперативной памятью, которую можно представить в виде непрерывной последовательности ячеек, размером в один байт.

Каждая ячейка имеет свой номер, который называется адресом.

![04](/Good_good_C_C++/img/04_05.jpg)

Также вы знаете, что в этих ячейках располагаются программы и данные. 

Но нас будут интересовать только данные, которые на уровне языка описываются переменными и константами. 

Поэтому предположим, что в программе объявляется переменная типа `char`:

```c
char d;
```

В результате, когда выполнение дойдет до этой строчки, в памяти устройства автоматически будет выделена область памяти размером в один байт (одну ячейку):

![04](/Good_good_C_C++/img/04_06.png)

Если затем в программе объявляется еще одна переменная, предположим, типа `int`:

```c
int f;
```

то также автоматически где-то в памяти будет выделена свободная область для хранения этой переменной. 

Причем, под нее будет уже отведено четыре подряд идущих байта. 

При этом адресом переменной считается номер первой ячейки. 

В нашем примере адрес переменной `f` равен `101`, несмотря на то, что она охватывает еще три ячейки с адресами `102`, `103` и `104`.

![04](/Good_good_C_C++/img/04_07.png)

Также обратите внимание, что ячейки памяти для переменных `f` и `d` не пересекаются. 

У каждой переменной строго своя область. 

И это наиболее частый вариант, если сами, намеренно не укажем делать иначе. 

Именно так мы будем полагать далее. 

То есть, смысл объявления переменных с точки зрения вычислительной техники – это размещение их в памяти устройства. 

Под каждую переменную где-то в памяти отводится своя независимая область и в этой области хранится значение соответствующей переменной. Например, если переменной `d` присвоить значение `10`:

```c
d = 10;
```

то в ячейке, отведенной под эту переменную, будет занесено значение `10`. А если переменной `f` присвоить значение `75432`:

```c
f = 75432;
```

то в ее ячейках будут записаны числа: `168`, `38`, `1`, `0`. Почему именно такие? Потому, что число `75432` кодируется на уровне байт следующим образом:


$75432 = 168 + 256 ∙ 38 + 256^2 ∙ 1$

И аналогичная картина будет для любых переменных языка Си. Например, при объявлении вещественной переменной `t` типа `double`:

```c
double t;
```

в памяти будет выделено уже 8 байт. И то, что содержится в этих 8 байтах и будет определять содержимое этой переменной. Так хранятся любые переменные, которые мы объявляем в программах.

## Указатели, страшные и ужасные!

Фактически получается, что имена переменных обозначают определенную непрерывную область памяти, в которой хранятся некоторые данные. 

А раз это так, то изменение значений в этих ячейках автоматически приведет к изменению значения самой переменной. 

Но как мы можем изменить эти ячейки, не используя саму переменную? 

Вот как раз это способны делать указатели. 

Именно для этого они существуют – для записи и считывания данных из произвольных ячеек памяти. Это еще называется прямым доступом к памяти.

Так что же из себя представляют указатели? 

Возможно, вас это удивит, но это, по сути, те же самые переменные, причем, целочисленные. 

А хранят они (в виде целого числа) адрес той ячейки памяти, в которую можно что-то записать или прочитать, то, что в ней содержится. 

Поэтому размер данных указателя в памяти определяется разрядностью системы.

Если система 32-х разрядная, то указатели занимают 4 байта; если 64-х разрядная, то 8 байт:

![04](/Good_good_C_C++/img/04_08.png)

Этого как раз достаточно, чтобы охватить все ячейки памяти целым беззнаковым значением. 

Соответственно, для систем с другими разрядностями, размер указателей также будет другим. Но, чаще всего, мы имеем дело с 32-х и 64-х разрядами.

Давайте теперь посмотрим, как в языке Си можно объявить указатель. Общий синтаксис здесь такой:

```c
<тип данных> *<имя указателя>;
```

Вначале указываем тип данных, с которым будет работать указатель. 

Затем ставится звездочка и следом прописывается имя указателя. 

Обратите внимание, сам по себе указатель всегда хранит лишь адрес переменной и имеет фиксированный размер (4 байта для 32-х разрядных систем; 8 байт для 64-х разрядных систем). 

Тип, который мы указываем вначале, относится не к указателю, а к типу данных, с которыми его предполагается использовать. Сейчас на конкретных примерах вы все это увидите и поймете.

Давайте предположим, что мы хотим через указатель взаимодействовать с байтовой переменной `d`. Так как переменная `d` имеет тип `char`, то и при объявлении указателя также нужно указать этот же тип `char`:

```c
char d = 10;
char *gpt;
```

После этого указателю нужно присвоить адрес переменной (ячейки памяти), где располагается переменная `d`. В нашем примере – это ячейка с номером `34024`. То есть, нужно записать следующую команду:

```c
gpt = 34024;
```

В результате указатель `gpt` будет хранить это целое число, следующим образом:

```c
34024 = 232 + 256 ∙ 132
```

В первом байте будет записано 232, во втором – 132, а все остальные равны нулю. 

Как только мы присвоили указателю адрес переменной, то говорят, что указатель указывает (ссылается) на эту переменную. 

После этого мы можем совершенно спокойно посредством указателя `gpt` записывать значения в ячейку с номером `34024` и считывать оттуда данные.

Делается это следующим образом:

```c
char x = *gpt;  // считывание значения из ячейки памяти
*gpt = 100;      // запись значения 100 в ячейку памяти
```

То есть, когда перед именем указателя стоит символ `*`, его следует воспринимать как переменную типа `char`, расположенной по адресу `34024`.

Соответственно, команда `x = *gpt;` будет выполнять чтение данных из этой переменной, а команда `*gpt = 100;` - запись значения `100` в эту переменную.

И, так как переменная `*gpt` и переменная `d` располагаются в одной и той же ячейке, то сначала будет прочитано значение `10` и присвоено переменной `x`, а затем, переменная `d` будет изменена на значение `100`. 

Сама операция `*`, записанная перед именем указателя (после его объявления), называется операцией разыменования.

Вот принцип объявления и использования указателей в языке Си. 

+ Конечно, сейчас у вас может возникать вопрос зачем все это надо? 
+ Есть же переменные и с ними можно работать напрямую? 
+ Какой смысл в этих указателях? 

Но, все по порядку. 

И первый правильный вопрос такой: как нам в реальной программе узнать адрес расположения переменной? 

Число `34024`, что мы использовали – это всего лишь иллюстрация. 

В реальности, та же переменная `d` может находиться в любой доступной ячейке памяти. Как же узнать номер этой ячейки? И здесь тоже все очень просто. 

В языке Си есть специальный оператор, который возвращает адрес переменных. Он определяется символом амперсанд и записывается перед именем переменной. Например, так:

```c
gpt = &d;
```

В результате указатель `gpt` будет содержать адрес переменной `d`, где бы она ни располагалась в памяти. 

Это универсальная конструкция. И, обратите внимание, здесь мы прописываем указатель без символа `*`, так как присваиваем ему адрес. Давайте еще раз. Смотрите, если записать указатель в двух формах:

```c
gpt = 0;
*gpt = 0;
```

то в первой строчке присваивается адрес, с которым, затем, этот указатель может работать, а во второй заносим значение `0` в ячейку памяти с адресом `0`. 

Вот эти две формы использования указателей нужно очень хорошо запомнить и понимать, как они работают. 

Если вам кажется, что вы сейчас что-то не улавливаете, то изучите этот вопрос подробнее, прежде чем идти дальше.

Итак, мы теперь готовы написать свою первую программу с использованием указателей. Пусть она делает ровно то, о чем я только что рассказывал: меняет значение переменной `d` через указатель `gpt`:

```c
#include <stdio.h>

int main(void) {
    char d = 10;
    char *gpt;
    gpt = &d;

    printf("gpt = %p, *gpt = %d, d = %d\n", gpt, *gpt, d);

    *gpt = 100;
    printf("gpt = %p, *gpt = %d, d = %d\n", gpt, *gpt, d);

    return 0;
}
```

После выполнения программы увидим строчки:

```
gpt = 0062ff1b, *gpt = 10, d = 10
gpt = 0062ff1b, *gpt = 100, d = 100
```

Смотрите, указатель `gpt` хранит адрес `0062ff1b`, где расположена байтовая переменная `d` со значением `10`. 

Операция `*gpt` позволяет прочитать значение этой переменной и оно, естественно, совпадает с самой переменной `d`. 

После этого с использованием той же операции `*gpt` мы заносим в ячейку памяти с номером `0062ff1b` значение `100`. И видим, что переменная `d` также изменила свое значение.

А теперь, смотрите, мы с вами в программе можем объединить две строчки:

```c
char *gpt;
gpt = &d;
```

в одну следующим образом:

```c
char *gpt = &d;
```

На первый взгляд, кажется, что мы используем форму записи указателя со звездочкой, а значит, присваиваем ему не адрес, а заносим некоторое значение по какому-то адресу. 

Но это не так. 

Здесь определена операция инициализации указателя, а не присваивания. 

Когда мы говорили о переменных, то я отмечал этот факт. 

Если в момент объявления переменных мы им сразу что-либо присваиваем, то отрабатывает операция инициализации, которая, в общем случае, отличается от операции простого присваивания. 

Здесь, как раз тот самый случай. 

При инициализации указателя ему присваивается адрес, а звездочка записана для объявления переменной `gpt` как указателя, а не просто как обычной переменной.

Инициализатор это прекрасно «понимает» и заносит в указатель адрес переменной `d`. Этот момент также следует понимать. Он часто используется на практике.

Итак, мы с вами научились объявлять указатель типа `char` и с его помощью читать и менять значение байтовой переменной. 

Давайте теперь посмотрим, что будет происходить, если вместо типа `char` прописать тип `int` и у переменной и у указателя:

```c
#include <stdio.h>

int main(void) {
    int d = 10;
    int *gpt = &d;

    printf("gpt = %p, *gpt = %d, d = %d\n", gpt, *gpt, d);

    *gpt = 75432;
    printf("gpt = %p, *gpt = %d, d = %d\n", gpt, *gpt, d);

    return 0;
}
```

После запуска увидим строчки:

```
gpt = 0062ff18, *gpt = 10, d = 10
gpt = 0062ff18, *gpt = 75432, d = 75432
```

На первый взгляд, работа программы никак не изменилась. Однако тип `int` обрабатывается несколько иначе. Когда выполняется команда:

```c
*gpt = 75432;
```

то на уровне машинных кодов оно автоматически раскладывается по четырем байтам в числа `168`, `38`, `1`, `0`:

$75432 = 168 + 256 ∙ 38 + 256^2 ∙ 1 + 256^3 ∙ 0$

И эти числа, начиная с адреса переменной `d`, последовательно заносятся в четыре байта, которые определяют значение этой переменной. То есть, здесь тип `int`, который прописан при объявлении указателя `gpt`, как раз и указывает компилятору, как следует интерпретировать и в какое количество ячеек заносить присваиваемые данные. 

Например, если следующей строчкой присвоить число 1:

```
*gpt = 1;
```

то все равно будет сформировано четыре числа:

```
1, 0, 0, 0
```

которые будут записаны в соответствующие ячейки переменной типа `int`.

А вот если бы у нас указатель по-прежнему имел бы тип `char`, то было бы сформировано только одно число `1` и занесено только в одну ячейку, так как `char` – это один байт. 

Вот в чем смысл типа, который прописывается при объявлении указателя. 

Мы указываем компилятору, в  каком формате следует представлять данные и как их заносить или считывать по указанному адресу. 

Поэтому, при работе с теми или иными переменными через указатели, типы должны совпадать, иначе возможны непредвиденные ошибки или неточности в представлении данных.

На этом мы завершим наше первое занятие по указателям. 

Мы сделали первый, важный шаг в понимании, что это вообще такое. 

Увидели, как объявляются указатели и как с их помощью можно менять значения в заданных ячейках памяти, обращаясь к ним напрямую, а не через переменные. 

На следующем занятии мы продолжим эту тему и окончательно развеем мифы о сложности этой одной из самых простых концепций языка программирования Си.

Видео по теме [#26. Указатели. Проще простого](https://www.youtube.com/watch?v=LORkeB_5MGM&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, касающиеся размещения переменных в памяти устройства

+ [x] порядковый номер ячейки памяти называется ее адресом
+ [x] адресом переменной называют порядковый номер ячейки, начиная с которой переменная хранится в памяти
+ [ ] адресом переменной называют порядковый номер ячейки, которой оканчивается область памяти, отведенная под переменную
+ [x] разные переменные (обычные) хранятся в разных не пересекающихся ячейках памяти
+ [ ] разные переменные (обычные) могут использовать одни и те же ячейки памяти
+ [x] через имя переменной на уровне языка Си осуществляется доступ к непрерывной области памяти из одной или нескольких ячеек

### Подвиг 2. Выберите все верные утверждения, касающиеся указателей языка Си.

+ [x] общий синтаксис объявления указателей следующий: <тип данных> *<имя указателя>;
+ [x] тип, указываемый при объявлении указателей, относится к данным, с которыми его предполагается использовать
+ [x] указатель хранит адрес области памяти, с которой потенциально может работать (записывать и считывать данные)
+ [x] посредством указателей можно осуществлять доступ к произвольным ячейкам памяти
+ [x] размер указателей, занимаемых в памяти устройства, как правило, совпадает с разрядностью операционной системы
+ [ ] тип, указываемый при объявлении указателей, относится к типу самого указателя

### Подвиг 3. Выберите все верные утверждения, касающиеся следующей программы.

```c
#include <stdio.h>

int main(void) {
    short var = 7;
    short* ptr_var;

    ptr_var = &var;
    *ptr_var = 8;

    printf("%d\n", *ptr_var);

    return 0;
}
```

+ [ ] если перед указателем записан символ *, то ему присваивается адрес области памяти
+ [x] если перед указателем записан символ *, то в область памяти, хранимой в указателе, заносится или считывается то или иное значение
+ [x] операция &, записанная перед именем переменной, возвращает ее адрес
+ [ ] операция &, записанная перед именем переменной, возвращает значение переменной
+ [x] если перед указателем не ставится *, то ему присваивается адрес области памяти
+ [x] объявляется указатель ptr_var для работы с данными типа short
+ [ ] если перед указателем не ставится *, то в область памяти, хранимой в указателе, заносится или считывается то или иное значение

### Подвиг 4. К чему может привести выполнение следующей программы?

```c
#include <stdio.h>

int main(void) {
    short* ptr_var;
    *ptr_var = 8;

    return 0;
}
```

+ [ ] в произвольную область памяти будет занесено значение 8 и программа гарантированно будет успешно завершаться
+ [x] в произвольную область памяти будет занесено значение 8 и программа может завершится аварийно
+ [ ] в область памяти с адресом 0 будет занесено значение 8 и программа может завершится аварийно
+ [ ] в область памяти с адресом 0 будет занесено значение 8 и программа гарантированно успешно завершится

### Подвиг 5. Допишите программу. Необходимо объявить указатель с именем ptr_var_d для работы с переменной var_d. Через указатель ptr_var_d изменить значение переменной var_d на -54.38.

P. S. В консоль ничего выводить не нужно.

```c
#include <stdio.h>

int main(void) {
    double var_d = 0;

    double* ptr_var_d = &var_d;

    *ptr_var_d = -54.38;

    return 0;
}
```

### Подвиг 6. Продолжите программу. Объявите указатель с именем ptr_k на переменную k. Увеличьте значение переменной k на 10, используя указатель ptr_k.

P. S. В консоль ничего выводить не нужно.

```c
#include <stdio.h>

int main(void) {
    int init, k;

    scanf("%d", &init);
    k = init;
    int* ptr_k = &k;
    *ptr_k += 10;

    return 0;
}
```

### Подвиг 7. Продолжите программу. Объявите указатель на переменную a с именем ptr_a. Через указатель ptr_a присвойте переменной a значение переменной b. Выведите в консоль значение переменной a в виде одного целого числа.

```c
#include <stdio.h>

int main(void) {
    short a, b;

    scanf("%hd", &b);

    short* ptr_a = &a;
    *ptr_a = b;

    printf("%d", a);
    return 0;
}
```

### Подвиг 8. Продолжите программу. Объявите указатель ptr_a на переменную a и указатель ptr_b на переменную b. Выполните обмен значениями переменных a и b через указатели ptr_a и ptr_b.

P. S. В консоль ничего выводить не нужно.

```c
#include <stdio.h>

int main(void) {
    short a, b, init_a, init_b;

    scanf("%hd, %hd", &a, &b);
    init_a = a;
    init_b = b;

    short* ptr_a = &a;
    short* ptr_b = &b;

    *ptr_a = init_b;
    *ptr_b = init_a;

    return 0;
}
```

### Подвиг 9. Продолжите программу. Объявите указатель ptr_a на переменную a и указатель ptr_b на переменную b. Вычислите произведение значений переменных a и b, используя указатели ptr_a и ptr_b. Результат присвойте переменной res и выведите ее в консоль в виде целого числа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/4.5.9

```c
#include <stdio.h>

int main(void) {
    short a, b;

    scanf("%hd, %hd", &a, &b);

    short* ptr_a = &a;
    short* ptr_b = &b;

    int res = *ptr_a * *ptr_b;

    printf("%d", res);

    return 0;
}
```

### Подвиг 10 (на повторение). Выберите все верные утверждения, касающиеся оператора цикла for языка Си стандарта C99 и выше.


+ [x] цикл for сначала проверяет условие, а затем, выполняет очередную итерацию
+ [x] в блоке инициализации цикла for можно объявлять и инициализировать новые переменные
+ [x] цикл for работает, пока истинно условие цикла
+ [ ] цикл for сначала выполняет итерацию, а затем, проверяет условие продолжения цикла
+ [ ] цикл for работает, пока ложно условие цикла
+ [x] блок "изменение значений" выполняется сразу после очередной итерации тела цикла
+ [x] цикл for записывается по синтаксису: for([инициализация]; [условие]; [изменение значений]) оператор;

# 4.6 Приведение типов указателей. Константа NULL

На предыдущем занятии мы с вами узнали следующее:

```c
char d = 5; 
char *gpt;   // объявление указателя для работы с данными типа char
gpt = &d;   // взятие адреса переменной d и присваивание его указателю gpt
char x = *gpt; // получение значения по адресу переменной d
*gpt = 100;  // запись значения в ячейку, где расположена переменная d
```

Сам же указатель на уровне машинных кодов – это обычное хранилище целочисленного значения (адреса ячейки памяти), который, как правило, занимает:
+ 4 байта – для 32-х разрядных систем;
+ 8 байтов – для 64-х разрядных систем.

И для полноты картины отмечу, что мы можем в одном операторе объявить сразу несколько указателей одного и того же типа. Например:

```c
short *a, * b, *c;  // три указателя
```

Обратите внимание, перед каждым именем должен стоять символ `*`. Только тогда мы получим объявление трех указателей. Иногда начинающие программисты пишут объявление так:

```c
short *a, b, c;  // указатель a и переменные b, c
```

В этом случае только `a` будет указателем, а `b` и `c` – обычными байтовыми переменными. Запомните, звездочку нужно прописывать перед каждым именем, если мы хотим получить три указателя.

## Присваивание указателей. Приведение типов указателей

Давайте представим, что у нас в программе объявлено два указателя и только один из них указывает на переменную `arg`:

```c
#include <stdio.h>

int main(void) {
    int arg = 7;
    int *ptr_arg, *ptr;

    ptr_arg = &arg;

    return 0;
}
```

Как сделать так, чтобы и второй указатель `ptr` тоже ссылался на эту же переменную `arg`. В данном конкретном случае можно поступить двумя способами. В первом также взять адрес переменной и присвоить второму указателю:

```c
ptr = &arg;
```

А во втором, присвоить одному указателю значение другого:

```c
ptr = ptr_arg;
```

Так тоже можно делать, так как указатели в основе своей – это обычные целочисленные хранилища адресов. Поэтому мы можем адрес из одного указателя присвоить другому указателю, используя уже знакомую нам операцию присваивания. В результате оба указателя будут ссылаться на одну и ту же переменную `arg`. И в этом легко убедиться:

```c
#include <stdio.h>

int main(void) {
    int arg = 7;
    int *ptr_arg, *ptr;

    ptr_arg = &arg;
    ptr = ptr_arg;

    printf("*ptr = %d, arg = %d\n", *ptr, arg);

    *ptr_arg = 100;
    printf("*ptr = %d, arg = %d\n", *ptr, arg);

    return 0;
}
```

Мы читаем значение переменной `arg` с помощью указателя `ptr`, а меняем с помощью указателя `ptr_arg`. После запуска программы видим следующие строчки:

```c
*ptr = 7, arg = 7
*ptr = 100, arg = 100
```

Все действительно работает, так как оба указателя ссылаются на один и тот же адрес в памяти, где хранится переменная `arg`.

Давайте теперь немного модифицируем программу и у второго указателя `ptr` поменяем тип данных с `int` на `char`:

```c
#include <stdio.h>

int main(void) {
    int arg = 777;
    int *ptr_arg;
    char *ptr;

    ptr_arg = &arg;
    ptr = ptr_arg;

    return 0;
}
```

При компиляции увидим предупреждение, что мы пытаемся присваивать разные несовместимые типы, с которыми работают указатели:

```
assignment to 'char *' from incompatible pointer type 'int *'
```

Хотя, при этом, программа выполнится без ошибок и адрес будет присвоен. Это предупреждение компилятор выдает исключительно программисту, чтобы избежать возможных ошибок при работе с ячейками памяти через указатели `ptr` и `ptr_arg`. И вы уже знаете, какие проблемы могут возникнуть. Так как `ptr` – это байтовый указатель, то команда:

```
*ptr = 1;
```

запишет значение `1` только в одну ячейку памяти, на которую ссылается `ptr`. Тогда как команда:

```c
int x = *ptr_arg;
```

прочитает четыре байта из памяти и из них будет сформировано целое число типа `int`. Поэтому при выводе результата:

```c
*ptr = 1;
printf("*ptr_arg = %d, arg = %d\n", *ptr_arg, arg);
```

первоначальное значение `777` будет изменено на значение `769`, а не на `1`. И все из-за разницы типов данных, с которыми работают указатели. Именно поэтому компилятор и выдает в таких случаях предупреждения.

Однако бывают (и не редко) ситуации, когда действительно в программе нужно указателю одного типа данных присвоить значение указателя, работающего с другим типом данных. В этом случае следует явно прописать операцию приведения типов для указателей. Делается это следующим образом:

```c
ptr = (char *)ptr_arg;
```

То есть, прописываются круглые скобки и в них указывается тот тип указателя, к которому он приводится. Тогда компилятор «поймет», что программист сознательно делает такую операцию и не выдает никаких предупреждений. Программа, разумеется, будет работать без каких-либо изменений.

Приведение типов для указателей следует прописывать всегда, когда типы различаются, кроме одного случая, когда указатель объявлен с обобщенным типом `void`:

```c
void *p;
```

Тогда мы можем совершенно свободно ему присваивать адреса любых других указателей:

```
p = ptr;
```

И, наоборот, его присваивать любым другим:

```
ptr_arg = p;
```

Компилятор в этих случаях не будет выдавать никаких предупреждений. Фактически, этот тип `void*` введен в язык Си исключительно для хранения адресов и их последующего присваивания другим указателям. При этом сам указатель с типом `void*` нельзя использовать для работы с ячейками памяти. Следующие команды приведут к ошибкам на этапе компиляции:

```c
*p = 10;      // тип void* не позволяет заносить данные
int x = *p;   // тип void* не позволяет читать данные
```

И это не случайно, так как тип `void` не определяет какой-либо конкретный формат данных. Поэтому как, например, интерпретировать число `10` при записи в ячейки, совершенно непонятно.

## Проблемы, сокрытые в указателях

Как видите, указатели совсем не такие страшные и ужасные, как о них порой говорят. Может даже наоборот показаться, что они простые, понятные, белые и пушистые. 

Но не спешите с выводами. Временами они бывают коварными, непредсказуемыми и даже губительными. Как правило, это происходит в моменты, когда от них такого совсем не ждешь. И связано это, в основном, с двумя распространенными ситуациями:
+ указатель ссылается на произвольную (не выделенную) область памяти и в нее происходит запись некоторого значения;
+ в программе динамически выделяется память (с помощью функции malloc), но не освобождается (утечка памяти).

Про вторую ситуацию мы с вами еще подробно будем говорить, когда речь пойдет о динамическом выделении памяти и работе с функциями `malloc()` и `free()`. 

Сейчас сосредоточимся на первом пункте. О чем он говорит? Я, думаю, вы все уже поняли. Пусть у нас в программе объявляется некоторый указатель, а затем, используется следующим образом:

```c
#include <stdio.h>

int main(void) {
    int *ptr;
    *ptr = 1;

    return 0;
}
```

Такая программа скомпилируется и запустится. Но, очень вероятно, что завершится с ошибкой. В данном случае, мы видим код завершения отличный от нуля:

```
exited with code=3221225477 in 0.73 seconds
```

Почему так произошло? Очевидно, мы пытаемся записать число `1` в некоторую область памяти, которая может быть отведена под какие-то другие задачи. 

Нельзя вот так запросто, куда угодно что-либо записывать. Сначала нужно запросить у операционной системы свободную область памяти, сказать, что мы ее будем использовать для нужд программы, а уже потом записывать туда данные. 

Только так. Никак иначе. И этот процесс запроса памяти называется в программировании выделением памяти. Кусок памяти выделяется операционной системой и в нее другие программы уже ничего не могут заносить. Она только наша. Пока не будет освобождена. Конечно, при завершении программы, вся выделенная память автоматически освобождается.

Так вот, когда мы объявляем ту или иную переменную, то как раз автоматически запускается этот процесс выделения памяти. Поэтому в ячейки, занятые переменной, мы совершенно спокойно можем что-либо записывать и считывать:

```c
#include <stdio.h>

int main(void) {
    int arg = 5;
    int *ptr = &arg;
    *ptr = 1;

    return 0;
}
```

В этом случае программа выполнится без ошибок и завершится с кодом 0.

## Константа NULL

Но все же, очень часто бывают ситуации, когда в нашем распоряжении имеется некий указатель и нам бы хотелось знать: указывает ли он на выделенную область, с которой можно работать, или на произвольную, то есть, указатель не был инициализирован? 

К сожалению, в языке Си нет встроенного механизма, который бы позволял гарантированно отвечать на этот вопрос. 

Но один прием довольно часто используется на практике. Ничто не мешаем нам договориться, если указатель принимает некоторое строго предопределенное значение, значит, он еще не был инициализирован. 

А иначе, ссылается на выделенную область памяти. Что может здесь выступать в качестве предопределенного значения? 

В языке Си для этого используется специальная константа `NULL`, определенная с помощью директивы define в заголовочном файле `stdio.h`:

```c
int *ptr = NULL;
```

Для разных ОС макрос `NULL` может принимать разные значения. В моем случае – это нулевой указатель, заданный в виде:

```c
#define NULL      ((void *)0)
```

То есть, фактически, мы присваиваем указателю нулевой адрес, который будет означать, что он пока не ссылается на выделенную область и записывать данные в эти ячейки не нужно. Проверку этого условия можно записать так:

```c
#include <stdio.h>

int main(void) {
    int arg = 5;
    int *ptr = NULL;

    if (ptr != NULL) *ptr = 1;

    return 0;
}
```

После запуска программа выполнится и завершится без ошибок. При этом команда `*ptr = 1;` выполнена не будет. Если же изменить значение указателя:

```c
ptr = &arg;
```

то условие станет истинным и значение переменной `arg` будет изменено на единицу.

Вот так с помощью предопределенной константы `NULL` можно контролировать значение указателя на выделенную область памяти. 

Хотя, конечно, этот прием не дает гарантии. Вполне может возникнуть ситуация, когда указатель не будет равен `NULL` и при этом ссылаться на невыделенную область. 

Но это уже ложится на плечи программиста. Именно мы должны так продумывать логику работы программы, чтобы указатели всегда гарантированно содержали нужные нам адреса.

Видео по теме [#27. Указатели. Приведение типов. Константа NULL](https://www.youtube.com/watch?v=qFAznyh-Gx4&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные варианты объявления указателей.

+ [x] long * ptr_var;
+ [ ] unsigned * char ptr_byte;
+ [ ] unsigned * short ptr_hd;
+ [x] float *a, *b, *c; // a, b, c - указатели
+ [x] double* a;
+ [ ] int* u, v, c; // u, v, c - указатели

### Подвиг 2. Выберите все верные варианты, касающиеся указателей.

+ [ ] указатели разных типов не могут ссылаться на одну и ту же область памяти
+ [x] присваивание адресов указателей разных типов приводит к предупреждению при компиляции программы
+ [x] указатель с типом void* можно присваивать указателям любых других типов без возникновения каких-либо предупреждений со стороны компилятора
+ [x] константа NULL языка Си служит для обозначения неиницализированного указателя (на выделенную область памяти)
+ [x] указатели разных типов могут ссылаться на одну и ту же область памяти
+ [x] присвоение указателей разных типов следует выполнять с операцией приведения типа одного указателя к другому

### Подвиг 3. Продолжите программу. Объявите указатель ptr_a на переменную a и указатель ptr_b на переменную b. Поменяйте адреса указателей ptr_a и ptr_b между собой, используя третий вспомогательный указатель с обобщенным типом void*. Выведите в консоль в одну строчку через пробел целочисленные значения, на которые ссылаются указатели ptr_a и ptr_b именно в таком порядке:

<значение для ptr_a> <значение для ptr_b>

```c
#include <stdio.h>

int main(void) {
    short a, b;

    scanf("%hd, %hd", &a, &b);

    short *ptr_a = &a;
    short *ptr_b = &b;

    void *tmp = ptr_a;
    ptr_a = ptr_b;
    ptr_b = tmp;

    printf("%d %d", *ptr_a, *ptr_b);

    return 0;
}
```

### Подвиг 4. Продолжите программу. Объявите указатель с именем ptr_var на переменную var. После этого объявите еще один указатель с именем ptr_ch для типа char и присвойте ему адрес, хранимый указателем ptr_var. (Не забудьте прописать операцию приведения типов.) Выведите в консоль целочисленное значение, на которое ссылается указатель ptr_ch.

```c
#include <stdio.h>

int main(void) {
    int var;

    scanf("%d", &var);

    int *ptr_var = &var;
    char *ptr_ch = (char *)ptr_var;

    printf("%d", *ptr_ch);

    return 0;
}
```

### Подвиг 5. Продолжите программу. Объявите указатель с именем ptr_var на переменную var. После этого объявите еще один указатель с именем ptr_ch для типа char и присвойте ему адрес, хранимый указателем ptr_var. (Не забудьте прописать операцию приведения типов.) Запишите в ячейку памяти, на которую ссылается указатель ptr_ch, целочисленное значение 2. Выведите в консоль значение переменной var в виде одного целого числа.

```c
#include <stdio.h>

int main(void) {
    short var;

    scanf("%hd", &var);

    short *ptr_var = &var;
    char *ptr_ch = (char *)ptr_var;

    *ptr_ch = 2;

    printf("%d", var);

    return 0;
}
```

### Подвиг 6. Выберите все верные утверждения, касающиеся приведенной программы.

```c
int main(void) {
    char ch = 'a';
    char* ptr = &ch;

    int* ptr_i = (int*)ptr;
    *ptr_i = 0;

    return 0;
}
```

+ [x] команда *ptr_i = 0; последовательно запишет четыре 0, начиная с ячейки памяти с адресом ptr_i
+ [ ] указатели ptr и ptr_i ссылаются на одну и ту же область памяти
+ [x] указатели ptr и ptr_i содержат один и тот же адрес
+ [ ] команда *ptr_i = 0; запишет один 0, в ячейку памяти с адресом ptr_i
+ [ ] в строчке int * ptr_i = (int *)ptr; не хватает амперсанда (&) перед именем указателя ptr
+ [x] программа имеет потенциальную уязвимость, так как указатель ptr_i работает с 4 байтами (обычно), а ptr ссылается на выделенную область в один байт

### Подвиг 7. Продолжите программу. По указателю global_ptr типа int необходимо выполнить запись целочисленного значения 10 в том случае, если global_ptr ссылается на выделенную область памяти.

Указатель `global_ptr` в программе не отображается, но он объявлен и существует.

P. S. В консоль ничего выводить не нужно.

```c
#include <stdio.h>

int main(void) {
    if (global_ptr != NULL) *global_ptr = 10;
    return 0;
}
```

### Подвиг 8 (на повторение). Выберите все верные утверждения, касающиеся тернарной условной операции.

+ [x] данная операция определяется синтаксисом: <выражение 1> ? <выражение 2> : <выражение 3>
+ [x] данная операция именно операция и может быть использована совместно с другими вычислениями
+ [ ] данная операция не может быть использована совместно с другими вычислениями
+ [x] приоритет тернарной условной операции ниже операций сравнения и арифметических операций
+ [x] данная операция работает по принципу if-else (если-иначе) и возвращает либо одно, либо другое вычисленное выражение
+ [ ] приоритет тернарной условной операции выше операций сравнения, но ниже арифметических операций
+ [ ] данная операция определяется синтаксисом: ? (<выражение 1>) <выражение 2> : <выражение 3>

### Подвиг 9 (на повторение). Выберите все верные утверждения, касающиеся условного оператора if/else.

+ [ ] переход на else осуществляется только при истинном условии
+ [x] по некоторому условию можно выполнить сразу несколько операторов, записав их в фигурных скобках
+ [ ] по некоторому условию можно выполнить строго только один оператор
+ [x] оператор if(<выражение>) передает управление к записанному в нем оператору, если <выражение> не равно нулю
+ [x] условные операторы также называют операторами ветвления
+ [x] переход на else осуществляется только при ложном условии
+ [x] оператор if можно записать по синтаксису: if(<выражение>) <оператор 1>; else <оператор 2>;
+ [x] оператор if можно записать по синтаксису: if(<выражение>) <оператор>;
+ [ ] оператор if(<выражение>) передает управление к записанному в нем оператору, если <выражение> равно нулю

# 4.7 Долгожданная адресная арифметика

## Адресная арифметика

На этом занятии поговорим о том, чем пугают студентов информационных специальностей, из-за чего они не спят ночами или просыпаются в холодном поту. 

Да, это моя любимая и долгожданная адресная арифметика! Суть которой можно выразить одной фразой:

> Значение указателя меняется на размер типа данных, для которого он определен.

Осталось только конкретизировать эту фразу и привести примеры.

Пусть в нашей программе объявлена целочисленная переменная `g` с начальным значением `4` и указатель `ptr`, который инициализирован на переменную `g`:

```c
#include <stdio.h>

int main(void) {
    int g = 4;
    int *ptr = &g;

    printf("ptr = %u\n", ptr);

    return 0;
}
```

С помощью функции `printf()` выполняется вывод адреса указателя `ptr` в виде беззнакового целого десятичного числа. После запуска программы увидим значение:

```
ptr = 6487832
```

Это номер ячейки, начиная с которой располагается целочисленная переменная `g`. А теперь давайте посмотрим, что будет, если значение адреса указателя `ptr` увеличить на единицу:

```c
ptr++;
printf("ptr = %u\n", ptr);
```

Запустим программу, увидим значения:

```
ptr = 6487832
ptr = 6487836
```

И вот здесь некоторые начинающие программисты испытывают то, что называют мудреной фразой «когнитивный диссонанс». 

Почему операция инкремента увеличивает значение адреса сразу на четыре, а не на один, как это, возможно, ожидалось? 

Ответ очень прост. 

Когда мы работаем с указателями, а не с обычными переменными, то целочисленные арифметические операции выполняются в соответствии с правилами адресной арифметики. 

В частности, увеличение на единицу означает, что нам нужно перейти к следующей порции данных в памяти компьютера, а не к следующей ячейке. 

Именно поэтому адрес указателя увеличивается на размер типа данных, для которого он объявлен. 

В нашем примере – это тип `int`, который занимает `4` байта. Поэтому увеличивая на единицу значение адреса указателя `ptr`, мы получаем прибавку на эти четыре байта. Отсюда и получается такой результат.

Подобный результат будет, если выполнить операцию декремента:

```c
ptr--;
printf("ptr = %u\n", ptr);
```

тогда значение адреса, наоборот, уменьшится на четыре:

```
ptr = 6487832
ptr = 6487828
```

Вот это и есть магия адресной арифметики. Вообще, мы можем с указателями выполнять следующие целочисленные арифметические операции:

```c
#include <stdio.h>

int main(void) {
    int g = 4;
    int *ptr = &g;

    printf("%p\n", ptr);

    ptr += 3;
    ptr -= 4;
    ptr = ptr + 10;
    ptr = ptr - 9;
    --ptr;
    ptr++;

    printf("%p\n", ptr);

    return 0;
}
```

Обратите внимание, операции должны быть именно целочисленными. 

В них должны фигурировать или целочисленные литералы или целочисленные переменные. 

Другие типы здесь использовать недопустимо. 

Также нельзя использовать операции умножения и деления. 

Исключение составляет только одна операция вычисления разности между двумя указателями, когда в операндах не используются целочисленные типы. 

Давайте посмотрим, как она работает на следующем примере:

```c
#include <stdio.h>

int main(void) {
    short g = 4, d = 1;
    short *ptr = &g;
    short *p = &d;

    printf("ptr = %u, p = %u\n", ptr, p);

    int res = ptr - p;

    printf("res = %d\n", res);

    return 0;
}
```

Смотрите, здесь объявлены сразу две переменные `g` и `d`, а затем, два указателя с инициализацией на эти переменные. После этого вычисляется разность между указателями `ptr` и `p` и результат заносится в обычную целочисленную переменную `res`.

После запуска программы увидим результат:

```
ptr = 6487826, p = 6487824
res = 1
```

Почему видим значение `1` в переменной `res`? Конечно, здесь выполняется адресная арифметика, которая возвращает расстояние в памяти между этими двумя переменными, причем расстояние выражено не в байтах, а в типе `short`, который занимает `2` байта. Фактически, значение `res` вычисляется по формуле:

```
res = (6487826 – 6487824) / 2 = 1
```

Здесь деление на `2` – это, как раз, следствие адресной арифметики (тип `short` занимает `2` байта).

Давайте посмотрим, что будет, если поменять местами операнды в операции вычитания:

```c
int res = p - ptr;
```

В этом случае переменная `res` принимает значение `-1`.

## Пример использования адресной арифметики

Вот вам и вся адресная арифметика. А чтобы было понятнее, приведу один показательный пример ее использования.

Пусть в программе по-прежнему объявляется целочисленная переменная типа `int` и ставится задача просмотреть побайтно содержимое этой переменной в памяти компьютера. Сделать это можно следующим образом:

```c
#include <stdio.h>

int main(void) {
    int g = 476789;
    char *ptr = (char *)&g;

    for (int i = 0; i < sizeof(g); ++i) {
        printf("%d ", *ptr);
        ptr++;
    }

    return 0;
}
```

Смотрите, мы здесь формируем указатель, который работает с байтовыми данными, то есть, с отдельными ячейками памяти. 

Затем, ему присваивается адрес целочисленной переменной `g` и в результате он ссылается на первый байт этой переменной. 

После этого в цикле `for` осуществляется вывод текущего значения байта на экран и указатель `ptr` увеличивается на единицу. 

Так как тип у него прописан как `char`, то операция инкремента увеличит адрес `ptr` ровно на один и мы перейдем к следующему байту. 

Соответственно, на следующей итерации будет выведено значение очередного байта и так для всех ячеек переменной `int`. В итоге на экране увидим числа:

```
117 70 7 0
```

которые в точности определяют число:

```
476789 = 117 + 256 ∙ 70 + 256^2 ∙ 7
```

## Приоритеты операций при работе с указателем

Кстати, тело цикла в программе можно было бы записать и короче:

```c
for(int i = 0; i < sizeof(g); ++i)
    printf("%d ", *ptr++);
```

Здесь у нас две унарные операции `++` и `*` применяются к указателю `ptr`.

Спрашивается, в каком порядке будут происходить вычисления? 

Здесь следует вспомнить, что приоритет унарных операций убывает справа-налево. 

Поэтому сначала идет инкремент в постфиксной форме и только затем операция разыменования. Это эквивалентно такой записи:

```
*(ptr++)
```

Так как инкремент записан в постфиксной форме, то вначале мы получаем текущее значение `ptr`, к нему применяется операция `*` и только после этого адрес увеличивается на единицу.

А вот если инкремент записать в префиксной форме:

```c
for(int i = 0; i < sizeof(g); ++i)
    printf("%d ", *++ptr);
```

то это будет эквивалентно записи:

```c
*(++ptr)
```

Здесь сначала адрес указателя увеличивается на единицу и только после этого срабатывает следующая операция разыменования. Поэтому байты будут прочитаны со сдвигом вправо на одну ячейку:

```
70 7 0 3
```

Вообще, когда мы используем указатель совместно с операцией разыменования и адресной арифметикой, то следует хорошо знать и учитывать их приоритеты. Например, имеется следующий фрагмент программы:

```
int g = 476789;
int *p = &g;
 
*p += 1;
```

Спрашивается, как будет работать последняя строчка? Рассуждаем здесь подобным образом. Так как операция `*` является унарной, то она обладает большим приоритетом, чем операция `+=`. 

Поэтому здесь сначала будет прочитано значение переменной `g`, затем, оно увеличивается на единицу и результат снова заносится в те же ячейки памяти, где расположена переменная `g`. В итоге, значение указателя `p` не изменится, а переменная `g` станет на единицу больше.

Если вы не уверены в порядке выполнения операций, то вполне допустимо использовать круглые скобки. Например, имеется программа:

```c
#include <stdio.h>

int main(void) {
    int g = 476789;
    char *ptr = (char *)&g;

    int x = *ptr + 1;
    printf("x = %d\n", x);

    return 0;
}
```

И спрашивается, чему будет равно значение переменной `x`? 

То есть, как отработает операция `*ptr + 1`? 

Очевидно, здесь приоритет унарной операции `*` выше, чем у бинарной операции сложения.  Поэтому, сначала будет прочитано значение из первого байта переменной `g` – это число `117`, а затем, к нему будет прибавлена единица. В итоге `x` будет содержать число `118`.

А вот если эту же строчку записать с круглыми скобками следующим образом:

```
int x = *(ptr + 1);
```

то ситуация кардинально меняется. Сначала будет увеличен адрес на единицу, мы перейдем к следующей ячейке переменной `g`, и переменной `x` будет присвоено значение этой второй ячейки. В итоге она будет принимать значение `70`.

И раз еще давайте посмотрим на работу команды:

```c
int x = *ptr++;
```

Такая запись указателя с операцией инкремента и разыменованием часто используется в практике программирования. 

В итоге мы здесь читаем значение из текущей ячейки, и только после этого адрес указателя увеличивается на единицу. Но, если мы это же выражение запишем в виде:

```c
int x = (*ptr)++;
```

то операция инкремента будет применена уже к данным в первой ячейке переменной `g`. В итоге переменной `x` присвоится начальное значение из первой ячейки, а переменная g станет содержать число:

```
476790 = 118 + 256 ∙ 70 + 256^2 ∙ 7
```

Как видите, все работает достаточно просто и логично. Возможно, если вы только делаете первые шаги в этой теме, нужно немного привыкнуть к особенностям работы указателей. 

Но ровным счетом ничего сложного в понимании их работы нет. Очень скоро, при определенной практике, каждый из вас сможет грамотно применять их в своих программах.

Видео по теме [#28. Долгожданная адресная арифметика](https://www.youtube.com/watch?v=fwpxSjoVf94&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Пусть в программе объявлены следующие переменные и указатели:

```c
int a = 5, b = 7;
double d = 2.0;
int* ptr_a = &a, *ptr_b = &b;
```

Выберите все верные (рабочие) варианты использования операций адресной арифметики для указателей `ptr_a` и `ptr_b`.

+ [ ] ptr_a *= a;
+ [x] ptr_b++;
+ [x] ptr_a += 3;
+ [ ] ptr_a -= d;
+ [x] ptr_b - ptr_a;
+ [ ] ptr_b += ptr_a;
+ [x] ptr_a += b * 5;
+ [ ] ptr_b -= ptr_a;
+ [x] --ptr_a;
+ [ ] ptr_a /= b;
+ [ ] ptr_b + ptr_a;

### Подвиг 2. Пусть имеется следующий фрагмент программы:

```c
short* p = (short *)10;  // тип short 16 бит
p++;
```

Чему будет равен адрес указателя `p` при выполнении этих двух строчек?

$12$

### Подвиг 3. Пусть имеется следующий фрагмент программы:

```c
double* p1 = (void *)128000, *p2 = (void *)128064;  // тип double 64 бит
int count = p2 - p1;
```

Чему будет равно значение переменной count при выполнении этих двух строчек?

$(128064 - 128000) / 64 * 8 = 8$

### Подвиг 4. Допишите следующую программу. Необходимо все 8 байт (тип double) переменной value вывести в консоль в виде десятичных чисел, записанных в одну строчку через пробел, начиная с первого байта.

Sample Input:

```
0.5
```

Sample Output:

```
0 0 0 0 0 0 -32 63
```

```c
#include <stdio.h>

int main(void) {
    double value;

    scanf("%lf", &value);

    char *ptr = (char *)&value;

    for (int i = 0; i < 8; i++) printf("%d ", *ptr++);

    return 0;
}
```

### Подвиг 5. Напишите программу, которая читает из входного потока целое число в переменную value типа int. Каждые два байта этой переменной следует обработать по следующему алгоритму:

1. Представить два байта в виде целого числа.
2. Увеличить каждое полученное двухбайтовое число на единицу.
3. Увеличенное значение снова побайтно перенести в соответствующие ячейки переменной value.

Полученное значение переменной value вывести в консоль в виде одного целого числа.

P. S. При написании программы гарантируется: char = 1 байт; short = 2 байта; int = 4 байта; double = 8 байт.

Sample Input:

```
325476
```
Sample Output:

```
391013
```

```c
#include <stdio.h>

int main(void) {
    int value;

    scanf("%d", &value);

    short *ptr = (short *)&value;

    for (int i = 0; i < 2; i++) {
        *ptr++ += 1;
    }
    printf("%d ", value);

    return 0;
}
```

### Подвиг 6. Продолжите программу. Используя указатели p1 и p2 определите сколько переменных типа double уместится в памяти, начиная с адреса p1 и заканчивая адресом p2 (не включая ячейку с адресом p2). Выведите вычисленное число переменных в консоль в виде целого числа.

Sample Input:

```
1024; 1112
```
Sample Output:

```
11
```

```c
#include <stdio.h>

int main(void)
{
    int a, b;

    scanf("%d; %d", &a, &b);

    void* p1 = (void *)a;
    void* p2 = (void *)b;

    int res = (p2 - p1) * sizeof(int) / sizeof(double);

    printf("%d", res);

    return 0;
}
```

### Подвиг 7 (с повторением). Напишите программу, которая читает из входного потока целое число в переменную count типа int. В каждом байте переменной count нужно включить 3-й и 0-й биты (нумерация бит в байте: 7, 6, 5, 4, 3, 2, 1, 0). Вывести в консоль полученное значение count в виде одного целого числа.

Sample Input:

0
Sample Output:

151587081

```c
#include <stdio.h>

int main(void) {
    int a;

    scanf("%d", &a);

    char *ptr_ch = (char *)&a;

    char count = sizeof(int);

    while (count--) {
        *ptr_ch++ |= 9;
    }

    printf("%d", a);

    return 0;
}
```

### Подвиг 8 (с повторением). Напишите программу, которая читает из входного потока целое число в переменную count типа int. В каждом байте переменной count нужно выключить 7-й, 6-й и 1-й биты (нумерация бит в байте: 7, 6, 5, 4, 3, 2, 1, 0). Вывести в консоль полученное значение count в виде одного целого числа.

Sample Input:

```
65535
```

Sample Output:

```
15677
```

```c
#include <stdio.h>

int main(void) {
    int a;

    scanf("%d", &a);

    char *ptr_ch = (char *)&a;

    char count = sizeof(int);
    unsigned char mask = 0b00111101;

    while (count--) {
        *ptr_ch++ &= mask;
    }

    printf("%d", a);

    return 0;
}
```

### Подвиг 9 (на повторение). Напишите программу, которая читает из входного потока четыре целых числа a, b, c, d, записанных в одну строчку через пробел. Необходимо определить войдет ли в конверт с внутренними размерами a и b см прямоугольная открытка с размерами с и d см. Для размещения открытки в конверте необходим зазор в 0,5 см с каждой стороны. Вывести в консоль "yes", если входит и "no" если не входит.

Sample Input:

```
5 10 9 3
```
Sample Output:
```
yes
```

```c
#include <stdio.h>
#define DELTA 1

int main(void) {
    int a, b, c, d;

    scanf("%d %d %d %d", &a, &b, &c, &d);

    char wight = (a > b ? a : b) - (c > d ? c : d) - DELTA >= 0;
    char height = (a < b ? a : b) - (c < d ? c : d) - DELTA >= 0;

    char res = wight * height;

    printf("%s", res ? "yes" : "no");

    return 0;
}
```

### Подвиг 10 (на повторение). Установите соответствия между суффиксами спецификаторов функции printf() и их описаниями.

![04](/Good_good_C_C++/img/04_09.PNG)

