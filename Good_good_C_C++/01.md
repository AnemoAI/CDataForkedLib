# 1. Первое знакомство

## Содержание
[1.1 Язык Си. Первые шаги](#11-язык-си-первые-шаги)

# 1.1 Язык Си. Первые шаги

[Video](https://cdn.stepik.net/video/365261/720/16f4a9aaecf62dc84dc1991d2ca25ef4.mp4)

## Язык Си. Рождение легенды
Сегодня математика составляет основу выражения современных научных знаний, а в основе математики лежат числа и операции сними, попросту говоря, вычисления. По-английски computing. Соответственно, устройство способное производить вычисления, звучит как computer. Отсюда и происходит знакомое нам русское слово компьютер. То есть, компьютер – это попросту вычислительная машина.

Первые попытки создать механические вычислительные машины предпринимались с незапамятных времен. Первой документально зафиксированной в истории считается машина Вильгельма Шиккарда, созданная в 1623 году. Однако есть предположения, что еще до этого в 16 веке известный изобретатель Леонардо да Винчи предпринимал попытки создания подобных механизмов. Удалось ли ему это или нет – доподлинно неизвестно. Но, наверное, самой известной счетной машиной является арифмометр Блеза Паскаля, созданный в 1645 году. И более совершенная конструкция, сделанная Готфридом Вильгельмом Лейбницем. Его счетная машина была способна не только складывать и вычитать, но также делить и умножать.

Однако все эти механические счетные машины автоматизировали одно-два действия с двумя числами: складывали, умножали, делили. Более продвинутую идею в 19 веке предложил Чарльз Беббидж сначала в виде разностной машины (1822 год), а позже – аналитической. Именно в аналитической машине у него появляется идея программного управления вычислениями. Правда, дальше идеи дело не пошло. Сложность построения его машины превосходила технологии того времени. Но с ней связан один интересный исторический факт. Когда леди Августа Ада Лавлейс переводила конспект лекций Беббиджа по устройству его аналитической машины на английский язык, то сопроводила перевод своими многочисленными комментариями, среди которых оказался полный набор команд для вычисления чисел Бернулли с помощью аналитической машины. Этот набор команд считается первой документально зафиксированной программой в истории человечества, а Ада Лавлейс – первым программистом.

Но все эти механические устройства, в большинстве своем, были громоздкими, неудобными и ненадежными. Поэтому оставались на уровне идей или единичных воплощений. Новый виток развития вычислительных машин начался в XX веке благодаря зарождению электроники. Одним из основоположников современной вычислительной техники стал английский математик Алан Тьюринг (1912 – 1954 гг.). В 1936 году он представил общую идею абстрактной универсальной вычислительной машины, которая выполняла различные задачи в зависимости от загруженных в нее данных. Вскоре, эта идея получила название универсальной машины Тьюринга. Затем эту идею развил венгерско-американский математик Джон фон Нейман (1903 – 1957 гг.). Он предложил команды и данные хранить в единой, однородной памяти компьютера. До этого команды следовало записывать в один тип памяти, а данные независимо в другую. Это приводило к заметным неудобствам. Поэтому идея фон Неймана по объединению команд и данных в единой памяти оказалась прорывной для того времени. Она стала настолько удачной, что сейчас практически вся вычислительная техника построена по этому принципу – по архитектуре, предложенной Джоном фон Нейманом.

Первое же поколение компьютеров (с 1944 года), построенных на электронных лампах, использовали принцип однородности памяти для данных и команд. Уже тогда сразу была принята на вооружение архитектура фон Неймана. И вычислительная техника, созданная по этому принципу, получила название машины фон Неймана.

Второе поколение компьютеров (с середины 1950-х) было выполнено на транзисторах. Схемотехнически, это те же лампы, но реализованные на уровне полупроводников. В результате вычислительная техника стала гораздо меньших объемов, потребляла меньше энергии, стала надежнее и с большим быстродействием. Внутреннее устройство компьютеров этого и всех последующих поколений уже базировалось на архитектуре фон Неймана.

Третье поколение компьютеров (с 1960-х годов) были разработаны на базе интегральных схем (микросхем), которые объединяли внутри себя схемы из большого числа транзисторов. Это привело к еще большему сокращению размеров компьютерной техники, повышению надежности и быстродействию.

Четвертое поколение вычислительной техники (с 1970-х годов) ознаменовано появлением специального типа микросхем, известных, как микропроцессор. Эта микросхема выполняла внутри себя все арифметические, логические операции и операции управления, записанные в машинном коде. Это дало новый скачок в развитии компьютерной техники. Благодаря миниатюризации и энергоэффективности компьютеры стали доступны массовому пользователю.

Практически всю современную вычислительную технику можно отнести к четвертому поколению. Конечно, она стала намного быстрее, с более сложным внутренним устройством, разнообразнее, но ничего принципиально нового в ней не появилось. Также присутствует центральный процессор, несколько вспомогательных процессоров, память, различные внешние и внутренние устройства, и все это объединено по архитектуре, предложенной Джоном фон Нейманом.

## Архитектура современного компьютера
Если внимательнее посмотреть на общее устройство компьютера, то мы увидим:

центральный процессор (CPU – central processing unit), который непрерывно выполняет поступающие в него команды;
оперативное запоминающее устройство (ОЗУ, англ. RAM – random access memory), в котором можно хранить данные и команды для процессора;
шину, соединяющую центральный процессор, память и другие дополнительные устройства, соединенные через контроллеры.
Как видите, процессор взаимодействует с другими компонентами через контроллеры. Почему это так сделано? Почему бы все эти устройства напрямую не подключать к шине? Зачем потребовался посредник в виде контроллера? Дело в том, что процессор понятия не имеет обо всех этих устройствах: ни о клавиатуре, ни о мониторе, ни о жестких дисках. У него нет инструкций, как, например, управлять считыванием информации с клавиатуры или с жесткого диска, или как выводить что-либо на монитор. Все, что умеет делать процессор – это выдавать определенные данные в шину и читать их оттуда. Именно так происходит взаимодействие с контроллерами: центральный процессор указывает адрес обращения к контроллеру, данные, и команды для контроллера. На основе принятых данных и команд контроллер выполняет определенные действия, например, указывает монитору вывести определенную информацию. И так с каждым устройством: клавиатурой, жестким диском и т.д.

Так как в шину процессор передает разные типы информации: данные для контроллера, его адрес и команды, то шина имеет соответствующие отдельные каналы, которые так и называют: шина данных, шина адресов, шина управления. Благодаря подключению устройств через контроллеры центральный процессор получает возможность взаимодействовать с ними на универсальном уровне. Если в будущем появится новый тип внешних носителей, например, какие-нибудь квантовые флэшки, или био-принтеры или что-либо еще, то это не потребует схемотехнического изменения самого процессора. Через контроллеры все новые устройства смогут, по-прежнему, обмениваться информацией с центральным процессором и полноценно выполнять свои функции.

Правда, из-за этого появляется еще один нюанс: процессор должен знать, какие команды, какие данные и в какой последовательности следует передавать на контроллеры, чтобы внешние устройства корректно ее принимали и обрабатывали. Для этого разработчики устройств совместно с ними поставляют специальные программы, которые называются драйверами. Центральный процессор для взаимодействия с тем или иным устройством просто выполняет соответствующую программу-драйвер и, таким образом, передает нужному контроллеру корректные управляющие команды. Так, в целом, происходит взаимодействие между процессором и любым внешним устройством.

## Память и выполнение команд центральным процессором
Давайте теперь посмотрим, что из себя представляет память. Практически во всей современной вычислительной технике, память можно представить в виде последовательностей упорядоченных ячеек, каждая из которых имеет свой физический номер (физический адрес). А сама ячейка, почти во всех схемотехнических реализациях, представляет собой восемь бит информации. Напомню, что один бит кодирует информацию двумя состояниями, которые, обычно, обозначаются числами 0 и 1. Число 0 – бит выключен; 1 – бит включен. Соответственно группа из восьми таких бит способна кодировать: 
$N=2^8=256$
различных вариантов. Например, целые числа в диапазоне от 0 до 255. Такая неделимая единица информации из 8 бит получила название байт. То есть, каждую ячейку памяти можно интерпретировать как один `байт`, в которой хранится целое число от 0 до 255.

Центральный процессор способен через шину заносить в любую ячейку оперативной памяти некоторое значение в этом диапазоне [0; 255], либо осуществлять запрос на получение значения также из любой существующей ячейки памяти. Но что в итоге нам это дает? Очевидно то, что в такой памяти можно хранить и команды для центрального процессора и данные. Причем, как команды, так и данные кодируются обычными числами.

Для определенности предположим, что в оперативной памяти, начиная с 1000-й ячейки, хранятся следующие числа (приведены в шестнадцатиричной записи):

    B8 22 11 00 FF 01 CA 31 F6 53 8B 5C 24 04 8D 34 48 39 C3 72 EB C3

И пусть компьютер оснащен 32-разрядным процессором архитектуры x86. Чтобы на вход процессора поступило первое число B8, расположенное по адресу 1000, счетчик команд этого процессора должен быть равен 1000. Да, внутри каждого процессора есть специальные внутренние хранилища данных, которые называются __регистрами__. В этих регистрах сохраняется промежуточная, вспомогательная информация для обработки текущей информации. Доступ к регистрам для чтения или записи (если это допустимо) выполняется очень быстро (быстрее, чем обращение к оперативной памяти). Так вот, один из регистров процессора – это счетчик команд (`program counter`) или его еще называют указателем инструкции (`instruction pointer`). Он содержит адрес ячейки памяти, в которой хранится следующая для выполнения команда. В нашем примере – это число 1000.

Итак, на вход процессора поступает число B8 из 1000-й ячейки памяти. В этом числе закодирована команда (на языке ассемблера):

    movl [адрес памяти], %eax

Она означает, что процессор должен взять 4 байта данных (32 бита) из оперативной памяти, расположенной по указанному адресу и занести эти данные в регистр процессора `eax`. Сам же адрес памяти кодируется следующими 4 байтами (32 битами):

    22 11 00 FF

В итоге, получаем команду (на языке ассемблера):

    movl $0xFF001122, %eax

Как только процессор выполнит эту команду, счетчик команд увеличится на 5 и станет ссылаться на число 01:

    B8 22 11 00 FF 01 CA 31 F6 53 8B 5C 24 04 8D 34 48 39 C3 72 EB C3

Это число будет восприниматься как новая команда, которая на уровне языка ассемблер означает сложение двух регистров:

    addl [первый регистр], [второй регистр]

Чтобы процессор понимал, какие два регистра складывать, берется следующий байт CA. В итоге, команда 01 CA означает прибавить к содержимому регистра edx значение из регистра ecx:

    addl %ecx, %edx

После этого счетчик команд увеличивается на 2 и ссылается на следующую команду 31. И так последовательно, такт за тактом происходит выполнение команд процессором в бесконечном цикле. 

![01](/Good_good_C_C++/img/01_01.PNG)

При этом все команды могут быть представлены обычными числами и записаны в оперативной памяти, наряду с данными. Но, благодаря регистру счетчику команд (или указателя инструкций), процессор точно знает откуда брать следующую команду на выполнение и не путает команды с данными. Мало того, центральный процессор никогда не отдыхает, не останавливается, а работает постоянно по непрерывному циклу обработки команд, выполняя все новые и новые инструкции, пока компьютер не будет выключен. Скорость обработки команд определяется тактовой частотой процессора. 

Например, тактовая частота 1 ГГц означает выполнение одного миллиарда команд в секунду. А размер порции данных, обрабатываемых процессором за одну операцию, называют машинным словом. Как правило, размер машинного слова совпадает с разрядностью процессора. Например, для 32-разрядного процессора машинное слово обычно 32 бита; для 64-разрядного – 64 бита.

## Все данные в памяти компьютера – это числа

Итак, получается, что в каждой ячейке оперативной памяти можно хранить только числа, например, в диапазоне от 0 до 255. И центральный процессор способен обрабатывать исключительно числовые данные. Спрашивается, как же тогда с помощью вычислительной машины работать с текстами, изображениями, звуками, да и любыми другими не числовыми данными? Выход только один – преобразовать их в набор чисел. Например, процессор компьютера понятия не имеет, что такое символ или буква. Вместо нее в памяти сохраняется ее кодовое представление в соответствии с используемой кодовой таблицей. Например, достаточно известная таблица ASCII содержит следующие коды символов (приведен фрагмент):

![01](/Good_good_C_C++/img/01_02.jpg)

В соответствии с ней, например, строка «I love C» будет представлена последовательностью чисел:

    73 32 108 111 118 101 32 67

Это ее представление в памяти, и для процессора, а на экране, при использовании кодовой таблицы ASCII, мы увидим соответствующую строку.

Подобные преобразования выполняются и для всех других типов данных. В частности, изображения – это наборы отдельных точек (пикселей), цвет которых определяется числовым значением в соответствии с цветовой палитрой:

![01](/Good_good_C_C++/img/01_03.png)

И вообще, любые данные, предназначенные для компьютерной обработки, предварительно нужно перевести в набор чисел (говорят оцифровать) и только после этого использовать в вычислительной технике. И, наоборот, такие устройства, как мониторы, принтеры, звуковые колонки и т.д. преобразовывают цифровую (то есть, числовую) информацию обратно в исходный, привычный для нас вид. Так происходит круговорот цифровой информации в вычислительной технике.

![01](/Good_good_C_C++/img/01_04.PNG)

## Операционная система
Но вернемся к вопросу взаимодействия между процессором и другими узлами компьютера (оперативной памятью, внешними устройствами). Как мы увидели, это происходит не таким уж и тривиальным способом. 

И если бы перед нами поставили задачу написать, например, программу для вычисления обратных матриц с выводом результата на экран, имея только «железо» в виде центрального процессора, памяти, клавиатуры, дисплея, жесткого диска, нам было бы очень непросто ее выполнить. 

Пришлось бы вначале прописывать на программном уровне взаимодействие процессора с дисплеем, клавиатурой, жестким диском. Затем, порядок запуска и выполнения программы вычисления матрицы, контролировать цикл обработки команд процессора, так как он работает непрерывно, и решать еще очень и очень много других вспомогательных задач, не относящихся непосредственно к поставленной перед нами начальной цели. 

Это жутко неудобно! 

Но выход из этой ситуации есть и он очевиден. Нужно написать программную оболочку, которая бы брала на себя управление всеми периферийными устройствами, памятью и пользовательскими программами. 

И такая оболочка представляет собой не что иное, как операционная система. Как правило, она автоматически загружается при включении компьютера и предоставляет простой, универсальный доступ ко всем имеющимся его ресурсам посредством специальных программ, называемых драйверами. А нам, как прикладным программистам, остается только обратиться к установленной операционной системе и запросить, например, нужный объем памяти для хранения данных, или «попросить» вывести некоторую информацию на экран, или открыть файл на внешнем носителе и занести туда какие-либо данные. И так далее. 

Все эти операции берет на себя операционная система. Нас не интересует, как конкретно она это делает, главное, чтобы предоставляла доступ к нужным ресурсам и максимально быстро выполняла указанный запрос. Такие запросы к ОС со стороны пользовательских программ называются системными вызовами. Именно через системные вызовы происходит взаимодействие со всем многообразием внешних устройств, подключенных к компьютеру, а также выполняются некоторые внутренние инструкции, за которые отвечает операционная система, например, выделение памяти под нужные нам данные.

Помимо системных задач ОС предоставляет набор команд для управления состоянием компьютера для оператора – человека. Например, мы можем посмотреть список файлов на жестком диске, или скопировать информацию на флэшку, или установить пароль доступа к компьютеру, и многое другое. 

![01](/Good_good_C_C++/img/01_05.PNG)

Однако не стоит полагать, что основное назначение ОС – это взаимодействие между человеком и компьютером. Совсем нет. Она в первую очередь ориентирована на корректное выполнение пользовательских программ и их взаимодействие с ресурсами вычислительной техники. 

Например, в современных дата-центрах можно увидеть ряды стоек с серверами (компьютерами), у которых нет ни клавиатуры, ни дисплея, так как не предполагается постоянная работа с ними человека. При необходимости, можно установить удаленное взаимодействие по сети Ethernet и через командную строку выполнить требуемые действия.

![01](/Good_good_C_C++/img/01_06.PNG)

## История создания языка Си
Вообще, первые операционные системы появились еще в 1960-х годах. Вначале они не имели графического интерфейса и все взаимодействие выполнялось на уровне команд. Позже стали появляться графические пользовательские интерфейсы, но вплоть до середины 1990-х они не были массовым явлением. Пока в 1995 году не вышла известная ОС Windows 95 со встроенным графическим интерфейсом, которая завоевала очень большую популярность. 

![01](/Good_good_C_C++/img/01_07.PNG)

С тех пор вся линейка ОС Windows поставлялась со встроенным графическим интерфейсом и популярна по сей день.

Другое распространенное семейство ОС известно под общим названием Unix. К нему относятся различные вариации Linux, такие как Debian, Ubuntu, Fedora, Gentoo и многие другие, а также различные семейства BSD: FreeBSD, OpenBSD и так далее. Интересно, что графический интерфейс в ОС Unix реализован не на уровне ядра системы (как это сделано в ОС Windows), а на уровне пользовательской программы, которую можно поменять, если потребовалась другая графическая оболочка. Также открытый исходный код дистрибутивов Unix позволяют на их основе относительно просто создавать свои вариации операционных систем. На практике этим довольно часто пользуются. Например, так появилась первая версия ОС Android от компании Google.

Но для нас намного важнее, что именно зарождение Unix способствовало появлению первой версии языка Си. Все начиналось в далеких 1960-х годах. На тот момент некто Кен Томпсон сотрудник фирмы Bell Laboratories принимал участи в создании ОС под названием MULTICS. Проект оказался неудачным, но опыт был получен. Несколько позже, работая с довольно устаревшей даже на тот момент машиной PDP-7, Кен Томпсон решил улучшить ее системное программное обеспечение и, немного-немало, написать свою версию ОС. И он это сделал. В шутку Брайан Керниган назвал эту систему UNICS. Название пошло в народ, только последние две буквы изменились на X, получилось UNIX. Так появилась новая на тот момент ОС Unix для компьютера PDP-7. Но это была устаревшая техника, поэтому Кен Томпсон уже совместно с Деннисом Ритчи решили ее перенести на более совершенную машину PDP-11. Но для этого требовалось переписать ОС. Чтобы не выполнять всю эту кропотливую работу на уровне языка Ассемблер, то есть, по сути, на уровне машинных команд, Кен Томпсон решил воспользоваться языком более высокого уровня под названием «B» - усеченный вариант другого языка BCPL. Но этот язык оказался слишком неудобным для создания ОС. Тогда Деннис Ритчи предложил расширить (усовершенствовать) язык «B» и, недолго думая, назвал новый язык следующей буквой английского алфавита «C». Так в 1972 году появилась первая версия языка Си. Ее автором считается Деннис Ритчи – сотрудник Bell Laboratories. Именно на этом новом языке программирования «С» в 1973 году Кен Томпсон написал ОС Unix для компьютера PDP-11. А в 1974 году вышла совместная статья Кена Томпсона и Денниса Ритчи, где они подробно рассказали о своих разработках. Благодаря тому, что машина PDP-11 на тот момент была довольно распространена, то желающих попробовать новую ОС, а также язык Си, нашлось немало. С этого началось торжественное шествие и становление языка программирования Си, который остается популярным и востребованным до наших дней.

Особенность этого языка в том, что он был создан программистами для программистов в первую очередь для того, чтобы уйти с низкого ассемблерного уровня и позволить писать программы на более высоком абстрактном уровне. Но, при этом, сохраняя все преимущества низкоуровневого программирования, то есть, предоставляя программисту полный контроль и полную свободу действий. Поэтому язык Си можно отнести к самым низкоуровневым из высокоуровневых языков программирования. Благодаря этому программы, написанные на нем, эффективно переводятся в машинный код, максимально быстро работают и могут выполнять все допустимые операции, ограниченные только конкретной архитектурой компьютера. Этот язык удобен для написания ОС, игровых приложений, используется в системах дополненной реальности, искусственном интеллекте, управлении различным оборудованием, на нем реализованы автопилоты самолетов, кораблей. Также на языке Си, а точнее, на С++ написаны различные интерпретаторы для таких языков, как Python, Java, C#. То есть, везде, где нам важна скорость и/или полный контроль за процессом выполнения программы, в том числе и в реальном времени, язык Си оказывается незаменим. Именно поэтому идеи, заложенные в него 50 лет назад, актуальны и поныне. Если бы не было такого языка программирования, его пришлось бы создать!

Видео по теме:
[Язык Си. Рождение легенды](https://www.youtube.com/watch?v=d971m08_5Zo&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Что такое один бит в вычислительной технике?

+ [ ] единица информации, соответствующая одной (любой) команде центрального процессора
+ [x] базовая информационная единица, принимающая только два состояния (например, 0 и 1)
+ [ ] единица информации, состоящая из восьми байт
+ [ ] базовая информационная единица, принимающая 256 возможных состояний (например, от 0 до 255)

### Подвиг 2. Что чаще всего означает один байт в современной вычислительной технике?

+ [x] группа из восьми бит
+ [ ] единица информации, соответствующая одной (любой) команде центрального процессора
+ [ ] группа из 16-ти бит
+ [ ] единица информации, принимающей только два состояния (например, 0 и 1)

### Подвиг 3. Какое число вариантов (комбинаций) может быть закодировано в одном байте, состоящего из восьми бит?

+ [x] 256
+ [ ] 2
+ [ ] 8
+ [ ] 32 или 64 в зависимости от разрядности ОС

### Подвиг 4. Выберите все верные утверждения, касающиеся неймановской архитектуры компьютера.


+ [ ] данные хранятся в памяти для данных, а программы хранятся в памяти для программ (два независимых вида памяти)
+ [ ] центральный процессор останавливается после завершения текущей программы
+ [x] центральный процессор работает непрерывно, обрабатывая постоянно поступающие команды
+ [x] в центральном процессоре имеется регистр "счетчик команд", который хранит адрес следующей для выполнения команды
+ [x] данные и программы хранятся в памяти единым образом (нет разделения на память данных и память программ)

### Подвиг 5. Выберите все верные утверждения, касающиеся оперативного запоминающего устройства (ОЗУ).

+ [x] физическая память компьютера состоит из набора независимых ячеек, каждая размером в один байт
+ [x] каждая ячейка памяти пронумерована по порядку (от 0 и далее) и этот номер называется адресом ячейки
+ [x] как правило, в современных компьютерах одна ячейка памяти состоит из восьми бит
+ [ ] физическая память компьютера состоит из набора зависимых (пересекающихся) ячеек, каждая размером в один байт
+ [x] в каждую ячейку памяти можно занести данные и прочитать их оттуда (без учета ограничений ОС)

### Подвиг 6. Выберите все верные утверждения, касающиеся операционной системы (ОС)

+ [x] операционные системы часто предоставляют интерфейс для взаимодействия между компьютером и человеком
+ [x] это программа, которая, как правило, выполняет управление памятью устройства (например, выделение и освобождение памяти для запущенных пользовательских программ)
+ [x] операционная система взаимодействует с периферийными устройствами посредством специальных программ - драйверов
+ [x] это программа, которая берет на себя взаимодействие с внешними (периферийными) устройствами (например, клавиатура, монитор, мышь и т.п.)
+ [x] пользовательские программы взаимодействуют с периферийными устройствами через системные вызовы к ОС
+ [ ] операционная система взаимодействует с периферийными устройствами посредством системных вызовов

### Подвиг 7. Кто официально считается автором (или авторами) языка Си?

+ [ ] авторство неизвестно
+ [x] Деннис Ритчи
+ [ ] Брайан Керниган
+ [ ] Кен Томпсон

### Подвиг 8. Отметьте все верные утверждения, касающиеся языка Си.

+ [x] программы, написанные на языке Си, можно переносить с одной архитектуры процессора на другой простой перекомпиляцией
+ [x] современные компиляторы языка Си часто переводят текст программы в машинный код так, словно он изначально был написан на Ассемблере
+ [ ] язык Си довольно сильно ограничивает возможности программиста, но взамен позволяет создавать быстро исполняемые программы
+ [ ] программы, написанные на языке Си, жестко привязаны к архитектуре процессора и перенос их на другую часто оказывается проблематичным или даже невозможным
+ [x] язык Си предоставляет полную свободу действий программисту такую же, как и ассемблерный уровень
+ [x] язык Си часто позволяет уйти от низкоуровневого программирования на Ассемблере, сохранив скорость выполнения программ

### Подвиг 9. Отметьте задачи, которые целесообразно разрабатывать на языке Си (включая С++).

+ [ ] скрипты для бэкенда и фронтенда сайтов
+ [x] разработка игровых движков
+ [x] создание автопилотов (самолетов, кораблей и др.)
+ [x] разработка операционных систем
+ [x] реализация алгоритмов обучения нейронных сетей
+ [x] разработка веб-серверов
+ [x] программирование микроконтроллеров
+ [ ] создание прикладных программ (приложений) для смартфонов и планшетов
+ [x] создание интерпретаторов языков программирования (например, для Python, C#, Java и др.)

# 1.2 Этапы трансляции программы в машинный код. Стандарты

## Машинный код
На предыдущем занятии мы с вами увидели принцип обработки команд процессором, когда в памяти содержалась последовательность чисел:

    B8 22 11 00 FF 01 CA 31 F6 53 8B 5C 24 04 8D 34 48 39 C3 72 EB C3

и подавалась в виде исполняемых инструкций на центральный процессор. Такая последовательность закодированных команд в виде целых чисел называется машинным кодом. Только такой код «понимает» процессор компьютера. Но человеку создавать программы на таком уровне было бы очень непросто. Поэтому для облегчения работы программиста было предложено все эти числовые команды представлять в символьном виде, а именно, в виде мнемоник языка Ассемблер. Например, представленная числовая последовательность на уровне мнемоник ассемблера, предложенных компанией AT&T, выглядит следующим образом:

Метка | Мнемоника | Машинный код
-|-|-
foo:| movl $0xFF001122, %eax<br>addl %ecx, %edx<br>xorl %esi, %esi<br>pushl %ebx<br>movl 4(%esp), %ebx<br>leal (%eax, %ecx, 2), %esi<br>cmpl %eax, %ebx<br>jnae foo<br>Retl | B8 22 11 00 FF<br>01 CA <br>31 F6<br>53<br>8B 5C 24 04<br>8D 34 48<br>39 C3<br>72 EB<br>C3

Как видите, язык Ассемблер дает заметное удобство при создании программ. Теперь программисту достаточно запомнить общие команды, вроде `movl` (переместить из памяти или регистра информацию в память или регистр); `addl` (сложить содержимое регистров или памяти); `xorl` (побитовая операция `XOR`) и т.д. 

Запоминать числовое (кодовое) представление команд процессора уже не нужно. Достаточно написать программу на уровне мнемоник, а затем, с помощью __компилятора__ языка Ассемблер, перевести ее в числовой вид (машинные коды) понятные центральному процессору компьютера.

Обратите внимание, я здесь употребил слово «компилятор». В программировании под ним понимается специальная исполняемая программа, которая переводит текст программы, написанной программистом на каком-либо языке программирования, как правило, в машинные коды. Именно в этом смысле я буду использовать слово «компилятор».

Возвращаясь к фрагменту программы на Ассемблере, мы видим в нем первую ступеньку упрощения описания логики задачи, по сравнению с уровнем машинных кодов. Однако уровень Ассемблера все равно остается достаточно низким. При создании более-менее состоятельных программ, трудоемкость работы программиста остается очень высокой, а значит, высока и стоимость разработки конечного продукта. Кроме того, система команд  (мнемоник) языка Ассемблер может несколько меняться при переходе от одной архитектуры процессора к другой, так как у каждого типа процессоров может быть свой набор команд, своя разрядность, свои особенности работы. Поэтому перенос программы с одного компьютера на другой может вызывать большие трудности.

Для преодоления этих и некоторых других недостатков стали создавать языки, на которых можно описывать логику программы на более высоком (абстрактном) уровне. В частности, на прошлом занятии мы увидели, что столкнувшись с проблемой переноса ОС с компьютера PDP-7 на компьютер PDP-11, Кен Томпсон решил воспользоваться языком высокого уровня. Сначала это был язык B, но из-за его ограниченности в 1972 году Деннис Ритчи создал другой новый, на тот момент, язык Си. Время показало, что язык Си хорошо сочетает более высокий уровень программирования, по сравнению с языком Ассемблер, а программы, написанные на Си, качественно и эффективно можно перевести на уровень машинных кодов с помощью компилятора языка Си. То есть, конечный результат получается таким, словно программу изначально написал профессиональный программист на Ассемблере, а не на языке высокого уровня Си. Это одно из ключевых преимуществ языка Си перед другими языками высокого уровня. В результате, грамотно написанная программа, будет выполняться на компьютере с максимально возможной скоростью и разумно, без излишеств использовать его ресурсы. Это свойство языка Си незаменимо в ряде направлений, например:
+ игровой индустрии (разработка движков);
+ дополненной реальности;
+ обучение нейронных сетей;
+ создание надежных программ управления оборудованием в реальном режиме времени и многое другое. 

Именно по этим причинам язык Си остается востребованным и будет таковым до тех пор, пока программы пишет человек привычным для нас сейчас способом.

## Этапы перевода (трансляции) текстов программы в исполняемый код

Итак, все, что требуется от программиста – это создать один или несколько файлов с текстами программы, которая решает поставленные задачи. 

Каждый такой независимый файл в программировании часто называют модулем. Так как мы говорим о языке Си, то все эти текстовые варианты программ далее переводятся (транслируются) на уровень машинных кодов. 

Как это происходит? 

Сначала каждый модуль независимо пропускается через текстовый препроцессор. Его задача в программе найти все, так называемые, директивы (указания) для этого препроцессора и выполнить их. Что это за директивы, мы с вами еще будем говорить. 

В результате, исходный текст программы несколько меняется. После этого, преобразованные тексты подаются на компилятор (также независимо друг от друга), которые сначала проходят через лексический анализ программы. На этом этапе выделяются возможные синтаксические ошибки. Если ошибок не обнаружено, то программа далее переводится непосредственно в машинные коды. На выходе получаются объектные файлы модулей. 

Но в этих объектных файлах отсутствуют:
+ связи с другими модулями (если они были прописаны в тексте программы),
+ реализации библиотечных функций (если они были использованы),
+ код запуска всей программы. 

Все это делает на последнем этапе линкер (по-простому, редактор связей). 

Он связывает все объектные файлы модулей в единый исполняемый файл, добавляет в него необходимые реализации библиотечных функций и код запуска для текущей операционной системы. На выходе получается окончательный результат в виде исполняемого файла.

![01](/Good_good_C_C++/img/01_08.jpg)

Почему все сделано именно так?

Конечно, для полного ответа на этот вопрос, его нужно задать разработчикам языка Си, но некоторые моменты вполне логичны и понятны. 
+ Первое. Независимая компиляция каждого модуля позволяет сократить время перевода большого проекта в машинный код, состоящего из десятков, а то и сотен текстовых файлов.<br> 
Первый раз, конечно, придется скомпилировать все файлы и сформировать объектные файлы каждого модуля. Но, при последующем изменении программы в отдельных модулях, достаточно будет перекомпилировать только их, а потом собрать проект с помощью линкера (линковщика, редактора связей), используя ранее созданные объектные файлы других не измененных модулей. В целом, такой подход заметно экономит время при изменении и отладке проекта.
+ Второе. Линкер добавляет в итоговые исполняемые файлы только те реализации библиотечных функций, которые используются в программе. Ничего дополнительного, лишнего на выходе не образуется.
+ Третье. Использование компиляторов для разных архитектур процессоров и разных ОС позволяет относительно просто и быстро переносить ранее написанную программу с одной ОС на другую, или с одной архитектуры процессора на другую. И, так как компиляторы языка Си реализованы практически везде, на всех платформах, то программа на языке Си оказывается самой переносимой среди многих других языков высокого уровня.

## Стандарты языка Си
Конечно, компиляторы языка Си пишутся разными людьми в разных фирмах. А, значит, они и работают с некоторыми отличиями. В то же время, программист на Си не должен задумываться об особенностях этих компиляторов и программы, написанные разными программистами, должны корректно переводиться (транслироваться) в машинный код разными компиляторами. Добиться этого можно только стандартизацией. Программисты по всему миру должны договориться между собой о синтаксисе и наборе команд, используемых в языке Си.

Первым таким неформальным стандартом стала книга Брайана Кернигана и Денниса Ритчи «Язык программирования Си». На первых этапах становления языка Си этого было достаточно.

### Стандарт ANSI C (ISO C)
Но по мере того, как все больше и больше программистов по всему миру стали использовать этот язык программирования, остро встал вопрос создания вполне официального стандарта, который бы, к тому же, включал все полезные новшества этого нового языка. 

С этой целью в 1983 году национальный институт стандартизации США – ANSI (American National Standards Institute) образовал специальную рабочую группу (комитет) под названием X3J11. И в 1989 году миру был предъявлен новый стандарт, который сейчас часто называют ANSI C или C89. Правда, официально он был принят только в 1990 году, поэтому вместо C89 иногда используют запись C90. Но это означает, по сути, одно и то же.

По итогам своей работы комитет X3J11 сформулировал несколько довольно важных принципов:
+ доверять программисту;
+ не мешать программисту делать то, что он считает необходимым;
+ без необходимости не усложнять язык, сохранять его простоту;
+ каждая операция языка должна иметь только один способ выполнения;
+ операция должна выполняться максимально быстро, даже в ущерб переносимости языка.

Конструкции языка Си, так или иначе, отражают эти принципы, заложенные в самом начале становления этого языка.

### Стандарт C99
Совсем скоро, уже в 1994 году появилась необходимость в создании нового стандарта языка Си. В первую очередь это было обусловлено растущей популярностью самого языка и его применение в самых разных задачах. В частности, возникла необходимость:
+ в интернационализации (поддержке различных международных языков) на программном уровне;
+ в устранении некоторых неточностей предыдущей версии языка стандарта ANSI C;
+ в повышении стабильности математических вычислений для возможности безопасного использования языка в научных проектах.

В 1999 году этот новый стандарт был принят и стал известен под кодовым названием C99.

### Другие стандарты
Язык Си стал хорошей базой для развития и создания нового подобного и во многом похожего на него языка программирования C++. Его автором считается Бьёрн Страуструп – сотрудник Bell Laboratories. В этом языке появилась объектно-ориентированная составляющая, шаблоны классов и функций и некоторые другие полезные инструменты для современной разработки программ любого уровня сложности.

Новые стандарты языка Си появляются с завидной регулярностью. И, как вы догадываетесь, этот безудержный процесс, скорее всего, будет продолжаться, пока существует язык Си. Но я остановлюсь на стандарте C99, принятом в 1999-м году. На мой взгляд, он удачно сочетает возможности и красоту языка Си, а также сохраняет его дух, заложенный создателем Деннисом Ритчи в далеком 1972 году.

Видео по теме [#1. Этапы трансляции программы в машинный код. Стандарты](https://www.youtube.com/watch?v=8QiqrL_WHD4&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Что называют модулем в проекте программы на языке Си?

+ [ ] отдельные библиотечные файлы, поставляемые с языком Си
+ [ ] каждый отдельный объектный файл
+ [x] каждый отдельный файл с текстом программы
+ [ ] итоговый исполняемый файл

### Подвиг 2. Какую роль играет текстовый препроцессор при компиляции программы на языке Си?

+ [ ] обрабатывает директивы препроцессора в полученных объектных файлах
+ [ ] добавляет специальные директивы в текст программы для оптимизации процесса компиляции
+ [ ] выполняет сборку объектных модулей программы в единый исполняемый файл
+ [x] обрабатывает директивы препроцессора в исходных файлах текстов программы

### Подвиг 3. Какую роль играет непосредственно компилятор при транслировании программы на языке Си в машинный код?

+ [ ] отдельные файлы с текстами программы преобразует в машинный код, формируя конечный исполняемый файл
+ [x] отдельные файлы с текстами программы преобразует в машинный код, формируя объектные файлы
+ [ ] объединяет все файлы с текстами программы текущего проекта в единую программу и переводит ее в машинный код
+ [ ] выполняет сборку объектных модулей программы в единый исполняемый файл

### Подвиг 4. Какую роль играет линкер (редактор связей) при компиляции программы на языке Си?
+ [ ] объединяет все файлы с текстами программы текущего проекта в единую программу и переводит ее в машинный код
+ [x] соединяет между собой объектные файлы, формируя единую программу, добавляет код запуска и коды используемых библиотечных функций
+ [ ] соединяет между собой объектные файлы, формируя единую программу, без добавления какой-либо дополнительной информации
+ [ ] соединяет между собой объектные файлы, формируя единую программу, добавляет код запуска и коды всех библиотечных функций используемых в программе библиотек

### Подвиг 5. Отметьте принципы, изначально заложенные в язык Си.

+ [x] операция должна выполняться максимально быстро, даже в ущерб переносимости языка
+ [x] без необходимости не усложнять язык, сохранять его простоту
+ [x] доверять программисту
+ [x] не мешать программисту делать то, что он считает необходимым
+ [x] каждая операция языка должна иметь только один способ выполнения

### Подвиг 6. Для чего нужны стандарты языка Си?

+ [ ] для определения ориентиров дальнейшего развития языка программирования
+ [x] чтобы программисты независимо друг от друга одинаково понимали конструкции языка программирования
+ [ ] для объединения сообществ программистов по всему миру и обмена знаниями
+ [ ] для документирования возможных ошибок языка программирования

# 1.3 Установка компилятора gcc и Visual Studio Code на ОС Windows

Видео по теме [#2. Установка компилятора gcc и Visual Studio Code на ОС Windows](https://www.youtube.com/watch?v=TGpYh9X1PYk&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

# 1.4 Структура и понимание работы программы "Hello, World!"

На предыдущих занятиях был сделан первый маленький шажок, ведение в этот язык. Теперь пришло время познакомиться и разобрать структуру простой, но типовой программы.

Часто в учебниках или на лекциях для этой цели приводят программу, печатающую на экране строку «Hello, World!». Я не стану нарушать эту традицию и поступлю ровно также, тем более, что пример достаточно удачный.

```c
/* Моя первая программа */
#include <stdio.h>
 
int main(void)
{
    printf("Hello, World\n");
    return 0;
}
```

Первое, что сразу же следует отметить, это то, что текст программы пишется программистом для себя и/или других программистов. 

И только во вторую очередь для компилятора. 

Это означает, что в программе следует соблюдать форматирование текста для лучшего визуального восприятия, а также не использовать сложные синтаксические конструкции, если без ущерба для производительности программы можно записать их в более простой форме. 

Чаще всего искусственное усложнение программного кода можно наблюдать у новичков, которые этим хотят показать свое виртуозное владение языком программирования. 

В рабочей среде, в лучшем случае, это вызывает только улыбку, а в худшем – требование переписать код в понятном для человека виде. Не совершайте таких ошибок и сразу правильно оформляйте тексты программ. Как вариант, можно ориентироваться на оформление в текущем курсе.

Итак, у нас имеется простейшая программа. Давайте теперь построчно разберем, что здесь к чему. 

В первой строчке записан комментарий. Обычно, это некий текст, который пишется для программистов с разъяснением работы отдельных операторов или фрагментов кода. 

Компилятор игнорирует все комментарии и не переводит их в машинный код.

До стандарта C99 комментарии можно было оформлять только с помощью комбинаций символов `/* */`. И все, что заключено в них, считается комментарием. Его можно записывать и в одну строчку и в несколько строчек, например, так:

```c
/* Это
многострочный
комментарий
*/

```
С появлением стандарта C99 добавились однострочные комментарии, обозначаемые символами `//`. Например, комментарий в нашей программе можно оформить и так:

```c
// Моя первая программа
```

Но, обычно, однострочные комментарии используют для разъяснения отдельных операторов программы, например:

```c
printf("Hello, World\n");   // вывод строки на экран
```

Следующая строчка программы – это, так называемая, директива препроцессора. 

Подробно о них мы еще будем говорить. Здесь отмечу только, что все директивы начинаются с символа шарп `#` и следом идет ее имя. 

В частности, директива `#include` выполняет включение содержимого заголовочного файла `stdio.h` в то место, где записана эта директива. 

Сразу возникает вопрос, зачем это потребовалось в программе? 

Дело в том, что база языка Си весьма ограничена. Изначально в нем не реализовано даже функций ввода/вывода. Поэтому для вывода какой-либо информации на экран нам необходимо воспользоваться внешней библиотечной функцией `printf()`, которая записана ниже в программе. 

Так вот, в текстовом файле `stdio.h`, в частности, прописано объявление функции `printf()`. Обратите внимание, объявление функции, но не ее реализация. 

Компилятор языка Си так устроен, что для формирования объектного файла текущего модуля ему достаточно дать определение (объявление) функции `printf()`, а конкретная реализация добавится в программу на этапе линковки кода, то есть, редактором связей. 

Эта реализация будет взята из библиотечного откомпилированного модуля, поставляемого вместе с компилятором языка Си. 

Поэтому, все что нужно будет сделать линковщику – это найти фрагмент машинного кода для функции `printf()` и добавить в исполняемый файл. Или же, при использовании динамических библиотек (`DLL`), реализация многих стандартных функций не добавляется в скомпилированный файл, а берется из соответствующей динамической библиотеки, хранимой в ОС. 

Но на данном этапе, для нас важно лишь одно: для успешного транслирования программы в машинный код компилятору достаточно дать лишь описание используемых функций, а их реализации добавит позже редактор связей. Вот для этого и нужна в программе директива `#include` с подключением файла `stdio.h`, имя которого является сокращением от английских слов:

    standard input ouput

(стандартный ввод/вывод). А расширение `h` – это первая буква от слова `header` (заголовок). Получается заголовочный файл стандартного ввода/вывода.

В следующей строчке программы идет объявление функции с именем `main`. Опять же, зачем это понадобилось? Забегая вперед, отмечу, что функции – это активные элементы программы, которые выполняют, заключенные в них операторы (инструкции). 

Вся программа на языке Си – это, по сути, наборы разных функций и их вызов в запрограммированном порядке. Так вот, первая функция, с которой начинается выполнение программы, должна называться `main`. 

Почему именно `main`? 

Потому, что так решил разработчик этого языка Деннис Ритчи в далеком 1972 году. 

Все компиляторы языка Си формируют машинный код так, что после загрузки программы в память компьютера, ОС передает управление сначала, так называемой, секции кода, как правило, с переходом по метке `_start`. 

Там выполняются некоторые подготовительные действия, а затем, вызывается функция `main()`. 

И это всегда так. 

Мало того, если в программе будет отсутствовать такая функция, то при компиляции появится сообщение об ошибке.

![01](/Good_good_C_C++/img/01_09.png)

Итак, в программе на языке Си обязательно должна присутствовать функция с именем `main`, которой передается управление после запуска программы и выполнения некоторых подготовительных действий. Условно этот процесс показан на рисунке.

Далее, перед именем этой функции записано ключевое слово `int`. 

Оно означает целочисленный тип данных и то, что функция `main()` возвращает целочисленное значение. 

Обо всем этом мы еще подробно будем говорить, здесь я лишь даю краткие пояснения. 

После имени `main` должны идти круглые скобки и в них прописаны параметры функции. 

Так как в нашем примере функция `main()` не имеет параметров, то в круглых скобках указано ключевое слово `void`, которое можно перевести с английского как «пустой». 

Далее, в фигурных операторных скобках прописываются операторы, которые будут последовательно выполняться (сверху-вниз) при вызове функции `main()`. 

В частности, в нашей программе, сначала будет вызвана библиотечная функция `printf()` для вывода указанной строки в консоль, а затем, сработает оператор:

```c
return 0;
```

Опять же, забегая вперед, оператор `return` выполняет два действия.
+ Первое, он завершает текущий вызов функции `main()`.
+ И второе, в нем указывается значение, которое будет возвращено этой функцией.

Почему здесь прописано значение `0`? 

Дело в том, что это значение, затем, через системный вызов `_exit` будет передано операционной системе. 

Собственно, этот системный вызов и завершает программу, а вовсе не функция `main()`. 

Так вот, значение `0` говорит ОС о том, что программа выполнила свою функцию и успешно решила поставленную перед ней задачу. 

Все другие значения, отличные от нуля, будут означать ошибки выполнения программы. 

Например, мы что то планируем записать в файл, а ОС не позволяет открыть указанный файл на запись. Тогда программа может выдать сообщение об ошибке и вернуть код, отличный от нуля. Хотя, в современной практике программирования, обычно, так не поступают и просто выводят сообщение об ошибке с кодом завершения `0`.

И пару слов о функции `printf()`, которую, конечно же, мы позже будем рассматривать подробнее. Название функции – это сокращение от английских слов:

    print formatted (форматированный вывод)

Соответственно, эта функция способна выводить произвольные данные в виде форматированной строки. Не буду сейчас углубляться, отмечу только, что строки в языке Си обязательно должны быть заключены в двойные кавычки и никакие другие. 

Довольно частая ошибка, когда происходит переход с одного языка программирования на другой, и в ранее изученном языке строки допустимо было заключать и в двойных и в одинарных кавычках. Например, так допустимо делать на Python, PHP и некоторых других языка программирования. Поэтому здесь нужно сразу запомнить, что строковые литералы на языке Си записываются только в двойных кавычках. Позже мы с вами об этом также будем подробнее говорить.

Наконец, обратите внимание на символ `\n` в конце строки. Так прописываются спецсимволы, т.е. ставится слеш и, затем символ или код символа. 

В частности, `\n` означает перевод курсора на новую строку. То есть, если бы мы следом еще раз вызвали функцию `printf()` и напечатали какую-либо информацию, то она была бы отображена на следующей строчке.

Вот, в целом, общее описание нашей простой программы, которая выводит на экран сообщение «Hello, World!». 

Возможно, некоторых из вас может поразить объем информации, необходимой для понимания даже самых простых программ на Си. Да, это действительно так. Но это не удивительно. Если вспомнить историю появления языка Си, то он был разработан программистами для программистов, как заменитель языка Ассемблер. А не для того, чтобы его можно было последовательно изучать конструкция за конструкцией, как, например, язык Python. Хотя, и в языке Си нет ничего особенно сложного.

Основная трудность – это ответственный и профессиональный подход к написанию программ, т.к. язык дает огромную свободу действий. 

А свобода подразумевает не меньшую ответственность. Именно ответственность за грамотное использование ресурсов лежит на плечах программиста языка Си. Но это вознаграждается возможностями, которые перед нами открываются. Именно поэтому язык Си остается незаменимым в ряде направлений, о которых я вам уже рассказывал на предыдущих занятиях.

### Подвиг 1. Выберите все верные утверждения, касающиеся написания (оформления) текста программы на языке Си.

+ [x] текст программы, в первую очередь, пишется для ее восприятия программистом, а во вторую - для компилятора
+ [x] при оформлении текста программы следует соблюдать общепринятые элементы ее форматирования
+ [ ] допускается произвольное оформление текста программы, главное, чтобы она работала с максимально возможной скоростью
+ [x] в тексте программы следует использовать наиболее простые для понимания и восприятия конструкции языка, но без ущерба в скорости ее работы

### Подвиг 2. Как в тексте программы оформляются комментарии, начиная со стандарта C99?

+ [x] `//` (однострочный комментарий)
+ [ ] `\* *\` (многострочный комментарий)
+ [ ] `\\` (однострочный комментарий)
+ [x] `/* */` (многострочный комментарий)

### Подвиг 3. Какие действия выполняет директива:

```c
#include <stdio.h>
```

+ [x] добавляет в текущий модуль определение (объявление заголовка) функции printf()
+ [ ] указывает линковщику (редактору связей) подключать библиотеку stdio к итоговому исполняемому файлу
+ [x] вставляет содержимое файла stdio.h в место, где записана директива
+ [ ] вставляет содержимое файла stdio.h в начало модуля (всегда в начало), где прописана данная директива
+ [ ] добавляет в текущий модуль реализацию функции printf()

### Подвиг 4. Какую роль играет функция main() в тексте программы на языке Си?

+ [x] если функция main() отсутствует в тексте программы (проекта), то при компиляции возникает ошибка
+ [x] это функция, которая автоматически запускается при запуске исполняемого файла
+ [ ] если функция main() возвращает не нулевое значение, значит, программа была выполнена успешно (без ошибок)
+ [x] если функция main() возвращает 0, значит, программа была выполнена успешно (без ошибок)
+ [x] как только функция main() завершает свою работу, завершается выполнение всей программы
+ [ ] функция main() служит для начальной инициализации переменных в программе (и только для этого)

### Подвиг 5. Какие непосредственные действия выполняет оператор return в функции main()?

+ [x] определяет возвращаемое функцией main() значение
+ [ ] выполняет проверку, что программа завершилась с указанным числовым кодом
+ [ ] передает операционной системе код завершения программы
+ [x] завершает выполнение текущего вызова функции main()

### Подвиг 6. Для чего служит функция printf() в приведенном фрагменте программы:

```c
#include <stdio.h>
 
int main(void)
{
    printf("Hello, World\n");
    return 0;
}
```

+ [ ] выводит в стандартный входной поток строку "Hello, World" без переноса (перевода курсора) на следующую строку
+ [x] выводит в стандартный выходной поток строку "Hello, World" с переносом (переводом курсора) на следующую строку
+ [ ] выводит в стандартный входной поток строку "Hello, World" с переносом (переводом курсора) на следующую строку
+ [ ] выводит в стандартный выходной поток строку "Hello, World" без переноса (перевода курсора) на следующую строку

### Подвиг 7. Напишите по аналогии (с рассмотренной на этом занятии) программу с выводом на экран строки "I love C" по следующей схеме:

1. Подключите файл `stdio.h`
2. Запишите функцию `main(void)`, которая возвращает целочисленные значения типа `int`.
3. В фигурных скобках запишите вызов функции `printf()` с выводом указанной строки и переводом на новую строку.
4. После функции `printf()` не забудьте прописать оператор `return`, который возвращает целое число `0`.

P.S. Постарайтесь соблюдать оформление программы, приведенное на этом занятии.

```c
#include <stdio.h>


int main(void) {
    printf("I love C\n");
    return 0;
}
```

