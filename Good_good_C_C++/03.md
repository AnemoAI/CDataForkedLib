# 3. Условные операторы. Директивы препроцессора

## Содержание

+ [3.1 Булевый тип. Операции сравнения. Логические И, ИЛИ, НЕ](#31-булевый-тип-операции-сравнения-логические-и-или-не)

<hr>

[Содержание](#содержание)

[Оглавление курса](/Good_good_C_C++/README.MD)

# 3.1 Булевый тип. Операции сравнения. Логические И, ИЛИ, НЕ

## Булевый тип.

На этом занятии вы увидите, как в программах можно делать логические выводы на уровне:
+ `true` – истина;
+ `false` – ложь.

Так как компьютер – это вычислительная машина, то понятия «истина» и «ложь» должны выражаться на уровне чисел. 

В большинстве, а может быть во всех языках программирования, значение `false` определяется как `0`, а `true` – как любое ненулевое значение. Поэтому константы `true` и `false` часто  определяют как:

```
true = 1; false = 0
```

До стандарта `C99` язык Си не предполагал наличия какого-либо специального булевого типа данных. Вместо этого использовался любой целочисленный тип, и если значение переменной равнялось нулю, это означало `false` (ложь), а любое другое значение, отличное от нуля – `true` (истина). Например, так:

```c
char fl_view = 0;        // false
int fl_open_file = 1;     // true
```

Но стандарт C99 предоставляет нам новый тип (новое ключевое слово):

```c
_Bool
```

И булевы переменные стало возможно определять следующим образом:

```c
_Bool fl_view = 0;           // false
```

На самом деле, тип `_Bool` определен на базе обычного целочисленного типа, который соответствует наименьшему допустимому размеру, то есть, `char`. В этом легко убедиться, воспользовавшись оператором `sizeof`:

```c
#include <stdio.h>
 
int main(void) {
    _Bool fl_view = 0;       // false
    printf("Size of _Bool: %d\n", sizeof(_Bool));
 
    return 0;
}
```

После запуска программы увидим строчку:

```c
Size of _Bool: 1
```

К сожалению, ключевые слова `true` или `false` по-прежнему не определены. Поэтому булевой переменной `fl_view` нужно явно присваивать значение `0` в качестве `false` и `1` – для `true`. Причем, никакие другие значения она принимать не может. Если попытаться присвоить, например, число `10`:

```c
_Bool fl_view = 10;
```

то `fl_view` его преобразует к единице. 

И, вообще, любое ненулевое значение приравнивается единице. В этом ключевое отличие типа `_Bool`, например, от типа `char`, который позволяет представлять любые целые числа в диапазоне `[0; 255]`.

А теперь внимательнее посмотрим на написание этого типа. Вначале идет символ подчеркивания, а затем, с заглавной буквы слово «Bool». Довольно неудобная и «корявая» запись. Дело в том, что это была первая официальная попытка определить булевый тип в языке Си. И никто тогда точно не мог сказать, как эта идея будет воспринята сообществом программистов. Кроме того, для совместимости с прежними компиляторами, этот тип можно было легко заменить на любой другой базовый целочисленный, например, `char`. И программы бы компилировались без проблем.

В действительности, именно в такой записи тип `_Bool` практически не использовался на практике. Позже его подменили более изящным словом `bool`. И, кроме того, такой тип официально появился в языке С++, который является естественным развитием языка Си. 

Так вот, чтобы в программах на языке Си в соответствии со стандартом C99 можно было бы использовать более приятную и общеупотребительную запись булевого типа `bool`, следует подключить заголовочный файл `stdbool.h`:

```c
#include <stdbool.h>
```

В нем не только переопределен тип `_Bool` как `bool`, но и введены две константы:

```c
true = 1; false = 0
```

Поэтому переменную `fl_view` в нашей программе теперь можно определить так:

```c
bool fl_view = true;
```

Эта строчка выглядит естественнее и понятнее для программиста, чем корявый тип `_Bool` и числа `0` или `1`.

## Операции сравнения
Я, думаю, с определением переменных булевого типа в языке Си все понятно. Давайте теперь посмотрим, как можно их использовать в операциях сравнения. Вначале приведу список этих операций.

Операция | Описание
`==` | (Два равно). Сравнение на равенство.
`!=` | Сравнение на неравенство.
`<` | Сравнение на меньше.
`>` | Сравнение на больше.
`<=` | Сравнение на меньше или равно.
`>=` | Сравнение на больше или равно.

Все эти операции являются бинарными, то есть, слева и справа от них прописываются выражения (операнды):

`<левый операнд>` `<операция сравнения>` `<правый операнд>`

В качестве операндов может выступать любая конструкция языка Си, со значениями которых возможны сравнения. Часто это переменные и числовые литералы.

Обратите внимание, все операции сравнения являются именно операциями, а не операторами, то есть, они позволяют выполнять некоторое сравнение и возвращают вычисленный результат в виде значений:

```c
0 – false; 1 – true.
```

Например:

```c
#include <stdio.h>
#include <stdbool.h>
 
int main(void) {
    double x = 5.67;
    bool fl_view = x < 0;
    
    printf("%d\n", fl_view);
 
    return 0;
}
```

Так как в нашем примере `x` больше нуля, то операция сравнения на отрицательное значение вернет 0, которое соответствует понятию «ложь» (`false`). А вот если вместо нуля указать, например, значение `10`:

```c
bool fl_view = x < 10;
```

то переменная `fl_view` будет равна `1`, что соответствует понятию «истина» (`true`). И так работают все операции сравнения:

```c
double x = 5.67;
int var_i = 7;

 
bool fl_view = x < 10;      // true
bool res_1 = 5 > 7;         // false
bool res_2 = x+2 >= 10.56;    // false
bool res_3 = var_i == 7;    // true
bool res_4 = var_i != 7;    // false
```

Причем, приоритет операций сравнения выше приоритета операции присваивания. Поэтому сначала выполняются сравнения и только потом – присваивания. 

А арифметические операции выше операций сравнения, поэтому `x+2` будет выполнено до сравнения на больше или равно. 

Кроме того, обратите внимание на операцию сравнения на равенство. Она записывается как два символа равно `==`. 

Как мы знаем, одно равно – это операция присваивания, поэтому для сравнения на равенство ввели обозначение из двух символов равно. И здесь начинающие программисты очень часто делают ошибку. Для сравнения на равенство значений они пишут не два, а, по привычке, одно равно, например, так:

```c
bool res_3 = var_i = 7;
```

При этом компилятор может даже не выдать никаких предупреждений и в любом случае переведет программу в машинный код. Только работать она будет не так, как задумывалась программистом. 

И чисто визуально найти такую ошибку бывает не просто, особенно, если в голове не зафиксировано, что сравнение – это два знака равно. 

В общем, если вы только начинаете постигать азы программирования на языке Си, то выпишите этот момент на бумажке и прилепите ее к монитору. Я гарантирую, что найдется немало тех, кто ее совершит.

Также следует помнить, что операции:

```
<= и >=
```

нужно прописывать именно в таком виде. Иногда, правда редко, меняют местами символы и пытаются прописать:

```
=< и => (неверная запись)
```

Это приведет к синтаксической ошибке.

Давайте в качестве короткого примера приведу программу ввода числового значения и определение четности числа:

```c
#include <stdio.h>
#include <stdbool.h>
 
int main(void) {
    int digit;
    scanf("%d", &digit);
 
    bool even = digit % 2 == 0;
    printf("%d\n", even);
 
    return 0;
}
```

После запуска и ввода целого значения мы увидим `0` – для нечетных чисел и `1` – для четных.

## Составные операции сравнения

Давайте теперь поставим более сложную задачу и определим, попадает ли число (значение переменной) в диапазон `[-2; 5]`? Какие логические умозаключения здесь нужно провести, чтобы ответить на этот вопрос? Для простоты представим, что у нас имеется переменная:

```c
double y = 1.85;
```

Очевидно, чтобы она попадала в диапазон `[-2; 5]`, нужно соблюдение двух условий:

```
y >= -2
```

и

```
y <= 5
```

В языке Си это можно реализовать следующим образом:

```c
bool is_range = y >= -2 && y <= 5;
```

Здесь операция `&&` означает логическое И. При этом общее условие истинно, если истинно каждое из подусловий: `y >= -2` и `y <= 5`. 

Благодаря этому мы будем получать значение `true` (единица), если `y` принадлежит диапазону `[-2; 5]` и `false` (ноль) в противном случае.

А теперь сделаем противоположную проверку, что переменная y не попадает в диапазон `[-2; 5]`. Очевидно, это будет происходить, если:

`y < -2` или `y > 5`

В языке Си такая составная операция сравнения может быть записана в виде:

```c
bool is_not_range = y < -2 || y > 5;
```

Операция `||` означает логическое `ИЛИ` и возвращает истину (`true`), если истинно хотя бы одно из подусловий. 

В нашем примере, это проверка, что y или меньше `-2` или больше `5`. 

Часто начинающие программисты здесь делают логическую ошибку и подобное сравнение записывают с использованием операции И следующим образом:

```c
bool is_not_range = y < -2 && y > 5;
```

В этом случае я прошу назвать число, которое одновременно меньше `-2` и больше `5`. Как правило, после этого в головах все встает на свои места. Не путайте принцип действия этих двух операций: логическое `ИЛИ` и логическое `И`.

На самом деле противоположную проверку непопадания в диапазон `[-2; 5]` можно было бы реализовать путем инвертирования ранее вычисленного значения `is_range` следующим образом:

```c
bool is_not_range = !is_range;
```

Здесь восклицательный знак – это унарная операция `НЕ`, которая может быть применена к любому выражению. Принцип ее работы заключается в инвертировании булевого значения:

```c
true -> false; false->true.
```

## Приоритеты операций И, ИЛИ, НЕ
Приоритеты всех этих трех логических операций следующие:

Операция | Приоритет
-|-
Логическое ИЛИ `\|\|` | 1
Логическое И `&&` | 2
Логическое НЕ (!) | 3

То есть, наибольший приоритет имеет унарная операция `НЕ`, затем, операция `И`, и самый низкий – у операции `ИЛИ`.

Все эти приоритеты необходимо строго соблюдать для составления корректных условий. Например:

```c
int x = 5;
bool is_correct = x % 2 == 0 || x % 3 == 0 && x > 5;
```

Это составное условие эквивалентно следующему:

```c
bool is_correct = x % 2 == 0 || (x % 3 == 0 && x > 5);
```

то есть, сначала проверяется, что число `x` кратно `2` (четное) `ИЛИ` число кратно `3` и при этом больше `5`. 

Обратите внимание здесь на два важных момента. Во-первых, стандартом языка Си определен строгий порядок проверок слева-направо при вычислении составных логических операций. 

Это значит, мы можем быть абсолютно уверены, что сначала выполнится проверка `x % 2 == 0` и только после этого следующее подусловие `x % 3 == 0 && x > 5`. Причем, в нем также сначала проверяется первое `x % 3 == 0` и только потом второе `x > 5`. Во-вторых, если в процессе проверки значение всей составной логической операции становится известным, то вычисления прерываются и не идут дальше. Например, в условии:

```c
bool fl_digit = x != 0 && 10 / x > 1;
```

сначала будет проверено, что переменная `x` не равна нулю, и если это не так (то есть это первое подусловие равно `false`), то дальше проверки делать не имеет смысла, т.к. при любом булевом значении второго подусловия (`10/x > 1`) общее все равно будет принимать значение `false`. Благодаря такому поведению, мы можем без проблем вычислять деление `10 / x` после проверки, что `x != 0`. Этим на практике довольно часто пользуются.

Но все это нужно применять очень аккуратно. Например, если прописать следующее составное условие:

```c
bool is_read = x < 0 && scanf("%d", &x) == 1;
```

то функция `scanf()` не будет вызвана, если `x` больше или равен нулю.

И последнее, важный, хотя и очевидный момент. Если нам нужно поменять приоритеты операций, то для этого можно использовать все те же круглые скобки. Например:

```c
bool is_correct = (x % 2 == 0 || x % 3 == 0) && x > 5;
```

Теперь это условие будет истинно, если `x` кратно `2` или `3` и больше `5`.

Видео по теме [#13. Булевый тип. Операции сравнения. Логические И, ИЛИ, НЕ](https://www.youtube.com/watch?v=E1MkdKL6HL8&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)


### Подвиг 1. Выберите все верные утверждения, касающиеся булевых типов и данных языка Си стандарта C99 и выше.

+ [x] приоритет операций сравнения ниже приоритетов арифметических операций
+ [ ] булево понятие "ложь" определяется любым ненулевым числовым значением
+ [x] в заголовочном файле stdbool.h определен тип bool и две константы true и false
+ [ ] приоритет операций сравнения выше приоритетов арифметических операций
+ [ ] приоритет операций сравнения ниже приоритета операции присваивания
+ [x] булево понятие "истина" определяется любым ненулевым числовым значением
+ [x] булево понятие "ложь" определяется нулевым значением
+ [x] приоритет операций сравнения выше приоритета операции присваивания
+ [x] булево понятие "истина" определяется нулевым значением

### Подвиг 2. Установите соответствия между операциями сравнения и их описаниями.

![03](/Good_good_C_C++/img/03_01.PNG)

### Подвиг 3. В приведенной ниже программе вычисляются различные сравнения. Отметьте для переменных res_1, ..., res_7 значения true/false, которые они будут принимать, при выполнении этой программы.

```c
#include <stdbool.h>

int main(void) {
    double f = 0.0;
    int i = 5, j = 5, k = 5;

    bool res_1 = i < 5;
    bool res_2 = i >= 5;
    bool res_3 = f;
    bool res_4 = i++ > 5;
    bool res_5 = ++j > 5;
    bool res_6 = 10 < k * 2;
    bool res_7 = 12 == k * 3;

    return 0;
}
```

![03](/Good_good_C_C++/img/03_02.PNG)

### Подвиг 4. Напишите программу, которая считывает из входного потока stdin целое число и выводит в консоль значение 100, если число кратно 5, и 0 в противном случае.

P.S. Программу реализовать без применения условных операторов.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/3.1.4

```c
#include <stdio.h>

int main(void) {
    int num;
    scanf("%d", &num);
    printf("%d", 100 * (num % 5 == 0));
    return 0;
}
```

### Подвиг 5. Напишите программу, которая считывает из входного потока stdin вещественное число. Если его целая часть кратна 5, то в консоль следует вывести число 1, иначе - число 0.

P.S. Программу реализовать без применения условных операторов.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/3.1.5

```c
#include <stdio.h>

int main(void) {
    double num;
    scanf("%lf", &num);
    printf("%d", ((int)num % 5 == 0));
    return 0;
}
```

### Подвиг 6. Расположите логические операции `И`, `ИЛИ`, `НЕ` в порядке возрастания их приоритетов.

![03](/Good_good_C_C++/img/03_03.PNG)

### Подвиг 7. Напишите программу, которая считывает из входного потока stdin вещественное число и выводит в консоль значение 1, если число принадлежит диапазону [-5.45; 10.37], и 0 в противном случае.

P.S. Программу реализовать без применения условных операторов.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/3.1.7

```c
#include <stdio.h>
#define MIN -5.45
#define MAX 10.37

int main(void) {
    double num;
    scanf("%lf", &num);

    int res = (num - MIN >= 0 && num - MAX <= 0);

    printf("%d", res);
    return 0;
}
```

### Подвиг 8. Напишите программу, которая считывает из входного потока stdin вещественное число и выводит в консоль значение 1, если число принадлежит диапазону `[-10; 0)` или `(5; 12]`, и 0 в противном случае.

Ликбез:
+ `[a; b]` - диапазон, включающий граничные значения;
+ `(a; b)` - диапазон не включающий граничные значения.

P.S. Программу реализовать без применения условных операторов.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/3.1.8

```c
#include <stdio.h>
#define MIN_A -10
#define MAX_A 0
#define MIN_B 5
#define MAX_B 12

int main(void) {
    double num;
    scanf("%lf", &num);
    int a, b, c, d;

    a = num - MIN_A >= 0;
    b = num - MAX_A < 0;
    c = num - MIN_B > 0;
    d = num - MAX_B <= 0;

    int res = a * b + c * d;

    printf("%d", res);
    return 0;
}
```

### Подвиг 9. Напишите программу, которая считывает из входного потока stdin два вещественных числа x, y, записанных в одну строчку через пробел, и выводит в консоль значение 1, если координаты (x, y) находятся внутри прямоугольника с координатами верхнего левого угла (-5, 0) и правого нижнего (10, 7). В противном случае выводится число 0.

![03](/Good_good_C_C++/img/03_04.png)

P.S. Программу реализовать без применения условных операторов.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/3.1.9

```c
#include <stdio.h>
#define MIN_X -5
#define MAX_X 10
#define MIN_Y 0
#define MAX_Y 7

int main(void) {
    double x, y;
    scanf("%lf %lf", &x, &y);
    int a, b, c, d;

    a = x - MIN_X > 0;
    b = x - MAX_X < 0;
    c = y - MIN_Y > 0;
    d = y - MAX_Y < 0;

    int res = a * b * c * d;

    printf("%d", res);
    return 0;
}
```

### Подвиг 10. Напишите программу, которая считывает из входного потока stdin два вещественных числа x, y и выводит в консоль значение 1, если координаты (x, y) не находятся внутри прямоугольника с координатами верхнего левого угла (-5, 0) и правого нижнего (10, 7). В противном случае выводится число 0.

P.S. Программу реализовать без применения условных операторов.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/3.1.10

```c
#include <stdio.h>
#define MIN_X -5
#define MAX_X 10
#define MIN_Y 0
#define MAX_Y 7

int main(void) {
    double x, y;
    scanf("%lf %lf", &x, &y);
    int a, b, c, d;

    a = x - MIN_X > 0;
    b = x - MAX_X < 0;
    c = y - MIN_Y > 0;
    d = y - MAX_Y < 0;

    int res = (a * b * c * d) == 0;

    printf("%d", res);
    return 0;
}
```

### Подвиг 11*. На плоскости размером rect_width x rect_height (ширина x высота) размещены непересекающиеся прямоугольники одинаковых размеров w x h, следующих друг за другом, как показано на рисунке ниже.

![03](/Good_good_C_C++/img/03_05.png)

Необходимо продолжить программу, вычислив общее число прямоугольников не умещающихся целиком на плоскости. Результат вывести в консоль в виде одного целого числа.

P.S. Программу реализовать без применения условных операторов, только используя изученный материал.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/3.1.11

```c
#include <stdio.h>

int main(void) {
    int rect_width = 640, rect_height = 480;
    int w = 1, h = 1;
    scanf("%d; %d", &w, &h);

    int count_w = rect_width / w;
    int count_h = rect_height / h;

    int a = rect_width - count_w * w > 0;
    int b = rect_height - count_h * h > 0;
    int c = a + b == 1;

    int res = count_h * a + count_w * b + c;

    printf("%d", res);

    return 0;
}
```

# 3.2 Условный оператор if. Конструкция if-else

## Условный оператор if.

На этом занятии мы познакомимся с условным оператором `if`. Что он делает и для чего нужен? 

На предыдущем занятии мы с вами рассматривали операции сравнения, которые выдают либо `0` (`false`), либо `1` (`true`). Так вот, чтобы программа могла менять свое поведение в зависимости от этих значений, как раз можно воспользоваться оператором `if`.

Принцип его работы очень прост. Процессор последовательно выполняет операторы (команды) и, как только доходит до условного оператора, то при истинности условия выполняется одна группа операторов, а иначе – другая:

![03](/Good_good_C_C++/img/03_06.png)

Это похоже на процесс ветвления при выполнении команд. Поэтому условные операторы еще иногда называют операторами ветвления.

Чтобы мы могли использовать оператор `if` в своих программах, нам нужно знать его синтаксис. В самых простых вариациях он имеет следующий вид:

```c
if(<выражение>) оператор;
```

или
```c
if(<выражение>) {
    оператор_1;
    ...
    оператор_N;
}
```

Здесь выражение – это любая конструкция языка Си, которая возвращает числовые значения. Число `0` будет интерпретировано как `false`, а любое не нулевое – как `true`. 

После круглых скобок должен идти оператор, который выполняется при истинности выражения. Если же нужно выполнить группу операторов, то для этого используются операторные фигурные скобки, которые можно воспринимать, как единый составной оператор. Поэтому, формально, после оператора `if` всегда следует один оператор.

Давайте для примера посмотрим, как можно использовать этот оператор для вычисления модуля числа:

```c
#include <stdio.h>
 
int main(void) {
    int x;
    scanf("%d", &x);
 
    if(x < 0) x = -x;
    printf("x = %d\n", x);
 
    return 0;
}
```

Вначале в переменную x вводится с клавиатуры некоторое целое значение, а затем, делается проверка: если число `x` меньше нуля (то есть, отрицательное), то выполняется команда `x = -x` и знак меняется на противоположный, число становится положительным. 

Причем, эта команда будет выполнена только при условии, что `x` меньше нуля. Если же `x` больше или равен нулю, то команда пропускается и число остается положительным. В результате мы этой проверкой формируем модуль числа.

Обратите внимание, что при истинности условия выполняется только один оператор `x = -x`. Функция `printf()`, которая записана следующей строчкой, находится вне условного оператора и выполняется всегда. С условным оператором `if` связана только одна команда `x = -x`.

Кстати, в этой же программе было бы правильно проверить корректность введенного значения. Для этого достаточно проверить, что функция `scanf()` вернула единицу. Но я пропишу обратное условие:

```c
    if(scanf("%d", &x) != 1) {
        printf("Error input");
        return 0;
    }
```

Смотрите, в качестве выражения здесь выступает вызов функции `scanf()` с последующей проверкой на неравенство единице. 

Так тоже вполне можно делать. Затем, если вводится некорректное значение, то это условие оказывается истинным и выполняются операторы внутри фигурных скобок. Будет выведена строка с сообщением об ошибке и оператор `return 0`, который завершит функцию `main()` и, как следствие, всю программу.

Не редко в программах на языке Си можно встретить использование оператора `if` с одной переменной в качестве условия, например, так:

```c
if(x) x = -x;
```

Это тоже допустимо, т.к. в круглых скобках можно указывать любое выражение, которое возвращает числовое значение. И легко догадаться, если значение `x` равно `0`, то условие считается ложным, а при любом другом – истинным.

А если нам нужно инвертировать это условие, то достаточно воспользоваться логической операцией НЕ следующим образом:

```c
if(!x) x = -x;
```

Тогда все будет наоборот, условие истинно при `x` равном `0`, и ложно при любом другом числовом значении.

Вообще, используя логические операции, можно формировать произвольные составные условия. Например, проверить попадание точки с координатой `x` в диапазон `[3; 11]`:

```c
    if(x >= 3 && x <= 11) 
        printf("x in [3; 11]\n");
```

А в качестве самостоятельного задания напишите проверку непопадания значения `x` в этот же диапазон `[3; 11]`. Вся информация для этого у вас уже есть.

## Конструкция if-else
Следующим шагом напишем программу различия положительных и отрицательных введенных чисел. Используя имеющиеся знания, это можно сделать следующим образом:

```c
#include <stdio.h>
 
int main(void) {
    int x;
    if(scanf("%d", &x) != 1) {
        printf("Error input");
        return 0;
    }
 
    if(x < 0) printf("x < 0\n");
    if(x >= 0) printf("x >= 0\n");
        
    return 0;
}
```

У нас здесь два подряд идущих условия. Причем, взаимоисключающие. Действительно, `x` не может быть одновременно и меньше нуля и больше либо равно. После ввода значения возможен только один вариант. В таких ситуациях было бы логично проверить первое условие, если оно истинно, выполнить соответствующий оператор, а иначе, выполнить другой оператор без какой-либо проверки. Такую конструкцию в языке Си можно записать следующим образом:

```c
if(<выражение>) оператор_1;
else оператор_2;
```

или с использованием операторных скобок:

```c
if(<выражение>) {
    оператор_1;
    ...
    оператор_N;
} else {
    оператор_1;
    ...
    оператор_M;
}
```

Здесь ключевое слово `else` как раз и соответствует ветке «иначе», то есть, оператор_2 (или операторы от 1 до M в фигурных скобках) выполняется, если не сработало (оказалось ложным) выражение в условном операторе `if`. Таким образом, если условие в операторе `if` истинно, то выполняется оператор_1 (или аналогичные операторы в фигурных скобках), а иначе – оператор_2 (или аналогичные операторы в фигурных скобках).

Давайте перепишем нашу программу с использованием этой конструкции. Получим:

```c
#include <stdio.h>
 
int main(void) {
    int x;
    if(scanf("%d", &x) != 1) {
        printf("Error input");
        return 0;
    }
 
    if(x < 0) 
        printf("x < 0\n");
    else 
        printf("x >= 0\n");
        
    return 0;
}
```

Из-за того, что здесь остался только один условный оператор, программа будет работать несколько быстрее. И везде, где мы имеем набор взаимоисключающих условий, их следует оформлять в виде конструкции `if-else`. Мало того, в нашем примере мы можем пойти дальше и после ключевого слова `else` прописать еще один условный оператор, например, так:

```c
    if(x < 0) 
        printf("x < 0\n");
    else if(x > 0) 
            printf("x > 0\n");
        else
            printf("x == 0\n");
```

Здесь после первого `else` записан еще один условный оператор `if` с проверкой `x > 0` и у этого второго условного оператора также имеется свой блок `else`. Получилась такая вложенная конструкция из операторов `if-else`.

Я специально в программе второй блок `if-else` сместил вправо, чтобы визуально показать его вложенность в первый блок `else`. То есть, здесь последний оператор `else` относится именно ко второму условному оператору `if`. Или, это же вложение можно было бы для лучшего понимания оформить и так:

```c
    if(x < 0) 
        printf("x < 0\n");
    else {
        if(x > 0) 
            printf("x > 0\n");
        else
            printf("x == 0\n");
    }
```

В операторных скобках мы определили вложенный оператор `if`. Но в практике программирования фигурные скобки в этом случае не пишут, а оформляют такие вложения следующим образом:

```c
    if(x < 0) 
        printf("x < 0\n");
    else if(x > 0) 
        printf("x > 0\n");
    else
        printf("x == 0\n");
```

Читается и понимается такая конструкция достаточно просто. Сначала идет проверка первого условия `x < 0`. Если оно истинно, то выполняется оператор по условию и дальнейшие блоки пропускаются. Если же первое условие ложно, то попадаем в блок `else` первого оператора `if` и там осуществляется проверка вложенного условия `x > 0`. Если это условие истинно, то выполняется оператор `printf("x > 0\n")`, а если ложно, то переходим в последний блок `else`, который гарантированно срабатывает с выполнением оператора `printf("x == 0\n")`.

Но всегда следует помнить, что конструкция `if-else`, или вложенные конструкции `if-else`, как правило, используются при проверке взаимоисключающих условий. Хотя это не всегда так. Например, нам нужно определить размер неотрицательного числа: является ли оно однозначным, двухзначным, трехзначным или каким-либо еще. Такую проверку можно прописать следующим образом:

```c
    if(x < 10) 
        printf("x in [0; 9]\n");
    else if(x < 100) 
        printf("x in [10; 99]\n");
    else if(x < 1000)
        printf("x in [100; 999]\n");
    else
        printf("x > 999\n");
```

Формально условия `x < 10`; `x < 100`; `x < 1000` не взаимоисключающие, но порядок их следования таков, что они позволяют выделять нам нужные независимые группы чисел. То есть, творческое мышление, при использовании различных операторов, никто не отменял. 

Иначе бы программы уже давно писались бы не людьми, а теми же компьютерами. Хотя такие попытки предпринимаются, в частности, с помощью нейронных сетей. Но пока до человеческого уровня им далеко и в ближайшие 10-20 лет грамотный программист в этой области незаменим.

Видео по теме [#14. Условный оператор if. Конструкция if-else](https://www.youtube.com/watch?v=7VZQbuCYPn8&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, касающиеся условного оператора if/else.

+ [ ] переход на `else` осуществляется только при истинном условии
+ [x] по некоторому условию можно выполнить сразу несколько операторов, записав их в фигурных скобках
+ [x] оператор `if`(<выражение>) передает управление к записанному в нем оператору, если <выражение> не равно нулю
+ [x] оператор `if` можно записать по синтаксису: `if`(<выражение>) <оператор 1>; `else` <оператор 2>;
+ [ ] оператор `if`(<выражение>) передает управление к записанному в нем оператору, если <выражение> равно нулю
+ [x] оператор `if` можно записать по синтаксису: `if`(<выражение>) <оператор>;
+ [x] условные операторы также называют операторами ветвления
+ [ ] по некоторому условию можно выполнить строго только один оператор
+ [x] переход на `else` осуществляется только при ложном условии

### Подвиг 2. Продолжите программу, представленную ниже. Определите минимальное из введенных чисел x и y, присвойте найденное минимальное значение переменной min и выведите ее значение в консоль в виде одного целого числа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/3.2.2

```c
#include <stdio.h>

int main(void) {
    short x, y;
    if (scanf("%hd, %hd", &x, &y) != 2) {
        printf("Input error.");
        return 0;
    }

    short min = x < y ? x : y;

    printf("%d", min);

    return 0;
}
```

### Подвиг 3. Продолжите программу, представленную ниже. Если число m делится нацело на число n, то вывести на экран частное от деления (результат деления), в противном случае вывести сообщение «division error».

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/3.2.3

```c
#include <stdio.h>

int main(void) {
    int m, n;
    if (scanf("%d, %d", &m, &n) != 2) {
        printf("Input error.");
        return 0;
    }

    if (m % n)
        printf("division error");
    else
        printf("%d", m / n);

    return 0;
}
```

### Подвиг 4. Напишите программу чтения двух целых чисел из входного потока, записанных в одну строчку через пробел. Если эти числа равны, то вывести в консоль любое из этих чисел, а иначе - в порядке возрастания.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/3.2.4

```c
#include <stdio.h>

int main(void) {
    int m, n;
    if (scanf("%d %d", &m, &n) != 2) {
        printf("Input error.");
        return 0;
    }

    if (m == n)
        printf("%d", m);
    else {
        printf("%d ", m < n ? m : n);
        printf("%d", m < n ? n : m);
    }
    return 0;
}
```

### Подвиг 5. Продолжите программу, представленную ниже. Необходимо убедиться, что первые два числа - это катеты прямоугольного треугольника, а третье - его гипотенуза.

Подсказка: для проверки используйте теорему Пифагора 

$c^2 = a^2 + b^2$. 

Если проверка проходит, то в консоль вывести строку "yes", иначе - строку "no".

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/3.2.5

```c
#include <stdio.h>

int main(void) {
    unsigned int a, b, c;
    if (scanf("%u, %u, %u", &a, &b, &c) != 3) {
        printf("Input error.");
        return 0;
    }

    char res = c * c == a * a + b * b;

    printf("%s", res ? "yes" : "no");

    return 0;
}
```

### Подвиг 6. Напишите программу чтения целого числа из входного потока - порядковый номер дня недели (1, 2, ..., 7). Необходимо вывести на экран название дня недели (понедельник, вторник, среда, четверг, пятница, суббота, воскресенье) в соответствии с прочитанным номером. Если номер выходит за пределы от 1 до 7, то вывести строку:

"не верный номер дня недели"

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/3.2.6

```c
#include <stdio.h>

int main(void) {
    unsigned int a;
    if (scanf("%u", &a) != 1 || a > 7) {
        printf("не верный номер дня недели");
        return 0;
    }

    char* lib[7] = {"понедельник", "вторник", "среда", "четверг", "пятница", "суббота", "воскресенье"};

    printf("%s", lib[a - 1]);

    return 0;
}
```

### Подвиг 7. Напишите программу чтения целого положительного числа из входного потока. Необходимо выполнить проверку, что оно оканчивается на цифру 3. Если это так, то в консоль вывести строку "yes", иначе - строку "no".

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/3.2.7

```c
#include <stdio.h>
#define LAST_DIGIT 3

int main(void) {
    int a;
    if (scanf("%d", &a) != 1) {
        printf("Input error.");
        return 0;
    }

    char res = a % 10 == LAST_DIGIT;

    printf("%s", res ? "yes" : "no");

    return 0;
}
```

### Подвиг 8. Напишите программу чтения трех целых чисел из входного потока, записанных в одну строчку через пробел. Занесите эти значения в переменные a, b, c. 

Проверьте, что уравнение

$a⋅x^2 + b⋅x + c = 0$

имеет хотя бы один действительный корень. Для этого необходимо вычислить дискриминант по формуле:

$D=b^2 −4ac$

и проверить, что он больше или равен нулю. Если это так, то вывести строку:

"real roots exist"

а иначе - значение вычисленного дискриминанта.

```c
#include <stdio.h>

int main(void) {
    int a, b, c;
    if (scanf("%d %d %d", &a, &b, &c) != 3) {
        printf("Input error.");
        return 0;
    }

    int res = (b * b) - (4 * a * c);

    if (res < 0)
        printf("%d", res);
    else
        printf("real roots exist");

    return 0;
}
```

### Подвиг 9. Напишите программу чтения трех вещественных чисел из входного потока, записанных в одну строчку через запятую. Необходимо определить наименьшее среди них и вывести его в консоль с точностью до сотых.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/3.2.9

```c
#include <stdio.h>

int main(void) {
    double a, b, c;
    if (scanf("%lf, %lf, %lf", &a, &b, &c) != 3) {
        printf("Input error.");
        return 0;
    }

    double min = a;

    if (b < min) min = b;
    if (c < min) min = c;

    printf("%.2lf", min);

    return 0;
}
```

### Подвиг 10. Напишите программу чтения трех положительных вещественных чисел из входного потока, записанных в одну строчку через запятую. Необходимо определить, могут ли эти числа образовывать стороны треугольника. Если образуют, то вывести в консоль "yes", иначе - "no".

Критерий проверки: у любого треугольника длина третьей стороны всегда должна быть меньше суммы двух других.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/3.2.10

```c
#include <stdio.h>

int main(void) {
    double a, b, c;
    if (scanf("%lf, %lf, %lf", &a, &b, &c) != 3) {
        printf("Input error.");
        return 0;
    }

    char res = (a < b + c) && (b < c + a) && (c < b + a);

    printf("%s", res ? "yes" : "no");

    return 0;
}
```

### Подвиг 11 (на повторение). Выберите все верные утверждения, касающиеся форматной строки функции scanf().

+ [x] если в форматной строке прописаны два спецификатора "%d %d", то читаются целые числа идущие через пробельный символ
+ [x] пробел в форматной строке означает наличие пробелов, символов табуляции, символов перевода строки
+ [x] если в форматной строке прописаны два спецификатора "%c%c", то читаются два подряд идущих байта из потока stdin
+ [ ] если в форматной строке прописаны два спецификатора "%d%d", то читаются целые числа идущие друг за другом без каких-либо разделительных символов
+ [x] если в форматной строке прописаны два спецификатора "%d,%d", то читаются целые числа идущие через запятую (пробельные символы также допустимы после запятой)
+ [x] если в форматной строке прописан спецификатор "%c", то из входного потока читается текущий байт
+ [ ] если в форматной строке прописаны два спецификатора "%d,%d", то читаются целые числа идущие через запятую (пробельные символы недопустимы)
+ [x] если в форматной строке прописаны два спецификатора "%d%d", то читаются целые числа идущие через пробельный символ
+ [ ] пробел в форматной строке означает наличие только пробелов и символов табуляции
+ [x] форматные строки "%d, %d" и "%d,%d" эквивалентны (одинаковы по действию)

# 3.3 Условное тернарное выражение

На этом занятии мы познакомимся с условной тернарной операцией, которая имеет следующий синтаксис:

```c
<выражение 1> ? <выражение 2> : <выражение 3>
```

Если выражение 1 истинно, то возвращается значение выражения 2, иначе – значение выражения 3. Давайте поясню его работу на конкретном примере. Предположим, у нас имеются две переменные:

```c
double a = 7.5, b = -3.43;
```

и мы хотим определить максимальное значение. Используя имеющиеся знания, это можно было бы сделать так:

```c
double max_ab;
if(a > b)
    max_ab = a;
else
    max_ab = b;
```

А с использованием тернарной условной операции это можно реализовать гораздо изящнее:

```c
double max_ab = a > b ? a : b;
```

Видите, какая простая, понятная и компактная запись в итоге получилась. Это одно из удобств данного оператора. 

Но, все же, между предыдущей программой с условным оператором `if` и тернарной операцией есть одно принципиальное отличие. 

Тернарная операция возвращает результат. В данном примере – это или переменная `a` или переменная `b`. Тогда как обычный условный оператор предназначен для выполнения блока кода по определенному условию и сам по себе не возвращает никаких значений.

Второе важное отличие – в тернарной условной операции нет внутренних блоков, где бы мы могли записывать несколько операторов. Вместо `a` и `b` можно указывать только одну какую-либо конструкцию. Часто это некое значение, или результат работы операторов, например, арифметических:

```c
double res = (a > b) ? a + 2 : b - 5;
```

Так делать вполне допустимо. И, обратите внимание, я поместил условие в круглые скобки, чтобы визуально выделить его в этой конструкции. Конечно, делать это не обязательно, так как приоритет операций `?` и `:` выше только операций присваивания и запятой, поэтому сначала будут вычислены операции сравнения и только потом осуществляется проверка условия.

Также в качестве выражений в тернарной операции можно использовать функции, например, так:

```c
double res_abs = (a < b) ? fabs(a) : fabs(b);
printf("res_abs = %.2f\n", res_abs);
```

Забегая вперед, я здесь использовал функцию `fabs()` для вычисления модуля вещественного числа. Чтобы воспользоваться этой функцией вначале программы нужно подключить заголовочный файл `math.h`:

```c
#include <math.h>
```

Из этого последнего примера хорошо видно, что в зависимости от истинности условия будет вызвана либо первая функция `fabs(a)`, либо вторая `fabs(b)`. И это очень важный момент. Следует всегда помнить, что в тернарной условной операции вычисляется только одно из двух последних выражений, но не оба вместе.

Так как тернарная операция – это операция, а не оператор, то ее можно прописывать как аргумент при вызове функций. Например:

```c
#include <stdio.h>
 
int main(void) {
    int x = 8;
    printf("x is %s digit\n", (x % 2 == 0) ? "even" : "odd");
 
    return 0;
}
```

Здесь тернарная операция записана как аргумент функции `printf()` и возвращает строковый литерал в зависимости от четности числа.

### Вложенная тернарная операция

Так как внутри тернарной условной операции можно использовать любые конструкции языка Си, то что нам мешает вложить одну тернарную операцию в другую, например, так:

```c
#include <stdio.h>
 
int main(void) {
    int a = 2, b = 3, c = -4;
    int max = (a > b) ? ((a > c) ? a : c) : (b > c) ? b : c;
 
    printf("max = %d\n", max);
 
    return 0;
}
```

Сразу скажу, что это делается крайне редко и лучше избегать таких вложений, так как восприятие и понимание текста программы резко снижается.

Работает приведенная программа следующим образом. Сначала проверяется условие `a > b`. Если это так, то далее с помощью вложенного тернарной операции возвращается максимально из двух переменных `a` и `c`. Иначе, максимум из переменных `b` и `c`. В результате получаем максимальное из трех чисел `a`, `b`, `c`.

Причем здесь обязательно вложенные тернарные операции следует записывать в круглых скобках, так как приоритет операций `?` и `:` очень низкий.

Еще раз отмечу, что таких вложений в практике программирования следует избегать, так как в ней очень легко запутаться и допустить ошибку. Да и потом разбираться, что здесь было написано не так то просто. Поэтому в 99% случаях условную тернарную операцию используют без каких либо вложений.

### Подвиг 1. Выберите все верные утверждения, касающиеся тернарной условной операции.

+ [x] данная операция работает по принципу if-else (если-иначе) и возвращает либо одно, либо другое вычисленное выражение
+ [x] приоритет тернарной условной операции ниже операций сравнения и арифметических операций
+ [x] данная операция определяется синтаксисом: <выражение 1> ? <выражение 2> : <выражение 3>
+ [ ] приоритет тернарной условной операции выше операций сравнения, но ниже арифметических операций
+ [x] данная операция именно операция и может быть использована совместно с другими вычислениями
+ [ ] данная операция не может быть использована совместно с другими вычислениями
+ [ ] данная операция определяется синтаксисом: ? (<выражение 1>) <выражение 2> : <выражение 3>

### Подвиг 2. Продолжите программу. С помощью тернарной операции определите минимальное значение переменных k и m и выведите в консоль квадрат этого значения.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/3.3.2

```c
#include <stdio.h>

int main(void) {
    int k, m;
    if (scanf("%d, %d", &k, &m) != 2) {
        printf("Input error.");
        return 0;
    }

    int min = k < m ? k : m;

    printf("%d", min * min);

    return 0;
}
```

### Подвиг 3. Напишите программу, которая считывает из входного потока одно целое значение x, затем, с помощью тернарной условной операции выполняет функциональное преобразование f(x) в соответствии со следующим рисунком:

![03](/Good_good_C_C++/img/03_07.png)

Результат преобразования (целое число) вывести в консоль.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/3.3.3

```c
#include <stdio.h>

int main(void) {
    int x;
    if (scanf("%d", &x) != 1) {
        printf("Input error.");
        return 0;
    }

    int res = x > 0 ? x : 0;

    printf("%d", res);

    return 0;
}
```

### Подвиг 4. Напишите программу, которая считывает из входного потока два целых положительных числа, записанных в одну строчку через точку с запятой. Выведите в консоль строку "square", если числа равны и образуют стороны квадрата, а иначе выведите строку "rectangle". (Строки выводить, разумеется, без кавычек.)

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/3.3.4

```c
#include <stdio.h>

int main(void) {
    int a, b;
    if (scanf("%d; %d", &a, &b) != 2) {
        printf("Input error.");
        return 0;
    }

    int res = a == b;

    printf("%s", res ? "square" : "rectangle");

    return 0;
}
```

### Подвиг 5. Напишите программу, которая считывает из входного потока два целых числа, записанных в одну строчку через пробел, и помещает их в переменные width и height. Затем, нужно сформировать третью целочисленную переменную border, как сумму максимального из прочитанных чисел плюс восемь:

$border=max(width,height)+8$

Результат вывести в консоль в виде одного целого числа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/3.3.5

```c
#include <stdio.h>

int main(void) {
    int width, height;
    if (scanf("%d %d", &width, &height) != 2) {
        printf("Input error.");
        return 0;
    }

    int border = (width > height ? width : height) + 8;

    printf("%d", border);

    return 0;
}
```

### Подвиг 6. Продолжите программу. С помощью вложенных тернарных операций реализуйте следующую логику. Если значение переменной type равно единице, то вычислите площадь прямоугольника со сторонами w и h 
(то есть, произведение $w⋅h$). Иначе, если значение type равно 2, то - периметр прямоугольника (по формуле: $2⋅(w+h)$). 

Иначе (если type не 1 и не 2), вернуть значение -1. 

Результат выведите в консоль. 

Если это результат вычислений, то как вещественное число с точностью до десятых, иначе, просто целое значение -1.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/3.3.6

```c
#include <stdio.h>

int main(void) {
    short type = 0;
    double w, h;

    if (scanf("%hd %lf %lf", &type, &w, &h) != 3) {
        printf("Input error.");
        return 0;
    }
    switch (type) {
        case 1:
            printf("%.1lf", w * h);
            break;
        case 2:
            printf("%.1lf", 2 * (w + h));
            break;
        default:
            printf("-1");
            break;
    }

    return 0;
}
```

```c
#include <stdio.h>

int main(void)
{
    short type = 0;
    double w, h;

    if(scanf("%hd %lf %lf", &type, &w, &h) != 3) {
        printf("Input error.");
        return 0;
    }
    type == 1 ? printf( "%.1f", w*h ) :
    type == 2 ? printf( "%.1f", 2 * ( w + h ) ) :
    printf( "%d", -1 );

    return 0;
}
```

### Подвиг 7. Напишите программу, которая считывает из входного потока три целых положительных числа (длины сторон треугольника), записанных в одну строчку через пробел. С помощью вложенных тернарных операций необходимо проверить, что эти числа могут описывать длины сторон треугольника. Выведите в консоль строку "yes", если числа образуют длины сторон треугольника, и "no" в противном случае.

Критерий проверки: у любого треугольника длина третьей стороны всегда должна быть меньше суммы двух других.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/3.3.7

```c
int main(void) {
    double a, b, c;
    if (scanf("%lf, %lf, %lf", &a, &b, &c) != 3) {
        printf("Input error.");
        return 0;
    }

    // char res = (a < b + c) && (b < c + a) && (c < b + a);
    char res = (a < b + c) ? (b < c + a) ? (c < b + a) ? 1 : 0 : 0: 0;

    printf("%s", res ? "yes" : "no");

    return 0;
}
```

### Подвиг 8 (на повторение). Напишите программу, которая читает из входного потока основания a, b и высоту h трапеции (целые числа в диапазоне [1; 100]), записанные в одну строчку через запятую. Необходимо вычислить площадь этой трапеции по формуле:

$S = \dfrac{a+b}{2} \cdot h$

Результат вывести в консоль в виде вещественного числа с точностью до десятых.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/3.3.8

```c
int main(void) {
    double a, b, h;
    if (scanf("%lf, %lf, %lf", &a, &b, &h) != 3) {
        printf("Input error.");
        return 0;
    }

    double res = h * (a + b) / 2;

    printf("%.1lf", res);

    return 0;
}
```

### Подвиг 9 (на повторение). Выберите все верные утверждения, касающиеся функции scanf().


+ [x] для использования функции scanf() в программе необходимо подключить файл stdio.h
+ [ ] функция scanf() возвращает число прочитанных байт из входного потока
+ [x] функция scanf() возвращает число прочитанных элементов (набора данных для каждой переменной)
+ [x] функция scanf() выполняет форматное чтение данных из потока stdin
+ [ ] функция scanf() выполняет форматное чтение данных из потока stdout

### Подвиг 10 (на повторение). Установите соответствия между модификаторами спецификаторов функции scanf() и их описаниями.

![03](/Good_good_C_C++/img/03_08.PNG)

Видео по теме [#15. Условное тернарное выражение](https://www.youtube.com/watch?v=_RztW4dtW9w&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

# 3.4 Оператор switch. Ключевое слово break

## Оператор switch множественного выбора.

В языке Си имеется еще один оператор ветвления `switch`, который позволяет реализовывать в программах множественный выбор.

Вначале я приведу синтаксис этого оператора, а затем, мы подробно посмотрим на примеры его работы. Общее определение можно записать следующим образом:

```c
switch(<выражение>) {
case <константа 1> :
        [операторы]
case <константа 2> :
        [операторы]
...
[default : операторы]
}
```

Здесь выражение – это любая конструкция языка Си, которая возвращает целочисленное значение (включая значение типа `char`). 

Соответственно, константы после ключевых слов `case` также должны быть целочисленными. Причем, вычисляемыми на этапе компиляции (например, целочисленные переменные использовать нельзя, а вот числовые литералы можно). 

После константы ставится двоеточие и могут быть прописаны операторы, которые выполняются по указанной метке. 

Обратите внимание, операторы здесь могут отсутствовать и далее в примерах мы увидим, когда это может быть полезно. Наконец, последнее необязательное ключевое слово default позволяет задавать набор операторов, которые выполняются, если не сработала ни одна из меток.

Работу оператора `switch` проще понять на конкретных примерах. 

Давайте предположим, что нам нужно делать выбор одного из пунктов меню:

1. Learning C language
2. Learning Python language
3. Learning Java language
4. Learning C++ language
5. Exit

Программа будет следующей:

```c
#include <stdio.h>
 
int main(void)
{
    int item;
 
    printf("1. Learning C language\n"
           "2. Learning Python language\n"
           "3. Learning Java language\n"
           "4. Learning C++ language\n"
           "5. Exit\n");
 
    if(scanf("%d", &item) != 1) {
        printf("Error input");
        return 0;
    }
 
    switch(item) {
    case 1:
        printf("Learning C language\n");
    case 2:
        printf("Learning Python language\n");
    case 3:
        printf("Learning Java language\n");
    case 4:
        printf("Learning C++ language\n");
    case 5:
        printf("Exit\n");
    }
 
    return 0;
}
```

Здесь после `case` прописаны целочисленные числовые литералы от `1` до `5`. 

Конечно, в реальной практике программирование этого следует избегать и не прописывать конкретные числа в программном коде. Но, так как мы с вами еще не проходили определение констант, то эти числа следует воспринимать исключительно, как учебный вариант.

Итак, когда выполнение программы доходит до оператора `switch`, то в нем берется значение из целочисленной переменной `item` и, затем, оно последовательно (сверху-вниз) сравнивается на равенство с константами (метками), записанными после ключевого слова case.

Давайте запустим программу и введем с клавиатуры число `3`. В результате увидим вывод следующих строк:

```
Learning Java language
Learning C++ language
Exit
```

И этот результат часто удивляет начинающих программистов. Они ожидают здесь увидеть только выполнение одной функции `printf()`, связанной с меткой `3`, а выполняются три функции `printf()`, начиная с метки `3`. 

Именно так работает оператор `switch`. 

Как только срабатывает какая-либо метка, то далее выполняются все операторы, которые записаны после этой метки, включая операторы в других нижестоящих метках. Причем, речь идет именно о нижестоящих метках. Например, если ключевое слово case со значением `3` прописать в самом начале:

```c
    switch(item) {
    case 3:
        printf("Learning Java language\n");
    case 1:
        printf("Learning C language\n");
    case 2:
        printf("Learning Python language\n");
    case 4:
        printf("Learning C++ language\n");
    case 5:
        printf("Exit\n");
    }
```

И снова выполнить программу, ввести значение `3`, то увидим все выводы строк:

```
Learning Java language
Learning C language
Learning Python language
Learning C++ language
Exit
```

## Прерывание выполнения оператора switch. Ключевое слово break

Может для вас такое поведение оператора `switch` кажется несколько неожиданным, но он работает именно так. 

Тогда, спрашивается, как нам можно реализовать множественный выбор так, чтобы выполнялись операторы только по одной метке, а не по всем нижестоящим? 

Для этого можно воспользоваться оператором `break`, который прерывает работу оператора `switch`. Например, если прописать `break` после каждого вызова функции `printf()`:

```c
    switch(item) {
    case 3:
        printf("Learning Java language\n");
        break;
    case 1:
        printf("Learning C language\n");
        break;
    case 2:
        printf("Learning Python language\n");
        break;
    case 4:
        printf("Learning C++ language\n");
        break;
    case 5:
        printf("Exit\n");
        break;
    }
```

То, как только он встречается, управление переходит к следующему оператору после `switch`. В результате, все операторы в нижестоящих метках пропускаются.

Однако часто оператор `switch` выносят в отдельную функцию и тогда прервать его работу можно также и с помощью оператора `return`. В нашем примере тоже так можно сделать, если вместо break прописать `return 0;` следующим образом:

```c
    switch(item) {
    case 3:
        printf("Learning Java language\n");
        return 0;
    case 1:
        printf("Learning C language\n");
        return 0;
    case 2:
        printf("Learning Python language\n");
        return 0;
    case 4:
        printf("Learning C++ language\n");
        return 0;
    case 5:
        printf("Exit\n");
        return 0;
    }
```

Кстати, оператор `return` чаще применяется в практике программирования для прерывания работы оператора `switch`.

Конечно, как только встречается `return 0;`, то функция `main()` завершает свою работу и все операторы, стоящие после `switch` выполняться уже не будут. 

В нашем конкретном случае, это не критично, т.к. там нет никакого значимого программного кода. 

Однако, если программу нужно продолжить после оператора `switch`, прервав его работу, то следует использовать оператор `break`. В этом главное отличие между `return 0` и `break`.

## Ключевое слово default

Давайте для примера рассмотрим еще один вариант использования оператора `switch`. Мы с клавиатуры будем вводить символ буквы (малой или большой) и выводить соответствующее сообщение на экран:

```c
#include <stdio.h>
 
int main(void) {
    char item;
 
    if(scanf("%c", &item) != 1) {
        printf("Error input");
        return 0;
    }
 
    switch(item) {
    case 'a':
    case 'A':
        printf("Symbol A\n");
        break;
    case 'b':
    case 'B':
        printf("Symbol B\n");
        break;
    case 'c':
    case 'C':
        printf("Symbol C\n");
        break;
    }
 
    return 0;
}
```

Обратите внимание на два момента.
+ Первый, метки для малой и заглавной букв следуют друг за другом, причем, блок операторов записан только у второй метки, а первая идет без операторов. Благодаря этому мы можем и для малой и для большой буквы выполнять одни и те же операторы, что довольно удобно. 
+ И второй момент. В качестве меток используются символы. В действительности, как мы с вами уже говорили, символы при трансляции программы в машинный код, преобразуются в целые числа и, по сути, представляют собой целочисленные константы. Именно поэтому символы можно прописывать наряду с целыми числами после ключевого слова `case`.

Если мы запустим эту программу и введем символ, который не указан в метках, например, буквы `d`, то на экран ничего выведено не будет. 

Оператор `switch` просто завершит свою работу, а, затем, завершится и вся программа. Давайте сделаем так, чтобы при вводе не указанного символа на экран выводилась строка «Incorrect symbol». Сделать это очень просто, используя ключевое слово default, следующим образом:

```c
    switch(item) {
    case 'a':
    case 'A':
        printf("Symbol A\n");
        break;
    case 'b':
    case 'B':
        printf("Symbol B\n");
        break;
    case 'c':
    case 'C':
        printf("Symbol C\n");
        break;
    default:
        printf("Incorrect symbol\n");
    }
```

То есть, операторы по метке `default` отрабатывают в том случае, когда не сработала ни одна из меток `case`. Причем определение `default` может быть записано в любом месте оператора `switch`, но, как правило, его пишут в самом конце.

## Рекомендации по использованию оператора switch

Вы могли заметить, что запись оператора `switch` занимает немало строк, даже в самых простых задачах. В реальной практике он нередко разрастается до больших размеров и затрудняет восприятие текста программы. Поэтому есть несколько рекомендаций, которых следует придерживаться при использовании оператора `switch`:
+ оператор `switch` лучше выносить в отдельную функцию и прерывать его работы с помощью оператора `return`;
+ программу следует организовывать так, чтобы после каждой метки `case` прописывался вызов некоторой функции вместо набора операторов;
+ никогда в программах не используйте вложенные операторы `switch`.

### Подвиг 1. Выберите все верные утверждения, касающиеся следующего фрагмента программы:

```c
#include <stdio.h>

int main(void) {
    short item = 3;
    switch(item) {
        case 1: printf("one\n");
        case 2: printf("two\n");
        case 3: printf("three\n");
        case 4: printf("four\n");
        default: printf("other number\n");
    }
    return 0;
}
```

+ [x] оператор switch выполняет проверку на равенство переменной item той или иной метке, при совпадении выполняет оператор и переходит к следующей метке (case)
+ [ ] ключевое слово default должно быть прописано только в самом низу (после всех меток case)
+ [x] после ключевого слова case должна быть прописана целочисленная метка времени компиляции программы
+ [ ] после ключевого слова case должен быть прописан только числовой целочисленный литерал
+ [x] метки case просматриваются строго сверху-вниз
+ [x] ключевое слово default может быть прописано в любом месте блока меток оператора switch
+ [ ] порядок перебора меток case не определено стандартом языка Си
+ [ ] оператор switch выполняет проверку на равенство переменной item той или иной метке, при совпадении выполняет оператор и завершает работу оператора switch
+ [x] работу оператора switch можно досрочно прервать операторами break и return

### Подвиг 2. Продолжите программу. Необходимо записать оператор switch для преобразования малых символов из набора:

a, b, c, d, e, f

в заглавные. Под преобразованием понимается изменение текущего значения переменной symbol на соответствующий символ заглавной буквы. После оператора switch выполнить вывод в консоль значения переменной symbol в виде символа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/3.4.2

```c
#include <stdio.h>

int main(void) {
    char symbol;
    if (scanf("%c", &symbol) != 1) {
        printf("Input error.");
        return 0;
    }

    // switch (symbol) {
    //     case 'a':
    //         symbol = 'A';
    //         break;
    //     case 'b':
    //         symbol = 'B';
    //         break;
    //     case 'c':
    //         symbol = 'C';
    //         break;
    //     case 'd':
    //         symbol = 'D';
    //         break;
    //     case 'e':
    //         symbol = 'E';
    //         break;
    //     case 'f':
    //         symbol = 'F';
    //         break;

    //     default:
    //         return 0;
    // }

    if (symbol >= 'a' && symbol <= 'f') {
        symbol += 'A' - 'a';
    } else
        return 0;

    printf("%c", symbol);

    return 0;
}
```

### Подвиг 3. Продолжите программу. 

Необходимо выполнить проверку выбора одного из пунктов меню с помощью оператора `switch`. 

Если пользователь вводит латинский символ из множества {a, b, c, d} или {A, B, C, D}, то соответственно выбирается один из пунктов, остальные пропускаются. 

Обратите внимание, что может быть введена или малая буква или заглавная. Оба варианта должны срабатывать. 

Если выбран один из пунктов меню, то переменной menu_number следует присвоить номер выбранного пункта. 

Номера отсчитываются с единицы, то есть, a -> 1; b -> 2; c -> 3; d -> 4. 

Если ни один из пунктов не выбран, то переменная menu_number должна принимать значение -1. 

В консоль выводятся пункты меню (уже реализовано) и на следующей строчке значение переменной menu_number в виде одного целого числа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/3.4.3

```c
#include <stdio.h>

int main(void) {
    char menu_item;
    short menu_number = 0;

    printf(
        "a) learning english\n\
b) learning C/C++\n\
c) learning mathematic\n\
d) learning Python\n");

    if (scanf("%c", &menu_item) != 1) {
        printf("Input error.");
        return 0;
    }

    if (menu_item >= 'a' && menu_item <= 'd') {
        menu_number = 1 + menu_item - 'a';
    } else if (menu_item >= 'A' && menu_item <= 'D') {
        menu_number = 1 + menu_item - 'A';
    } else
        menu_number = -1;

    // switch(menu_item){
    // case 'a': 
    // case 'A':menu_number = 1; break;
    // case 'b':
    // case 'B':menu_number = 2; break;
    // case 'c':
    // case 'C':menu_number = 3; break;
    // case 'd':
    // case 'D':menu_number = 4; break;
    // default: menu_number = -1; break;
    // }

    printf("%d", menu_number);
    return 0;
}
```

### Подвиг 4. Выберите все верные утверждения, касающиеся оператора switch.

+ [ ] если работа оператора прерывается с помощью break, то текущая функция завершается и следующий после switch оператор не выполняется
+ [x] программу следует организовывать так, чтобы после каждой метки case прописывался вызов некоторой функции вместо набора операторов
+ [ ] оператор switch не рекомендуется выносить в отдельную функцию
+ [x] в программах крайне не рекомендуется использовать вложенные операторы switch
+ [x] если работа оператора прерывается с помощью return, то текущая функция завершается и следующий после switch оператор не выполняется
+ [x] если работа оператора прерывается с помощью break, то управление передается следующему оператору после switch
+ [x] оператор switch рекомендуется выносить в отдельную функцию и прерывать его работу с помощью оператора return
+ [ ] если работа оператора прерывается с помощью return, то управление передается следующему оператору после switch

### Подвиг 5. Продолжите программу. В функции show_menu() необходимо выполнить считывание символа в переменную menu_item из входного потока. После этого прописать оператор switch, который возвращает порядковый номер выбранного пункта меню в соответствии с введенным символом: a -> 1; b -> 2; c -> 3; d -> 4. (Могут быть введены и заглавные символы: A, B, C, D.) Возврат значения в операторе switch выполнить с помощью оператора return. Если ни одно из условий не срабатывает, то возвращается -1 (это уже есть в функции программы).

В функции main() вывести в консоль значение переменной item в виде одного целого числа на следующей строчке после пунктов меню.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/3.4.5

```c
#include <stdio.h>

int show_menu(void) {
    char menu_item;

    printf(
        "a) learning english\n\
b) learning C/C++\n\
c) learning mathematic\n\
d) learning Python\n");

    if (scanf("%c", &menu_item) != 1) {
        printf("Input error.");
        return -1;
    }
    switch (menu_item) {
        case 'a':
        case 'A':
            return 1;
        case 'b':
        case 'B':
            return 2;
        case 'c':
        case 'C':
            return 3;
        case 'd':
        case 'D':
            return 4;
    }

    return -1;
}

int main(void) {
    int item = show_menu();

    printf("%d", item);

    return 0;
}
```

### Подвиг 6 (на повторение). Установите соответствия между операциями сравнения и их описаниями.

![03](/Good_good_C_C++/img/03_09.PNG)

### Подвиг 7 (на повторение). Напишите программу чтения целого положительного четырехзначного числа из входного потока. Необходимо выполнить проверку, что оно начинается на цифру 3. Если это так, то в консоль вывести строку "yes", иначе - строку "no".

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/3.4.7

```c
#include <stdio.h>
#define DELIT 1000
#define FIRST_DIGIT 3


int main(void) {
    int num;
    if (scanf("%d", &num) != 1) {
        printf("Input error.");
        return 0;
    }

    char res = num / DELIT == FIRST_DIGIT;

    printf("%s", res ? "yes" : "no");

    return 0;
}
```

код в стиле минимализма

```c
#include <stdio.h>
int main(){ printf( getchar() == '3' ? "yes" : "no"); }
```

# 3.5 Битовые операции И, ИЛИ, НЕ, XOR. Сдвиговые операции

В языке Си можно выполнять не только арифметические операции над числами, но и с отдельными битами. Что такое биты и как с их помощью кодируются целые числа, мы с вами ранее уже говорили. Так вот для работы с отдельными битами чисел используются следующие общепринятые операции:

`И`, `ИЛИ`, `НЕ`, исключающее `ИЛИ` (`XOR`)

## Битовая операция НЕ

Начнем с самой простой битовой операции `НЕ`, которая выполняет инверсию бит в соответствии со следующей таблицей истинности:

x | НЕ (~)
-|-
0 | 1
1 | 0

На языке Си она записывается с помощью символа `~` (тильда). Например:

```c
#include <stdio.h>
 
int main(void) {
    unsigned char var = 153;  //двоичная запись 10011001
    unsigned char not_v = ~var; //результат:    01100110 (число 102)
 
    printf("var = %d, not_v = %d\n", var, not_v);
 
    return 0;
}
```

Здесь для простоты восприятия информации переменные обозначены как однобайтовые без знака. Первая принимает значение `153`, а вторая формируется с помощью битовой операции `НЕ`, то есть, с помощью инверсии всех бит числа. В результате переменная `not_v` принимает значение `102`.

Можно заметить, что `153 + 102 = 255` – максимальное значение байтовой переменной. И это логично, так как число `102` содержит недостающие единицы числа `153` и в сумме они дают восемь единичных бит, то есть, число `255`.

## Битовая операция И
Следующая операция битовая И в языке Си записывается символом `&` (амперсанд). Она является бинарной и образует следующую таблицу истинности:

x | y | И (&)
-|-|-
0 | 0 | 0
0 | 1 | 0
1 | 0 | 0
1 | 1 | 1

Это очень похоже на умножение, поэтому ее условно воспринимают, как битовое умножение. Величины `x` и `y` – соответствующие биты двух операндов. Давайте посмотрим, как она работает на конкретных примерах:

```c
#include <stdio.h>
 
int main(void) {
    unsigned char flags = 5;  //двоичная запись 00000101
    unsigned char mask = 4;   //двоичная запись 00000100
 
    unsigned char res = flags & mask;
 
    printf("res = %d\n", res);
 
    return 0;
}
```

В этой программе происходит побитовое умножение соответствующих бит двух переменных `flags` и `mask` в соответствии с таблицей истинности операции `И`. В результате, переменная `res` будет содержать следующую информацию:

||||||||||
-|-|-|-|-|-|-|-|-
flags=  | 0 | 0 | 0 | 0 | 0 | 1 | 0 | 1
mask=   | 0 | 0 | 0 | 0 | 0 | 1 | 0 | 0
res =   | 0 | 0 | 0 | 0 | 0 | 1 | 0 | 0

То есть, мы над каждыми парами бит переменных `flags` и `mask` выполняем битовую операцию `И`, и то что получается на выходе заносится в соответствующие биты переменной `res`. 

Получаем ее двоичное представление, которое соответствует десятичному значению `4`. И, действительно, после запуска программы видим именно это значение переменной `res`.

Я, думаю, вы поняли, как это работает, но здесь возникает вопрос зачем все это надо? 

Смотрите, если нам нужно проверить включен ли какой-либо бит числа (то есть установлен ли он в `1`), то мы можем относительно просто сделать это с помощью битовой операции И следующим образом:

```c
#include <stdio.h>
 
int main(void) {
    unsigned char flags = 5;  //двоичная запись 00000101
    unsigned char mask = 4;   //двоичная запись 00000100
 
    if((flags & mask) == mask)
        printf("bit 2 is on");
    else
        printf("bit 2 is off");
 
    return 0;
}
```

Здесь переменная `mask` определяет маску с включенным 2-м битом, который мы хотим проверить у переменной `flags`. Далее, в соответствии с битовой операцией И (`flags & mask`) все биты обнулятся, кроме 2-го, но только в том случае, если в переменной `flags` 2-й бит установлен в `1`. 

В итоге, если результат операции (`flags & mask`) равен маске, то 2-й бит включен и на экране мы видим соответствующее сообщение.

Чтобы убедиться, что все действительно работает, давайте поменяем переменную `flags` на `1`:

```c
unsigned char flags = 1;  //двоичная запись 00000001
```

и снова запустим программу. На этот разу увидим другое сообщение, что 2-й бит выключен. По аналогии можно проверять другие биты или сразу группы бит.

Другим важным назначением операции `И` является выключение определенных бит переменной. Делается это следующим образом:

```c
#include <stdio.h>
 
int main(void) {
    unsigned char flags = 13;  //двоичная запись 00001101
    unsigned char mask = 5;    //двоичная запись 00000101
 
    flags = flags & ~mask;
 
    printf("flags = %d\n", flags);
 
    return 0;
}
```

Как это работает?
+ Сначала вычисляется инверсия бит переменной `mask`, так как операция `НЕ` имеет более высокий приоритет, чем операция `И`.
+ Затем, идет операция битового `И`, и там где в маске стоят `1`, биты переменной `flags` не меняются, остаются прежними, а там где в маске стоят `0` – соответствующие биты в переменной `flags` обнуляются. За счет этого происходит выключение 2-го и 0-го битов переменной `flags`:

||||||||||
-|-|-|-|-|-|-|-|-
flags=  | 0 | 0 | 0 | 0 | 1 | 1 | 0 | 1
mask=   | 1 | 1 | 1 | 1 | 1 | 0 | 1 | 0
res =   | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 0

Кстати, строчку битовых операций здесь можно записать в более краткой форме:

```c
flags &= ~mask;      //двоичная запись 00001000
```

## Битовая операция ИЛИ

Следующая битовая операция – битовое `ИЛИ`. Она определяется символом `|` и ее таблица истинности выглядит следующим образом:

x | y | ИЛИ `\|`
-|-|-
0 | 0 | 0
0 | 1 | 1
1 | 0 | 1
1 | 1 | 1

Для чего можно использовать эту операцию? Обычно ее применяют, когда нужно включить отдельные биты переменной. Рассмотрим следующую программу:

```c
#include <stdio.h>
 
int main(void) {
    unsigned char flags = 8;  //двоичная запись 00001000
    unsigned char mask = 5;   //двоичная запись 00000101
 
    flags = flags | mask;       //двоичная запись 00001101 (число 13)
 
    printf("flags = %d\n", flags);
 
    return 0;
}
```

Здесь преобразования над переменными `flags` и `mask` выполняются следующим образом:

||||||||||
-|-|-|-|-|-|-|-|-
flags=  | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 0
mask=   | 0 | 0 | 0 | 0 | 0 | 1 | 0 | 1
res =   | 0 | 0 | 0 | 0 | 1 | 1 | 0 | 1

То есть, операция битового `ИЛИ` как бы собирает все единички из обеих переменных и получается своеобразное битовое сложение. Кстати, в нашем конкретном примере действительно получается результат `8 + 5 = 13`. Но это не всегда так, например, если:

```c
unsigned char flags = 9;  //двоичная запись 00001001
```

то результат тоже будет `13`, так как операция ИЛИ включает бит вне зависимости был ли он уже включен или нет, все равно на выходе будет единица. И здесь уже `9 + 5 = 13`, что математически неверно.

## Битовая операция исключающее ИЛИ (XOR)
И последняя базовая операция работы с битами – исключающее ИЛИ (ее еще называют XOR). Она определяется символом ^ и имеет следующую таблицу истинности:

x | y | XOR (^)
-|-|-
0 | 0 | 0
0 | 1 | 1
1 | 0 | 1
1 | 1 | 0

Из нее видно, что данная операция позволяет переключать биты числа, то есть, если они были равны `0`, то станут `1` и, наоборот, если были `1` – станут `0`. Продемонстрируем это на примере:

```c
#include <stdio.h>
 
int main(void) {
    unsigned char flags = 9;  //двоичная запись 00001001
    unsigned char mask = 1;   //двоичная запись 00000001
 
    flags = flags ^ mask;      //двоичная запись 00001000 (число 8)
 
    printf("flags = %d\n", flags);
 
    flags ^= mask;     //двоичная запись 00001001 (число 9)
    printf("flags = %d\n", flags);
 
    return 0;
}
```
||||||||||
-|-|-|-|-|-|-|-|-
flags=  | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 1
mask=   | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1
res =   | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 0

Интересной особенностью операции `XOR` является отсутствие потерь данных при ее работе. Что это значит? Смотрите, какую бы маску мы не взяли, дважды примененная маска дает исходное значение:

```c
#include <stdio.h>
 
int main(void) {
    unsigned char flags = 9;  //двоичная запись 00001001
    unsigned char mask = 111;
 
    flags = flags ^ mask;      //двоичная запись 00001000 (число 8)
    printf("flags = %d\n", flags);
 
    flags ^= mask;     //двоичная запись 00001001 (число 9)
 
    printf("flags = %d\n", flags);
 
    return 0;
}
```

Это, как раз, связано с эффектом переключения бит, а значит, двойное переключение даст исходный результат. 

Где этот эффект можно применить? 

Самое простое – в шифровании данных. Например, когда у нас есть сообщение в виде набора данных и маска – как шифровальный ключ. Тогда, к каждому блоку данных можно применить маску и, таким образом, зашифровать сообщение. 

В частности по такому принципу устроена защита по паролю в архиваторе `zip`. 

Причем, сам пароль является ключом, который накладывается по `XOR` на заархивированные данные.

## Приоритеты базовых битовых операций
Итак, мы с вами рассмотрели основные битовые операции, которые также можно записывать и в краткой форме:

Бинарная форма | Краткая форма | Приоритет
-|-|-
`~`a; | | 4 (НЕ) 
a = a `&` b; | a `&=` b; | 3 (И)
a = a `^` b; | a `^=` b; | 2 (XOR)
a = a `\|` b; | a `\|=` b; | 1 (ИЛИ)

Самый высокий приоритет у унарной операции `НЕ`, затем, с меньшим приоритетом следует операция `И`, далее, `XOR` и самый низкий приоритет у битовой операции `ИЛИ`. Также обратите внимание, приоритет всех битовых операций ниже, чем у операций сравнения и существенно ниже обычных арифметических операций.

## Битовые операции сдвигов `>>` и `<<`
В заключение этого занятия рассмотрим еще два распространенных битовых оператора:

+ `>>` смещение бит вправо;
+ `<<` смещение бит влево;

Само название уже говорит, что они сдвигают все биты числа вправо или влево и если переменная объявлена как беззнаковая, то на освободившиеся позиции добавляются нули. Например:

```c
#include <stdio.h>
 
int main(void) {
    unsigned char x = 40;                   // 00101000
    printf("x = %d\n", x); 
 
    x = x >> 1;                       // 00010100 (число 20)
    printf("x = %d\n", x);
 
    x = x >> 2;                       // 00000101 (число 5)
    printf("x = %d\n", x); 
 
    x = x >> 1;                       // 00000010 (число 2)
    printf("x = %d\n", x);
 
    x = x >> 1;                       // 00000001 (число 1)
    printf("x = %d\n", x);
 
    x = x << 1;                       // 00000010 (число 2)
    printf("x = %d\n", x);
 
    x = x << 2;                       // 00001000 (число 8)
    printf("x = %d\n", x);
 
    return 0;
}
```

Смотрите, при единичном сдвиге бит числа вправо получаем целочисленное деление числа на `2`, а при единичном сдвиге влево – целочисленное умножение числа на `2`.

Именно поэтому число 5 при сдвиге бит вправо дает число 2. 

Причем эти операции умножения и деления работают значительно быстрее, чем традиционные арифметические операции умножения и деления. 

Поэтому, разработчики различных алгоритмов для маломощных процессоров стараются составлять вычисления так, чтобы они базировались на сдвиговых операциях, исключая прямое умножение и деление.

Сдвиги бит влево для знаковых чисел работают абсолютно так же, как и для беззнаковых. А вот сдвиг вправо несколько отличается. Здесь старший бит знака дублируется. Например:

```c
#include <stdio.h>
 
int main(void) {
    signed char x = -128;              // 1000 0000
    printf("x = %d\n", x);
 
    x = x << 1;                  // 0000 0000
    printf("x = %d\n", x);
 
    x = -128;                          // 1000 0000
    x = x >> 1;                  // 1100 0000 (-64)
    printf("x = %d\n", x);
 
    return 0;
}
```

И последнее. Приоритет сдвиговых битовых операций `<<` и `>>` одинаковый, но выше, чем у операций сравнений и меньше чем у арифметических операций.

Видео по теме [#17. Битовые операции И, ИЛИ, НЕ, XOR. Сдвиговые операции](https://www.youtube.com/watch?v=KYQ06DNnmy8&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Расположите в порядке возрастания приоритетов битовых операций И, ИЛИ, XOR (исключающее ИЛИ), НЕ.

![03](/Good_good_C_C++/img/03_10.PNG)

### Подвиг 2. Установите соответствия между обозначениями операторов и их описаниями.

![03](/Good_good_C_C++/img/03_11.PNG)

### Подвиг 3. Продолжите программу. Инвертируйте все биты переменной b и сохраните результат в переменной not_b. Выведите в консоль значение переменной not_b в виде целого десятичного числа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/3.5.3

```c
#include <stdio.h>

int main(void)
{
    unsigned char b, not_b;
    scanf("%hhu", &b);

    not_b = ~b;

    printf("%hhu", not_b);

    return 0;
}
```

### Подвиг 4. Продолжите программу. Необходимо проверить, что биты 3 и 5 переменной bits включены (установлены в 1). Если это так, то выведите в консоль значение переменной bits в виде целого десятичного числа, иначе целое число -1.

P.S. Нумерация бит числа идет в порядке от младшего к старшему и начинается с нуля: 7, 6, 5, 4, 3, 2, 1, 0

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/3.5.4

```c
#include <stdio.h>

int main(void) {
    unsigned char bits;
    scanf("%hhu", &bits);

    if ((bits & 40) == 40) {
        printf("%hhu", bits);
    } else {
        printf("-1");
    }

    return 0;
}
```

### Подвиг 5. Продолжите программу. Необходимо выключить 7 и 6 биты переменной bits (установить в 0). Результат сохраните в байтовой беззнаковой переменной res и выведите ее значение в консоль в виде целого десятичного числа.

P.S. Нумерация бит числа идет в порядке от младшего к старшему и начинается с нуля: 7, 6, 5, 4, 3, 2, 1, 0

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/3.5.5

```c
#include <stdio.h>

int main(void)
{
    unsigned char bits, res;
    scanf("%hhu", &bits);

    res = bits & ~192;

    printf("%hhu", res);

    return 0;
}
```

### Подвиг 6. Продолжите программу. Необходимо включить 4, 2 и 0 биты переменной bits (установить в 1). Результат сохраните в байтовой беззнаковой переменной res и выведите ее значение в консоль в виде целого десятичного числа.

P.S. Нумерация бит числа идет в порядке от младшего к старшему и начинается с нуля: 7, 6, 5, 4, 3, 2, 1, 0

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/3.5.6

```c
#include <stdio.h>

int main(void) {
    unsigned char bits, res;
    scanf("%hhu", &bits);

    res = bits | 21;

    printf("%hhu", res);

    return 0;
}
```

### Подвиг 7. Продолжите программу. Необходимо переключить 3 и 0 биты переменной bits. Результат сохраните в байтовой беззнаковой переменной res и выведите ее значение в консоль в виде целого десятичного числа.

P.S. Нумерация бит числа идет в порядке от младшего к старшему и начинается с нуля: 7, 6, 5, 4, 3, 2, 1, 0

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/3.5.7

```c
#include <stdio.h>

int main(void) {
    unsigned char bits, res;
    scanf("%hhu", &bits);

    res = bits ^ 9;

    printf("%hhu", res);

    return 0;
}
```

### Подвиг 8. Напишите программу, которая читает из входного потока целое неотрицательное число и выполняет целочисленное деление этого числа на 4 с использованием сдвиговых битовых операций. Результат выведите в консоль в виде целого десятичного числа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/3.5.8

```c
#include <stdio.h>

int main(void) {
    unsigned int bits, res;
    scanf("%u", &bits);

    res = bits >> 2;

    printf("%u", res);

    return 0;
}
```

### Подвиг 9. Напишите программу, которая читает из входного потока целое неотрицательное число (тип int) и выполняет умножение этого числа на 8 с использованием сдвиговых битовых операций. Результат выведите в консоль в виде целого десятичного числа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/3.5.9

```c
#include <stdio.h>

int main(void) {
    unsigned int bits, res;
    scanf("%u", &bits);

    res = bits << 3;

    printf("%u", res);

    return 0;
}
```

### Подвиг 10. Напишите программу, в которой вводятся два целых неотрицательных числа в одну строчку через пробел. Необходимо выполнить целочисленное деление этих чисел на 2 с помощью сдвиговых битовых операций и перемножить их между собой (обычное арифметическое умножение). Вывести результат в консоль в виде целого десятичного числа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/3.5.10

```c
#include <stdio.h>

int main(void) {
    unsigned int a, b, res;
    scanf("%u %u", &a, &b);

    res = a >> 1 * b >> 1;

    printf("%u", res);

    return 0;
}
```

### Подвиг 11. Напишите программу, в которой вводятся два целых неотрицательных числа в одну строчку через пробел, которые заносятся в байтовые беззнаковые переменные с именами flags и mask. Необходимо проверить, включены ли в переменной flags соответствующие биты переменной mask. Например:

flags = 5; // 00000101
mask = 4; // 00000100

В переменной flags включен 2-й бит, проверка проходит. А если:

```
flags = 5; // 00000101
mask = 6; // 00000110
```

В переменной flags включен 2-й бит, но выключен 1-й, проверка не проходит.

Если включенные биты переменной mask совпадают с соответствующими включенными битами переменной flags, то в консоль вывести строку "yes", иначе - строку "no".

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/3.5.11

```c
#include <stdio.h>

int main(void) {
    unsigned int flags, mask;

    scanf("%u %u", &flags, &mask);

    char res = (flags & mask) == mask;

    printf("%s", res ? "yes" : "no");

    return 0;
}
```

### Подвиг 12. Напишите программу, в которой вводятся два целых неотрицательных числа в одну строчку через пробел, которые заносятся в беззнаковые целочисленные переменные (тип int) с именами flags и mask. Необходимо проверить, включен ли в переменной flags хотя бы один соответствующий бит переменной mask. Например:

```
flags = 5; // 00000101
mask = 20; // 00010100
```

В переменной flags включен 2-й бит, который совпадает со 2-м включенным битом из mask, проверка проходит. А если:

```
flags = 5; // 00000101
mask = 18; // 00010010
```

В переменной flags нет ни одного включенного бита, совпадающего хотя бы с одним включенным битом переменной mask, проверка не проходит.

Если проверка проходит, то в консоль вывести строку "yes", иначе - строку "no".

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/3.5.12

```c
#include <stdio.h>

void print_byte(unsigned int byte) {
    const char *bit_rep[16] = {
        [0] = "0000",  [1] = "0001",  [2] = "0010",  [3] = "0011",  [4] = "0100",  [5] = "0101",
        [6] = "0110",  [7] = "0111",  [8] = "1000",  [9] = "1001",  [10] = "1010", [11] = "1011",
        [12] = "1100", [13] = "1101", [14] = "1110", [15] = "1111",
    };
    printf("%s%s\n", bit_rep[byte >> 4], bit_rep[byte & 0x0F]);
}

int main(void) {
    unsigned int flags, mask, res;

    scanf("%u %u", &flags, &mask);

    res = flags & mask;
    print_byte(flags);
    print_byte(mask);
    print_byte(res);

    printf("%s", res ? "yes" : "no");

    return 0;
}
```

# 3.6 Генерация псевдослучайных чисел. Математическая библиотека

Видео по теме [#18. Генерация псевдослучайных чисел. Функции математической библиотеки](https://www.youtube.com/watch?v=ewVeA0XzI8g&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

## Генерация псевдослучайных чисел.

После того, как мы разобрали арифметические и битовые операции, для полноты картины рассмотрим порядок генерации случайных значений и основные математические функции.

Начнем с генерации случайных значений. Это довольно распространенная операция, которую совместно используют при арифметических действиях. В языке Си для этого имеется специальная функция, которая определена следующим образом:

```c
int rand(void);
```

Она возвращает псевдослучайные целые значения в диапазоне от `0` до константы `RAND_MAX`. Значение `RAND_MAX` не меньше числа `32767`. Функция `rand()` и константа `RAND_MAX` определены в заголовочном файле `stdlib.h`. Например, в самом простом варианте в программе можно сгенерировать несколько случайных значений следующим образом:

```c
#include <stdio.h>
#include <stdlib.h>
 
int main(void) {
    int r_1 = rand();
    int r_2 = rand();
 
    printf("%d, %d, %d, %d, %d\n", r_1, r_2, rand(), rand(), rand());
 
    return 0;
}
```

После запуска программы увидим значения:

```
41, 18467, 19169, 26500, 6334
```

А теперь, внимание, несколько важных моментов!
+ Первое. Сгенерированные числа называются псевдослучайными, а не случайными, так как они все же вычисляются по некоторому алгоритму.<br> 
Истинной случайности мы здесь получить не можем. В частности, это означает, что такие псевдослучайные значения не следует применять в алгоритмах шифрования.
+ Второе. При каждом запуске программы функция `rand()` выдает абсолютно ту же самую последовательность значений псевдослучайных чисел.<br> 
Это связано с тем, что алгоритм их генерации базируется на начальном состоянии регистров при запуске программы. А они каждый раз содержат одни и те же данные.
+ Третье. Значения псевдослучайных чисел распределены по равномерному закону в диапазоне `[0; RAND_MAX]`.<br> 
То есть, с равной вероятностью может появиться любое значение из этого диапазона.

![03](/Good_good_C_C++/img/03_12.png)

## Генерация разных вариаций псевдослучайных чисел

Все это следует учитывать при использовании функции `rand()`. И, соответственно, возникают вопросы. Первый. Что если нам нужно при запуске получать все время разные случайные значения? Как это сделать? Для этого пользуются функцией:

```c
void srand(unsigned int seed);
```

которая задает начальное значение «зерна» (`seed`) для датчика псевдослучайных чисел. Если это зерно указать, например, равным 10 (в начале функции `main()`):

```c
srand(10);
```

то увидим уже другую последовательность чисел:

```
71, 16899, 13697, 13694, 3272
```

Правда, она все равно меняться не будет. Чтобы изменения происходили каждый раз от запуска к запуску, необходимо при каждом запуске менять значение зерна. В практике программирования для этого часто используют еще одну функцию:

```c
time_t time(time_t * const _Time);
```

которая объявлена в заголовочном файле `time.h` и возвращает текущее время в секундах. Не вдаваясь в подробности, мы можем ее вызвать, например, следующим образом:

```c
int t = time(NULL);
```

Тогда значение переменной `t` каждый раз будет меняться от запуска к запуску. А это именно то, что нам и нужно. Объединим обе функции, получим:

```c
srand(time(NULL));
```

Все, теперь каждый раз мы будем получать разные вариации псевдослучайных значений. Причем, функцию `srand()` достаточно вызвать только один раз при запуске программы.

## Генерация псевдослучайных чисел заданного диапазона

Следующий вопрос, как сформировать псевдослучайные числа произвольного диапазона? Как правило, меньшего чем `[0; RAND_MAX]`. Если при этом, нам нужно сохранить целочисленные значения, то меньший диапазон легко получить с помощью операции деления по модулю, например, так:

```c
int range = 10;
int r_1 = rand() % range;   // [0; range)
```

Обратите внимание, граничное значение `10` не входит в диапазон, оно исключается (поэтом в конце записана круглая скобка).

Если диапазон должен начинаться не с нуля, то соответственно, нужно сделать обычное математическое смещение значений (вычитание), например:

```c
int r_2 = rand() % range - 5; // [-5; range-5)
```

И так для любого разумного диапазона целых чисел, меньшего начального `[0; RAND_MAX]`. Если потребуется больший, то вначале можно сложить два случайных значения:

```c
int r_3 = rand() + rand();  // [0; 2*RAND_MAX]
```

А, затем, применить к нему все те же математические преобразования.

Несколько иначе обстоит дело с получением вещественных значений. Часто поступают следующим образом. Вначале весь диапазон `[0; RAND_MAX]` приводят к диапазону вещественных значений `[0; 1]`, а затем, масштабируют и смещают его, если это необходимо. Например:

```c
double range_float = (double)rand() / (double)RAND_MAX; // [0; 1]
```

Обратите внимание на операцию приведения типов. 

Так как функция `rand()` возвращает целочисленные значения и константа `RAND_MAX` тоже целочисленная, то при делении мы бы получали тоже целые числа с отбрасыванием дробной части. Поэтому перед делением мы приводим оба значения к вещественному типу `double`, чтобы получить также вещественное число в диапазоне `[0; 1]`.

После этого, используя вещественное случайное значение `range_float` диапазона `[0; 1]`, мы легко можем формировать любые другие диапазоны из псевдослучайных вещественных чисел.

Вот основные приемы при генерации псевдослучайных значений на языке Си.

## Основные математические функции
Во второй части занятия познакомимся с часто используемыми математическими функциями, определенные в заголовочном файле math.h. Они следующие:

Функция | Описание
-|-
int abs(int) | Вычисление модуля целочисленного значения.
double fabs(double) | Вычисление модуля вещественного значения.
Функции округления
double round(double) | Округление вещественного значения до ближайшего целого.
double floor(double) | Округление вещественного значения до наименьшего целого.
double ceil(double) | Округление вещественного значения до наибольшего целого.
double trunc(double) | Отбрасывание дробной части вещественного числа.
Степенные функции
double sqrt(double) | Вычисление квадратного корня от вещественного значения.
double cbrt(double) | Вычисление кубического корня от вещественного значения.
double pow(double x, double y) | Возведение числа x в степень y.
double exp(double) | Вычисление экспоненты от вещественного значения.
double log(double) | Вычисление натурального логарифма.
double log2(double) | Вычисление логарифма по основанию 2.
double log10(double) | Вычисление десятичного логарифма.
Тригонометрические функции
double sin(double) | Вычисление синуса угла, заданного в радианах.
double cos(double) | Вычисление косинуса угла, заданного в радианах.
double tan(double) | Вычисление тангенса угла, заданного в радианах.
double asin(double) | Вычисление арксинуса угла (возвращает радианы).
double acos(double) | Вычисление арккосинуса угла (возвращает радианы).
double atan(double) | Вычисление арктангенса угла (возвращает радианы).

То есть, если вам в программе потребуется выполнять операции округления, возведения в степень, применять тригонометрические функции, то все это уже имеется в стандартной математической библиотеке языка Си. Все, что от вас требуется – это подключить заголовочный файл `math.h`, где все эти функции определены.

Использовать их достаточно просто и очевидно. Поэтому я просто приведу довольно популярный, но показательный пример использования функции `sqrt()` для вычисления действительных корней квадратного уравнения вида:

$a \cdot x^2 + b \cdot x + c = 0$

Здесь a, b, c – коэффициенты уравнения (вещественные числа). Надеюсь, все помнят школьный курс математики и знают, как находить корни такого уравнения. Вначале нам нужно вычислить дискриминант по формуле:

$D = b^2 - 4 \cdot a \cdot c$

Если он окажется больше или равен нулю, то действительные корни существуют. Иначе, действительных корней нет. Сами же корни вычисляются по формулам:

$x_1 = - \dfrac{b + \sqrt{D}}{2 \cdot a}$

$x_2 = - \dfrac{b - \sqrt{D}}{2 \cdot a}$

Ниже приведена программа, которая решает такие квадратные уравнения:

```c
#include <stdio.h>
#include <math.h>
 
int main(void) {
    double a, b, c;
    double D, x1, x2;
 
    if(scanf("%lf, %lf, %lf", &a, &b, &c) != 3) {
        printf("Error input\n");
        return 0;
    }
 
    D = b*b - 4*a*c;
 
    if(D < 0) {
        printf("D  = %.2f < 0", D);
        return 0;
    }
 
    D = sqrt(D);
 
    x1 = -(b + D) / (2.0 * a);
    x2 = -(b - D) / (2.0 * a);
 
    printf("x1 = %.2f, x2 = %.2f\n", x1, x2);
 
    return 0;
}
```

Как видите, здесь используется функция `sqrt()`, которая возвращает квадратный корень от дискриминанта и используется при вычислении корней `x1` и `x2`.

Вообще в функции `sqrt()`, равно, как и почти в любой другой функции математической библиотеки, можно прописывать любые выражения языка Си, которые возвращают целые или вещественные значения. То есть, ничто нам не мешает ту же функцию `sin()` записывать в таких вариациях:

```c
double res_1 = sin(x1);
double res_2 = sin(2 * x1);
double res_3 = sin(10.0 / 15.0);
```

Главное, чтобы вычисляемое выражение соответствовало типу передаваемых значений. Во всем остальном ограничений никаких нет.

### Подвиг 1. Выберите все верные утверждения, касающиеся функции rand() языка Си.

+ [x] функция rand() генерирует псевдослучайные числа, вычисляемые по некоторому алгоритму
+ [x] функция rand() выдает числа в диапазоне [0; RAND_MAX]
+ [x] числа, генерируемые функцией rand(), распределены по равномерному закону (равновероятны)
+ [x] для использования функции rand() в программе необходимо подключить файл stdlib.h
+ [ ] функция rand() выдает числа в диапазоне [0; RAND_MAX-1]
+ [ ] при каждом новом запуске программы функция rand() выдает разные последовательности чисел
+ [x] при каждом новом запуске программы функция rand() выдает одну и ту же последовательность чисел
+ [ ] функция rand() генерирует настоящие случайные числа, которые невозможно предугадать

### Подвиг 2. Продолжите программу. С помощью функции rand() сгенерируйте четыре псевдослучайных числа, присвойте их переменным и по порядку выведите их в консоль в одну строчку через пробел.

```c
#include <stdio.h>
#include <stdlib.h>
#define DIGITS 4

int main(void) {
    int nums[DIGITS];

    for (int i = 0; i < DIGITS; i++) {
        nums[i] = rand();
    }
    for (int i = 0; i < DIGITS; i++) {
        printf("%d%s", nums[i], i != DIGITS - 1 ? " " : "");
    }

    return 0;
}
```

### Подвиг 3. Продолжите программу, которая генерирует семь целых псевдослучайных чисел в диапазоне от 0 до N (включительно). Число N меньше значения константы RAND_MAX. Для формирования диапазона значений используйте арифметическую операцию вычисления целого остатка от деления. Выведите сгенерированные числа в консоль в одну строчку через пробел.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/3.6.3

```c
#include <stdio.h>
#include <stdlib.h>
#define DIGITS 7

int main(void) {
    int nums[DIGITS];
    int N;
    scanf("%d", &N);

    for (int i = 0; i < DIGITS; i++) {
        nums[i] = rand() % (N + 1);
    }
    for (int i = 0; i < DIGITS; i++) {
        printf("%d%s", nums[i], i != DIGITS - 1 ? " " : "");
    }

    return 0;
}
```

### Подвиг 4. Продолжите программу, которая генерирует псевдослучайные целые числа в диапазоне от a до b (включительно). Числа a и b (a < b) считываются из входного потока. Для формирования диапазона значений используйте арифметическую операцию вычисления целого остатка от деления:

$y=rnd \% (b−a+1)+a$

Сгенерируйте десять псевдослучайных чисел и выведите их в консоль в одну строчку через пробел.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/3.6.4

```c
#include <stdio.h>
#include <stdlib.h>
#define DIGITS 10

int main(void) {
    int nums[DIGITS];
    int a, b;
    scanf("%d %d", &a, &b);

    for (int i = 0; i < DIGITS; i++) {
        nums[i] = rand() % (b - a + 1) + a;
    }
    for (int i = 0; i < DIGITS; i++) {
        printf("%d%s", nums[i], i != DIGITS - 1 ? " " : "");
    }

    return 0;
}
```

### Подвиг 5. Продолжите программу, которая генерирует псевдослучайные вещественные числа в диапазоне от a до b (включительно). Целые числа a и b (a < b) считываются из входного потока. Значения формируются путем уменьшения исходного диапазона значений [0; RAND_MAX] до диапазона [a; b], как показано на рисунке ниже.

![03](/Good_good_C_C++/img/03_13.png)

Используйте для этого формулу:

$y= \dfrac{rnd}{RAND\_MAX} \cdot (b−a)+a$

где rnd - случайное значение, возвращенное функцией rand().

Сгенерируйте десять псевдослучайных чисел и выведите их в консоль в одну строчку через пробел с точностью до сотых.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/3.6.5

```c
#include <stdio.h>
#include <stdlib.h>
#define DIGITS 10
#define RAND_MAX 32767

int main(void) {
    double nums[DIGITS];
    int a, b;
    scanf("%d %d", &a, &b);

    for (int i = 0; i < DIGITS; i++) {
        nums[i] = (rand() / (double)RAND_MAX) * (b - a) + a;
    }
    for (int i = 0; i < DIGITS; i++) {
        printf("%.2lf%s", nums[i], i != DIGITS - 1 ? " " : "");
    }

    return 0;
}
```

### Подвиг 6. Продолжите программу, которая при каждом новом запуске генерирует разные последовательности из пяти псевдослучайных чисел и сохраняет их в целочисленные переменные r1, r2, r3, r4, r5.

P.S. В консоль ничего выводить не нужно. 

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main(void) {
    srand(time(NULL));
    int r1, r2, r3, r4, r5;

    r1 = rand();
    r2 = rand();
    r3 = rand();
    r4 = rand();
    r5 = rand();

    return 0;
}
```

### Подвиг 7. Установите соответствия между математическими функциями округления и их описаниями.

![03](/Good_good_C_C++/img/03_14.PNG)

### Подвиг 8. Установите соответствия между математическими степенными функциями и их описаниями.

![03](/Good_good_C_C++/img/03_15.PNG)

### Подвиг 9. Установите соответствия между математическими тригонометрическими функциями и их описаниями.

![03](/Good_good_C_C++/img/03_16.PNG)

### Подвиг 10. Продолжите программу решения следующей задачи. Каждый день во время конференции расходуется N пакетиков чая. Конференция длится 7 дней. В пачке чая 100 пакетиков. Какого наименьшего количества пачек чая хватит на все дни конференции? Результат выведите в консоль в виде одного целого числа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/3.6.10

```c
#include <math.h>
#include <stdio.h>

int main(void) {
    unsigned short N;
    scanf("%hu", &N);

    int res = ceil(N * 7 / 100.0);
    printf("%d", res);
    return 0;
}
```

### Подвиг 11. Продолжите программу решения следующей задачи. Диагональ экрана телевизора составляет N дюймов. Выразите диагональ экрана в сантиметрах, если в одном дюйме 2,54 см. Результат округлите до целого числа сантиметров (по правилам математики). Результат выведите в консоль в виде одного целого числа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/3.6.11

```c
#include <stdio.h>

int main(void)
{
    unsigned short N;
    scanf("%hu", &N);

    int res = round(N * 2.54);
    printf("%d", res);

    return 0;
}
```

### Подвиг 12. Напишите программу чтения из входного потока вещественного значения угла, выраженного в градусах. Вычислите синус этого угла и выведите результат в консоль в виде вещественного значения с точностью до десятых.

P.S. Не забудьте перевести градусы в радианы по формуле: $rad=grad⋅π/180$. Значение $π=3.1415$.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/3.6.12

```c
#include <math.h>
#include <stdio.h>

#define PI 3.1415

int main(void) {
    double grad;
    scanf("%lf", &grad);

    double res = sin(grad * PI / 180);
    printf("%.1lf", res);

    return 0;
}
```

### Подвиг 13. Продолжите программу. Необходимо вычислить тангенс угла прямоугольного треугольника с противолежащим катетом размером a и прилежащим катетом размером b. (Вычисляется по формуле: tan = a / b.) Затем, определите угол (в радианах) по вычисленному тангенсу. Выведите в консоль тангенс угла и угол в виде вещественных чисел с точностью до сотых в одну строчку через пробел.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/3.6.13

```c
#include <math.h>
#include <stdio.h>

#define PI 3.1415

int main(void) {
    int a, b;
    scanf("%d, %d", &a, &b);

    double tan = a / (double) b;
    double res = atan(tan);

    printf("%.2lf %.2lf",tan , res);

    return 0;
}
```

# 3.7 Директивы макропроцессора #define и #undef

## Директива макропроцессора #define

На этом занятии мы вспомним о текстовом препроцессоре, который выполняет некоторое преобразование текста программы до ее компиляции. 

Нас, главным образом, будет интересовать работа макропроцессора, который выполняет команды, прописанные непосредственно в тексте программы. О чем здесь идет речь? 

Смотрите. 

Практически в любой программе на языке Си имеются, так называемые, макродирективы (или, попросту, директивы). Все они начинаются со специального символа `#`, за которым следует имя директивы. Например, в наших программах постоянно фигурировала макродиректива с именем `include`:

```c
#include <stdio.h>
```

Это одна из команд для макропроцессора. О ней мы подробнее еще будем говорить, но в двух словах, как только текстовый препроцессор встречает в тексте программы эту команду, он на ее место вставляет содержимое файла (в нашем примере `stdio.h`). Сама же макродиректива удаляется из текста программы и на компилятор поступает программа, состоящая только из конструкций языка Си.

Все директивы в тексте программы принято писать с начала строки без отступов. Хотя, стандарт C99 разрешает это делать, в частности, ставить пробельные символы перед символом `#` и даже после него. Но все же лучше по возможности этого избегать.

Знакомство с командами макропроцессора мы начнем с директивы `define`, которая позволяет определять в программе свои собственные макроопределения (или, как часто говорят, макросы).

В простейшем случае синтаксис для описания макроопределения имеет следующий вид:

```c
#define <макроимя> [тело макроса]
```

И, как правило, записывается в пределах одной строки. Строго говоря, обычный перенос строки будет означать завершение описания макроса. Хотя, при необходимости, это правило можно обойти.

Чтобы было понятно, как работает директива `define`, приведу конкретные примеры макроопределений:

```c
#define MENU_TRANSL 1
#define MENU_ADD    2
#define MENU_EXIT   3
#define MENU_FMT    "You have selected menu item %d\n"
#define FIRST_LETTER    'a'
```

Как видите, макроимена принято записывать заглавными буквами, хотя формально можно использовать и малые. Но лучше придерживаться этой традиции, чтобы выделять макросы на фоне остальных конструкций языка Си.

В приведенном примере, имена `MENU_TRANSL`, `MENU_ADD`, `MENU_EXIT` связаны с целыми числовыми литералами `1`, `2` и `3`. Имя `MENU_FMT` – со строкой, а макрос `FIRST_LETTER` – с символом. Обратите внимание, в конце я нигде не прописывал точку с запятой. Этого не требуется. Как я уже говорил, описание макроса заканчивается с переходом на новую строку.

Итак, мы в программе ввели несколько новых макроимен. Как дальше всем этим можно воспользоваться и что это нам дает? Помните, я приводил пример реализации меню с оператором `switch`. Вот краткий пример:

```c
#include <stdio.h>
 
int main(void) {
    int item;
 
    scanf("%d", &item);
 
    switch(item) {
    case 1:
        printf("Translate words\n");
        break;
    case 2:
        printf("Add words\n");
        break;
    case 3:
        printf("Exit\n");
        break;
    default:
        printf("Incorrect menu item\n");
    }
 
    return 0;
}
```

Здесь в качестве меток после ключевых слов `case` можно использовать целые числа или константы времени компиляции. Как раз макроопределения в `define` вполне можно использовать и заменить числовые литералы более читаемыми именами:

```c
    switch(item) {
    case MENU_TRANSL:
        printf("Translate words\n");
        break;
    case MENU_ADD:
        printf("Add words\n");
        break;
    case MENU_EXIT:
        printf("Exit\n");
        break;
    default:
        printf("Incorrect menu item\n");
    }
```

Это один маленький пример, где полезны макроопределения. На самом деле, как я уже говорил, в тексте программы нужно избегать использования конкретных чисел, так как они, во-первых, сложнее воспринимаются человеком, а, во-вторых, при изменении хотя бы одного числа, его придется искать и менять во всем проекте, что очень неудобно. Куда проще определить макроопределение и записывать его в тексте программы. Такая программа лучше воспринимается человеком и проще модифицируется.

Вернемся к нашему примеру с меню. После того, как мы прописали макросы в операторе `switch`, они стали не чем иным, как макровызовами. Это значит, что на этапе обработки текста препроцессором (до непосредственной компиляции программы в машинный код) все эти макровызовы будут преобразованы макропроцессором в заданные нами определения. Например, макрос `MENU_TRANSL` определен как целое число `1`. Значит, вместо него макропроцессор подставит это значение. И также поступит с именами `MENU_ADD` и `MENU_EXIT`. В итоге, дальше на компиляцию поступит программа без этих текстовых определений, а с конкретными числами.

В общем случае мы можем задавать и использовать макросы следующими способами:

```c
#include <stdio.h>
 
#define FIVE    5
#define TEN     2 * FIVE
#define TEXT    "Text message in one line"
#define TEXT2   "Text message in \
two line"
#define PRINT_D  printf("digit = %d\n", digit)
#define FORMAT  "digit = %d\n"
 
int main(void) {
    int digit = FIVE;
    PRINT_D;
    
    digit = TEN;
    printf(FORMAT, digit);
    printf(TEXT "\n");
    printf(TEXT2 "\n");
    
    return 0;
}
```

Вначале прописаны несколько макроопределений, а затем, они используются в программе в функции `main()`. В частности, макровызов `FIVE` подставляет число `5` на свое место. Вместо `PRINT_D` будет подставлено определение `printf("digit = %d\n", digit)`. Обратите внимание, макропроцессор не выполняет синтаксического разбора текста программы, он работает с информацией на уровне текста. Поэтому для него запись `printf("digit = %d\n", digit)` - это всего лишь строка, которую следует подставить на место макровызова `PRINT_D` и не более того. 

И так со всеми остальными макроопределениями. 

Вместо `TEN` будет подставлено выражение `2 * 5` без каких-либо вычислений, именно в таком виде, вместо `FORMAT` строка `digit = %d\n` и так далее.

А теперь, внимание, вопрос. Что если мы пропишем функцию `printf()` следующим образом:

```c
printf("FORMAT\n");
```

Будет ли здесь вместо `FORMAT` подставлено содержимое макроса `FORMAT`? На самом деле нет. 

Это единственное исключение, когда макропроцессор пропускает макроимена, записанные внутри строк. Поэтому функция `printf()` просто выведет строку  `FORMAT` в консоль. И так с любыми макроименами, прописанными внутри любых строк.

Думаю, излишне говорить, что макровызовы следует делать после макроопределений. Именно поэтому, директивы `#define`, как правило, прописываются вначале программы. Это гарантирует, что во всем тексте можно без ограничений прописывать соответствующие макросы и позволяет легко находить место их определения.

## Директива #undef
Также, разумеется, если какой-либо макрос ранее был определен, то переопределить его с новым поведением уже не получится. Если все же это требуется сделать, то сначала нужно отменить прежний макрос и прописать новый. Для отмены макроопределений используется директива `#undef`, например, так:

```c
#define TEN     2 * FIVE
#undef TEN
#define TEN     10
```

Я думаю, вы теперь хорошо себе представляете, как можно прописывать простые макросы и использовать их в программах.

### Подвиг 1. Отметьте все верные (рабочие) макроопределения фрагмента программы языка Си стандарта C99.

+ [ ] define STUDY "C/C++"
+ [x] #define LESSON 32
+ [x] #define PHELLO2 printf("Hello!\n");
+ [x] # define SPACE ' '
+ [x] # define other_lesson LESSON + 1
+ [ ] #define NEW_DEFINE #define A 2
+ [x] #define PHELLO printf("Hello!\n")

### Подвиг 2. Выберите все верные утверждения, касающиеся макроопределений.


+ [x] директива #define создает макроопределение, а директива #undef отменяет существующее макроопределение
+ [x] имена макросов принято записывать заглавными буквами
+ [x] макроопределения обрабатываются до непосредственной компиляции программы
+ [x] макроопределение формально должно быть записано в одну строчку (до символа переноса строки)
+ [ ] макроопределения обрабатываются после компиляции программы (перевода в машинный код)
+ [ ] директива #undef создает макроопределение, а директива #define отменяет существующее макроопределение
+ [x] при компиляции программы текстовый препроцессор вместо имени макроса подставляет его определение (тело макроса)

### Подвиг 3. Выберите все верные утверждения, касающиеся следующего фрагмента программы:

```c
#include <stdio.h>

#define TOTAL           512
#define DOUBLE_TOTAL    TOTAL * 2
#define P_SIZE          printf("Size: %d\n", size)

int main(void) {
    int dsize = DOUBLE_TOTAL;
    int size = dsize / 2;
    P_SIZE;

    return 0;
}
```

+ [ ] функция printf() не может быть частью макроопределения
+ [ ] вместо P_SIZE в функции main() будет подставлено printf("Size: %d\n", size)
+ [x] макроопределение DOUBLE_TOTAL не может быть сформировано на основе других макросов
+ [x] справа от операции присваивания переменной size будет фигурировать выражение 1024 / 2
+ [x] вместо DOUBLE_TOTAL в функции main() будет подставлено выражение 512 * 2
+ [ ] вместо DOUBLE_TOTAL в функции main() будет подставлено число 1024

### Подвиг 4. Продолжите программу. Необходимо определить макрос KMH, который бы позволял переводить скорость из м/с в км/ч путем простого умножения. Напомню, что для этого скорость в м/с нужно умножить на математическое выражение 3600/1000, получим скорость в км/ч. Далее, в функции main() нужно объявить вещественную переменную с именем s_kmh и присвоить ей значение скорости s_mc, переведенное в км/ч. Вывести в консоль значение переменной s_kmh с точностью до сотых.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/3.7.4

```c
#include <stdio.h>

#define KMH  3.6 *

int main(void) {
    int s_mc;
    scanf("%d", &s_mc);

    double s_kmh = KMH s_mc; 

    printf("%.2lf", s_kmh);

    return 0;
}
```

### Подвиг 5. Продолжите программу. Необходимо определить два макроса: PI - значение числа пи (взять равным 3.1415) и GRAD - формула перевода из радиан в градусы (математически: 180 деленное на пи). Далее, в функции main() нужно объявить вещественную переменную с именем grad и присвоить ей значение градусов, переведенное из радиан переменной rad (перевод осуществляется простым умножением радиан на GRAD). Вывести в консоль значение переменной grad с точностью до сотых.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/3.7.5

```c
#include <stdio.h>

#define PI 3.1415 // здесь определяйте макрос PI
#define GRAD  180 / PI * // здесь формула перевода из радиан в градусы

int main(void) {
    double rad;
    scanf("%lf", &rad);

    double grad = GRAD rad;

    printf("%.2lf", grad);

    return 0;
}
```

### Подвиг 6. Напишите программу, в которой задаются два макроопределения MAX_WIDTH и MAX_HEIGHT с целочисленными значениями 256 и 500 соответственно. Далее, в функции main() следует реализовать чтение двух вещественных чисел, записанных в одну строчку через пробел, в переменные width и height (именно в таком порядке). Затем, выполнить проверку: если значение width больше MAX_WIDTH, то width должна быть равна MAX_WIDTH. И аналогичную проверку реализовать для переменной height. В конце программы вывести в консоль значения переменных width и height в одну строчку через пробел с точностью до десятых.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/3.7.6

```c
#include <stdio.h>

#define MAX_WIDTH 256
#define MAX_HEIGHT 500

int main(void) {
    double width, height;
    scanf("%lf %lf", &width, &height);

    if (width > MAX_WIDTH) width = MAX_WIDTH;
    if (height > MAX_HEIGHT) height = MAX_HEIGHT;
    
    printf("%.1lf %.1lf", width, height);

    return 0;
}
```

### Подвиг 7. Напишите программу, в которой объявляется макроопределение MAX_LENGTH с целочисленным значением 100. В функции main() реализовать чтение двух целочисленных положительных чисел, записанных в одну строчку через пробе, в переменные x и y (именно в таком порядке). Затем, выполнить проверку: если длина радиус-вектора с координатами (x, y) превышает значение MAX_LENGTH, то в консоль вывести сообщение (без кавычек):

"Radius length exceeds value of MAX_LENGTH"

Иначе вывести в консоль длину радиус-вектора в виде вещественного числа с точностью до сотых.

Напомню, что длина радиус-вектора с координатами (x, y) вычисляется по формуле:

$length= \sqrt{x^2 + y^2}$
 
Тесты: https://github.com/selfedu-rus/c-tests/tree/main/3.7.7

```c
#include <math.h>
#include <stdio.h>

#define MAX_LENGHT 100

int main(void) {
    int x, y;
    scanf("%d %d", &x, &y);

    double res = sqrt(x * x + y * y);

    printf(res > MAX_LENGHT ? "Radius length exceeds value of MAX_LENGTH" : "%.2lf", res);

    return 0;
}
```

### Подвиг 8. Выберите все верные утверждения, касающиеся следующего фрагмента программы:

```c
#include <stdio.h>

#define TWO     2
#define FOUR    TWO * 2
#undef TWO

int main(void) {
    int b = FOUR;
    printf("TWO = %d\n", b / 2);
    return 0;
}
```

+ [ ] благодаря директиве #undef в функции printf() можно в строке использовать слово TWO
+ [x] директива #undef отменяет определение макроимени TWO
+ [x] макрос FOUR в функции main() не может быть использован, так как не определен макрос TWO
+ [x] макросы в строках не обрабатывается и считаются фрагментом строки
+ [ ] макрос FOUR в функции main() можно использовать, так как он был определен до отмены макроимени TWO

### Подвиг 9. Напишите программу, в которой объявляется макрос с именем MAX_BUFF_SIZE со значением 1024 и выполняется чтение (в функции main()) целочисленного положительного значения в целочисленную переменную buff_size. С помощью тернарного условного оператора скорректируйте значение переменной buff_size, чтобы оно не превосходило значения MAX_BUFF_SIZE. Итоговое значение переменной buff_size выведите в консоль в виде одного целого числа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/3.7.9

```c
#include <math.h>
#include <stdio.h>

#define MAX_BUFF_SIZE 1024

int main(void) {
    int buff_size;
    scanf("%d %d", &buff_size);

    if (buff_size > MAX_BUFF_SIZE) buff_size = MAX_BUFF_SIZE;

    printf("%d", buff_size);

    return 0;
}
```

### Подвиг 10 (на повторение). Выберите все верные утверждения, касающиеся функции rand() языка Си.


+ [x] функция rand() выдает числа в диапазоне [0; RAND_MAX]
+ [ ] при каждом новом запуске программы функция rand() выдает разные последовательности чисел
+ [x] числа, генерируемые функцией rand(), распределены по равномерному закону (равновероятны)
+ [x] при каждом новом запуске программы функция rand() выдает одну и ту же последовательность чисел
+ [ ] функция rand() выдает числа в диапазоне [0; RAND_MAX-1]
+ [x] для использования функции rand() в программе необходимо подключить файл stdlib.h
+ [x] функция rand() генерирует псевдослучайные числа, вычисляемые по некоторому алгоритму
+ [ ] функция rand() генерирует настоящие случайные числа, которые невозможно предугадать

# 3.8 Макросы. Операции `#` и `##`

## Директива #define для определения макросов-функций.

На прошлом занятии мы подробно разобрали объявление простых макроопределений. Давайте теперь сделаем следующий шаг и посмотрим, как можно использовать параметры при макроопределениях. 

На самом деле все предельно просто. После имени макроса можно поставить круглые скобки и в них через запятую прописать параметры, а затем, в теле макроса, указать, что с этими параметрами следует сделать. Например, так:

```c
#include <stdio.h>
 
#define SQ_PR(A, B)   A * B
 
int main(void) {
    int res = SQ_PR(2, 3);
    printf("res = %d\n", res);
 
    return 0;
}
```

Получаем, своего рода, макрос-функцию, которая формирует результаты в зависимости от переданных значений в параметры A и B. 

Давайте разберемся детально, как это работает, и увидим, какие потенциальные ошибки таит в себе приведенное макроопределение.

Итак, при вызове макроса `SQ_PR(2, 3)` со значениями `2` и `3`, параметр `A` будет представлять собой число `2`, а параметр `B` – число `3`. Обратите внимание, параметры `A` и `B` – это не переменные, они не хранят какие-либо значения. Это лишь некоторое условное обозначение первого и второго параметров макроса `SQ_PR`. Когда мы передаем `2` и `3`, то вместо `A` появляется `2`, а вместо `B` – `3`. А далее, в теле макроса указывается формат подставляемого выражения для этого макровызова. 

В нашем примере, получим `2 * 3`. Именно на такую конструкцию будет заменен макровызов `SQ_PR(2, 3)`.

А вот если для примера передать значения:

```c
int res = SQ_PR(x + 2, y - 3);
```

то в процессе макровызова будет подставлено выражение:

```c
int res = x + 2 * y - 3;
```

Видите, как прямолинейно действует макропроцессор? 

Он ничего предварительно не вычисляет и не анализирует, а просто буквально берет то, что мы указываем и подставляет вместо `A` и `B`. 

И в результате можем получить на выходе не то, что ожидали. Поэтому в практике определения макросов-функций каждый параметр заключают в круглые скобки, а потом еще и все выражение. Например, так:

```c
#define SQ_PR(A, B)   ((A) * (B))
```

Тогда последний пример даст корректное выражение:

```c
int res = ((x + 2) * (y - 3));
```

Хотя и такая запись макроса не защищает нас от всех возможных ошибок при его вызове. 

Но это самое разумное, что можно сделать. 

Поэтому макроопределения, строго говоря, вполне могут таить в себе потенциальные ошибки и их использование на практике следует избегать. 

Кстати, это еще одна причина, по которой имена макросов прописывают заглавными буквами. Они нам, как бы говорят: внимание, здесь может скрываться ошибка!

Однако макроопределения прочно вошли в практику программирования на Си и отказаться от них теперь совсем непросто. Да и простые макросы в виде целых чисел, символов или строк вполне удобны и безопасны в использовании.

## Операции # и ##

В заключение этого занятия рассмотрим две операции `#` и `##`, которые иногда используют при определении макросов.

Первая операция `#` возвращает текстовое представление лексемы, например, параметра:

```c
#include <stdio.h>
 
#define SQ_PR(A, B)     ((A) * (B))
#define TEXT(A, B)     "Square of rectangle (" #A ") x (" #B ")\n"
 
int main(void) {
    int res = SQ_PR(2, 3);
    printf(TEXT(x-2, y-3));
 
    return 0;
}
```

После выполнения программы увидим строку:

```
Square of rectangle (x-2) x (y-3)
```

Обратите внимание, программа была успешно скомпилирована и выполнена, несмотря на то, что в ней нет объявлений для `x` и `y`, которые были указаны в макровызове `TEXT(x-2, y-3)`.

И в этом нет никакой магии. 

Как я уже говорил, макропроцессор выполняет обработку текста программы до синтаксического анализатора и до перевода программы непосредственно в машинный код. Поэтому фрагмент `TEXT(x-2, y-3)` заменяется на строку `«Square of rectangle (x-2) x (y-3)\n»`, которая компилируется без каких-либо проблем.

А теперь, как она работает. 

В макро-функции `TEXT(A, B)` у нас два параметра, а затем, идет тело макроса в виде пяти фрагментов строки. Первый фрагмент – это буквально та строка, что прописана. Второй фрагмент `#A` формируется из представления параметра `A`, а он в нашем примере представляет собой выражение `x-2`. И это выражение преобразуется в обычную строку. И далее все остальные фрагменты. Все они соединяются в одну строку и формируют конечный результат макровызова `TEXT(x-2, y-3)`.

Вторая операция `##` работает аналогичным образом, только служит не для склейки строковых представлений, а исходных лексем – самих выражений. Например:

```c
#include <stdio.h>
 
#define SQ_PR(A, B)     ((A) * (B))
#define TEXT(A, B)      "Square of rectangle (" #A ") x (" #B ")\n"
#define X_N(N)          x ## N
 
int main(void) {
    int x1 = 1, x2 = -2, x4 = 10;
    printf("%d\n", X_N(4));
 
    return 0;
}
```

Смотрите, в программе мы объявили три переменных с именами `x1`, `x2` и `x4`. А, затем, выводим значение переменной `x4`, используя макровызов `X_N(4)`. 

Почему это сработало? 

В теле макро-функции `X_N` прописаны две лексемы: `x` и `N`, причем, вместо `N` подставляется переданное выражение `4`. В итоге, вызов `X_N(4)` объединяет в единую лексему `x4` выражение `x` и `4` и это эквивалент того, что мы в программе вместо `X_N(4)` прописали выражение `x4`, которое соответствует ранее объявленной целочисленной переменной. 

Вот принцип работы операции `##` в макроопределениях.

Как я уже говорил, сложные выражения в макроопределениях лучше избегать, т.к. они вполне могут служить источником непредвиденных ошибок. 

Поэтому чаще всего директиву `#define` применяют для задания констант в виде чисел или строк и много реже в виде каких-либо выражений.

Видео по теме [#20. Директива #define для определения макросов-функций. Операции # и ##](https://www.youtube.com/watch?v=d3E1rmOPymo&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения для следующего фрагмента программы:

```c
#include <stdio.h>

#define MUL(X, Y)     X * Y
#define ADD(X, Y)     ((X) + (Y))
#define T_ADD(X, Y)     "Adding two values " # X " and " # Y
#define RES_N(RES)     res_ ## RES

int main(void) {
    int a = 2, b = 5;
    int res_1 = MUL(7, b);
    int res_2 = MUL(a + 2, b - 1);
    int res_3 = ADD(7, b * 2);
    printf(T_ADD(i, j) "\n");
    printf("%d %d %d", RES_N(1), RES_N(2), RES_N(3));

    return 0;
}
```

+ [x] действие макроопределений распространяется только на текущий модуль
+ [x] вызов макро-функции `ADD(X, Y)` всегда будет давать корректные результаты сложения двух числовых выражений
+ [x] операция `#` возвращает текстовое представление лексемы `X`
+ [ ] вызов макро-функции `MUL(7, b)` приведет к не верным результатам вычисления произведения `7 * b`
+ [x] макрос-функция `T_ADD(i <> 2, j == 3)` вернет строку `"Adding two values i <> 2 and j == 3"`
+ [ ] вызов макрос-функции `T_ADD(i <> 2, j == 3)` приведет к синтаксической ошибке
+ [x] операция `##` служит для склейки двух лексем в одну
+ [x] вызов макро-функции `MUL(a + 2, b - 1)` приведет к не верным результатам вычисления произведения `(a+2) * (b-1)`

### Подвиг 2. Продолжите программу. Определите макро-функцию GET_WIDTH так, чтобы она возвращала значение W, если W <= MAX_WIDTH, иначе - значение MAX_WIDTH. Сделайте это с использованием тернарного условного оператора. Вызовите макрос-функцию GET_WIDTH для корректировки значения переменной width. Выведите ее значение в консоль в виде строки (без кавычек):

"width = <значение>"

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/3.8.2

```c
#include <stdio.h>

#define MAX_WIDTH 1280
#define GET_WIDTH(W) (W) > MAX_WIDTH ? MAX_WIDTH : (W)

int main(void) {
    int width;
    scanf("%d", &width);

    width = GET_WIDTH(width);

    printf("width = %d", width);

    return 0;
}
```

### Подвиг 3. Продолжите программу, в которой нужно определить макро-функцию с именем GET_MAX, возвращающую максимальное из двух чисел. Вызовите в функции main макрос GET_MAX следующим образом:

```c
double res = GET_MAX(val_1 + 1, val_2 - 1) / (val_1 + val_2);
```

Выведите в консоль значение переменной `res` с точностью до сотых.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/3.8.3

```c
#include <stdio.h>

#define GET_MAX(A, B) (A > B ? A : B)

int main(void) {
    double val_1, val_2;
    if (scanf("%lf; %lf", &val_1, &val_2) != 2) {
        printf("Input error");
        return 0;
    }

    double res = GET_MAX(val_1 + 1, val_2 - 1) / (val_1 + val_2);

    printf("%.2lf", res);

    return 0;
}
```

### Подвиг 4. Продолжите программу, в которой определена макро-функция с именем GIPOT, вычисляющая длину гипотенузы по двум катетам прямоугольного треугольника. Вызовите макрос GIPOT для величин a+3 и b-2. Результат вызова сохраните в переменной length. Выведите в консоль значение переменной length с точностью до сотых.

Напомню, что длина гипотенузы вычисляется по формуле: 
$c = \sqrt{a^2 + b^2}$.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/3.8.4

```c
#include <math.h>
#include <stdio.h>


#define GIPOT(A, B) sqrt((A) * (A) + (B) * (B))

int main(void) {
    int a, b;
    if (scanf("%d, %d", &a, &b) != 2) {
        printf("Input error");
        return 0;
    }

    double res = GIPOT(a + 3, b - 2);

    printf("%.2lf", res);

    return 0;
}
```

### Подвиг 5. Выберите все верные утверждения, касающиеся следующего фрагмента программы:

```c
#include <stdio.h>

#define CELL_N(N)   cell_ ## N

int main(void) {
    short cell_1 = 1, cell_2 = 2, cell_3 = 3;
    int n = 2;

    int res_1 = CELL_N(1) + 10;
    int res_2 = CELL_N(n) * 2;
    int res_3 = CELL_N(1+2) * 3;

    return 0;
}
```

+ [ ] значение переменной res_3 равно 9
+ [x] значение переменной res_1 равно 11
+ [ ] в место вызова CELL_N(1+2) препроцессор подставляет лексему cell_3
+ [x] значение переменной res_3 равно 7
+ [x] в место вызова CELL_N(1) препроцессор подставляет лексему cell_1
+ [ ] в место вызова CELL_N(n) препроцессор подставляет лексему cell_2
+ [x] вызов CELL_N(n) приводит к ошибке
+ [x] в место вызова CELL_N(1+2) препроцессор подставляет лексему cell_1+2

### Подвиг 6. Продолжите программу, которая читает из входного потока два целых числа, записанных в одну строчку через пробел, в две целочисленные переменные с некоторыми именами: <имя_переменной_1> и <имя_переменной_2>. Затем, с помощью макроопределения MUL_VAR_NAME, используя операцию ##, объявите третью переменную с именем:

`mul_<имя_переменной_1>_<имя_переменной_2>`

и присвойте ей значение произведения двух исходных переменных. Выведите значение переменной

`mul_<имя_переменной_1>_<имя_переменной_2>` в консоль в виде одного целого числа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/3.8.6

```c
#include <stdio.h>

#define MUL_VAR_NAME(A, B) MUL_##A##_##B

int main(void) {
    int a, b;
    if (scanf("%d %d", &a, &b) != 2) {
        printf("Input error");
        return 0;
    }

    int MUL_VAR_NAME(a, b) = a * b;

    printf("%d", MUL_VAR_NAME(a, b));

    return 0;
}
```

### Подвиг 7 (на повторение). Выберите все верные утверждения, касающиеся тернарной условной операции.


+ [x] приоритет тернарной условной операции ниже операций сравнения и арифметических операций
+ [x] данная операция именно операция и может быть использована совместно с другими вычислениями
+ [ ] данная операция не может быть использована совместно с другими вычислениями
+ [x] данная операция работает по принципу if-else (если-иначе) и возвращает либо одно, либо другое вычисленное выражение
+ [ ] приоритет тернарной условной операции выше операций сравнения, но ниже арифметических операций
+ [x] данная операция определяется синтаксисом: <выражение 1> ? <выражение 2> : <выражение 3>
+ [ ] данная операция определяется синтаксисом: ? (<выражение 1>) <выражение 2> : <выражение 3>

### Подвиг 8 (на повторение). Выберите все верные утверждения, касающиеся условного оператора if/else.

+ [x] оператор if можно записать по синтаксису: if(<выражение>) <оператор 1>; else <оператор 2>;
+ [x] условные операторы также называют операторами ветвления
+ [ ] переход на else осуществляется только при истинном условии
+ [ ] оператор if(<выражение>) передает управление к записанному в нем оператору, если <выражение> равно нулю
+ [x] оператор if можно записать по синтаксису: if(<выражение>) <оператор>;
+ [x] переход на else осуществляется только при ложном условии
+ [x] оператор if(<выражение>) передает управление к записанному в нем оператору, если <выражение> не равно нулю
+ [x] по некоторому условию можно выполнить сразу несколько операторов, записав их в фигурных скобках
+ [ ] по некоторому условию можно выполнить строго только один оператор

### Подвиг 9 (на повторение). Установите соответствия между операциями сравнения и их описаниями.

![03](/Good_good_C_C++/img/03_17.PNG)

# 3.9 Директивы #include и условной компиляции

## Директива #include

Пришло время ближе познакомиться с директивой `#include`, которую мы прописывали с самых первых программ. 

Что она делает, я также кратко уже озвучивал и говорил, что как только макропроцессор встречает эту директиву, то вставляет содержимое указанного файла на ее место. В частности, в программе:

```c
#include <stdio.h>
 
int main(void) {
    printf("Hello, World!\n");
    return 0;
}
```

после обработки текстовым препроцессором вместо первой строчки будет подставлено содержимое файла `stdio.h`. В данном примере это нужно, чтобы мы могли использовать библиотечную функцию `printf()` в своей программе. Но в самом файле `stdio.h` нет реализации этой функции, а только ее описание (прототип) в виде:

```c
int printf(const char* format, ...);
```

Кстати, если вместо директивы прописать в явном виде сигнатуру функции `printf()`:

```c
int printf(const char* format, ...);
 
int main(void) {
    printf("Hello, World!\n");
    return 0;
}
```

то программа также откомпилируется и запустится. Однако делать в реальных проектах так не стоит, т.к. детали описания функций могут несколько меняться.

В целом, этого понимания работы директивы `#include` вполне достаточно для программирования на Си. Отмечу только один нюанс. Имя файла после директивы `#include` можно заключать или в угловых скобках, или в кавычках. Например, если ее записать в виде:

```c
#include "stdio.h"
```

то ничего не изменится и программа также успешно откомпилируется. 

Но отличия в работе директивы все же есть. 

Согласно стандарту C99 файл прописанный в угловых скобках сначала ищется в системных каталогах, и если не будет найден, то в текущем рабочем каталоге проекта. Если же прописываются двойные кавычки, то поиск работает наоборот, сначала файл ищется в рабочем каталоге проекта, а затем только в системных каталогах.

В действительности, эти правила не всегда соблюдаются и компиляторы могут реализовывать свою логику поиска файлов. Мало того, в последних стандартах языка Си алгоритм поиска файлов несколько изменен и стал таким неопределенным, что разработчики компиляторов этот пункт часто просто игнорируют. Благо, нам, как программистам на Си важно лишь, что макропроцессор будет искать указанный файл и добавлять его содержимое в наш проект. А правило использования угловых скобок и кавычек в сообществе разработчиков стало таким:
+ Если нужно подключить стандартные файлы, поставляемые с компилятором языка Си, то следует писать угловые скобки.
+ Если же подключаются свои собственные заголовочные файлы, то их имена следует заключать в двойные кавычки.

Например, давайте в нашем проекте создадим подкаталог `tmp` и в нем разместим файл с именем `printf.h` и содержимым:

```c
int printf(const char *format, ...);
```

Затем, подключим этот файл в программе следующим образом:

```c
#include "tmp/printf.h"
 
int main(void) {
    printf("Hello, World!\n");
    return 0;
}
```

Как видите, мы использовали здесь двойные кавычки, т.к. файл `printf.h` наш собственный и, кроме того, указали подкаталог `tmp` относительно рабочего каталога, т.к. файл `printf.h` находится в этом подкаталоге.

## Директивы условной компиляции

Следующий набор директив, который мы разберем, - это, так называемые, директивы условной компиляции:

+ `#if`,
+ `#endif`,
+ `#elif`,
+ `#else`,
+ `#ifdef`,
+ `#ifndef`,
+ `#elifdef`,
+ `#elifnde`f

В основном они используются, чтобы оставить или убрать определенный фрагмент текста программы в зависимости от какого-либо условия. Например, пишется программа, которую предполагается компилировать  с использованием компилятора Си, а также с использованием компилятора С++. Но в этих языках программирования имеются некоторые отличия в используемых конструкциях и часть программного кода должна различаться в зависимости от языка. Так вот, чтобы написать универсальный текст программы и иметь возможность компилировать его как Си, так и С++, можно воспользоваться условными директивами следующим образом:

```c
#define LANG_C
 
#if defined(LANG_C)
#   include <stdio.h>
#else
#   include <iostream>
#endif
 
int main(void) {
         int x=5;
#ifdef LANG_C
         printf("%d\n", x);
#else
         std::cout << x << std::endl;
#endif
 
    return 0;
}
```

Смотрите:
+ вначале определено макроимя `LANG_C` с помощью директивы `#define`.
+ Затем, прописана директива `#if`, в которой проверяется условие:
    + определено ли макроимя LANG_C в текущем модуле.
+ Если это так (как в нашем примере), то макропроцессор оставляет в программе все, что записано после этой директивы либо до следующей условной директивы, либо до директивы `#endif`. 

В приведенном примере, остается строчка `#   include <stdio.h>` и удаляется строка `#   include <iostream>`. 

Соответственно, директива `#include` также, затем, обрабатывается макропроцессором. В итоге, после обработки, у нас получается следующий текст программы:

```c
#   include <stdio.h>
 
int main(void) {
         int x=5;
         printf("%d\n", x);
 
    return 0;
}
```

Разумеется, директива `#include` здесь также впоследствии преобразуется макропроцессором. А директива `#ifdef` – это сокращенный вариант записи конструкции `#if defined`.

По сути, директивы условной компиляции `#if`, `#else`, `#endif` работают подобно условным операторам `if-else`, о которых мы с вами уже говорили. 

Но, конечно же, есть и отличия.
+ Первый важный момент: в условиях директив можно использовать исключительно целочисленные литералы и макроимена. С этими элементами можно выполнять все булевы операции сравнения:<br>
`==`, `!=`, `<`, `>`, `<=`, `>=`<br>
логические связки:<br>
`&&`, `||`, `!`<br>
все бинарные арифметические и битовые операции:<br>
`+`, `-`, `*`, `/`, `%`, `&`, `|`, `^`<br>
и применять оператор `defined`, которые возвращает `1`, если указанное макроимя существует и `0` – в противном случае. <br>
Есть еще несколько экзотических конструкций, вроде условной тернарной операции, которые допустимо прописывать в условиях директив, но в основном используются те операции, что перечислены выше. Обратите внимание, никаких переменных, функций и прочих конструкций, значение которых определяется в процессе работы программы, здесь применять нельзя.

+ Второй важный момент. Директивы условной компиляции не образуют своих собственных внутренних блоков. Поэтому для указания того, что попадает внутрь таких директив, в конце обязательно следует прописать директиву `#endif` – метку, означающую конец текущей директивы условной компиляции.
+ Третий важный момент. Директивы препроцессора анализируют программу как текст (на уровне лексем). Это означает, что они не учитывают области видимости: локальные, глобальные и т.п. Поэтому все директивы принято записывать с самого начала строки (с левого края). В частности, именно поэтому символ `#` у директив `include` записан на одном уровне с другими директивами, т.к. никакого реального вложения здесь нет, и это мы подчеркиваем оформлением. То же самое при записи директив внутри функции `main()`. Для всех этих директив функции не имеют никакого значения – это просто текст. Поэтому все они прописаны с самого начала строки.

## Использование директив условной компиляции в заголовочных файлах
Если мы посмотрим на содержимое какого-либо стандартного заголовочного файла, например, того же `stdio.h`, то вначале увидим такие строчки:

```c
#ifndef _INC_STDIO
#define _INC_STDIO

// А ниже обязательно будет записана директива:

#endif
```

С какой целью эти директивы здесь используются? На самом деле это защита от повторного включения содержимого заголовочного файла в текущий модуль. Например, если мы в программе дважды напишем строчки:

```c
#include <stdio.h>
#include <stdio.h>
```

То программа скомпилируется и отработает без ошибок, так как содержимое файла `stdio.h` было добавлено макропроцессором в текущий модуль только один раз. Почему так произошло? Смотрите. Когда файл `stdio.h` подключался первый раз, то макроимя `_INC_STDIO` отсутствовало и условие директивы `#ifndef` оказалось истинным, так как `#ifndef` – это аналог `#if !defined`. Раз условие истинно, то все, что определено до директивы `#endif` включается в файл, в том числе и директива `#define _INC_STDIO`, которая определяет макроимя `_INC_STDIO`. Теперь оно существует в текущем модуле. Это значит, при повторном включении файла `stdio.h` условие директивы `#ifndef` окажется ложным и фрагмент дублироваться не будет.

Вот так просто и элегантно можно с помощью директив условной компиляции создавать защиту от повторных включений заголовочных файлов. И это очень важно в современной практике программирования, когда проект содержит десятки и сотни файлов и они подключаются друг к другу. Дублирования здесь избежать практически невозможно.

Я думаю, в целом понятна работа директив условной компиляции. В заключение этого занятия приведу расшифровку всех этих директив:

Директива | Описание
-|-
`#if` | Проверка произвольного условия.
`#else` | Определение ветки «иначе».
`#endif` | Директива (метка) завершения фрагмента для условия.
`#ifdef` | Сокращение от `if defined. Позволяет делать проверку на наличие макроимени в текущем модуле.`
`#ifndef` | Сокращение от `if !defined`. Позволяет делать проверку на отсутствие макроимени в текущем модуле.
`#elif` | Сокращение от `else if`. Позволяет делать проверку по ветке «иначе».
`#elifdef` | Сокращение от `else if defined`. Для реализации проверки наличия макроимени по ветке «иначе».
`#elifndef` | Сокращение от `else if !defined`. Для реализации проверки отсутствия макроимени по ветке «иначе».

В целом, все они работают аналогичным образом и должны быть теперь вам понятны.

Видео по теме [#21. Директивы #include и условной компиляции](https://www.youtube.com/watch?v=GGl4mS5nUGg&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Выберите все верные утверждения, касающиеся директивы `#include`.

+ [x] данная директива может быть записана в виде: #include <math.h>
+ [ ] если подключается файл func.h, расположенный в подкаталоге inc, то имеем запись вида: #include <inc.func.h>
+ [x] если подключается файл func.h, расположенный в подкаталоге inc, то имеем запись вида: #include "inc/func.h"
+ [ ] данная директива может быть записана в виде: #include math.h
+ [x] данная директива может быть записана в виде: #include "math.h"
+ [x] препроцессор на место записи директивы #include вставляет содержимое указанного файла

### Подвиг 2. Установите соответствия между директивами условной компиляции и их описаниями.

![03](/Good_good_C_C++/img/03_18.PNG)

### Подвиг 3. В программу ниже добавьте директивы условной компиляции так, чтобы при наличии макроимени PERIMETR_CALC вычислялся и выводился периметр, а при отсутствии макроимени PERIMETR_CALC вычислялась и выводилась площадь.

P.S. Существующие в программе операторы не удалять.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/3.9.3

```c
#include <stdio.h>

#define PERIMETR_CALC

int main(void) {
    int a, b;
    if (scanf("%d, %d", &a, &b) != 2) {
        printf("Input error.");
        return 0;
    }

#ifndef PERIMETR_CALC
    int res = a * b;
    printf("%d", res);
#else
    int res = 2 * (a + b);
    printf("%d", res);
#endif

    return 0;
}
```

### Подвиг 4. Пусть имеется следующее начало текста программы:

```c
const int max_size = 5;

#define SIZE    1
#define IS_CPP
```

Отметьте все корректно работающие записи директив условной компиляции.

+ [ ] #if max_size > 1 ... #endif
+ [ ] #if IS_CPP ... #endif
+ [ ] #ifdef(IS_CPP) ... #endif
+ [x] #if SIZE > 0 ... #endif
+ [x] #if SIZE > 10 - 8 ... #endif
+ [x] #if(SIZE == 1) ... #endif
+ [x] #if SIZE >= 0 && SIZE <= 10 ... #endif
+ [x] #if defined(SIZE) ... #endif
+ [x] #ifdef IS_CPP ... #endif
+ [x] #ifndef IS_CPP ... #endif
+ [x] #if !defined(SIZE) ... #endif

### Подвиг 5. Запишите название директивы условной компиляции, которая срабатывает без каких-либо проверок при ложном условии в директиве #if.

Запись директивы начинать с символа #.

`#else`

### Подвиг 6. Запишите название директивы условной компиляции, к которой переходит управление при ложном условии в директиве #if и дополнительно проверяется произвольное (общее) условие.

Запись директивы начинать с символа #.

`#elif`

### Подвиг 7 (на повторение). Отметьте все верные (рабочие) макроопределения фрагмента программы языка Си стандарта C99.

+ [x] #define PHELLO2 printf("Hello!\n");
+ [x] # define SPACE ' '
+ [x] #define PHELLO printf("Hello!\n")
+ [ ] #define NEW_DEFINE #define A 2
+ [x] #define LESSON 32
+ [x] # define other_lesson LESSON + 1
+ [ ] define STUDY "C/C++"

### Подвиг 8 (на повторение). Установите соответствия между математическими функциями округления и их описаниями.

![03](/Good_good_C_C++/img/03_19.PNG)