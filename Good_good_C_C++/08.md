# 8. Работа с файлами

# 8.1 Файловые функции: fopen(), fclose(), fgetc(), fputc()

## Файловые функции

С этого занятия мы начинаем большую тему по работе с файлами. Думаю, не надо объяснять, что такое файлы, где они располагаются и для чего нужны. Было бы странно видеть человека, который смотрит курс по языку Си и не знает этих базовых вещей. Также, я полагаю, что вы все умеете прописывать абсолютные и относительные пути к файлам. 

Вот здесь, наверное, надо сказать пару слов. 

Предположим, у нас с вами имеется следующая структура каталогов и файлов:

![08](/Good_good_C_C++/img/08_01.jpg)

с рабочим каталогом "d:/app/". Тогда относительные и абсолютные пути можно к разным файлам можно прописывать следующим образом:

Относительные пути | Абсолютные пути
-|-
`my_file.txt` | `d:\\app\\my_file.txt`<br>или<br>`d:/app/my_file.txt`
`images/img.png` | `d:/app/images/img.png`
`../out.txt` | `d:/out.txt`
`../parent/prt.dat` | `d:/parent/prt.dat`

Варианты

`d:\\app\\my_file.txt` и `d:/app/my_file.txt`

представляют собой абсолютный путь к файлу, то есть, полный путь, начиная с указания диска. 

Причем, обычно используют слеш в качестве разделителя: так короче писать и такой путь будет корректно восприниматься как под ОС Windows, так и Linux.

Для доступа к файлу `out.txt` пути могут быть записаны как:

`../out.txt`<br>
`d:/out.txt`<br>

Обратите внимание, здесь две точки означают переход к родительскому каталогу, то есть, выход из каталога app на один уровень вверх. И, наконец, для доступа к файлу `prt.dat` пути пишутся так:

`../parent/prt.dat`<br>
`d:/parent/prt.dat`<br>

Если вам все это кажется непонятным, почитайте об этом подробнее, а я вернусь непосредственно к языку Си.

## Функции fopen() и fclose()

Философия работы с файлами заключается в открытии потока, связанного с тем или иным файлом. Затем, через открытый поток выполняется чтение или запись информации в файл. Что это за поток, какую роль он играет и как его открыть?

Начну с последнего. 

Для открытия потока, связанного с файлом, используется функция:

```c
FILE* fopen(const char* path, const char* mode);
```

+ Первый параметр `path` – это путь к файлу;
+ второй параметр `mode` – режим доступа к файлу. 

Как прописывать путь, мы с вами уже знаем, а режимы доступа могут быть следующими:

Режим | Описание
-|-
`r` | Открытие текстового файла только на чтение.
`w` | Открытие текстового файла только на запись.<br> Если файл не существует, то он создается.<br> Если существует, то все его прежнее содержимое удаляется.
`a` | Открытие текстового файла на дозапись (новые данные добавляются в конец файла).<br> Если файл не существует, то он создается.
`r+` | Открытие текстового файла для чтения и записи одновременно.
`w+` | Открытие текстового файла для чтения и записи.<br> Если файл не существует, то он создается.<br> Если существовал, то все его прежнее содержимое удаляется.
`a+` | Открытие текстового файла для чтения и записи.<br> Добавлять данные можно только после имеющегося содержимого.<br> Читать можно все данные.<br> Если файл не существует, то он создается.

Все эти режимы для работы именно с текстовыми файлами. 

Есть еще набор режимов для бинарного доступа файлам:

`rb`, `wb`, `ab`, `rb+`, `wb+`, `ab+`

То есть, здесь просто добавляется буква `b`. 

В ОС Unix текстовый режим и бинарный работают одинаково. 

Но в ОС Windows по-разному. Что это за режим и как с ним работать мы будем говорить позже.

Функция `fopen()` возвращает указатель типа `FILE` на открытый поток, либо значение `NULL`, если файл по каким-либо причинам открыть не удалось. 

Надо сказать, ошибки открытия файла встречаются очень часто. 

Например, мы пытаемся открыть на чтение не существующий файл. 

Тогда функция `fopen()` вернет значение `NULL`. Поэтому в программе нужно обязательно делать проверку на корректность открытия файлового потока и только после этого с ним работать.

Теперь, что из себя представляет файловый поток. 

Когда отрабатывает функция `fopen()` она делает системный запрос к ОС на открытие указанного файла. 

ОС выполняет необходимые действия и в случае успеха возвращает дескриптор файлового потока. 

Дополнительно функция `fopen()` создает входной буфер, при чтении данных из файла, или выходной, при записи данных в файл, или на чтение и записи одновременно:

![08](/Good_good_C_C++/img/08_02.jpg)

Зачем нужен этот буфер? 

Дело в том, что данные из файла читаются не по байту, а сразу порцией байт и помещаются во входной буфер. 

И то же самое с записью. 

Данные сначала попадают в выходной буфер и при достижении определенного размера, переносятся в файл. 

Но все же, почему бы данные сразу не читать и записывать в файлы? 

Чтобы это делать наша программа каждый раз должна обращаться к ОС, то есть выполнять системные вызовы, а это не быстрый процесс. 

Да и, к тому же, дополнительная нагрузка на ОС. Поэтому, для ускорения работы с файлами, как правило, формируются входные и выходные буферы и данные проходят через них.

В целом вся работа с получением дескриптора на файловый поток и работа с буферов скрыта от программиста. 

Все, что от нас требуется, это вызвать сначала функцию `fopen()`, чтобы получить указатель на файловый поток, а затем, закрыть его с помощью функции:

```c
int fclose(FILE* fp);
```

Вызывать функцию `fclose()` строго обязательно после успешного открытия файла. 
+ Она, во-первых, помещает все данные в файл из выходного буфера, если они там есть и,
+ во-вторых, освобождает все ресурсы, связанные с открытым файловым потоком, в том числе, память, занимаемую буфером, и формирует системный вызов для освобождения файлового дескриптора.

Данная функция возвращает `0`, если закрытие файла прошло успешно и `-1`, если возникли какие-либо ошибки. 

Правда, обработать эти ошибки мы все равно вряд ли сможем, т.к. они обычно связаны с системными вызовами, а это уже зона действия ОС.

Давайте для примера, посмотрим, как в программе можно открыть файл на запись и закрыть его:

```c
#include <stdio.h>
 
int main(void) {
    FILE* fp = fopen("my_file.txt", "w");
    if(fp == NULL)
        return 1;
 
    fclose(fp);
 
    return 0;
}
```

Если все прошло успешно, то в каталоге рядом с файлом `lessons.exe` появится еще один пустой файл с именем `my_file.txt`.

## Функции fgetc() и fputc()

Давайте теперь посмотрим, как можно записывать данные в файл и считывать их оттуда. В самом простом случае можно воспользоваться следующими функциями:

```c
int fgetc(FILE* stream);
int fputc(int ch, FILE* stream);
```

Первая функция `fgetc()` позволяет побайтового читать данные из указанного потока `stream`, а вторая `fputc()` побайтно записывает данные в поток `stream`. 

Причем, в качестве потоков могут быть как файловые, так и стандартные: `stdin`, `stdout`. Вообще эти функции работают аналогично функциям `getchar()` и `putchar()`, о которых мы с вами уже говорили.

Давайте с помощью функции `fputc()` запишем в файл небольшую строку:

```c
#include <stdio.h>
 
int main(void) {
    char str[] = "Function fputc() in action.";
 
    FILE* fp = fopen("my_file.txt", "w");
    if(fp == NULL)
        return 1;
 
    for(int i = 0; str[i]; ++i)
        fputc(str[i], fp);
 
    fclose(fp);
 
    return 0;
}
```

Если после выполнения программы открыть файл `my_file.txt`, то увидим в нем искомую строку.

Очень частая ошибка, когда начинающие программисты забывают закрыть файл, в который производилась запись данных, и обнаруживают, что он либо пустой, либо содержит не полные данные.

Все дело в том, что данные не сразу попадают физически в файл, а сначала сохраняются в выходном буфере и только при достижении определенного объема все данные разом заносятся в файл. 

Поэтому, если в буфере имеется какая-либо несохраненная информация, то при закрытии файла, она автоматически переносится в файл и данные не пропадают. 

Если же файл не закрыть, то возможна потеря части информации, которая так осталась в буфере. 

В моем случае компилятор грамотно переводит программу и при ее завершении все данные из буфера сохраняются в файле. 

Но срабатывает это не всегда.  

Давайте я это продемонстрирую на примере, когда данные записываются в файл, а потом тут же, без его закрытия, читаются:

```c
#include <stdio.h>
 
int main(void) {
    char str[] = "Function fputc() in action.";
    char buff[100];
 
    FILE* fp = fopen("my_file.txt", "w");
    if(fp == NULL)
        return 1;
 
    for(int i = 0; str[i]; ++i)
        fputc(str[i], fp);
 
    FILE* in = fopen("my_file.txt", "r");
    if(in == NULL) {
        puts("File open error");
        return 2;
    }
 
    char ch;
    int i = 0;
    while((ch = fgetc(in)) != EOF)
        buff[i++] = ch;
    buff[i] = '\0';
    puts(buff);
 
    fclose(fp);
    return 0;
}
```
Если сейчас запустить программу, то на экране будет высвечена пустая строка, так как файл `my_file.txt` пустой. Но, если его закрыть, прежде чем читать из него данные, то строка будет успешно прочитана.

Видео по теме [#57. Файловые функции: fopen(), fclose(), fgetc(), fputc()](https://www.youtube.com/watch?v=eh0dpF_hCmI&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Установите соответствия между функциями и их описаниями.

![08](/Good_good_C_C++/img/08_03.PNG)

### Подвиг 2. Установите соответствия между режимами доступа к файлу и их описаниями.

![08](/Good_good_C_C++/img/08_04.PNG)

### Подвиг 3. Выберите все верные утверждения, касающиеся файловых потоков.

+ [x] после работы с файловым потоком его следует закрыть функцией fclose
+ [x] новый файловый поток открывается с помощью функции fopen
+ [x] каждый файловый поток (по умолчанию) имеет буфер приема или передачи данных
+ [x] функция fclose освобождает все ресурсы, связанные с открытым файловым потоком
+ [x] для работы с файловыми функциями необходимо подключить файл stdio.h
+ [x] на файловый поток ссылается указатель специального типа FILE

### Подвиг 4. Напишите программу, которая открывает файл с именем "test.dat" на чтение. Если файл открыт успешно, то его следует закрыть и функция main в этом случае возвращает 0. Иначе, при ошибке открытия файла, функция main должна вернуть значение 2.

P. S. В консоль ничего выводить не нужно.

```c
#include <stdio.h>

int main(void) {
    FILE* fp = fopen("test.dat", "r");
    if (fp == NULL) return 2;

    fclose(fp);

    return 0;
}
```

### Подвиг 5. Выберите все верные утверждения, касающиеся следующей программы:

```c
#include <stdio.h>

int main(void) {
    FILE* fp = fopen("test_file.txt", "r");
    if (fp == NULL) return 1;

    int data;
    while ((data = fgetc(fp)) != EOF) printf("%c ", data);

    fclose(fp);

    return 0;
}
```


+ [x] перед завершением функции main выполняется закрытие файлового потока fp
+ [x] если файл не может быть открыт, то функция main завершает свою работу с кодом 1
+ [ ] в цикле while читаются данные из файлового потока fp по четыре байта за раз (размер типа int), пока не будет достигнут конец файла
+ [x] выполняется открытие на чтение файлового потока для файла "test_file.txt"
+ [ ] выполняется открытие на запись файлового потока для файла "test_file.txt"
+ [x] в цикле while побайтно читаются данные из файлового потока fp, пока не будет достигнут конец файла

### Подвиг 6. Выберите все верные утверждения, касающиеся следующей программы:

```c
#include <stdio.h>

int main(void) {
    FILE* fp = fopen("test_file.txt", "w");
    if(fp == NULL)
        return 1;

    int data[] = {1, 2, 3, 0, -1, -100};
    for(int i = 0; i < sizeof(data) / sizeof(*data); ++i)
        fputc(data[i], fp);

    fclose(fp);

    return 0;
}
```


+ [x] выполняется открытие на запись файлового потока для файла "test_file.txt"
+ [x] функция fputc на каждой итерации цикла заносит в файловый поток fp символы (байты) с соответствующими кодами (1, 2, ...)
+ [ ] в результате успешной работы программы в файле test_file.txt увидим символы '1', '2', '3' и так далее (идущие подряд друг за другом)
+ [ ] функция fputc на каждой итерации цикла читает очередной байт из потока fp
+ [ ] выполняется открытие на чтение файлового потока для файла "test_file.txt"

### Подвиг 7. Имеется следующая программа:

```c
#include <stdio.h>

int main(void) {
    FILE* fp = fopen("test_file.txt", "r");
    if(fp == NULL)
        return 1;

    char byte;

    // здесь предполагается вызвать функцию fgetc

    fclose(fp);

    return 0;
}
```

Запишите ниже корректный вызов функции fgetc для чтения очередных данных в переменную byte из потока fp.

```c
byte = fgetc(fp);
```

```c
#include <stdio.h>

int main(void) {
    FILE* fp = fopen("test_file.txt", "r");
    if (fp == NULL) return 1;

    char byte;
    char buff[100];
    int i = 0;

    while ((byte = fgetc(fp)) != EOF) buff[i++] = byte;
    buff[i] = '\0';
    puts(buff);

    fclose(fp);

    return 0;
}
```

### Подвиг 8. Имеется следующая программа:

```c
#include <stdio.h>

int main(void) {
    FILE* fp = fopen("test_file.txt", "a");
    if(fp == NULL)
        return 1;

    char byte = 'B';

    // здесь предполагается вызвать функцию fputc

    fclose(fp);

    return 0;
}
```

Запишите ниже корректный вызов функции fputc для записи данных из переменной byte в поток fp.

```c
fputc(byte, fp);
```

```c
#include <stdio.h>

int main(void) {
    FILE* fp = fopen("test_file.txt", "a");
    if (fp == NULL) return 1;

    char byte = 'B';

    fputc(byte, fp);

    fclose(fp);

    return 0;
}
```

### Подвиг 9 (на повторение). Выберите все верные утверждения, касающиеся ключевого слова static.

+ [x] внешнее связывание - это когда переменная или функция доступна и за пределами текущего модуля
+ [x] внутреннее связывание - это когда переменная или функция имеет область видимости только в пределах текущего модуля
+ [ ] ключевое слово static у функций позволяет объявлять статические функции без ограничения области их видимости
+ [x] ключевое слово static у функций ограничивает их область видимости текущим модулем
+ [ ] внешнее связывание - это когда переменная или функция использует другие внешние переменные или функции
+ [ ] внутреннее связывание - это когда переменная или функция может быть использована в других функциях
+ [x] ключевое слово static у глобальных переменных ограничивает их область видимости текущим модулем

### Подвиг 10 (на повторение). Выберите все верные утверждения для функций malloc и free.

+ [x] если запрашиваемый объем памяти не может быть выделен, то функция malloc возвращает значение NULL
+ [ ] для использования функций работы с памятью нужно подключить файл stdio.h
+ [x] для использования функций работы с памятью нужно подключить файл stdlib.h
+ [x] функция malloc служит для выделения указанного числа байт непрерывного блока в памяти устройства
+ [x] функция free служит для освобождения ранее выделенного блока памяти устройства
+ [x] если запрашиваемый объем памяти успешно выделяется, то функция malloc возвращает адрес начала выделенного блока памяти

# 8.2 Функции perror(), fseek() и ftell()

## Функции perror()

На прошлом занятии мы с вами получили программу, которая побайтно читает данные из файла в массив `buff`:

```c
#include <stdio.h>
 
int main(void) {
    char buff[100];
 
    FILE* in = fopen("my_file.txt", "r");
    if(in == NULL) {
        puts("File open error");
        return 1;
    }
 
    char ch;
    int i = 0;
    while((ch = fgetc(in)) != EOF)
        buff[i++] = ch;
    buff[i] = '\0';
 
    puts(buff);
 
    fclose(in);
    return 0;
}
```

В случае, если функция `fopen()` не может открыть поток для работы с файлом, выводится сообщение `"File open error"`. 

Это достаточно общая фраза, не сообщающая о конкретной ошибке. 

Как бы можно было бы уточнить ее? 

Для этого в языке Си определен специальный макрос `errno`. Чтобы использовать его в своей программе нужно подключить заголовочный файл `errno.h`:

```c
#include <errno.h>
```

Что это за макрос? 

Он возвращает различные коды ошибок при их возникновении в результате системных вызовов (любых системных вызовов), в том числе и тех, что связаны с файлами. 

Значения всех этих кодов можно посмотреть в соответствующей литературе, я приводить их не буду, в этом нет особого смысла, и вы сейчас узнаете почему. 

Но для начала, давайте просто выведем код ошибки при попытке открыть несуществующий файл:

```c
    FILE* in = fopen("my_file2.txt", "r");
    if(in == NULL) {
        printf("errno: %d\n", errno);
        return 1;
    }
```

После запуска программы, увидим:

```
errno: 2
```

То есть, код ошибки системного вызова, связанного с открытием не существующего файла, равен `2`. 

Однако число выглядит совсем не информативно. 

Хотелось бы получить сообщение, расшифровывающее этот код. 

Для этого можно воспользоваться специальной функцией, которая называется:

```c
void perror(const char* );
```

и определена в заголовочном файле `stdio.h`. Давайте воспользуемся ей в нашей программе:

```c
    FILE* in = fopen("my_file2.txt", "r");
    if(in == NULL) {
        printf("errno: %d\n", errno);
        perror("my_file2.txt");
        return 1;
    }
```

Увидим сообщения:

```
my_file2.txt: No such file or directory
errno: 2
```

То есть, код ошибки `2` означает, что файл не был найден. 

Теперь все предельно ясно. 

Мало того, функция `perror()` выводит сообщения в стандартный поток ошибок `stderr`, а не в поток `stdout`. 

По умолчанию, оба потока связаны с монитором, поэтому особых отличий в выводе информации мы не наблюдаем.

## Файловые указатели позиций

Давайте теперь внимательнее посмотрим на фрагмент нашей программы:

```c
    while((ch = fgetc(in)) != EOF)
        buff[i++] = ch;
```

и зададимся вопросом: откуда функция `fgetc()` знает, какой следующий символ из файла читать? 

Мы же этого нигде не указываем, и при этом она прочитывает все символы из файла от начала и до конца. 

Вся магия в том, что указатель `in` на файловый поток содержит в себе специальный указатель позиции, который указывает на очередной для считывания байт. 

И после его чтения, автоматически переходит к следующему символу. Благодаря этому функция `fgetc()` последовательно читает байт за байтом из файла.

Такой же указатель имеется и для потока записи данных в файл. 

Очередная порция записывается, начиная с места, на которое он указывает. 

Причем, эти два указателя работают совершенно независимо друг от друга.

При желании мы можем управлять указателем файла:
+ получать значение его позиции и
+ устанавливать в любую доступную позицию. 

Для этого в языке Си имеются следующие две функции:

```c
int fseek(FILE* stream, long offset, int whence);
long ftell(FILE* stream);
```


Первая функция `fseek()` позволяет задавать файловую позицию, а вторая `ftell()` – получать значение файловой позиции.

Параметр `offset` функции `fseek()` определяет смещение файловой позиции относительно места, указанного в следующем параметре `whence`, который может принимать следующие значения в виде предопределенных констант:
+ `SEEK_SET` – от начала файла;
+ `SEEK_CUR` – от текущей позиции;
+ `SEEK_END` – от конца файла.

Причем, если мы позиционируемся с начала файла, то `offset` может быть только положительным. Для двух других флагов и положительным и отрицательным.

Давайте в качестве примера прочитаем содержимое файла `my_file.txt` в обратном порядке:

```c
#include <stdio.h>
 
int main(void) {
    FILE* fp = fopen("my_file.txt", "r");
    if(fp == NULL) {
        perror("my_file2.txt");
        return 1;
    }
 
    fseek(fp, 0, SEEK_END);
    int length = ftell(fp);
    
    printf("Length of the string: %d\n", length);
 
         for (int i = 1; i <= length; ++i) {
                   fseek(fp, -i, SEEK_END);
                   putchar(fgetc(fp));
         }
    
         putchar('\n');
 
    fclose(fp);
    return 0;
}
```

После открытия файлового потока, мы устанавливаем его указатель на самую последнюю позицию путем вызова функции:

```c
fseek(fp, 0, SEEK_END);
```

и, затем, читаем ее значение:

```c
int length = ftell(fp);
```

В результате, переменная `length` содержит число байтов, которые требуется прочитать из файла. Само чтение происходит в цикле `for`, устанавливая каждый раз нужную позицию файла:

```c
fseek(fp, -i, SEEK_END);
```

и читая символ с выводом его на экран:

```c
putchar(fgetc(fp));
```

Как видите, все достаточно просто. После запуска программы увидим следующий результат ее работы:

```c
Length of the string: 27
.noitca ni )(ctupf noitcnuF
```

Вот пример того, как можно осуществлять произвольный доступ к файлу и считывать из него информацию в произвольном порядке.

В заключение этого занятия приведу еще один пример использования функции `fseek()`. Предположим, мы посимвольно записываем информацию в файл следующим образом:

```c
#include <stdio.h>
 
int main(void) {
    char str[] = "Function fputc() in action.";
 
    FILE* fp = fopen("my_file.txt", "w");
    if(fp == NULL) {
        perror("my_file2.txt");
        return 1;
    }
 
    for(int i = 0; str[i]; ++i) {
        fseek(fp, 0, SEEK_SET);
        fputc(str[i], fp);
    }
 
    fclose(fp);
    return 0;
}
```

На каждой итерации цикла позиция файла устанавливается в его начало. В результате, файл будет содержать только один последний символ, так как запись строки производилась в одну и ту же позицию.

Видео по теме [#58. Функции perror(), fseek() и ftell()](https://www.youtube.com/watch?v=9iFKX65NrC4&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Установите соответствия между функциями и их описаниями.

![05](/Good_good_C_C++/img/08_05.PNG)

### Подвиг 2. Выберите все верные утверждения, касающиеся потоков ввода/вывода

+ [x] предопределенное значение EOF означает конец данных в файловом потоке
+ [ ] для использования макроса errno необходимо подключить заголовочный файл stdio.h
+ [x] макрос errno содержит код последней возникшей ошибки при работе с потоками ввода/вывода
+ [x] для использования макроса errno необходимо подключить заголовочный файл errno.h
+ [x] функции perror, fseek, ftell определены в заголовочном файле stdio.h
+ [ ] функции perror, fseek, ftell определены в заголовочном файле stdfile.h

### Подвиг 3. Продолжите программу. С помощью функции fgetc необходимо читать данные из потока fp в переменную byte, пока не будет достигнут конец данных. На каждой итерации необходимо выводить в консоль в одну строчку через пробел следующие данные:

<числовое значение byte>:<номер текущей файловой позиции>

P. S. Здесь в Stepik номер позиции возвращается -1, но для реальных файловых потоков он будет меняться от 1 и далее.

```c
#include <stdio.h>

int main(void) {
    char byte;
    FILE* fp = stdin;  // стандартный поток для чтения данных

    while ((byte = fgetc(fp)) != EOF) {
        printf("%d: %d ", (int)byte, (int)ftell(fp));
    }
    
    // fclose(fp); для стандартного потока делать не нужно

    return 0;
}
```

### Подвиг 4. Установите соответствия между константами и их описаниями.

![08](/Good_good_C_C++/img/08_06.PNG)

### Подвиг 5. Запишите функцию fseek, которая устанавливает файловую позицию в предпоследнюю позицию потока fp.

```c
fseek(fp, -1, SEEK_END);
```

### Подвиг 6. Запишите функцию fseek, которая устанавливает файловую позицию на вторую позицию потока fp. Считать, что первая позиция начинается с нуля.

```c
fseek(fp, 1, SEEK_SET);
```

### Подвиг 7 (на повторение). Установите соответствия между режимами доступа к файлу и их описаниями.

![08](/Good_good_C_C++/img/08_07.PNG)

### Подвиг 8 (на повторение). Установите соответствия между математическими степенными функциями и их описаниями.

![08](/Good_good_C_C++/img/08_08.PNG)

### Подвиг 9 (на повторение). Установите соответствия между математическими функциями округления и их описаниями.

![08](/Good_good_C_C++/img/08_09.PNG)

# 8.3 Функции fputs(), fgets() и fprintf(), fscanf()

## Функции fputs(), fgets()

На этом занятии речь пойдет о функциях записи и считывания строк. Начнем с функций:

```c
int fputs(const char* s, FILE* stream);
char* fgets(char* s, int size, FILE* stream);
```

определенных в заголовочном файле `stdio.h`. Первая функция `fputs()` служит для записи строк, а вторая `fgets()` для их считывания. 

Функция `fputs()` возвращает `-1` в случае ошибки и другое значение при успешной записи данных. 

Обычно другим значением является число записанных символов, но стандартом языка Си это не оговорено. 

Функция `fgets()` возвращает переданный указатель s или `NULL`, если не удалось прочитать ни одного значения.

Давайте вначале посмотрим, как можно воспользоваться функцией `fputs()`. 

Предположим, что мы бы хотели сохранить в файле следующие строчки стихотворения:

```
– Скажи-ка, дядя, ведь не даром
Я Python, Си учил с каналом
Балакирев что раздавал?
```

Сделать это можно следующим образом:

```c
#include <stdio.h>
 
int main(void) {
    const char* str[] = {
        "- Скажи-ка, дядя, ведь не даром",
        "Я Python, Си учил с каналом",
        "Балакирев что раздавал?"
    };
 
    FILE* fp = fopen("my_file.txt", "w");
    if(fp == NULL) {
        perror("my_file.txt");
        return 1;
    }
 
    for(int i = 0;i < sizeof(str)/sizeof(*str); ++i)
        fputs(str[i], fp);
 
    fclose(fp);
    return 0;
}
```

Мы здесь в цикле перебираем все строки и с помощью функции `fputs()` записываем их целиком в файл. В результате получим следующее содержимое:

```
- Скажи-ка, дядя, ведь не даромЯ Python, Си учил с каналомБалакирев что раздавал?
```

Как видите, все выстроилось в одну строчку без переноса строк. И это не удивительно, так как функция `fputs()` записывает данные так, как они есть, пока не встретит символ конца строки `\0`.

Никаких переносов она автоматом не добавляет. 

Поэтому, если мы хотим их иметь в выходном файле, нужно об этом позаботиться самостоятельно и записать цикл, например, так:

```c
    for(int i = 0;i < sizeof(str)/sizeof(*str); ++i) {
        fputs(str[i], fp);
        fputc('\n', fp);
    }
```

Получим ожидаемый вид текстового файла.

Теперь давайте прочитаем все строки из этого файла и выведем их на экран:

```c
#include <stdio.h>

int main(void) {
    char buffer[100];

    FILE* fp = fopen("my_file.txt", "r");
    if (fp == NULL) {
        perror("my_file.txt");
        return 1;
    }

    while (fgets(buffer, sizeof(buffer), fp)) puts(buffer);

    fclose(fp);
    return 0;
}
```
Мы открываем файл на чтение и в цикле выполняем функцию `fgets()`, пока она возвращает значение отличное от `NULL`, то есть, цикл `while` будет продолжаться, пока данные в файле присутствуют. На каждой итерации читается строка из файла. При этом признаком конца строки является символ переноса `\n`, либо достижение конца файла. 

Функция `fgets()` максимум читает:

```c
sizeof(buffer) - 1
```

символ так, чтобы оставалось место для последнего символа конца строки `\0`. Этот символ функция `fgets()` всегда автоматически добавляет после последнего прочитанного значения. Поэтому в `buffer` формируется корректная строка языка Си.

После выполнения программы увидим следующий результат:

```
- Скажи-ка, дядя, ведь не даром

Я Python, Си учил с каналом

Балакирев что раздавал?
```

Откуда взялись пустые строки? Дело в том, что символ переноса строки, прочитанный из файла, попадает в строку `buffer`. Функция `fgets()` ничего не убирает. 

А функция `puts()` при выводе строк добавляет еще один символ переноса строки. Получается два переноса, которые мы наблюдаем в виде пустых строк. 

По идее, если мы читаем строки из файла, то нам следовало бы убирать символ переноса. В самом простом варианте сделать это можно с помощью строковой функции `strchr()` следующим образом:

```c
    while(fgets(buffer, sizeof(buffer), fp)) {
        char *ptr = strchr(buffer, '\n');
        if(ptr != NULL)
            *ptr = '\0';
 
        puts(buffer);
    }
```

Я напомню, что функция `strchr()` возвращает указатель на найденный символ, либо значение `NULL`, если такого символа нет.

Поэтому дальше по условию мы заменяем найденный символ переноса строки на символ конца строки. 

Теперь, при выполнении программы увидим ожидаемый результат:

```
- Скажи-ка, дядя, ведь не даром
Я Python, Си учил с каналом
Балакирев что раздавал?
```

## Функции fprintf() и fscanf()

Далее рассмотрим следующие две функции для форматной записи и чтения данных:

```c
int fprintf(FILE* stream, const char* format, ...);
int fscanf(FILE* stream, const char* format, ...);
```

Мы уже знакомы с вами с функциями `printf()` и `scanf()`. Так вот, функции `fprintf()` и `fscanf()` работают аналогичным образом, только с дополнительным указанием потока `stream`. 

Обычно, это файловые потоки, но мы можем прописывать и стандартные `stdout` и `stdin`. Тогда `fprintf()` и `fscanf()` будут полными аналогами функций `printf()` и `scanf()`.

Зачем нужны такие функции? 

Обычно они используются, когда нужно записать данные в файл в определенном формате или прочитать данные по определенному формату. 

Например, можно сделать экспорт `excel`-файла в текстовый формат `csv` следующего вида:

```
78.43; 78.65; 78.90; 80.10; 79.88; 80.23; 80.67; 81.22; 82.34; 81.54
```

Предположим, это котировки рубль/доллар и сохранены в файле с именем `data_rubusd.csv`. 

Тогда для чтения этих вещественных чисел удобно воспользоваться функцией `fscanf()`. Получим:

```c
#include <stdio.h>
 
enum {max_length=1024};
 
int main(void) {
    double rub_usd[max_length] = {0.0};
    unsigned length = 0;
 
    FILE* fp = fopen("data_rubusd.csv", "r");
    if(fp == NULL) {
        perror("data_rubusd.csv");
        return 1;
    }
 
    while(fscanf(fp, "%lf ; ", &rub_usd[length]) == 1)
        length++;
 
    fclose(fp);
 
    for(int i = 0; i < length; ++i)
        printf("%.3f ", rub_usd[i]);
 
    return 0;
}
```
Мы здесь делаем цикл, пока функция `fscanf()` успешно читает данные. 

Так как на каждой итерации читается только одно значение, то делаем цикл, пока возвращается число `1`. 

В теле цикла увеличиваем счетчик прочитанных данных `length` на единицу.

После запуска программы, увидим:

```
78.430 78.650 78.900 80.100 79.880 80.230 80.670 81.220 82.340 81.540
```

Все данные были прочитаны успешно.

Для такой же форматной записи в файл удобно воспользоваться функцией `fprintf()`. 

Например, у нас имеется список из номеров телефонов и мы их хотим записать в файл в определенном формате:

```c
#include <stdio.h>
 
int main(void)
{
    const char* phones[][5] = {
        {"8", "917", "123", "45", "67"},
        {"8", "904", "123", "45", "68"},
        {"8", "906", "123", "45", "69"}
    };
 
    FILE* fp = fopen("my_file.txt", "w");
    if(fp == NULL) {
        perror("my_file.txt");
        return 1;
    }
 
    for(int i = 0;i < sizeof(phones) / sizeof(*phones); ++i)
        fprintf(fp,"%s(%s)%s-%s-%s\n", phones[i][0], phones[i][1], phones[i][2],
                                    phones[i][3], phones[i][4], phones[i][5]);
 
    fclose(fp);
 
    return 0;
}
```

В файле `my_file.txt` увидим следующий результат:

```
8(917)123-45-67
8(904)123-45-68
8(906)123-45-69
```

Вот общий принцип использования функций форматного ввода/вывода информации из файла.

Видео по теме [#59. Функции fputs(), fgets() и fprintf(), fscanf()](https://www.youtube.com/watch?v=ioCjZgaUEyo&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Установите соответствия между функциями и их описаниями.

![08](/Good_good_C_C++/img/08_10.PNG)

### Подвиг 2. Выберите все верные утверждения, касающиеся следующей программы:

```c
#include <stdio.h>
#include <string.h>

int main(void) {
    char buff[512];

    FILE* fp = fopen("test_file.txt", "r");
    if(fp == NULL)
        return 1;

    if(fgets(buff, sizeof(buff), fp) == NULL) {
        fclose(fp);
        return 2;
    }
    fclose(fp);

    fp = fopen("test_file.txt", "w");
    if(fp == NULL)
        return 3;

    fputs(strcat(buff, "Hello C!"), fp);
    fclose(fp);
    
    return 0;
}
```

+ [ ] при ошибке открытия файла "test_file.txt" на чтение функция main завершит свою работу с кодом 3
+ [x] при успешном выполнении программы в файл "test_file.txt" добавляется (к уже имеющейся там информации) фрагмент "Hello C!"
+ [x] при ошибке открытия файла "test_file.txt" на чтение функция main завершит свою работу с кодом 1
+ [ ] при ошибке чтения данных из файла "test_file.txt" функция main завершит свою работу с кодом 1
+ [x] при ошибке чтения данных из файла "test_file.txt" функция main завершит свою работу с кодом 2
+ [x] при ошибке открытия файла "test_file.txt" на запись функция main завершит свою работу с кодом 3
+ [ ] при ошибке открытия файла "test_file.txt" на запись функция main завершит свою работу с кодом 2

### Подвиг 3. Выберите все верные утверждения, касающиеся функций fgets и fputs.

+ [x] функция fgets читает данные из файла пока не встретится символ переноса строки или конец файла
+ [ ] при записи строки в файл функция fputs автоматически добавляет символ перевода строки
+ [x] при ошибке записи данных функция fputs возвращает -1
+ [x] для использования функций fgets и fputs необходимо подключить заголовочный файл stdio.h
+ [x] при ошибке чтения данных функция fgets возвращает NULL
+ [x] функция fputs записывает данные в файл пока не встретит символ конца строки
+ [x] функция fgets автоматически добавляет символ конца строки для формирования корректной Си-строки

### Подвиг 4. Выберите все верные утверждения, касающиеся функций fprintf и fscanf.

+ [x] синтаксис вызова функции fscanf следующий: int fscanf(FILE* stream, const char* format, ...);
+ [x] функция fscanf работает по аналогии с функцией scanf только применительно к произвольному (указанному) выходному потоку
+ [x] синтаксис вызова функции fprinf следующий: int fprintf(FILE* stream, const char* format, ...);
+ [x] для использования функций fprintf и fscanf необходимо подключить заголовочный файл stdio.h
+ [x] функция fprintf работает по аналогии с функцией printf только применительно к произвольному (указанному) входному потоку
+ [ ] синтаксис вызова функции fprinf следующий: int fprintf(const char* format, FILE* stream, ...);
+ [ ] синтаксис вызова функции fscanf следующий: int fscanf(const char* format, FILE* stream, ...);

### Подвиг 5. Продолжите программу. Необходимо прочитать из потока fp с помощью функции fgets или fputs (подумайте какой) строку в массив buff. Подсчитайте количество слов в строке (слова разделяются одним или несколькими пробелами). Выведите в консоль количество слов в виде одного целого числа.

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/8.3.5

```c
#include <stdio.h>
#include <string.h>

enum { max_length = 512 };

int main(void) {
    char buff[max_length];

    FILE* fp = stdin;  // имитация отрытого файлового входного потока

    if (fgets(buff, sizeof(buff), fp) == NULL) {
        // fclose(fp); закрывать стандартный поток не нужно
        return 2;
    }

    int res = 0;

    for (size_t i = 0; i < max_length && buff[i] != '\0'; i++) {
        if (buff[i] != ' ' && (buff[i + 1] == ' ' || buff[i + 1] == '\0')) res++;
    }

    printf("%d", res);

    // fclose(fp); закрывать стандартный поток не нужно

    return 0;
}
```

```c
#include <stdio.h>
#include <string.h>

int main(void)
{
    char buff[512];

    FILE* fp = stdin; // имитация отрытого файлового входного потока
    int i = 0, cnt = 0;
    
    fgets(buff, sizeof(buff), fp);
    
    while(buff[i]){
        if (buff[i] != ' ' && (buff[i+1] == ' ' || buff[i+1] == '\0'))
            cnt++;
        i++;
    }
    
    printf("%d", cnt);

    // fclose(fp); закрывать стандартный поток не нужно

    return 0;
}
```

### Подвиг 6. Продолжите программу. Прочитайте из стандартного входного потока целочисленные значения, записанные в одну строчку через пробел, в переменные w, h (именно в таком порядке). Затем, сформируйте строку в переменной buff по формату:

"rectangle: <ширина w>; <высота h>"

Например, при w=10, h=20 должна получиться строка:

"rectangle: 10; 20"

Выведите строку buff в поток fp с помощью функции fputs или fgets (подумайте какой).

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/8.3.6

```c
#include <stdio.h>

int main(void) {
    char buff[512];
    int w, h;

    FILE* fp = stdout;  // имитация отрытого файлового потока

    scanf("%d %d", &w, &h);

    sprintf(buff, "rectangle: %d; %d", w, h);

    fputs(buff, fp);

    // fclose(fp); закрывать стандартный поток не нужно

    return 0;
}
```

### Подвиг 7. Продолжите программу. Необходимо прочитать из потока fp с помощью функции fprintf или fscanf (подумайте какой) данные поместить в массив temp, записанные в виде вещественных чисел в одну строчку через пробел. Максимальное число читаемых данных не должно превышать max_length_ar (то есть, в потоке данных может быть и больше). Выведите в консоль в одну строчку через пробел только положительные прочитанные данные из массива temp с точностью до сотых (в порядке их следования).

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/8.3.7

```c
#include <stdio.h>

enum { max_length_ar = 20 };

int main(void) {
    double temp[max_length_ar];

    FILE* fp = stdin;  // имитация отрытого файлового потока

    size_t count = 0;

    while (count < max_length_ar && fscanf(fp, "%lf", &temp[count]) == 1) count++;

    for (size_t i = 0; i < count; i++) {
        if (temp[i] > 0) printf("%.2lf ", temp[i]);
    }

    // fclose(fp); закрывать стандартный поток не нужно

    return 0;
}
```

### Подвиг 8. Продолжите программу. Объявите структуру с именем типа BOX, состоящую из следующих полей:
+ id; идентификатор; тип unsigned int;
+ width, height, depth; габариты; тип unsigned int;
+ weight; вес; тип double.

В функции `main` объявите переменную типа `BOX` и прочитайте в нее из входного потока данные, записанные в виде чисел в одну строчку через точку с запятой. С помощью функции `fprintf` или `fscanf` (подумайте какой) выведите в поток `fp` данные из переменной типа BOX в следующем формате:

```
"box <id>: <width> x <height> x <depth>"
```

Например, для значений id=5, width=11, height=7, depth=30, получим:

```
"box 5: 11 x 7 x 30"
```

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/8.3.8

```c
#include <stdio.h>

typedef struct {
    unsigned id;
    unsigned width;
    unsigned height;
    unsigned depth;
    double weight;
} BOX;

int main(void) {
    FILE* fp = stdout;  // имитация отрытого файлового потока

    BOX tmp;

    scanf("%u; %u; %u; %u; %lf", &tmp.id, &tmp.width, &tmp.height, &tmp.depth, &tmp.weight);

    fprintf(fp, "box %u: %u x %u x %u", tmp.id, tmp.width, tmp.height, tmp.depth);

    // fclose(fp); закрывать стандартный поток не нужно

    return 0;
}
```

### Подвиг 9 (на повторение). Выберите все верные утверждения, касающиеся битовых полей.

+ [x] общий размер всех битовых полей кратен одному байту (то есть, составляет целое число байт в памяти)
+ [x] битовые поля определяются через структуру, каждое поле которой рекомендуется определять типом unsigned int
+ [ ] битовые поля определяются через структуру, каждое поле которой рекомендуется определять типом unsigned char
+ [ ] битовые поля определяются через объединение, каждое поле которой рекомендуется определять типом unsigned char
+ [x] после переменной через двоеточие указывается число бит, которое отводится под хранение данных в ней
+ [ ] общий размер всех битовых полей в памяти устройства равен сумме бит, отведенных каждому полю

### Подвиг 10 (на повторение). Выберите все верные варианты присвоения значений переменной d типа VAR (на структуру):

```c
typedef struct {
    int var_i;
    double var_d;
} VAR;

VAR d;
```

+ [x] d.var_i = 10;
+ [ ] d = 10;
+ [x] d = (VAR){.var_d = 0.5};
+ [x] d = (VAR){.var_d = 0.5, .var_i = -5};
+ [x] d = (VAR){10};
+ [x] d.var_d = -0.12;

# 8.4 Функции feof(), fflush(), setvbuf()

## Функция feof()

Давайте представим, что нам нужно из файла `data_rubusd2.csv` прочитать данные в более сложном формате:

```
rub/usd
78.43; 78.65; 78.90; 80.10; 79.88; 80.23; 80.67; 81.22; 82.34; 81.54
rub/eur
88.43; 88.65; 88.90; 88.10; 89.88; 88.23; 88.67; 89.22; 90.34; 90.54; 90.23; 89.10
rub/yan
9.23; 9.44; 9.56; 9.32; 9.88; 10.01; 10.20; 10.11; 10.54; 10.78; 11.0; 11.04
```

То есть, перед данными идут еще и заголовки. Очевидно, что заголовки можно прочитать функцией `fgets()`, а последующие числовые данные, с помощью функции `fscanf()`. Получаем следующую программу:

```c
#include <stdio.h>
 
enum {max_length=100};
 
int main(void) {
    double data[max_length];
    char buffer[max_length];
    int length = 0;
 
    FILE* fp = fopen("data_rubusd2.csv", "r");
    if(fp == NULL) {
        perror("data_rubusd2.csv");
        return 1;
    }
 
    while(!feof(fp)) {
        fgets(buffer, sizeof(buffer), fp);
 
        length = 0;
        while(fscanf(fp, "%lf ; ", &data[length]) == 1)
            length++;
 
        puts(buffer);
        for(int i = 0;i < length;++i)
            printf("%.2f ", data[i]);
        putchar('\n');
    }
 
    fclose(fp);
    return 0;
}
```

Смотрите, мы здесь использовали новую функцию `feof()`. 

Эта функция позволяет проверять, был ли достигнут конец файла или нет. 

Если все данные были прочитаны, то функция возвращает истину `1`, а иначе ложь `0`. 

В итоге, мы делаем цикл, то есть, читаем данные, пока не достигнут конец файла. Это бывает очень удобно, когда внутри цикла используется не одна какая-то функция для чтения, а набор функций. В этом случае, условие цикла прописывается просто через функцию `feof()`.

## Функция fflush()

Следующая функция, которая бывает полезна при работе с файлами, – это `fflush()`:

```c
int fflush(FILE* stream);
```

Она служит для очистки выходного потока `stream` с помещением всех данных из буфера в файл (если поток связан с файлом). Обратите внимание, эта функция по стандарту языка Си определена именно для выходных потоков, а не для входных. 

Хотя, иногда она работает и с входными, но это неопределенное действие и переносимость такой программы будет под большим вопросом. 

Поэтому лучше использовать ее строго по назначению – только для очистки выходных потоков. 

Причем вызывать ее следует после операций записи информации. 

Например, если поток открыт и на чтение и на запись, то функция `fflush()` должна вызваться после операции записи.

Давайте на простом примере посмотрим на принцип ее работы:

```c
#include <stdio.h>
 
int main(void) {
    int data[] = {1, 2, 3, 4, 5, 4, 3, 2, 1, -1};
    int length = sizeof(data) / sizeof(*data);
 
    FILE* fp = fopen("write_and_read.dat", "w");
    FILE* in = fopen("write_and_read.dat", "r");
    if(fp == NULL || in == NULL) {
        perror("write_and_read.dat");
        return 1;
    }
 
    for(int i = 0;i < length;++i)
        fprintf(fp, "%d ", data[i]);
 
    fflush(fp);
 
    int value;
    for(int i = 0;i < length;++i)
        if(fscanf(in, "%d ", &value) == 1)
            printf("%d ", value);
 
    fclose(fp);
    fclose(in);
 
    return 0;
}
```

Мы здесь открыли для одного и того же файла `write_and_read.dat` сразу два потока: на запись и на чтение. 

Затем, записали целочисленные значения в выходной поток, они были занесены в буфер этого потока и далее, чтобы перенести данные физически в файл, вызывается функция `fflush()` для выходного потока. 

После этого входной поток читает данные из файла и выводит их на экран:

```
1 2 3 4 5 4 3 2 1 -1
```

Так вот, если в этой программе убрать вызов функции `fflush()`, то после запуска программы мы ничего на экране не увидим. 

Это произошло как раз по той причине, что данные находятся в буфере выходного потока, но не в файле, а входной поток читает их исключительно из файла. Поэтому ничего прочитано не было.

Конечно, в данной программе, вместо функции `fflush()` логичнее было бы просто закрыть выходной поток функцией `fclose()`, так как далее мы с ним не работаем. 

Но, в более сложных ситуациях, когда происходит то запись, то чтение данных из одного и того же файла разными потоками, функция `fflush()` оказывается незаменимой. 

Но, конечно же, помните, что ее следует применять только к выходному потоку, а не к входному.

## Функция setvbuf()

Функция `fopen()`, открывая файловый поток, автоматически формирует входной или выходной буфер. Но мы, при необходимости, можем определить свой собственный с помощью функции:

```c
int setvbuf(FILE * restrict stream, char * restrict buf, int mode, size_t size);
```

Здесь указатель `buf` – это адрес области памяти для буфера (если равен `NULL`, то буфер создается автоматически); `mode` – режим работы буфера; `size` – размер буфера в байтах. Режимы определены следующими константами:
+ _IOFBF – полная буферизация (очистка после заполнения буфера);
+ _IOLBF – построчная буферизация (очистка по символу переноса строки);
+ _IONBF – выключение буферизации.

Функция `setvbuf()` должна вызываться после создания потока, но перед использованием какой-либо операции записи/чтения данных из этого потока.

Давайте посмотрим на пример использования этой функции:

```c
#include <stdio.h>
 
enum {buffer_size=512, data_size=100};
 
int main(void) {
    char buffer[buffer_size] = {0};
    char data[data_size];
 
    FILE* fp = fopen("data_rubusd2.csv", "r");
    if(fp == NULL) {
        perror("data_rubusd2.csv");
        return 1;
    }
 
    if(setvbuf(fp, buffer, _IOFBF, buffer_size) != 0) {
        puts("Incorrect type or size of buffer");
        return 2;
    }
 
    fgets(data, sizeof(data), fp);
    puts(buffer);
    puts("----------------");
    puts(data);
 
    fclose(fp);
    return 0;
}
```

После открытия файлового потока вызывается функция `setvbuf()`, которая в качестве буфера использует массив `buffer` длиной `512` байт и режим полной буферизации. После чтения первой строки из файла, в буфер попадает сразу все содержимое файла. 

Так отработала буферизация. 

При этом в массиве `data` содержится только первая строка.

Если отключить буферизацию (использовать режим `_IONBF`), то буфер будет пустым.

Надо сказать, на практике не часто подключают свою собственную буферизацию, так как буферизации по умолчанию вполне хватает. Но если потребуется управлять этим процессом, то вы теперь знаете, как это можно сделать.

Видео по теме [#60. Функции feof(), fflush(), setvbuf()](https://www.youtube.com/watch?v=Eq9xp5NBbSY&list=PLA0M1Bcd0w8w-mqVmBjt-2J8Z1gVmPZVz)

### Подвиг 1. Установите соответствия между функциями и их описаниями.

![08](/Good_good_C_C++/img/08_11.PNG)

### Подвиг 2. Выберите все верные утверждения, касающиеся следующей программы:

```c
#include <stdio.h>

int main(void) {
    FILE* fp = fopen("test_file.txt", "r");
    if(fp == NULL) {
        perror("test_file.txt");
        return 1;
    }

    char ch;
    while(!feof(fp)) {
        ch = fgetc(fp);
        putchar(ch);
    }
    
    fclose(fp);
    return 0;
}
```

+ [x] файл "test_file.txt" открывается на чтение и при ошибке открытия функция main завершается с кодом 1
+ [x] цикл while будет работать до тех пор, пока не будет достигнут конец файлового потока fp
+ [ ] файл "test_file.txt" открывается на запись и при ошибке открытия функция main завершается с кодом 1
+ [ ] цикл while не сделает ни одной итерации, т.к. условие записано неверно (нужно убрать операцию ! перед функцией feof)
+ [x] в теле цикла while посимвольно читаются данные из потока fp и выводятся в консоль

### Подвиг 3. Продолжите программу. Необходимо из потока fp читать строки целиком (до символа переноса строки или символа EOF) и сохранять их в массиве text. При чтении следует контролировать количество читаемых строк, чтобы оно не превосходило значения max_lines. Гарантируется, что строки не длиннее значения max_string_len. В конце каждой строки не должно быть символа перевода строки. Выведите в консоль все полученные в массиве text строки (каждая с новой строки).

Тесты: https://github.com/selfedu-rus/c-tests/tree/main/8.4.3

Sample Input:

Язык Си. Рождение легенды<br>
Структура и понимание работы программы "Hello, World!"<br>
Арифметические операции деления по модулю, инкремента и декремента<br>
Функция printf() для форматированного вывода<br>
Булевый тип. Операции сравнения. Логические И, ИЛИ, НЕ<br>

Sample Output:

Язык Си. Рождение легенды<br>
Структура и понимание работы программы "Hello, World!"<br>
Арифметические операции деления по модулю, инкремента и декремента<br>
Функция printf() для форматированного вывода<br>
Булевый тип. Операции сравнения. Логические И, ИЛИ, НЕ<br>