# Урок 7. Циклы

## Содержание

+ [Циклические конструкции в языке Си]()
+ [Цикл со счётчиком for]()
+ [Цикл с предусловием while и цикл с постусловием do-while]()
+ [Операторы управления циклом: break, continue. Зацикливание]()

## Циклические конструкции в языке Си

Основное преимущество компьютера перед человеком заключается в том, что он может очень быстро выполнять операции и хранить большие объёмы информации. При этом он не устаёт и не ошибается. 

Но данными преимуществами ещё нужно научиться грамотно пользоваться. Например, какая польза от того, что компьютер может выполнить миллион операций в секунду, если нам нужно предварительно записать каждую из этого миллиона операций? Сколько времени на это уйдёт? 

Очевидно, что нам требуется способ записывать много простых операций малыми усилиями, желательно в 2-3 строчки кода. И, конечно, такой способ есть – это циклические конструкции (циклы).

__Цикл__ – конструкция, которая позволяет указать компьютеру выполнить некоторую последовательность операций много раз.

В этом уроке мы обсудим, как устроены циклические конструкции в языке Си, и научимся ими пользоваться.

В языке Си используются три основных вида циклов:
+ цикл со счётчиком for
+ цикл с предусловием while
+ цикл с постусловием do-while

Мы последовательно разберём каждый из них.

## Дополнительные материалы 1

[Видео из проекта Hour of Code. Марк Цукерберг рассказывает о том, зачем нужны циклы](https://youtu.be/mgooqyWMTxk)

[Содержание](#содержание)

<hr>

# Цикл со счётчиком for

Данная циклическая конструкция обычно используется, когда заранее известно, сколько раз необходимо повторить какую-то команду или набор команд. Вспомним урок про генерацию случайных чисел: там была забавная задача для самостоятельного исследования. Вот её условие:

## Пример: Равномерность случайных чисел

Числа, генерируемые функцией rand(), имеют равномерное распределение. Это значит, что если запускать функцию rand очень много раз и каждый раз записывать, какое число выпало, то различные числа выпадут примерно одинаковое число раз.

Например, если генерировать только числа 0 и 1, то через 100 запусков примерно 50 раз выпадет ноль и 50 раз единичка. Обратите внимание, что я говорю примерно. Может быть, например, 49 и 51, или 53 и 47.

Если рассматривать отношение этих чисел к общему количеству генераций, получим 49/100 и 51/100 или 53/100 и 47/100. Но чем больше экспериментов мы проведём, тем отношение количества единичек к количеству испытаний будет ближе к 1/2.

Проведите самостоятельно эксперимент с 10, 50 и 100 запусками. Это муторно и долго, если делать руками, но что поделать? В будущем мы напишем программу, чтобы проверить свойство равномерности распределения этих псевдослучайных чисел.

Давайте проведём подобный эксперимент. Пусть программа генерирует одно из трёх чисел: 0, 1 или 2. Вот, посмотрите на её код.

_Листинг 1._

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main(void) { 
  
  srand(time(NULL));
// счётчики для сгенерированых чисел
// если выпадет 1, то увеличим на единицу count_1
  int count_0 = 0, count_1 = 0, count_2 = 0;

  int rand_number;
  
  rand_number = rand()%3;  
  switch (rand_number){
    case 0 : count_0 = count_0 + 1; break;
    case 1 : count_1 = count_1 + 1; break;
    case 2 : count_2 = count_2 + 1; break;
  }

  rand_number = rand()%3;  
  switch (rand_number){
    case 0 : count_0 = count_0 + 1; break;
    case 1 : count_1 = count_1 + 1; break;
    case 2 : count_2 = count_2 + 1; break;
  }

  rand_number = rand()%3;  
  switch (rand_number){
    case 0 : count_0 = count_0 + 1; break;
    case 1 : count_1 = count_1 + 1; break;
    case 2 : count_2 = count_2 + 1; break;
  }

  rand_number = rand()%3;  
  switch (rand_number){
    case 0 : count_0 = count_0 + 1; break;
    case 1 : count_1 = count_1 + 1; break;
    case 2 : count_2 = count_2 + 1; break;
  }

  rand_number = rand()%3;  
  switch (rand_number){
    case 0 : count_0 = count_0 + 1; break;
    case 1 : count_1 = count_1 + 1; break;
    case 2 : count_2 = count_2 + 1; break;
  }

  rand_number = rand()%3;  
  switch (rand_number){
    case 0 : count_0 = count_0 + 1; break;
    case 1 : count_1 = count_1 + 1; break;
    case 2 : count_2 = count_2 + 1; break;
  }

  rand_number = rand()%3;  
  switch (rand_number){
    case 0 : count_0 = count_0 + 1; break;
    case 1 : count_1 = count_1 + 1; break;
    case 2 : count_2 = count_2 + 1; break;
  }

  rand_number = rand()%3;  
  switch (rand_number){
    case 0 : count_0 = count_0 + 1; break;
    case 1 : count_1 = count_1 + 1; break;
    case 2 : count_2 = count_2 + 1; break;
  }

  rand_number = rand()%3;  
  switch (rand_number){
    case 0 : count_0 = count_0 + 1; break;
    case 1 : count_1 = count_1 + 1; break;
    case 2 : count_2 = count_2 + 1; break;
  }

  rand_number = rand()%3;  
  switch (rand_number){
    case 0 : count_0 = count_0 + 1; break;
    case 1 : count_1 = count_1 + 1; break;
    case 2 : count_2 = count_2 + 1; break;
  }

  printf("0 - %d\n1 - %d\n2 - %d\n", count_0, count_1, count_2);

  return 0;
}
```

Если вам непонятно, как работает данная программа, то проработайте уроки «Приручаем случайность» и «Оператор выбора».

Программа получилась объемной, но довольно простой. При этом легко видеть, что одни и те же операции (генерация случайного числа и оператор выбора) повторяются буквально без изменений. Результат работы этой программы на рисунке ниже.

![007](/StepikC/Pictures/007_001.png)

_Рис.1 Пример работы программы Листинг 1_

Как видите, пока что-то не очень похоже на то, что все цифры выпадают одинаковое количество раз. Запустите программу у себя, возможно, у вас получится более хороший результат. Ну, а мы продолжим. Давайте увеличим количество опытов до 100. Можно было бы, конечно, ещё 90 раз скопировать эту конструкцию или запустить программу ещё 9 раз и вручную складывать результаты, но это не дело. Лучше воспользуемся циклической конструкцией for.

[Содержание](#содержание)

<hr>

## Общий шаблон цикла for

_Листинг 2._

```c
for (инициализация счетчика; условие; изменение счетчика)
  оператор;
```

Цикл `for` состоит из двух частей: заголовок цикла (первая строка) и тело цикла (вторая строка).

__Тело цикла__ – это команда, которую необходимо выполнить несколько раз. Если необходимо выполнить несколько команд, а не одну, то можно воспользоваться составным оператором {}. Мы уже проделывали такой трюк, когда изучали условный оператор.

В нашем случае тело цикла for будет выглядеть так:

_Листинг 3._
```c
{
  rand_number = rand()%3;  
  switch (rand_number){
    case 0 : count_0 = count_0 + 1; break;
    case 1 : count_1 = count_1 + 1; break;
    case 2 : count_2 = count_2 + 1; break;
  }
}
```

Так как в теле цикла две команды (присваивание, оператор выбора), то пришлось использовать составной оператор.

Разберём подробно заголовок цикла `for`. В нём, кроме ключевого слова `for` и скобок, имеется ещё три выражения.

Первое выражение – инициализация счетчика.

В этой части нам нужно завести переменную-счетчик и присвоить ей какое-нибудь начальное значение. Например:

_Листинг 4._

```c
for (int i = 0; ; )  
// или
for (int j = 13; ; )
// или
for (int k = -100; ; )
// или
for (int m = 255; ; )
// или
for (int q = 1; ; )
```

Второе выражение – условие.

В этой части необходимо записать условное выражение, при котором должно выполняться тело цикла. Цикл for будет работать, пока условие истинно. Например:

_Листинг 5._

```c
for (int i = 0; i <= 100; )  
// или
for (int j = 13; j > 0; )
// или
for (int k = -100; k != 0; )
// или
for (int m = 255; m >= 0; )
// или
for (int q = 1; q < 1000; )
```

И последняя третья часть – изменение счетчика.

Здесь записывается то, что должно происходить после каждого выполнения тела цикла. Обычно здесь пишут то, как должен измениться счётчик после каждой итерации. Одно повторение тела цикла в серьёзных книгах иногда называют итерацией.

Например:

_Листинг 6._
```c
for (int i = 0; i <= 100; i = i + 1) // увеличиваем счётчик на единицу
// или
for (int j = 13; j > 0; j = j / 2) // уменьшаем вдвое 
// или
for (int k = -100; k != 0; k = k - 1) // уменьшаем счётчик на единицу
// или
for (int m = 255; m >= 0; m = m - 5) // уменьшаем счётчик на 5
// или
for (int q = 1; q < 1000; q = q * 2) //увеличиваем счётчик в два раза
```

Давайте перепишем нашу программу с использованием цикла `for`.

_Листинг 7._

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main(void) {   
  srand(time(NULL));
// счётчики для сгенерированных чисел
// если выпадет 0, то увеличим на единицу count_0
// аналогично для count_1 и count_2
  int count_0 = 0, count_1 = 0, count_2 =0;

  int rand_number;
  
  // i = 0 начинаем отсчёт с нуля
  // i < 100 повторяем, пока i меньше 100
  // i = i + 1 на каждом шаге увеличиваем счётчик на единицу
  // итого тело цикла выполнится 100 раз
  for (int i = 0; i < 100; i = i + 1){
    rand_number = rand()%3;  
    switch (rand_number){
      case 0 : count_0 = count_0 + 1; break;
      case 1 : count_1 = count_1 + 1; break;
      case 2 : count_2 = count_2 + 1; break;
    }
  }

  printf("0 - %d\n1 - %d\n2 - %d\n", count_0, count_1, count_2);
  return 0;
}
```

Гораздо понятнее и нагляднее, не так ли? Вот-вот. Опишем подробно алгоритм работы цикла `for`.

1. Программа встречает ключевое слово `for`, а значит дальше идёт циклическая конструкция.
2. Сначала создаётся переменная счетчик (выражение 1).
3. Проверяется условие выполнение цикла (выражение 2).
4. Если условие ЛОЖЬ, то программа выходит из цикла `for` и продолжает свое выполнение.
5. Если условие ИСТИНА, то выполняется тело цикла.
6. Когда тело цикла выполнится, программа возвращается к заголовку и выполняет инструкции из третьей части заголовка. Изменяется значение переменной-счетчика (выражение 3).
7. Возвращаемся к пункту три.

А теперь то же самое для нашей программы. Встречаем цикл for.

+ Инициализируем переменную счётчик i = 0;
+ Проверяем условие i < 100. Т.к. i = 0, то условие ИСТИНА;
+ Выполняем тело цикла. Генерируем число от 0 до 2. В операторе switch определяем, какое число было сгенерировано, и увеличиваем соответствующий счётчик;
+ Т.к. тело цикла закончено, то выполняем Выражение 3. Теперь i = 1.
+ Возвращаемся к условию;
+ Проверяем условие i < 100. Т.к. i = 1, то условие ИСТИНА
+ Выполняем тело цикла. Генерируем число от 0 до 2. В операторе switch определяем, какое число было сгенерировано, и увеличиваем соответствующий счётчик;
+ Изменяем счётчик. Теперь i = 2. Возвращаемся к условию.

И так далее, пока i не станет равным 100. В этом случае при проверке условия получим ЛОЖЬ. Выполнение цикла прекратится. Программа продолжит выполнять инструкции, расположенные за циклом.

Давайте посмотрим ещё на один пример.

Напишем программу, которая выводит на экран сумму натуральных чисел из промежутка [A;B]. Числа A и B (B>A) вводятся пользователем.

_Листинг 8._

```c
#include <stdio.h>

int main(void) {

  int a = 0, b = 0;
  scanf("%d %d", &a, &b);

  // сюда будем записывать результат
  int sum = 0;
  
  
  // k++ эквивалентно k = k + 1, но короче
  // ++ оператор инкремента
  
  for (int k = a; k <= b; k++){
    sum = sum + k;
    // на каждой итерации добавляем к уже имеющейся сумме
    // очередное число
  }

  printf("%d\n", sum);

  return 0;
}
```

Все неясные моменты я постарался отразить в комментариях к программе. Если возникнут вопросы, то задавайте их в комментариях к уроку.


[Содержание](#содержание)

<hr>

# Циклы с условиями

Иногда заранее нельзя предсказать, какое количество раз должен выполниться цикл. Но при этом известно некоторое условие, когда цикл должен остановиться. Например:

Программа: Игральный кубик.

Программа заменяет обычный игральный кубик.

Управление:
```
1 -- бросить кубик;
0 -- закончить игру.
```

Давайте напишем заготовку для нашей игры.

_Листинг 1._

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main(void) {   
  srand(time(NULL));

  printf("###########  Devil\'s bones   ###########\n");
  printf("#                                      #\n");
  printf("#   Commands:                          #\n");
  printf("#                                      #\n");
  printf("#   1 - new game                       #\n");
  printf("#   0 - exit                           #\n");
  printf("#                                      #\n");
  printf("########################################\n\n");
  
  int control;
  int value = 0;
  printf("Enter command: ");
  scanf("%d", &control);
  
  if(control == 1){
    value = 1 + rand()%6;
    printf("Result: %d\n", value);
  }

  return 0;
}
```

Тут-то мы и сталкиваемся с проблемой. Понятно, что заранее узнать, когда игра закончится невозможно. А значит использовать цикл `for` напрямую не получится. Одним из выходов из подобной ситуации является использование других циклических конструкций. 

Например, цикла `while`.

## Цикл с предусловием while

_Листинг 2._

```c
while (условие)
  оператор;
```

Работает эта конструкция следующим образом:
1. Программа встречает ключевое слово `while`, значит дальше идёт циклическая конструкция;
2. Проверяется условие. Вычисляется логическое выражение, записанное в скобках;
3. Если значение условия ИСТИНА, то выполняется тело цикла. Переходим к пункту 2;
4. Если значение условия ЛОЖЬ, то цикл завершается. Управление передаётся на оператор, следующий за телом цикла.

Под оператором понимается один оператор. Если нужно выполнить в цикле несколько команд, то необходимо использовать составной оператор {}.

Давайте перепишем нашу программу с использованием данного цикла.

_Листинг 3._

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main(void) {   
  srand(time(NULL));

  printf("###########  Devil\'s bones   ###########\n");
  printf("#                                      #\n");
  printf("#   Commands:                          #\n");
  printf("#                                      #\n");
  printf("#   1 - new game                       #\n");
  printf("#   0 - exit                           #\n");
  printf("#                                      #\n");
  printf("########################################\n\n");
  
  int control;
  int value = 0;

  printf("Enter command: ");
  scanf("%d", &control);
  while(control != 0){
    switch(control){
      case 1:
        value = 1 + rand()%6;
        printf("Result: %d\n", value);
        break;
      default: 
        printf("Error! Try again...\n");
        break;
    } 
    printf("Enter command: ");
    scanf("%d", &control);
  }

  printf("Good bye!\n");
  return 0;
}
```

Опишем словами алгоритм работы данной программы:

1. Выводим меню пользователя и предложение ввести команду;
2. Считываем код команды в переменную control;
3. Запускаем цикл `while`. Проверяем условие;
4. Если пользователь ввёл 0, то условие выполнения цикла принимает значение ЛОЖЬ. Тело цикла не выполняется. Управление передаётся на следующий за циклом оператор. Выводится строка Good bye!. Программа завершается;
+ Оператор выбора:
    + Если пользователь ввёл 1, то генерируем случайное число от 1 до 6 и выводим его на экран. Выходим из оператора выбора;
    + Если пользователь ввёл что-то иное, выводим сообщение об ошибке. Выходим из оператора выбора.
+ Выводим пользователю предложение ввести новую команду;
+ Считываем код команды в переменную control;
+ Возвращаемся к проверке условия. Пункт 3.

Цикл `while` называют циклом с предусловием, т.к. прежде, чем выполнить тело цикла, проверяется условие. Это значит, например, что возможна такая ситуация, что тело цикла не выполнится вообще ни один раз. Другое название цикла `while` – цикла ПОКА. Дословный перевод с английского. Это название отображает саму суть цикла.

### Мнемоническое правило:

__ПОКА условие ИСТИНА, выполняй тело цикла.__

[Содержание](#содержание)

<hr>

## Цикл с постусловием do-while

И последняя, третья циклическая конструкция – цикл `do-while`.

Данный цикл отличается от цикла while тем, что условие проверяется не перед выполнением тела цикла, а после выполнения тела цикла. Это значит, что тело цикла do-while выполнится хотя бы один раз обязательно.

Синтаксис данной циклической конструкции таков:

_Листинг 4._

```c
do 
  оператор;
while (условие);
```

Работает эта конструкция следующим образом:
1. Программа встречает ключевое слово `do`. Значит перед ней цикл `do-while`;
2. Выполняется тело цикла;
3. Проверяется условие;
4. Если условие ИСТИНА,то снова выполняется тело цикла;
5. Если условие ЛОЖЬ, то работа циклической конструкции прекращается. Программы выполняет оператор, следующий за циклом do-while.

Давайте перепишем нашу программу с использованием данного типа циклической конструкции.

_Листинг 5._

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main(void) {   
  srand(time(NULL));

  printf("###########  Devil\'s bones   ###########\n");
  printf("#                                      #\n");
  printf("#   Commands:                          #\n");
  printf("#                                      #\n");
  printf("#   1 - new game                       #\n");
  printf("#   0 - exit                           #\n");
  printf("#                                      #\n");
  printf("########################################\n\n");
  
  int ch_control;
  int value = 0;

  do {
    printf("Input command: ");
    scanf("%d", &ch_control);

    switch(ch_control){
      case 0: break;
      case 1:
        value = 1 + rand()%6;
        printf("Result: %d\n", value);
        break;
      default: 
        printf("Error! Try again...\n");
        break;
    }
  }while(ch_control != 0);

  printf("Good bye!\n");
  return 0;
}
```

В общем-то очень похоже на предыдущий код. Правда, пришлось немножко поменять оператор выбора: добавить туда ветку `case 0:`. 

Иначе из-за того, что проверка производится после выполнения тела цикла, программа работала некорректно. При вводе нуля появлялось сообщение об ошибке. В прошлой программе (с циклом `while`) подобной ситуации быть не могло, т.к. равенство нулю проверялось в условии цикла. При вводе нуля условие стало бы ложью, а значит цикл завершился бы и тело цикла не выполнилось.

[Содержание](#содержание)

<hr>

# Операторы управления циклом. Зацикливание

Существует два оператора, которые позволяют управлять выполнением цикла. Это операторы break и continue.

Давайте рассмотрим их работу на следующем примере: Модифицируем программу из прошлого урока.

### Программа: Игральный кубик.

Программа заменяет обычный игральный кубик.

Управление:
```
1 -- бросить кубик;
0 -- закончить игру.
```

В конце игры программа должна выводить количество бросков кубика, сделанных в игре.
После 50 бросков программа автоматически завершается. Выводится сообщение "Game over!".

Код такой программы будет выглядеть следующим образом:

_Листинг 1._

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main(void) {   
  srand(time(NULL));

  printf("###########  Devil\'s bones   ###########\n");
  printf("#                                      #\n");
  printf("#   Commands:                          #\n");
  printf("#                                      #\n");
  printf("#   1 - new game                       #\n");
  printf("#   0 - exit                           #\n");
  printf("#                                      #\n");
  printf("########################################\n\n");
  
  int ch_control;
  int value = 0, score = 0;
 
  do {
    printf("Input command: ");
    scanf("%d", &ch_control);

    switch(ch_control){
      case 0: 
        score = score -1;
        break;
      case 1:
        value = 1 + rand()%6;
        printf("Result: %d\n", value);
        break;
      default: 
        printf("Error! Try again...\n");
        continue;   // прерываем текущую итерацию цикла
    }
    
    score = score + 1;
    
    if(score == 50){
      printf("Game over!\n"); 
      break;      // завершаем цикл
    }
  }while(ch_control != 0);
  
  printf("\n\nSCORE: %d\n\nGood bye!\n", score);
  return 0;
}
```

Давайте поясню некоторые новые операторы, которые там используются.

[Содержание](#содержание)

<hr>

### Оператор break

Оператор break прекращает выполнение цикла. Помните, мы уже использовали данную команду в операторе `switch`. Здесь всё точно так же. Мы используем данный оператор, чтобы выйти из цикла, когда произойдёт 50 бросков.

Важный момент. Оператор break работает и во всех циклических конструкциях, и в операторе выбора.

В нашем примере он используется и там, и там. Возникает вопрос: а как он решает, откуда надо выйти: из `switch` или из цикла. Очень просто.

Оператор `break` всегда завершает ближайший внешний оператор, внутри которого он находится.

Например, в нашей программе первый раз оператор `break` встречается в ветке `case 0`. Значит он находится внутри оператора `switch`, который находится внутри цикла do-while. Ближайший оператор, внутри которого он расположен, – это `switch`. Следовательно, завершается оператор `switch`. Аналогично и с другими ветками оператора `switch`.

Последний оператор `break` находится внутри `if`, который находится внутри цикла `do-while`. Т.к. на конструкцию `if` оператор `break` не действует, то ближайшим оператором, в котором он находится, является цикл `do-while`. Поэтому в этом случае `break` завершает цикл.

[Содержание](#содержание)

<hr>

### Оператор continue

Данный оператор применяется только внутри циклов. Он позволяет прервать текущую итерацию цикла. После того, как компьютер встречает оператор continue, он завершает исполнение тела цикла и переходит к проверке условия (в циклах `while` и `do-while`) или к изменению счётчика (выражение 3 в цикле `for`).

В нашей программе он используется для того, чтобы не учитывать плохие ходы. 

Например, пользователь ввёл число 2. Программа выдаёт ему сообщение об ошибке и сразу же переходит к проверке условия. 

При этом все команды ниже пропускаются, а значит не увеличивается счётчик ходов, и не проверяется превышение предела в 50 ходов на игру. Если здесь убрать оператор, то после вывода сообщения об ошибке тело цикла продолжит выполняться дальше и увеличится счётчик ходов.

[Содержание](#содержание)

<hr>

## Зацикливание

Иногда бывает так, что условие, при котором работа цикла должна прекратиться, никогда не выполняется. В таких случаях говорят, что программа «зациклилась».

Зачастую это происходит при использовании циклов `do-while` и `while`.

Пример: программа сложения пяти введённых чисел.

_Листинг 2._

```c
#include <stdio.h>

int main(void) {
  double sum = 0, temp = 0;
  int k = 0;
  
  do {
    scanf("%lf", &temp);
    sum = sum + temp;
  } while(k < 5);

  printf("%.3f", sum);
  return 0;
}
```

На первый взгляд всё верно, но попробуйте скомпилировать и запустить эту программу. Вы заметите, что она не спешит останавливаться после того, как мы ввели первые пять чисел.

Когда мы используем эти циклы, необходимо внимательно отслеживать, что переменные, входящие в условия цикла, в теле цикла хоть как-то изменяются.

В нашем примере допущена именно такая ошибка. Условие записано верно, переменная k (счётчик считанных чисел) объявлена и инициализирована, но внутри тела цикла мы забыли её увеличить. Поэтому нашему условию окончания цикла k < 5 не суждено стать истинным.

Не всегда подобные ошибки так очевидны, как в нашем случае. Поэтому будьте внимательны, когда используете циклы с условиями.

Давайте приведем нашу программу в рабочее состояние:

_Листинг 3._

```c
#include <stdio.h>

int main(void) {
  double sum = 0, temp = 0;
  int k = 1;
  
  do {
    scanf("%lf", &temp);
    sum = sum + temp;
    k = k + 1;
  } while(k <= 5);

  printf("%.3f", sum);
  return 0;
}
```

[Содержание](#содержание)

<hr>

# Задачи

## Написать программу выводящую на экран первые N натуральных чисел.

Входные данные:

Одно  целое число N, N>0

Выходные данные:

Первые N натуральных чисел, записанных через пробел.

```c
#include <stdio.h>

int main() {
    int N;
    scanf("%d", &N);

    for (int i =  1; i < N + 1; i++)
    {
        printf("%d%s", i, i < N ? " " : "");        
    }
    return 0;
}
```

[Содержание](#содержание)

<hr>

## Усовершенствуйте программу, написанную на прошлом шаге. Теперь необходимо вывести все натуральные числа из промежутка [K,M],(K<M)

Входные данные:
Два целых числа K,M. При этом M больше K.

Выходные данные:

Натуральные числа в порядке возрастания принадлежащие промежутку [K,M]. Числа нужно разделять одним пробелом.

```c
#include <stdio.h>

int main() {
    int K, M;
    scanf("%d%d", &K, &M);
    for (int i = K > 0 ? K : 1 ; i < M + 1; i++)
    {
            printf("%d%s", i, i < M ? " " : "");        
    }
    return 0;
}
```

[Содержание](#содержание)

<hr>

## Усовершенствовать программу, написанную на прошлом шаге: дополнительно на отдельной строке вывести количество напечатанных чисел.

Входные данные:

Два целых числа K,M. При этом M больше K.

Выходные данные:

Натуральные числа в порядке возрастания, принадлежащие промежутку [K,M]. 

Числа нужно разделять одним пробелом. 

На новой строке вывести количество выведенных натуральных чисел, а если натуральные числа отсутствуют -- ноль.

Уточнение:

На конце первой строки обязательно должен ставиться пробел.

```c
#include <stdio.h>

int main() {
    int K, M, res = 0;
    scanf("%d%d", &K, &M);
    for (int i = K > 0 ? K : 1 ; i < M + 1; i++)
    {
            printf("%d ", i);
            res++;        
    }
    printf("\n%d", res);
    return 0;
}
```

[Содержание](#содержание)

<hr>

## Вывести через пробел все целые числа из промежутка [A,B],(A<B) в обратном порядке: от B до A.

Входные данные:

Два целых числа A,B, при этом A<B.

Выходные данные:

Целые числа из промежутка от [A,B], записанные через пробел в обратном порядке.

```c
#include <stdio.h>

int main() {
    int A, B;
    scanf("%d%d", &A, &B);
    for (int i = B; i > A - 1; i--)
    {
            printf("%d ", i);
    }
    return 0;
}
```

[Содержание](#содержание)

<hr>

## Факториал.
Для целого числа k(0≤k≤12) посчитать k!.

Входные данные:

Одно целое число k, (0≤k≤12).

Выходные данные:

Значение факториала числа k.

```c
#include <stdio.h>

int main() {
    int K, res = 1;
    scanf("%d", &K);
    for (int i = 1; i < K + 1; i++)
    {
        res *=i;
    }
    printf("%d ", res);
    return 0;
}
```

[Содержание](#содержание)

<hr>

## Числа Фибоначчи
Последовательность чисел Фибоначчи определяется следующим образом:

$F_1 = 1, F_2  =1, F_3 = F_1 + F_2, … , F_k = F_{k−2} + F_{k−1}$.

Посчитать значение N-го числа Фибоначчи.

Входные данные:

Одно натуральное число N, (N≤45)

Выходные данные:

Значение N-го числа Фибоначчи.

```c
#include <stdio.h>

int main() {
    int N, res, N1 = 1, N2 = 1;
    scanf("%d", &N);
    for (int i = 1; i < N + 1; i++)
    {
        res = N1;
        N1 = N2;
        N2 = N2 + res;
    }
    printf("%d ", res);
    return 0;
}
```

[Содержание](#содержание)

<hr>

[Содержание курса](/StepikC/README.md)