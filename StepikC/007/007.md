# Урок 7. Циклы

## Содержание

+ [Циклические конструкции в языке Си](#циклические-конструкции-в-языке-си)
+ [Цикл со счётчиком for](#цикл-со-счётчиком-for)
    + [Равномерность случайных чисел](#пример-равномерность-случайных-чисел)
    + [Общий шаблон цикла for](#общий-шаблон-цикла-for)
    + [Алгоритм работы цикла `for`](#алгоритм-работы-цикла-for)
+ [Циклы с условиями](#циклы-с-условиями)
    + [Цикл с предусловием while](#цикл-с-предусловием-while)
    + [Алгоритм работы цикла `while`](#алгоритм-работы-цикла-while)
    + [Цикл с постусловием do-while](#цикл-с-постусловием-do-while)
+ [Операторы управления циклом: break, continue. Зацикливание](#операторы-управления-циклом-зацикливание)
    + [Программа: Игральный кубик.](#программа-игральный-кубик)
    + [Оператор break](#оператор-break)
    + [Оператор continue](#оператор-continue)
    + [Зацикливание](#зацикливание)






# Циклические конструкции в языке Си

Основное преимущество компьютера перед человеком заключается в том, что он может очень быстро выполнять операции и хранить большие объёмы информации. При этом он не устаёт и не ошибается. 

Но данными преимуществами ещё нужно научиться грамотно пользоваться. Например, какая польза от того, что компьютер может выполнить миллион операций в секунду, если нам нужно предварительно записать каждую из этого миллиона операций? Сколько времени на это уйдёт? 

Очевидно, что нам требуется способ записывать много простых операций малыми усилиями, желательно в 2-3 строчки кода. И, конечно, такой способ есть – это циклические конструкции (циклы).

__Цикл__ – конструкция, которая позволяет указать компьютеру выполнить некоторую последовательность операций много раз.

В этом уроке мы обсудим, как устроены циклические конструкции в языке Си, и научимся ими пользоваться.

В языке Си используются три основных вида циклов:
+ цикл со счётчиком for
+ цикл с предусловием while
+ цикл с постусловием do-while

Мы последовательно разберём каждый из них.

## Дополнительные материалы 1

[Видео из проекта Hour of Code. Марк Цукерберг рассказывает о том, зачем нужны циклы](https://youtu.be/mgooqyWMTxk)

[Содержание](#содержание)

<hr>

# Цикл со счётчиком for

Данная циклическая конструкция обычно используется, когда заранее известно, сколько раз необходимо повторить какую-то команду или набор команд. Вспомним урок про генерацию случайных чисел: там была забавная задача для самостоятельного исследования. Вот её условие:

## Пример: Равномерность случайных чисел

Числа, генерируемые функцией rand(), имеют равномерное распределение. Это значит, что если запускать функцию rand очень много раз и каждый раз записывать, какое число выпало, то различные числа выпадут примерно одинаковое число раз.

Например, если генерировать только числа 0 и 1, то через 100 запусков примерно 50 раз выпадет ноль и 50 раз единичка. Обратите внимание, что я говорю примерно. Может быть, например, 49 и 51, или 53 и 47.

Если рассматривать отношение этих чисел к общему количеству генераций, получим 49/100 и 51/100 или 53/100 и 47/100. Но чем больше экспериментов мы проведём, тем отношение количества единичек к количеству испытаний будет ближе к 1/2.

Проведите самостоятельно эксперимент с 10, 50 и 100 запусками. Это муторно и долго, если делать руками, но что поделать? В будущем мы напишем программу, чтобы проверить свойство равномерности распределения этих псевдослучайных чисел.

Давайте проведём подобный эксперимент. Пусть программа генерирует одно из трёх чисел: 0, 1 или 2. Вот, посмотрите на её код.

_Листинг 1._

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main(void) { 
  
  srand(time(NULL));
// счётчики для сгенерированых чисел
// если выпадет 1, то увеличим на единицу count_1
  int count_0 = 0, count_1 = 0, count_2 = 0;

  int rand_number;
  
  rand_number = rand()%3;  
  switch (rand_number){
    case 0 : count_0 = count_0 + 1; break;
    case 1 : count_1 = count_1 + 1; break;
    case 2 : count_2 = count_2 + 1; break;
  }

  rand_number = rand()%3;  
  switch (rand_number){
    case 0 : count_0 = count_0 + 1; break;
    case 1 : count_1 = count_1 + 1; break;
    case 2 : count_2 = count_2 + 1; break;
  }

  rand_number = rand()%3;  
  switch (rand_number){
    case 0 : count_0 = count_0 + 1; break;
    case 1 : count_1 = count_1 + 1; break;
    case 2 : count_2 = count_2 + 1; break;
  }

  rand_number = rand()%3;  
  switch (rand_number){
    case 0 : count_0 = count_0 + 1; break;
    case 1 : count_1 = count_1 + 1; break;
    case 2 : count_2 = count_2 + 1; break;
  }

  rand_number = rand()%3;  
  switch (rand_number){
    case 0 : count_0 = count_0 + 1; break;
    case 1 : count_1 = count_1 + 1; break;
    case 2 : count_2 = count_2 + 1; break;
  }

  rand_number = rand()%3;  
  switch (rand_number){
    case 0 : count_0 = count_0 + 1; break;
    case 1 : count_1 = count_1 + 1; break;
    case 2 : count_2 = count_2 + 1; break;
  }

  rand_number = rand()%3;  
  switch (rand_number){
    case 0 : count_0 = count_0 + 1; break;
    case 1 : count_1 = count_1 + 1; break;
    case 2 : count_2 = count_2 + 1; break;
  }

  rand_number = rand()%3;  
  switch (rand_number){
    case 0 : count_0 = count_0 + 1; break;
    case 1 : count_1 = count_1 + 1; break;
    case 2 : count_2 = count_2 + 1; break;
  }

  rand_number = rand()%3;  
  switch (rand_number){
    case 0 : count_0 = count_0 + 1; break;
    case 1 : count_1 = count_1 + 1; break;
    case 2 : count_2 = count_2 + 1; break;
  }

  rand_number = rand()%3;  
  switch (rand_number){
    case 0 : count_0 = count_0 + 1; break;
    case 1 : count_1 = count_1 + 1; break;
    case 2 : count_2 = count_2 + 1; break;
  }

  printf("0 - %d\n1 - %d\n2 - %d\n", count_0, count_1, count_2);

  return 0;
}
```

Если вам непонятно, как работает данная программа, то проработайте уроки «Приручаем случайность» и «Оператор выбора».

Программа получилась объемной, но довольно простой. При этом легко видеть, что одни и те же операции (генерация случайного числа и оператор выбора) повторяются буквально без изменений. Результат работы этой программы на рисунке ниже.

![007](/StepikC/Pictures/007_001.png)

_Рис.1 Пример работы программы Листинг 1_

Как видите, пока что-то не очень похоже на то, что все цифры выпадают одинаковое количество раз. Запустите программу у себя, возможно, у вас получится более хороший результат. Ну, а мы продолжим. Давайте увеличим количество опытов до 100. Можно было бы, конечно, ещё 90 раз скопировать эту конструкцию или запустить программу ещё 9 раз и вручную складывать результаты, но это не дело. Лучше воспользуемся циклической конструкцией for.

[Содержание](#содержание)

<hr>

## Общий шаблон цикла for

_Листинг 2._

```c
for (инициализация счетчика; условие; изменение счетчика)
  оператор;
```

Цикл `for` состоит из двух частей: заголовок цикла (первая строка) и тело цикла (вторая строка).

__Тело цикла__ – это команда, которую необходимо выполнить несколько раз. Если необходимо выполнить несколько команд, а не одну, то можно воспользоваться составным оператором {}. Мы уже проделывали такой трюк, когда изучали условный оператор.

В нашем случае тело цикла for будет выглядеть так:

_Листинг 3._
```c
{
  rand_number = rand()%3;  
  switch (rand_number){
    case 0 : count_0 = count_0 + 1; break;
    case 1 : count_1 = count_1 + 1; break;
    case 2 : count_2 = count_2 + 1; break;
  }
}
```

Так как в теле цикла две команды (присваивание, оператор выбора), то пришлось использовать составной оператор.

Разберём подробно заголовок цикла `for`. В нём, кроме ключевого слова `for` и скобок, имеется ещё три выражения.

Первое выражение – инициализация счетчика.

В этой части нам нужно завести переменную-счетчик и присвоить ей какое-нибудь начальное значение. Например:

_Листинг 4._

```c
for (int i = 0; ; )  
// или
for (int j = 13; ; )
// или
for (int k = -100; ; )
// или
for (int m = 255; ; )
// или
for (int q = 1; ; )
```

Второе выражение – условие.

В этой части необходимо записать условное выражение, при котором должно выполняться тело цикла. Цикл for будет работать, пока условие истинно. Например:

_Листинг 5._

```c
for (int i = 0; i <= 100; )  
// или
for (int j = 13; j > 0; )
// или
for (int k = -100; k != 0; )
// или
for (int m = 255; m >= 0; )
// или
for (int q = 1; q < 1000; )
```

И последняя третья часть – изменение счетчика.

Здесь записывается то, что должно происходить после каждого выполнения тела цикла. Обычно здесь пишут то, как должен измениться счётчик после каждой итерации. Одно повторение тела цикла в серьёзных книгах иногда называют итерацией.

Например:

_Листинг 6._
```c
for (int i = 0; i <= 100; i = i + 1) // увеличиваем счётчик на единицу
// или
for (int j = 13; j > 0; j = j / 2) // уменьшаем вдвое 
// или
for (int k = -100; k != 0; k = k - 1) // уменьшаем счётчик на единицу
// или
for (int m = 255; m >= 0; m = m - 5) // уменьшаем счётчик на 5
// или
for (int q = 1; q < 1000; q = q * 2) //увеличиваем счётчик в два раза
```

Давайте перепишем нашу программу с использованием цикла `for`.

_Листинг 7._

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main(void) {   
  srand(time(NULL));
// счётчики для сгенерированных чисел
// если выпадет 0, то увеличим на единицу count_0
// аналогично для count_1 и count_2
  int count_0 = 0, count_1 = 0, count_2 =0;

  int rand_number;
  
  // i = 0 начинаем отсчёт с нуля
  // i < 100 повторяем, пока i меньше 100
  // i = i + 1 на каждом шаге увеличиваем счётчик на единицу
  // итого тело цикла выполнится 100 раз
  for (int i = 0; i < 100; i = i + 1){
    rand_number = rand()%3;  
    switch (rand_number){
      case 0 : count_0 = count_0 + 1; break;
      case 1 : count_1 = count_1 + 1; break;
      case 2 : count_2 = count_2 + 1; break;
    }
  }

  printf("0 - %d\n1 - %d\n2 - %d\n", count_0, count_1, count_2);
  return 0;
}
```

[Содержание](#содержание)

<hr>

## Алгоритм работы цикла `for`

Гораздо понятнее и нагляднее, не так ли? Вот-вот. Опишем подробно алгоритм работы цикла `for`.

1. Программа встречает ключевое слово `for`, а значит дальше идёт циклическая конструкция.
2. Сначала создаётся переменная счетчик (выражение 1).
3. Проверяется условие выполнение цикла (выражение 2).
4. Если условие ЛОЖЬ, то программа выходит из цикла `for` и продолжает свое выполнение.
5. Если условие ИСТИНА, то выполняется тело цикла.
6. Когда тело цикла выполнится, программа возвращается к заголовку и выполняет инструкции из третьей части заголовка. Изменяется значение переменной-счетчика (выражение 3).
7. Возвращаемся к пункту три.

А теперь то же самое для нашей программы. Встречаем цикл for.

+ Инициализируем переменную счётчик i = 0;
+ Проверяем условие i < 100. Т.к. i = 0, то условие ИСТИНА;
+ Выполняем тело цикла. Генерируем число от 0 до 2. В операторе switch определяем, какое число было сгенерировано, и увеличиваем соответствующий счётчик;
+ Т.к. тело цикла закончено, то выполняем Выражение 3. Теперь i = 1.
+ Возвращаемся к условию;
+ Проверяем условие i < 100. Т.к. i = 1, то условие ИСТИНА
+ Выполняем тело цикла. Генерируем число от 0 до 2. В операторе switch определяем, какое число было сгенерировано, и увеличиваем соответствующий счётчик;
+ Изменяем счётчик. Теперь i = 2. Возвращаемся к условию.

И так далее, пока i не станет равным 100. В этом случае при проверке условия получим ЛОЖЬ. Выполнение цикла прекратится. Программа продолжит выполнять инструкции, расположенные за циклом.

Давайте посмотрим ещё на один пример.

Напишем программу, которая выводит на экран сумму натуральных чисел из промежутка [A;B]. Числа A и B (B>A) вводятся пользователем.

_Листинг 8._

```c
#include <stdio.h>

int main(void) {

  int a = 0, b = 0;
  scanf("%d %d", &a, &b);

  // сюда будем записывать результат
  int sum = 0;
  
  
  // k++ эквивалентно k = k + 1, но короче
  // ++ оператор инкремента
  
  for (int k = a; k <= b; k++){
    sum = sum + k;
    // на каждой итерации добавляем к уже имеющейся сумме
    // очередное число
  }

  printf("%d\n", sum);

  return 0;
}
```

Все неясные моменты я постарался отразить в комментариях к программе. Если возникнут вопросы, то задавайте их в комментариях к уроку.


[Содержание](#содержание)

<hr>

# Циклы с условиями

Иногда заранее нельзя предсказать, какое количество раз должен выполниться цикл. Но при этом известно некоторое условие, когда цикл должен остановиться. Например:

Программа: Игральный кубик.

Программа заменяет обычный игральный кубик.

Управление:
```
1 -- бросить кубик;
0 -- закончить игру.
```

Давайте напишем заготовку для нашей игры.

_Листинг 1._

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main(void) {   
  srand(time(NULL));

  printf("###########  Devil\'s bones   ###########\n");
  printf("#                                      #\n");
  printf("#   Commands:                          #\n");
  printf("#                                      #\n");
  printf("#   1 - new game                       #\n");
  printf("#   0 - exit                           #\n");
  printf("#                                      #\n");
  printf("########################################\n\n");
  
  int control;
  int value = 0;
  printf("Enter command: ");
  scanf("%d", &control);
  
  if(control == 1){
    value = 1 + rand()%6;
    printf("Result: %d\n", value);
  }

  return 0;
}
```

Тут-то мы и сталкиваемся с проблемой. Понятно, что заранее узнать, когда игра закончится невозможно. А значит использовать цикл `for` напрямую не получится. Одним из выходов из подобной ситуации является использование других циклических конструкций. 

Например, цикла `while`.

[Содержание](#содержание)

<hr>

## Цикл с предусловием while

_Листинг 2._

```c
while (условие)
  оператор;
```

Работает эта конструкция следующим образом:
1. Программа встречает ключевое слово `while`, значит дальше идёт циклическая конструкция;
2. Проверяется условие. Вычисляется логическое выражение, записанное в скобках;
3. Если значение условия ИСТИНА, то выполняется тело цикла. Переходим к пункту 2;
4. Если значение условия ЛОЖЬ, то цикл завершается. Управление передаётся на оператор, следующий за телом цикла.

Под оператором понимается один оператор. Если нужно выполнить в цикле несколько команд, то необходимо использовать составной оператор {}.

Давайте перепишем нашу программу с использованием данного цикла.

_Листинг 3._

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main(void) {   
  srand(time(NULL));

  printf("###########  Devil\'s bones   ###########\n");
  printf("#                                      #\n");
  printf("#   Commands:                          #\n");
  printf("#                                      #\n");
  printf("#   1 - new game                       #\n");
  printf("#   0 - exit                           #\n");
  printf("#                                      #\n");
  printf("########################################\n\n");
  
  int control;
  int value = 0;

  printf("Enter command: ");
  scanf("%d", &control);
  while(control != 0){
    switch(control){
      case 1:
        value = 1 + rand()%6;
        printf("Result: %d\n", value);
        break;
      default: 
        printf("Error! Try again...\n");
        break;
    } 
    printf("Enter command: ");
    scanf("%d", &control);
  }

  printf("Good bye!\n");
  return 0;
}
```

[Содержание](#содержание)

<hr>

### Алгоритм работы цикла `while`

Опишем словами алгоритм работы данной программы:

1. Выводим меню пользователя и предложение ввести команду;
2. Считываем код команды в переменную control;
3. Запускаем цикл `while`. Проверяем условие;
4. Если пользователь ввёл 0, то условие выполнения цикла принимает значение ЛОЖЬ. Тело цикла не выполняется. Управление передаётся на следующий за циклом оператор. Выводится строка Good bye!. Программа завершается;
+ Оператор выбора:
    + Если пользователь ввёл 1, то генерируем случайное число от 1 до 6 и выводим его на экран. Выходим из оператора выбора;
    + Если пользователь ввёл что-то иное, выводим сообщение об ошибке. Выходим из оператора выбора.
+ Выводим пользователю предложение ввести новую команду;
+ Считываем код команды в переменную control;
+ Возвращаемся к проверке условия. Пункт 3.

Цикл `while` называют циклом с предусловием, т.к. прежде, чем выполнить тело цикла, проверяется условие. Это значит, например, что возможна такая ситуация, что тело цикла не выполнится вообще ни один раз. Другое название цикла `while` – цикла ПОКА. Дословный перевод с английского. Это название отображает саму суть цикла.

### Мнемоническое правило:

__ПОКА условие ИСТИНА, выполняй тело цикла.__

[Содержание](#содержание)

<hr>

## Цикл с постусловием do-while

И последняя, третья циклическая конструкция – цикл `do-while`.

Данный цикл отличается от цикла while тем, что условие проверяется не перед выполнением тела цикла, а после выполнения тела цикла. Это значит, что тело цикла do-while выполнится хотя бы один раз обязательно.

Синтаксис данной циклической конструкции таков:

_Листинг 4._

```c
do 
  оператор;
while (условие);
```

Работает эта конструкция следующим образом:
1. Программа встречает ключевое слово `do`. Значит перед ней цикл `do-while`;
2. Выполняется тело цикла;
3. Проверяется условие;
4. Если условие ИСТИНА,то снова выполняется тело цикла;
5. Если условие ЛОЖЬ, то работа циклической конструкции прекращается. Программы выполняет оператор, следующий за циклом do-while.

Давайте перепишем нашу программу с использованием данного типа циклической конструкции.

_Листинг 5._

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main(void) {   
  srand(time(NULL));

  printf("###########  Devil\'s bones   ###########\n");
  printf("#                                      #\n");
  printf("#   Commands:                          #\n");
  printf("#                                      #\n");
  printf("#   1 - new game                       #\n");
  printf("#   0 - exit                           #\n");
  printf("#                                      #\n");
  printf("########################################\n\n");
  
  int ch_control;
  int value = 0;

  do {
    printf("Input command: ");
    scanf("%d", &ch_control);

    switch(ch_control){
      case 0: break;
      case 1:
        value = 1 + rand()%6;
        printf("Result: %d\n", value);
        break;
      default: 
        printf("Error! Try again...\n");
        break;
    }
  }while(ch_control != 0);

  printf("Good bye!\n");
  return 0;
}
```

В общем-то очень похоже на предыдущий код. Правда, пришлось немножко поменять оператор выбора: добавить туда ветку `case 0:`. 

Иначе из-за того, что проверка производится после выполнения тела цикла, программа работала некорректно. При вводе нуля появлялось сообщение об ошибке. В прошлой программе (с циклом `while`) подобной ситуации быть не могло, т.к. равенство нулю проверялось в условии цикла. При вводе нуля условие стало бы ложью, а значит цикл завершился бы и тело цикла не выполнилось.

[Содержание](#содержание)

<hr>

# Операторы управления циклом. Зацикливание

Существует два оператора, которые позволяют управлять выполнением цикла. Это операторы break и continue.

Давайте рассмотрим их работу на следующем примере: Модифицируем программу из прошлого урока.

## Программа: Игральный кубик.

Программа заменяет обычный игральный кубик.

Управление:
```
1 -- бросить кубик;
0 -- закончить игру.
```

В конце игры программа должна выводить количество бросков кубика, сделанных в игре.
После 50 бросков программа автоматически завершается. Выводится сообщение "Game over!".

Код такой программы будет выглядеть следующим образом:

_Листинг 1._

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main(void) {   
  srand(time(NULL));

  printf("###########  Devil\'s bones   ###########\n");
  printf("#                                      #\n");
  printf("#   Commands:                          #\n");
  printf("#                                      #\n");
  printf("#   1 - new game                       #\n");
  printf("#   0 - exit                           #\n");
  printf("#                                      #\n");
  printf("########################################\n\n");
  
  int ch_control;
  int value = 0, score = 0;
 
  do {
    printf("Input command: ");
    scanf("%d", &ch_control);

    switch(ch_control){
      case 0: 
        score = score -1;
        break;
      case 1:
        value = 1 + rand()%6;
        printf("Result: %d\n", value);
        break;
      default: 
        printf("Error! Try again...\n");
        continue;   // прерываем текущую итерацию цикла
    }
    
    score = score + 1;
    
    if(score == 50){
      printf("Game over!\n"); 
      break;      // завершаем цикл
    }
  }while(ch_control != 0);
  
  printf("\n\nSCORE: %d\n\nGood bye!\n", score);
  return 0;
}
```

Давайте поясню некоторые новые операторы, которые там используются.

[Содержание](#содержание)

<hr>

## Оператор break

Оператор break прекращает выполнение цикла. Помните, мы уже использовали данную команду в операторе `switch`. Здесь всё точно так же. Мы используем данный оператор, чтобы выйти из цикла, когда произойдёт 50 бросков.

Важный момент. Оператор break работает и во всех циклических конструкциях, и в операторе выбора.

В нашем примере он используется и там, и там. Возникает вопрос: а как он решает, откуда надо выйти: из `switch` или из цикла. Очень просто.

Оператор `break` всегда завершает ближайший внешний оператор, внутри которого он находится.

Например, в нашей программе первый раз оператор `break` встречается в ветке `case 0`. Значит он находится внутри оператора `switch`, который находится внутри цикла do-while. Ближайший оператор, внутри которого он расположен, – это `switch`. Следовательно, завершается оператор `switch`. Аналогично и с другими ветками оператора `switch`.

Последний оператор `break` находится внутри `if`, который находится внутри цикла `do-while`. Т.к. на конструкцию `if` оператор `break` не действует, то ближайшим оператором, в котором он находится, является цикл `do-while`. Поэтому в этом случае `break` завершает цикл.

[Содержание](#содержание)

<hr>

## Оператор continue

Данный оператор применяется только внутри циклов. Он позволяет прервать текущую итерацию цикла. После того, как компьютер встречает оператор continue, он завершает исполнение тела цикла и переходит к проверке условия (в циклах `while` и `do-while`) или к изменению счётчика (выражение 3 в цикле `for`).

В нашей программе он используется для того, чтобы не учитывать плохие ходы. 

Например, пользователь ввёл число 2. Программа выдаёт ему сообщение об ошибке и сразу же переходит к проверке условия. 

При этом все команды ниже пропускаются, а значит не увеличивается счётчик ходов, и не проверяется превышение предела в 50 ходов на игру. Если здесь убрать оператор, то после вывода сообщения об ошибке тело цикла продолжит выполняться дальше и увеличится счётчик ходов.

[Содержание](#содержание)

<hr>

## Зацикливание

Иногда бывает так, что условие, при котором работа цикла должна прекратиться, никогда не выполняется. В таких случаях говорят, что программа «зациклилась».

Зачастую это происходит при использовании циклов `do-while` и `while`.

Пример: программа сложения пяти введённых чисел.

_Листинг 2._

```c
#include <stdio.h>

int main(void) {
  double sum = 0, temp = 0;
  int k = 0;
  
  do {
    scanf("%lf", &temp);
    sum = sum + temp;
  } while(k < 5);

  printf("%.3f", sum);
  return 0;
}
```

На первый взгляд всё верно, но попробуйте скомпилировать и запустить эту программу. Вы заметите, что она не спешит останавливаться после того, как мы ввели первые пять чисел.

Когда мы используем эти циклы, необходимо внимательно отслеживать, что переменные, входящие в условия цикла, в теле цикла хоть как-то изменяются.

В нашем примере допущена именно такая ошибка. Условие записано верно, переменная k (счётчик считанных чисел) объявлена и инициализирована, но внутри тела цикла мы забыли её увеличить. Поэтому нашему условию окончания цикла k < 5 не суждено стать истинным.

Не всегда подобные ошибки так очевидны, как в нашем случае. Поэтому будьте внимательны, когда используете циклы с условиями.

Давайте приведем нашу программу в рабочее состояние:

_Листинг 3._

```c
#include <stdio.h>

int main(void) {
  double sum = 0, temp = 0;
  int k = 1;
  
  do {
    scanf("%lf", &temp);
    sum = sum + temp;
    k = k + 1;
  } while(k <= 5);

  printf("%.3f", sum);
  return 0;
}
```

[Содержание](#содержание)

<hr>

# Задачи

## Написать программу выводящую на экран первые N натуральных чисел.

Входные данные:

Одно  целое число N, N>0

Выходные данные:

Первые N натуральных чисел, записанных через пробел.

```c
#include <stdio.h>

int main() {
    int N;
    scanf("%d", &N);

    for (int i =  1; i < N + 1; i++)
    {
        printf("%d%s", i, i < N ? " " : "");        
    }
    return 0;
}
```

[Содержание](#содержание)

<hr>

## Усовершенствуйте программу, написанную на прошлом шаге. Теперь необходимо вывести все натуральные числа из промежутка [K,M],(K<M)

Входные данные:
Два целых числа K,M. При этом M больше K.

Выходные данные:

Натуральные числа в порядке возрастания принадлежащие промежутку [K,M]. Числа нужно разделять одним пробелом.

```c
#include <stdio.h>

int main() {
    int K, M;
    scanf("%d%d", &K, &M);
    for (int i = K > 0 ? K : 1 ; i < M + 1; i++)
    {
            printf("%d%s", i, i < M ? " " : "");        
    }
    return 0;
}
```

[Содержание](#содержание)

<hr>

## Усовершенствовать программу, написанную на прошлом шаге: дополнительно на отдельной строке вывести количество напечатанных чисел.

Входные данные:

Два целых числа K,M. При этом M больше K.

Выходные данные:

Натуральные числа в порядке возрастания, принадлежащие промежутку [K,M]. 

Числа нужно разделять одним пробелом. 

На новой строке вывести количество выведенных натуральных чисел, а если натуральные числа отсутствуют -- ноль.

Уточнение:

На конце первой строки обязательно должен ставиться пробел.

```c
#include <stdio.h>

int main() {
    int K, M, res = 0;
    scanf("%d%d", &K, &M);
    for (int i = K > 0 ? K : 1 ; i < M + 1; i++)
    {
            printf("%d ", i);
            res++;        
    }
    printf("\n%d", res);
    return 0;
}
```

[Содержание](#содержание)

<hr>

## Вывести через пробел все целые числа из промежутка [A,B],(A<B) в обратном порядке: от B до A.

Входные данные:

Два целых числа A,B, при этом A<B.

Выходные данные:

Целые числа из промежутка от [A,B], записанные через пробел в обратном порядке.

```c
#include <stdio.h>

int main() {
    int A, B;
    scanf("%d%d", &A, &B);
    for (int i = B; i > A - 1; i--)
    {
            printf("%d ", i);
    }
    return 0;
}
```

[Содержание](#содержание)

<hr>

## Факториал.
Для целого числа k(0≤k≤12) посчитать k!.

Входные данные:

Одно целое число k, (0≤k≤12).

Выходные данные:

Значение факториала числа k.

```c
#include <stdio.h>

int main() {
    int K, res = 1;
    scanf("%d", &K);
    for (int i = 1; i < K + 1; i++)
    {
        res *=i;
    }
    printf("%d ", res);
    return 0;
}
```

[Содержание](#содержание)

<hr>

## Числа Фибоначчи
Последовательность чисел Фибоначчи определяется следующим образом:

$F_1 = 1, F_2  =1, F_3 = F_1 + F_2, … , F_k = F_{k−2} + F_{k−1}$.

Посчитать значение N-го числа Фибоначчи.

Входные данные:

Одно натуральное число N, (N≤45)

Выходные данные:

Значение N-го числа Фибоначчи.

```c
#include <stdio.h>

int main() {
    int N, res, N1 = 1, N2 = 1;
    scanf("%d", &N);
    for (int i = 1; i < N + 1; i++)
    {
        res = N1;
        N1 = N2;
        N2 = N2 + res;
    }
    printf("%d ", res);
    return 0;
}
```

[Содержание](#содержание)

<hr>

## Вывести все числа из промежутка [A;B],(B>A). При этом число A должно выводиться 1 раз, число A+1 -- два раза, A+2 -- три раза и т.д.

Входные данные:

Два натуральных числа A,B, таких, что (B>A).

Выходные данные:

Число A, два числа A+1, три числа A+2 и т.д. Каждое число занимает поле шириной в 5 символа, выравнивание по правому краю.

```c
#include <stdio.h>

int main() {
     int A, B, count = 1, i, j;
    scanf("%d%d", &A, &B);
    
    for (j = A; j < B + 1; j++)
    {
        for (int i = 0; i < count; i++)
        {
            printf("%5d", j);    
        }
        count++;
    }

    return 0;
}
```

[Содержание](#содержание)

<hr>

## Измените программу, написанную на прошлом шаге таким образом, чтобы каждое число выводилось столько раз, каково его значение. Например, число 5 раз.

Входные данные:

Два натуральных числа A,B, таких, что B>A.

Выходные данные:

A чисел A, A+1 чисел A+1 и т.д. 

Каждое число занимает поле шириной в 4 символа.

```c
#include <stdio.h>

int main() {
    int A, B;
    scanf("%d%d", &A, &B);
    
    for (int j = A; j < B + 1; j++)
    {
        for (int i = 0; i < j; i++)
        {
            printf("%4d", j);    
        }
    }
    return 0;
}
```

[Содержание](#содержание)

<hr>

## Делители
Для заданного числа n вывести все его делители и их количество на экран.

Входные данные:

Одно натуральное число N.

Выходные данные:

Делители числа N, записанные через один пробел в порядке возрастания .

Количество делителей на отдельной строке.

```c
#include <stdio.h>

int main() {
    int N;
    int count;

    count = 0;

    scanf("%d", &N);
    
    for (int j = 1; j < N / 2 + 1; j++) //достаточно проверить до половины N
    {
        if (N % j == 0)
        {
            printf("%d ", j);
            count++;
        }
    }
            printf("%d \n%d", N, count + 1); // добавим само число N и прибавим 1 к счетчику
    return 0;
}
```

[Содержание](#содержание)

<hr>

## Для заданного числа N проверить, является ли оно простым.

Входные данные:

Одно натуральное число N, отличное от 1.

Выходные данные:

1 -- если число простое<br>
0 -- если число составное<br>

```c
#include <stdio.h>

int main() {
    int N;

    scanf("%d", &N);
    
    for (int j = 2; j < N / 2 + 1; j++)
    {
        if (N % j)
        {
            continue;
        }
        else
        {
            printf("%d ", 0);
            return 0;
        }
    }
    printf("%d ", 1);
    return 0;
}
```

[Содержание](#содержание)

<hr>

## Гилл Байтс изучил циклы и решил написать программу, которая ищет максимальное среди чисел введённых пользователем. Предполагалось, что программа будет работать следующим образом.

Пользователь вводит точное количество чисел, которые он хочет сравнить, например 5. После этого вводит свои пять чисел по модулю не превышающих 100. Далее программа выдаёт ему максимальное среди них.

Гилл, как обычно, поторопился и допустил в программе некоторые ошибки. Помогите ему их исправить.

Обратите внимание на разработанный Гиллом алгоритм. 

Это стандартный алгоритм поиска максимального числа. 

Попытайтесь самостоятельно разобраться с тем, как он работает. 

Возникнут трудности пишите в комментарии к этому уроку.

```c
#include <stdio.h>

int main(void) 
{
    int N;
    scanf("%d", &N);

    int max = -999;
    int number;

    for (int i = 0; i < N; i++)
    {
        scanf("%d", &number);
        if (max < number)
        max = number;
    }

    printf("%d", max);

    return 0;
}
```

[Содержание](#содержание)

<hr>

## Последовательность

Вывести последовательность чисел, поступившую на вход.

Входные данные:

На вход программы поступает последовательность целых чисел. 

Количество чисел в последовательности заранее неизвестно. 

Но известно, что в конце последовательности записано число -9999 и в последовательности всегда есть хотя бы одно число, кроме -9999.

Выходные данные:
Вывести элементы последовательности на экран через пробел.

```c
#include <stdio.h>

int main() {
    
    int N;
    do
    {
    scanf("%d", &N);
    printf("%d ", N);

    } while (N != -9999);
    return 0;
}
```

[Содержание](#содержание)

<hr>

## Последовательность 2.
Вывести последовательность чисел, поступившую на вход.

Входные данные:
На вход программы поступает последовательность целых чисел. Количество чисел в последовательности заранее неизвестно, но зато известно, что в конце последовательности записано число -9999 и в последовательности всегда есть хотя бы одно число.

Выходные данные:
Вывести все элементы последовательности, кроме заключительного -9999, на экран.

```c
#include <stdio.h>

int main() {
    int N;
    while (1)
    {
    scanf("%d", &N);
        if (N == -9999)
        {
            return 0;
        }
        else
        {
            printf("%d ", N);
        }
    }  
  return 0;
}
```

[Содержание](#содержание)

<hr>

## Последовательность 3
Вывести последовательность чисел, поступившую на вход.

Входные данные:

На вход программы поступает последовательность целых чисел. 

Количество чисел в последовательности заранее неизвестно. 

Но известно, что в конце последовательности записано число -9999 и последовательность может состоять из единственного числа -9999.

Выходные данные:
Вывести все элементы последовательности, кроме заключительного -9999, на экран.

```c
#include <stdio.h>

int main() {
    int N;
    while (1)
    {
    scanf("%d", &N);
        if (N == -9999)
        {
            return 0;
        }
        else
        {
            printf("%d ", N);
        }
    }  
  return 0;
}
```

[Содержание](#содержание)

<hr>

## Сумма элементов последовательности
Вычислить сумму элементов последовательности неизвестной длины.

Входные данные:

Последовательность целых чисел, оканчивающаяся нулём.

Выходные данные:

Одно целое число -- сумма всех элементов последовательности.

```c
#include <stdio.h>

int main() {
    int N;
    int result;

    result = 0;

    while (1)
    {
    scanf("%d", &N);
        if (N == 0)
        {
            printf("%d", result);
            return 0;
        }
        else
        {
            result +=N;
        }
    } 
  return 0;
}
```

```c
#include <stdio.h>

int main(void) {
  int number, sum = 0;

  do {
    scanf("%d", &number);
    sum += number; 
  } while (number);
  
  printf("%d\n", sum);
  return 0;
}
```

[Содержание](#содержание)

<hr>

## Максимум и минимум

Необходимо найти максимальный и минимальный элемент последовательности, неизвестной длины.

Входные данные:

Последовательность целых чисел, оканчивающаяся нулём. Само число нуль не является членом последовательности, а является лишь сигналом того, что достигнут конец последовательности. В последовательности есть как минимум одно ненулевое число.

Выходные данные:

Вывести два целых числа M и m, где M - максимальный элемент последовательности, m - минимальный элемент последовательности.

```c
#include <stdio.h>
#include <limits.h>

int main(void) {
    int N;
    int max;
    int min;

    max = INT_MIN;
    min = INT_MAX;

    while (1)
    {
    scanf("%d", &N);
    if (N == 0)
        {
            printf("%d %d", max, min);
            return 0;
        }
    if (N > max)
        {
            max = N;
        }
    if (N < min && N != 0)
        {
            min = N;
        }
}
    return 0;
}
```

```c
#include <stdio.h>

int main() {
    int n, min, max;
    scanf("%d", &n);
    max = min = n;
    do {
        if (n>max) max = n;
        if (n<min) min = n;
        scanf("%d", &n);
    }
    while(n);
    printf("%d %d", max, min);
}
```

[Содержание](#содержание)

<hr>

## Точные квадраты
Выведите на экран все точные квадраты натуральных чисел, не превосходящие данного числа N. Выводить квадраты следует от меньшего к большему.

Входные данные:

Одно целое число N. (1≤N≤10000)

Выходные данные:

Квадраты натуральных чисел, записанные через пробел.

```c
#include <stdio.h>

int main() {
    int n, i = 1;
    scanf("%d", &n);
    while (i*i <= n) {
        printf("%d ", i*i);
        i++;
    }
}
```

```c
#include <stdio.h>
#include <math.h>

int main() {
    int N;

    scanf("%d", &N);

    for (int i = 1; i < N + 1; i++)
    {
        if ( sqrt(i) - (int) sqrt(i) == 0)
        {
            printf("%d ", i);
        }    
    }
  return 0;
}
```

[Содержание](#содержание)

<hr>

## Степень двойки
По данном числу N определить, является ли оно степенью числа 2.

Входные данные:

Одно целое неотрицательное число N.

Выходные данные:

YES -- если число N является степенью двойки, и NO в противном случае.

```c
#include <stdio.h>

int main()
{
    double n;
    scanf("%lf", &n);
    while(n > 1)
        n /= 2;
    if(n == 1)
        printf("YES");
    else
        printf("NO");
    return 0;
}
```

```c
#include <stdio.h>

int main() {
    int N;
    int temp;
    int power;

    scanf("%d", &N);
    
    power = 0;
    temp = N;

    while (N > 1)
    {
        N /=2;
        power++;
    }
    
    printf("%s", temp == (int) pow(2, power)? "YES": "NO");
    return 0;
}
```

[Содержание](#содержание)

<hr>

## Количество цифр + описание %n функции scanf()

Подсчитать количество цифр в записи натурального числа N.

Входные данные:

Одно натуральное число N.

Выходные данные:

Одно целое число k -- количество цифр в записи числа N.

```c
#include <stdio.h>

int main() {
    int N;
    int result;
    
    result = 0;
    
    scanf("%d", &N);
    
    while (N > 0)
    {
        N /= 10;
        result++;
    }
    
    printf("%d", result);
  return 0;
}
```

согласно описанию функции (например http://www.cplusplus.com/reference/cstdio/scanf/ или http://www.c-cpp.ru/content/scanf) <br>
%d - Считать десятичное число целого типа<br>
%n - Принимает целое значение, равное количеству считанных до текущего момента символов<br>
таким образом, функция при работе сама содержит счётчик полученных символов, если запросить её об этом при помощи спецификатора `%n` и просто предоставить место, куда она результат счётчика выведет , что и сделано при помощи `&j` в дополнении к месту под собственно само считанное число `&i`

```c
#include <stdio.h>

int main() {
  int i, j;
  scanf("%d%n", &i, &j);
  printf("%d", j);
}
```

[Содержание](#содержание)

<hr>

## Степени двойки
По заданному N вывести через пробел все (натуральные, т.е. 1,2,3,… ) степени числа 2, для которых  $2^k ≤N$.

Входные данные:

Натуральное число N, причем N<30000.

Выходные данные:

Натуральные числа от 1 до p, такие, что если посчитать $2^p$ , то получится число не превосходящее N.

```c
#include <stdio.h>

int main() {
    int N;
    int result;

    result = 1;
    
    scanf("%d", &N);
    
    while (pow(2, result) < N + 1)
    {
        printf("%d ", result);
        result++;
    }
  return 0;
}
```

```c
#include <stdio.h>
int main(void) {
    int n, c = 0;
    scanf("%d", &n);  
    while(n/=2) printf("%d ", ++c);
}
```

[Содержание](#содержание)

<hr>

## Дано натуральное число N. Найти наименьшее натуральное число r, такое, что $2^r ≥N$.

Входные данные:

Одно натуральное число N.

Выходные данные:

Число r.

```c
#include <stdio.h>

int main() {
    int N;
    int result;

    result = 1;
    
    scanf("%d", &N);
    
    while (pow(2, result) < N)
    {
        result++;
    }

    printf("%d ", result);
    return 0;
}
```

[Содержание](#содержание)

<hr>

## Перевёртыш
Напишите программу, которая по данному натуральному N печатает его цифры в обратном порядке.

Входные данные:

Одно натуральное число N.

Выходные данные:
Цифры числа N, записанные в обратном порядке.

```c
#include <stdio.h>

int main() {
    int N;
    
    scanf("%d", &N);
    
    while (N > 0)
    {
        printf("%d", N % 10);        
        N/=10;
    }
  return 0;
}
```

```c
#include <stdio.h>

int main() {
    int n;
    scanf("%d", &n);
    do{
        printf("%d", n%10);
    }
    while(n/=10);
    
  return 0;
}
```

[Содержание](#содержание)

<hr>

## Экспонента с заданной точностью

Вычислить число $e = 1 + \dfrac{1}{1!} + \dfrac{1}{2!} + \dfrac{1}{3!} + \dfrac{1}{4!} + …$ с точностью  ε.

Входные данные:

Вещественное число $ε,(10^{−9} <= ε <= 10^{−1})$ .

Выходные данные:

Значение числа e с точностью ϵ (8 знаков после запятой). Считать, что достигнута точность ε, если очередной член последовательности меньше ε, т.е. $ \dfrac{1}{k!} < ε$

```c
#include <stdio.h>

int main() {
    double e;
    double eps;
    double k;
    double fact;

    e = 0;
    k = fact = 1.0L;
    
    scanf("%lf", &eps);
    
    while (1)
    {
        e += 1/fact;
        fact *= k++;
        if (1/fact < eps)
        {
            printf("%.8lf", e + 1/fact);
            return 0;
        }
    }

  return 0;
}
```

```c
#include <stdio.h>

int main() {
    double e, s=1, f=1, i=1; 
    scanf("%lf", &e);
    while((1/f)>e){
        f = f*i;
        s = s+1/f;
        i++;
    }
  printf("%.8lf", s);
  return 0;
}
```

[Содержание](#содержание)

<hr>

## Быстрое возведение в степень
Гилл Байтс на последнем занятии по информатике изучал алгоритм быстрого возведения числа a в степень k. Он основывается на следующем свойстве степени: $a^{2k} =a^k \cdot a^k$

Например, при нахождении чётной степени $a^4$ вместо последовательного вычисления $a^2, a^3$ и $a^4$ можно после вычисления $a^2$ умножить это число само на себя и получить сразу $a^4$. При нахождении нечётной степени, например, $a^5 можно действовать по тому же алгоритму, но получив $a^4 домножить результат на a.

Гилл решил обязательно запрограммировать этот алгоритм. Благо он уже прошёл тему циклы и быстро смог написать программу, реализующую подобный трюк. Вот её код:

```c
#include <stdio.h>

int main(void) {
  int a = 0, k = 0;
  int res = 0;

  scanf("%d %d", &a, &k);
  res = 1;
//пока степень больше нуля
  while(k > 0){
// если степень чётная, то
    if (k%2 == 0){   
      res = res*res; // умножаем текущий результат на себя
      k = k/2;  // степень делим пополам
    }else { //если степень нечётная
      res = res * a; // то умножаем на исходное число
      k = k - 1;   // от степени вычитаем единицу
   }
 }
  printf("%d\n", res);

  return 0;
}
```

Он запустил свою программу и ввёл "2 3", программа выдала 8. При вводе 2 5 вывод был 32. Гилл решил показать свою программу преподавателю. Но преподаватель ввёл 2 6 и в ответ программа выдала 8. Разберитесь в алгоритме, который написал Гилл и исправьте программу так, чтобы она работала верно.

 

Входные данные:

Два натуральных числа a и k.

Выходные данные:

Одно целое число, равное $a^k.

Примечание:

Можно воспользоваться функцией pow. Задание вы выполните, но в алгоритме не разберётесь. Как поступить решать вам.

задание действительно сложное, если не получается, можете посмотреть описание данного алгоритма в интернете

[Содержание](#содержание)

<hr>

## Наименьшее общее кратное

В Институте биоинформатики между информатиками и биологами устраивается соревнование. Победителям соревнования достанется большой и вкусный пирог. В команде биологов a человек, а в команде информатиков — b человек. Нужно заранее разрезать пирог таким образом, чтобы можно было раздать кусочки пирога любой команде, выигравшей соревнование, при этом каждому участнику этой команды должно достаться одинаковое число кусочков пирога. И так как не хочется резать пирог на слишком мелкие кусочки, нужно найти минимальное подходящее число. Напишите программу, которая помогает найти это число.

Входные данные:

два положительных целых числа a и b

Выходные данные:

Наименьшее число d, которое делится на оба этих числа без остатка

Источник:

Курс [Программирование в python](https://stepik.org/lesson/3364/step/12?unit=947).

[Содержание](#содержание)

<hr>

[Содержание курса](/StepikC/README.md)