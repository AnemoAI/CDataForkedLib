#  Функции и указатели

## Содержание

+ [Справочники стандартных функций Си](#справочники-стандартных-функций-си)
+ [Пользовательские функции в Си](#пользовательские-функции-в-си)
    + [Как устроены функции](#пользовательские-функции-в-си)
    + [Как создать свою функцию](#как-создать-свою-функцию)
+ [Область видимости и время жизни переменных](#область-видимости-и-время-жизни-переменных)
+ [Указатели в Си](#указатели-в-си)
+ [Передача аргументов в функцию](#передача-аргументов-в-функцию)
    + [Передача массивов в функцию](#передача-массивов-в-функцию)
+ [Задачи](#задачи)
    + [Сумматор](#сумматор)
    + [Минимум](#минимум)
    + [Минимум-2](#минимум-2)
    + [Факториал](#факториал)
    + [Число сочетаний](#число-сочетаний)
    + [Последовательные множители](#последовательные-множители)
    + [Квадрат](#квадрат)
    + [Форматирование даты](#форматирование-даты)
    + [Делители числа](#делители-числа)
    + [Переделайте функцию, написанную в прошлом уроке, таким образом, чтобы она возвращала число 1, если число K простое, или 0, если число K не является простым](#переделайте-функцию-написанную-в-прошлом-уроке-таким-образом-чтобы-она-возвращала-число-1-если-число-k-простое-или-0-если-число-k-не-является-простым)
    + [В программе имеются две целочисленные переменные a и b. Объявите два указателя с именами p_a и p_b, которые ссылаются на соответствующие переменные](#в-программе-имеются-две-целочисленные-переменные-a-и-b-объявите-два-указателя-с-именами-p_a-и-p_b-которые-ссылаются-на-соответствующие-переменные)
    + [В программе имеются символьные переменные ch и inp. Объявите  указатель с именем p_ch, который ссылается на переменную ch, и присвойте ей значение переменной inp](#в-программе-имеются-символьные-переменные-ch-и-inp-объявите-указатель-с-именем-p_ch-который-ссылается-на-переменную-ch-и-присвойте-ей-значение-переменной-inp)
    + [В программе объявлены две переменные целого типа. На каждую из них ссылается указатель. На первую ссылается указатель p_1, а на вторую указатель p_2](#в-программе-объявлены-две-переменные-целого-типа-на-каждую-из-них-ссылается-указатель-на-первую-ссылается-указатель-p_1-а-на-вторую-указатель-p_2)
    + [Даны два указателя по тем же правилам, что и в предыдущей задаче](#даны-два-указателя-по-тем-же-правилам-что-и-в-предыдущей-задаче)
    + [В программе объявлены две переменные целого типа. На каждую из них ссылается указатель. На первую ссылается указатель p_1, а на вторую указатель p_2. Кроме того, объявлена переменная типа double и указатель на неё p_dbl](#в-программе-объявлены-две-переменные-целого-типа-на-каждую-из-них-ссылается-указатель-на-первую-ссылается-указатель-p_1-а-на-вторую-указатель-p_2-кроме-того-объявлена-переменная-типа-double-и-указатель-на-неё-p_dbl)
    + [В программе объявлены два указателя p_1 и p_2, которые ссылаются на некоторые переменные. Присвойте переменной на которую ссылается указатель p_1, значение переменной c, а переменной, на которую ссылается указатель p_2, значение переменной d](#в-программе-объявлены-два-указателя-p_1-и-p_2-которые-ссылаются-на-некоторые-переменные-присвойте-переменной-на-которую-ссылается-указатель-p_1-значение-переменной-c-а-переменной-на-которую-ссылается-указатель-p_2-значение-переменной-d)
    + [Гилл Байтс написал программу, которая меняет значения двух целочисленных переменных местами. При этом, он поспорил со своим другом Стэном Добсом, что сможет сделать это, используя лишь указатели на данные переменные и дополнительную переменную temp](#гилл-байтс-написал-программу-которая-меняет-значения-двух-целочисленных-переменных-местами-при-этом-он-поспорил-со-своим-другом-стэном-добсом-что-сможет-сделать-это-используя-лишь-указатели-на-данные-переменные-и-дополнительную-переменную-temp)
    + [В программе объявлены три целочисленные переменные и указатели на них. Используя лишь указатели, найти среди переменных переменную с минимальным значением. Затем остальным переменным присвоить это значение](#в-программе-объявлены-три-целочисленные-переменные-и-указатели-на-них-используя-лишь-указатели-найти-среди-переменных-переменную-с-минимальным-значением-затем-остальным-переменным-присвоить-это-значение)
    + [Написать функцию void swap(int * x, int * y), которая меняет значения переменных местами](#написать-функцию-void-swapint--x-int--y-которая-меняет-значения-переменных-местами)
    + [Написать функцию void sum_digits(int * x), которая заменяет число x на сумму цифр из которых состоит число x](#написать-функцию-void-sum_digitsint--x-которая-заменяет-число-x-на-сумму-цифр-из-которых-состоит-число-x)
    + [Написать функцию void minmax(int * x, int * y), записывающую в переменную x минимальное из значений x и y, а в переменную y -- максимальное из этих значений](#написать-функцию-void-minmaxint--x-int--y-записывающую-в-переменную-x-минимальное-из-значений-x-и-y-а-в-переменную-y----максимальное-из-этих-значений)
    + [Написать функцию void char_register(char * ch, int fl), которая переводит переданный ей символ ch (символ латинского алфавита) в заданный переменной fl регистр: 0 — нижний, 1 — верхний](#написать-функцию-void-char_registerchar--ch-int-fl-которая-переводит-переданный-ей-символ-ch-символ-латинского-алфавита-в-заданный-переменной-fl-регистр-0--нижний-1--верхний)
    + [Шифр Цезаря](#шифр-цезаря)


[Содержание курса](/StepikC/README.md)

# Справочники стандартных функций Си

В прошлых уроках мы изучили много различных стандартных функций. Ещё больше их можно найти в каком-нибудь учебнике или справочнике по языку Си. 

Таких учебников и справочников великое-превеликое множество, возможно, и на этом сайте когда-нибудь появится подобный справочник, но это сейчас не очень важно. Важнее разобраться с тем, как с этими справочниками работать. Для примера я выбрал справочник, который стоит на первой позиции в гугле по запросу «справочник по функциям Си». Вот описание из справочника для функции `abs`.

_Листинг 1._

```c
Описание
  Вычисляет  абсолютное  значение  целого  аргумента.

Использование
#include <stdlib.h>
int abs(int i);                          /* ANSI */

Возвращаемое значение
  Возвращает абсолютное значение целого аргумента.

Пример
#include <stdlib.h>
#include <stdio.h>
main () {
  int numbr, absval;
  numbr = -3;
  absval= abs(numbr);
  printf("abs от (%d) равно %d\n",
  numbr,absval); 
}

Рекомендация
  Смотрите labs.
```

Остановимся подробнее на содержимом отдельных блоков.

Блок `Описание` обычно присутствует в любом справочнике и содержит описание того, для чего предназначена данная функция.

В блоке `Использование` указан заголовочный файл, который требуется подключить, чтоб использовать данную функцию. Кроме того, здесь же указано, какие параметры должны быть переданы функции для работы и тип значения, которое она вернёт.

Блок `Возвращаемое` значение описывает, что вернёт функция. В случае такой простой функции, как `abs`, данный блок в принципе не нужен, т.к. и так понятно, что возвращает эта функция.

Дальше есть отдельный блок `Пример`, в котором представлена маленькая демонстрационная программа, использующая описываемую функцию.

Это, в принципе, основные блоки, которые обычно присутствуют в любом справочнике. Могут быть и другие блоки, в которых указана дополнительная информация о функции. Например, переносимость или похожие функции и т.п.

В общем со стандартными функциями всё ясно. А вот пользовательские функции мы обсудим в этом уроке. И первое, что мы сделаем, так это ответим на вопрос «Зачем нужны пользовательские функции?»

[Содержание](#содержание)

<hr>

# Пользовательские функции в Си

Итак, зачем нужны пользовательские функции? 

Пользовательские функции нужны для того, чтобы программистам было проще писать программы.

Помните, мы говорили о парадигмах программирования, а точнее о структурном программировании. Основной идеей там было то, что любую программу можно написать используя только три основных конструкции: следование, условие и цикл. Теперь к этим конструкциям мы добавим ещё одну – «подпрограммы» – и получим новую парадигму __процедурное программирование__».

Отличие лишь в том, что отдельные кусочки нашей основной программы (в частности, повторяющиеся) мы будем записывать в виде отдельных функций (подпрограмм, процедур) и по мере необходимости их вызывать. По сути, программа теперь будет описывать взаимодействие различных функций.

В принципе, мы уже используем эту парадигму. Если вам пока ещё не совсем ясно, почему это проще, то просто представьте, что вместо того чтобы вызвать функцию `exp(x)` из заголовочного файла `math.h` вам каждый раз необходимо было бы описывать подробно, как вычислить значение этой функции.

Итак, в этом уроке мы подробно обсудим то, как функции устроены изнутри. А также научимся создавать свои собственные пользовательские функции.

[Содержание](#содержание)

<hr>

## Как устроены функции
Вспомним информацию с первого урока. Все функции, в том числе и те, которые пишет пользователь, устроены сходным образом. У них имеется две основных составных части: заголовок функции и тело функции.

_Листинг 1._

```c
int main(void){  // заголовок функции

// в фигурных скобках записано тело функции

}
```

С телом функции всё ясно: там описывается алгоритм работы функции. Давайте разберёмся с заголовком. Он состоит из трёх обязательных частей:
+ тип возвращаемого значения;
+ имя функции;
+ аргументы функции.

Сначала записывается тип возвращаемого значения, например, `int`, как в функции `main`. 

Если функция не должна возвращать никакое значение в программу, то на этом месте пишется ключевое слово `void`. 

Казалось бы, что раз функция ничего не возвращает, то и не нужно ничего писать. Раньше, кстати, в языке Си так и было сделано, но потом для единообразия всё-таки добавили. Сейчас современные компиляторы будут выдавать предупреждения/ошибки, если вы не укажете тип возвращаемого значения.

В некоторых языках программирования функции, которые не возвращают никакого значения, называют процедурами (например, pascal). Более того, для создания функций и процедур предусмотрен различный синтаксис. В языке Си такой дискриминации нет.

После типа возвращаемого значения записывается имя функции. Ну а уж после имени указываются типы и количество аргументов, которые передаются в функцию.

Давайте посмотрим на заголовки уже знакомых нам функций.

_Листинг 2._

```c
// функция с именем srand, принимающая целое число, ничего не возвращает
void srand(int)

//функция с именем sqrt, принимающая вещественное число типа float, возвращает вещественное число типа float
float sqrt(float)

//функция с именем rand, которая не принимает аргументов, возвращает целое число
int rand(void)

//функция с именем pow, принимающая два аргумента типа double, возвращает вещественное число типа double
double pow(double, double)
```

[Содержание](#содержание)

<hr>

## Как создать свою функцию
Для того чтобы создать свою функцию, необходимо её полностью описать. Тут действует общее правило: прежде чем использовать – объяви и опиши, как должно работать. Для этого вернёмся к схеме структуры программы на языке Си, которая у нас была в самом первом уроке. Отметим на ней те места, где можно описывать функции.

![010](/StepikC/Pictures/010_001.png)

_Рис.1 Уточнение структуры программы. Объявление функций._

Как видите, имеется аж два места, где это можно сделать.

Давайте посмотрим на пример, который иллюстрируют создание пользовательской функции вычисления максимального из двух чисел.

_Листинг 3._

```c
#include <stdio.h>

// объявляем пользовательскую функцию с именем max_num
// вход: два целочисленных параметра с именами a и b 
// выход: максимальное из двух аргументов
int max_num(int a, int b){
  int max = b;
  if (a > b) 
    max = a;

  return max;
}

//основная программа
int main(void) {
  int x = 0, y = 0;
  int  m = 0;

  scanf("%d %d", &x, &y);

  m = max_num(x,y);

  printf("max(%d,%d) = %d\n",x,y,m);

  return 0;
}
```

Давайте я подробно опишу, как будет работать эта программа. 
+ Выполняется тело функции `main`.
+ Создются целые переменные `x`, `y` и `m`. 
+ В переменные `x` и `y` считываются данные с клавиатуры. Допустим мы ввели 3 5, тогда `x` = 3, `y` = 5. Это вам всё и так должно быть понятно. Теперь следующая строчка

_Листинг 4._

```c
m = max_num(x,y);
```

Переменной `m` надо присвоить то, что находится справа от знака `=`. 

Там у нас указано имя функции, которую мы создали сами. 

Компьютер ищет объявление и описание этой функции. Оно находится выше. 

Согласно этому объявлению данная функция должна принять два целочисленных значения. В нашем случае это значения, записанные в переменных x и y. Т.е. числа 3 и 5. 

Обратите внимание, что в функцию передаются не сами переменные x и y, а только значения (два числа), которые в них хранятся. То, что на самом деле передаётся в функцию при её вызове в программе, называется фактическими параметрами функции.

Теперь начинает выполняться функция `max_num`. 

+ Первым делом для каждого параметра, описанного в заголовке функции, создается отдельная временная переменная. В нашем случае создаются две целочисленных переменных с именами a и b.
+ Этим переменным присваиваются значения фактических параметров. Сами же параметры, описанные в заголовке функции, называются формальными параметрами.
+ Итак, формальным параметрам a и b присваиваются значения фактических параметров 3 и 5 соответственно.
+ Теперь a = 3, b = 5. Дальше внутри функции мы можем работать с этими переменными так, как будто они обычные переменные.
+ Создаётся целочисленная переменная с именем max, ей присваивается значение b.
+ Дальше проверяется условие a > b.
+ Если оно истинно, то значение в переменной max следует заменить на a.
+ Далее следует оператор return, который возвращает в вызывающую программу (функцию main) значение, записанное в переменной max, т.е. 5. 
+ После чего переменные a, b и max удаляются из памяти.
+ А мы возвращаемся к строке

_Листинг 5._

```c
m = max_num(x,y);
```

Функция `max_num` вернула значение 5, значит теперь справа от знака = записано 5. 

Это значение записывается в переменную m. Дальше на экран выводится строчка, и программа завершается.

Внимательно прочитайте последние 4 абазаца ещё раз, чтобы до конца уяснить, как работает программа.

А я пока расскажу, зачем нужен нижний блок описания функций. 

Представьте себе, что в вашей программе вы написали 20 небольших функций. И все они описаны перед функцией main. Не очень-то удобно добираться до основной программы так долго. Чтобы решить эту проблему, функции можно описывать в нижнем блоке.

Но просто так перенести туда полностью код функции не удастся, т.к. тогда нарушится правило: прежде чем что-то использовать, необходимо это объявить. Чтобы избежать подобной проблемы, необходимо использовать прототип функции.

Прототип функции полностью повторяет заголовок функции, после которого стоит ;. Указав прототип в верхнем блоке, в нижнем мы уже можем полностью описать функцию. Для примера выше это могло бы выглядеть так:

_Листинг 6._

```c
#include <stdio.h>

int max_num(int, int);

int main(void) {
    int x =0, y = 0;
    int  m = 0;

    scanf("%d %d", &x, &y);

    m = max_num(x,y);

    printf("max(%d,%d) = %d\n",x,y,m);

    return 0;
}

int max_num(int a, int b){
    int max = b;
    if (a > b) 
        max = a;

    return max;
}
```

Всё очень просто. __Обратите внимание__, что у прототипа функции можно не указывать имена формальных параметров, достаточно просто указать их типы. В примере выше я именно так и сделал.

[Содержание](#содержание)

<hr>

# Область видимости и время жизни переменных

Каждая переменная кроме имени, типа данных и значения имеет ещё одну характеристику – __область видимости переменной__. 

Область видимости переменной – это участок кода программы, в котором данная переменная доступна для использования.

Рассмотрим пример, написанный ранее.

_Листинг 1._

```c
#include <stdio.h>

int max_num(int a, int b){
    int max = b;
    if (a > b) 
        max = a;

    return max;
}

int main(void) {
    int x =0, y = 0;
    int  m = 0;

    scanf("%d %d", &x, &y);

    m = max_num(x,y);
    
    printf("max(%d,%d) = %d\n",x,y,m);

    return 0;
}
```

В этом коде переменные `a`, `b` и `max` доступны для использования только внутри функции `max_num`. А переменные `x`,`y` и `m` – внутри функции `main`. Область видимости этих переменных – тело функции, в которой они объявлены. Это означает, к примеру, что мы не можем избавиться от переменной `max` внутри функции `max_num` и присваивать значение сразу переменной m. Т.е. вот такой код работать не будет:

_Листинг 2._

```c
#include <stdio.h>

void max_num(int a, int b){
    m = b;
    if (a > b) 
        m = a;
}

int main(void) {
    int x =0, y = 0;
    int  m = 0;

    scanf("%d %d", &x, &y);

    max_num(x,y);
    
    printf("max(%d,%d) = %d\n",x,y,m);

    return 0;
}
```

Если вы попытаетесь его скомпилировать, то компилятор будет ругаться на несуществующую переменную `m` внутри функции `max_num`.

Решить эту проблему довольно просто. Достаточно объявить переменную `m` вне всех функций, сразу после директив препроцессора.

_Листинг 3._

```c
#include <stdio.h>

int m = 0;

void max_num(int a, int b){
    m = b;
    if (a > b) 
        m = a;
}

int main(void) {
    int x =0, y = 0;

    scanf("%d %d", &x, &y);

    max_num(x,y);
  
    printf("max(%d,%d) = %d\n",x,y,m);

    return 0;
}
```

Переменные, объявленные таким образом, называются глобальными, т.к. доступ к ним возможен из любого места в этом файле (доступны глобально). Те переменные, которые мы использовали ранее, называются локальными, т.к. они доступны только в некоторых местах программы (доступны локально).

![010](/StepikC/Pictures/010_002.png)

_Рис.1 Область видимости переменных (глобальные и локальные)_

К локальным относятся также переменные, объявленные, например, внутри тела цикла. Возможно, вы замечали, что если в программе два цикла for, то в каждом из них счётчик может иметь имя i и объявляться в заголовке цикла.

_Листинг 4._

```c
#include <stdio.h>

int main(void) {
    int x[10] = {1,4,34,53,1,92,4,8,2,44};
    int min = 99999;
    int max = -99999;

    for(int i = 0; i<10; i++){
        if (x[i] < min)
        min = x[i];
    }

    for(int i = 0; i<10; i++){
        if (x[i] > max)
        max = x[i];
    }

    printf("max: %d\tmin: %d\n",max,min);

    return 0;
}
```

Дело как раз в области видимости и времени жизни локальных переменных. Каждый раз при создании цикла создаётся новая переменная с именем i. На протяжении всего тела цикла данная переменная доступна для использования, т.е. её область видимости – это блок тело цикла. После того как цикл завершается, эта переменная удаляется из памяти. Её время жизни – время работы цикла. Для переменных, объявленных внутри функции, время жизни переменных – время выполнения данной функции.

![010](/StepikC/Pictures/010_003.png)

_Рис.2 Область видимости переменных объявленных в цикле_

Если нам не жалко ресурсов памяти, то мы могли бы сделать вот так:

_Листинг 5._

```c
#include <stdio.h>

int main(void) {
    int x[10] = {1,4,34,53,1,92,4,8,2,44};
    int min = 99999;
    int max = -99999;

    int i;

    for(i = 0; i<10; i++){
        if (x[i] < min)
        min = x[i];
    }

    for(i = 0; i<10; i++){
        if (x[i] > max)
        max = x[i];
    }

    printf("max: %d\tmin: %d\n",max,min);

    return 0;
}
```

В этом случае создаётся одна переменная i, которая в дальнейшем используется во всех циклах. Попробуйте добавить вывод на экран значения переменной i между циклами. В первом случае должна появиться ошибка, т.к. переменная i существует только внутри циклов, а во втором случае всё будет нормально и значение i будет равно 10.

[Содержание](#содержание)

<hr>

# Указатели в Си

__Указатель__ – переменная, в которой хранится адрес какого-либо объекта в памяти компьютера, например, другой переменной. Мы уже сталкивались раньше с адресами переменных, когда изучали функцию scanf.

Итак, пойдём по порядку. Объявление указателя.

Объявление указателя отличается от объявления переменной только добавлением символа * после названия типа. Примеры:

_Листинг 1._

```c
int * p_g;    // указатель на переменную типа int
double * p_f; // указатель на переменную типа double
```

Присвоить указателю какой-то адрес можно, используя оператор присваивания. Примеры:

_Листинг 2._

```c
int n = 100;
double PI = 3.1415926;

int * p_k;     // указатель на переменную типа int
double * p_pi; // указатель на переменную типа double

p_k = &n;      // получаем адрес переменной n и присваиваем его указателю p_k
p_pi = &PI;    // получаем адрес переменной PI и присваиваем его указателю p_pi
```

Для вывода значения указателя на экран нужно в функции printf использовать спецификатор %p. Пример:

_Листинг 3._

```c
printf ("adres peremennoi PI %p\n", p_pi);
```

Используя адрес переменной, который хранится в указателе, можно изменять значения этой переменной. Для этого используется операция разыменования *. Вот посмотрите на пример:

_Листинг 4._

```c
#include <stdio.h>

int main(void) {
    int a = 100;
    int* p_a = &a;  // сохраняем в указатель адрес переменной a
    printf("a = %d\n", a);  // стандартный способ получить значение переменной a
    printf("a = %d\n", *p_a);  // получаем значение переменной a через указатель на неё

    // используя указатель p_a, записываем в переменную a другое значение
    *p_a = 50;

    printf("a =  %d\n", *p_a);
    return 0;
}
```

```
a = 100
a = 100
a =  50
```

_Доступ к переменной через указатель_

Итого, * применительно к указателям используется в двух случаях:
+ при объявлении указателя, чтобы показать, что это указатель;
+ если мы хотим обратиться к переменной, на которую указывает указатель.

Есть еще, так называемый, нулевой указатель NULL. Нулевой указатель не ссылается никуда. Он используется, чтобы обнулять указатели. Посмотрите на пример.

_Листинг 5._

```c
#include <stdio.h>

int main(void) {
    int a = 100;
    int* p_a = &a;  // сохраняем в указатель адрес переменной a
    printf("a = %d\n", a);  // стандартный способ получить значение переменной a
    printf("a = %d\n", *p_a);  // получаем значение переменной a через указатель на неё

    // используя указатель p_a, записываем в переменную a другое значение
    *p_a = 50;

    printf("a =  %d\n", *p_a);

    printf("%p\n", p_a);
    p_a = NULL;
    printf("%p\n", p_a);

    return 0;
}
```

```
a = 100
a = 100
a =  50
0061FF18
00000000
```
_Обнуление указателя_

[Содержание](#содержание)

<hr>

# Передача аргументов в функцию

Как уже отмечалось выше, при вызове функции в неё передаются не сами переменные, а только их значения. Т.е. функция, что бы она там ни делала, не может никак повлиять на значения переменных, которые в неё передаются. Такой способ передачи значений в функцию называется передачей аргументов по значению.

Рассмотрим пример. Допустим, мы хотим написать программу, которая меняет местами значения переменных. Кажется, всё просто.

_Листинг 1._

```c
#include <stdio.h>

void swap(int a, int b) {
    int temp;

    temp = a;
    a = b;
    b = temp;
}

int main(void) {
    int x = 4, y = 9;

    printf("x=%d y=%d\n", x, y);
    swap(x, y);
    printf("x=%d y=%d\n", x, y);

    return 0;
}
```

```
x=4 y=9
x=4 y=9
```

Вроде бы всё должно работать, но нет. Запустите программу и убедитесь в этом. И дело, как видите, не в функции, функция работает правильно, и значения переменных a и b действительно меняются, но к нашим исходным переменным это не имеет никакого отношения, т.к. они в функцию не передавались, а передавались только их значения.

Это никуда не годится. Чтобы с этим справиться, необходимо использовать другой способ передачи аргументов в функцию – передачу аргументов по ссылке. Для этого нам придётся воспользоваться указателями. Надеюсь вы хорошо с ними разобрались на прошлом шаге.

Напомню, что указатель – это такая переменная, в которой хранится адрес в памяти. В зависимости от типа указателя по этому адресу хранится значение соответствующего типа. Перепишем нашу программу используя передачу аргумента по ссылке.

_Листинг 2._

```c
#include <stdio.h>

// функция swap принимает два указателя на целые числа
// другими словами, два адреса в памяти компьютера,
// в которых записаны целые числа
void swap(int *a, int *b) {
    // a -- адрес первого числа
    // b -- адрес второго числа

    int temp;
    // *a -- разыменование указателя
    // *a позволяет обращаться к значению, хранящемуся по адресу a
    // выводим значения, хранящиеся по адресам a и b
    printf("a=%d b=%d\n", *a, *b);

    // переменной temp присваиваем значение, хранящееся по адресу a
    temp = *a;
    // в ячейку по адресу a записываем значение, хранящееся по адресу b
    *a = *b;
    // в ячейку по адресу b записываем значение из переменной temp
    *b = temp;
    printf("a=%d b=%d\n", *a, *b);
}

int main(void) {
    int x = 4, y = 9;

    printf("x=%d y=%d\n", x, y);
    // передаём адреса переменных x и y в фунцию swap
    swap(&x, &y);

    printf("x=%d y=%d\n", x, y);

    return 0;
}
```

```
x=4 y=9
a=4 b=9
a=9 b=4
x=9 y=4
```

Программа снабжена подробными комментариями, но я ещё раз поясню, что происходит:
+ В начале программы объявляются переменные x и y.
+ Им присваиваются значения 4 и 9 соответственно.
+ Адреса этих переменных передаются в функцию `swap`. <br>
Обращаю особое внимание. Передаются адреса переменных, а не их значения.
+ Внутри функции, используя дополнительную переменную, значения по переданным адресам меняются местами.
+ Функция `swap` заканчивает свою работу.

[Содержание](#содержание)

<hr>

## Передача массивов в функцию

Массивы, как и простые переменные, можно передавать в функцию, но есть ряд особенностей, с которыми нам следует познакомиться. Продемонстрирую их на примере. В следующей программе я написал две функции, которые выводят на экран переданный им массив.

_Листинг 3._

```c
#include <stdio.h>

void print_arr(int arr[], int n) {
    for (int k = 0; k < n; k++) {
        printf("arr[%d] = %d\t", k, arr[k]);
    }

    printf("\n");
}

void print_arr2(int arr[][5], int k, int n) {
    for (int i = 0; i < k; i++, printf("\n"))
        for (int j = 0; j < n; j++) printf("arr[%d][%d] = %d\t", i, j, arr[i][j]);

    printf("\n");
}

int main(void) {
    int q[5] = {5, 4, 2, 3, 4};
    int q2[2][5] = {{1, 2, 3, 4, 5}, {0, 9, 8, 7, 6}};

    print_arr(q, 5);

    print_arr2(q2, 2, 5);

    return 0;
}
```

Первый момент. Если в функцию предполагается передавать массив, то необходимо об этом предупредить компилятор. Для этого в заголовке функции при её описании необходимо рядом с именем переменной-массива указать пару квадратных скобок []. Посмотрите на объявление функции print_arr: из него сразу понятно, что переменная arr будет массивом, т.к. рядом с её именем указаны [].

_Листинг 4._

```c
void print_arr(int arr[], int n){
    ...
}
```

Второй момент. Когда мы передаём массив в функцию, то функция ничего не знает о размере этого массива. Поэтому необходимо дополнительно передавать размер массива в функцию отдельным параметром.

Третий нюанс. Если в функцию передаётся двумерный массив, то кроме двух пар квадратных скобочек [][], во второй из них необходимо явно указать её размерность. В примере выше это 5.

Четвертый нюанс. Массивы всегда передаются в функцию по ссылке. Это означает, что любые изменения массива внутри функции отразятся на исходном массиве.

Есть и другие способы передать массив в функцию, они связаны с передачей указателей на начало массива, но о них мы не будем упоминать в рамках данного курса.

[Содержание](#содержание)

<hr>

# Стандартная библиотека языка Си

В прошлых уроках мы изучили много различных стандартных функций. Большинство из них становились доступны, когда мы подключали в программу определенный заголовочные файлы, наприимер `stdio.h`, `math.h` или `string.h`. Они входят в состав стандартной библиотеки языка Си. Кроме них есть другие заголовочные файлы, которые включены в стандартную библиотеку языка Си, например, из используемых нами ранее `stdlib.h` и `time.h`.

Стандартная библиотека языка Си – это набор отдельных файлов, которые расширяют возможности языка Си. Например, как мы уже отмечали ранее, добавление к нашей программе файла `math.h` позволяет использовать различные математические функции. Добавление `stdio.h` позволяет взаимодействовать программе с внешним миром (читать/выводить данные).

Схематично можно представить себе язык программирования Си как набор отдельных законченных модулей. Условно эта структура изображена на следующем рисунке.

![010](/StepikC/Pictures/010_004.png)

_Рис.1 Архитектура языка Си._

По факту язык Си самостоятельно, без функций стандартной библиотеки, почти ничего не может. Даже вывести значение переменной на экран. Но благодаря дополнительным модулям (стандартным заголовочным файлам) возможности языка могут быть существенно расширены. А если какие-то возможности не нужны, то они не будут включены в итоговую версию программы.

Модульный подход получил широкое распространение в программировании. Основные плюсы:
+ модули между собой независимы и каждый из них может разрабатываться/меняться отдельно от других модулей и всей программы в целом;
+ возможность самостоятельно подключать необходимые модули;
+ возможность расширения функционала за счёт добавления/написания нового модуля.

Модули могут быть реализованы, например, в виде отдельных заголовочных файлов или отдельных файлов с кодом. Каждый модуль должен решать какие-то свои задачи. Модуль можно представить себе как «чёрный ящик». У него есть две основных части: интерфейс взаимодействия с модулем (сколько и каких данных поступает в чёрный ящик и какие данные им возвращаются) и внутренняя реализация модуля (содержимое чёрного ящика).

Если рассматривать отедельную функцию языка Си как модуль, то интерфейсом является заголовок или прототип функции. 

Он полностью описывает, что необходимо функции для работы:
+ какого типа данные нужны,
+ в каком порядке их надо передавать,
+ в каком количестве и т.д.,
+ а также какие данные функция возвращает. 

Тело функции при этом является реализацией модуля.

Кстати, что касается стандартной библиотеки языка Си. Если вы ещё не пробовали искать у себя на компьютере заголовочные файлы, то попробуйте. Внутри них только прототипы функций, а самой реализации нет. Т.е. по факту в заголовочных файлах содержится только интерфейс модуля или по-другому `API`(Application Programming Interface, чит. эй-пи-ай, иногда по-русски произносят апи), а сами реализации от программиста скрыты и находятся уже в отдельных, скомпилированных библиотечных файлах.

Использование `API` – тоже широко распространённая практика. Многие сервисы предоставляют свой открытый `API`. Например, платформа Stepic, которую я использую для автоматической проверки задач, или сайт Вконтакте. Т.е. по сути данные сайты выкладывают в открытый доступ ([vk](https://vk.com/dev/openapi), [Stepic](https://stepik.org/api/docs/)) описание различных функций, которые я могу использовать в своих программах. 

Именно на использовании `API` строится разработка различных сервисов и приложений для работы с различными платформами.

[Содержание](#содержание)

<hr>

# Задачи

## Сумматор.
Напишите функцию с именем sum, которая вычисляет сумму двух, переданных в неё целочисленных аргументов.

Входные данные:<br>
Два целых числа.

Выходные данные:<br>
Одно целое число, сумма чисел поступивших на вход

Справка:<br>
Необходимо написать только заголовок и тело функции, без подключения файла stdio.h и функции main.

```c
int sum (int a, int b) {
    return a + b;
}
```

[Содержание](#содержание)

<hr>

## Минимум
Опишите функцию с именем min, которая вычисляет минимальное из двух чисел, переданных в неё.

Входные данные:<br>
Два целых числа.

Выходные данные:<br>
Одно целое число -- минимум из чисел, переданных в функцию.

Справка:<br>
Необходимо написать только тело функции, без подключения файла stdio.h и функции main.

```c
int min (int a, int b){
    return a > b ? b : a;
}
```

[Содержание](#содержание)

<hr>

## Минимум-2.
Напишите программу, которая будет вычислять и возвращать минимальное из трёх чисел, переданных в неё, при помощи функции min.

Входные данные:<br>
Три целых числа.

Выходные данные:<br>
Одно целое число -- минимум из чисел, переданных в функцию.

```c
#include <stdio.h>
int min(int a, int b, int c) {
    int min = a;
    if (b < min) {
        min = b;
    }
    if (c < min) {
        min = c;
    }
    return min;
}
int main(void) {
    int a, b, c;
    scanf("%d %d %d", &a, &b, &c);
    printf("%d", min(a, b, c));
    return 0;
}
```

[Содержание](#содержание)

<hr>

## Факториал.
Напишите функцию с именем `factorial`, которая вычисляет факториал числа, переданного ей в качестве аргумента.

Входные данные:<br>
Одно целое неотрицательное число $N, N<13$.

Выходные данные:
Одно целое число, факториал исходного числа.

```c
#include <stdio.h>

int factorial(int k) {
    int res = 1;
    for (int i = 1; i <= k; i++) {
        res *= i;
    }
    return res;
}

int main(void) {
    int n;
    scanf("%d", &n);
    printf("%d", factorial(n));
    return 0;
}
```

[Содержание](#содержание)

<hr>

## Число сочетаний.

Допустим, у вас имеется $N$ хоккеистов. Из них нужно сформировать команду из  $K$ человек. Сколько существует вариантов это сделать? На подобные вопросы существует стандартный ответ -- число сочетаний, которое вычисляется по следующей формуле:

$С_n^k = \dfrac{k!}{(n−k)!n!}$
​ 
Например, $N=5,K=3$ , то $С_5^3 = \dfrac{5!}{3!(2)!} = \dfrac{120}{6⋅2} =10$

Входные данные: <br>
Натуральное число $N$ и целое неотрицательное число $K, K≤N ,N≤12$.

Выходные данные:<br>
Одно число - количество сочетаний хоккеистов.

```c
#include <stdio.h>

int factorial(int k) {
    int res = 1;
    for (int i = 1; i <= k; i++) {
        res *= i;
    }
    return res;
}

int combin(int n, int k) { return factorial(n) / (factorial(k) * factorial(n - k)); }

int main(void) {
    int n = 0, k = 0;
    scanf("%d%d", &n, &k);

    printf("%d", combin(n, k));

    return 0;
}
```

[Содержание](#содержание)

<hr>

## Последовательные множители.
Напишите функцию с именем sequence_multipliers, принимающую один аргумент x, которая определяет можно ли представить x в виде произведения трех последовательных натуральных чисел. Например, $120=4⋅5⋅6$

Входные данные:<br>
Одно натуральное число N,(N<1000000).

Выходные данные:<br>
k -- первое число последовательности трёх натуральных чисел такое, что k(k+1)(k+2)=x, либо -1, если число x нельзя представить в таком виде.


```c
#include <stdio.h>

int sequence_multipliers(int k) {
    int x = 1;
    while (x * (x + 1) * (x + 2) < k + 1) {
        if (x * (x + 1) * (x + 2) == k) {
            return x;
        }
        x++;
    }
    return -1;
}
int main(void) {
    int a;
    scanf("%d", &a);
    printf("%d", sequence_multipliers(a));
    return 0;
}
```

[Содержание](#содержание)

<hr>

## Квадрат.
Напишите функцию с именем square(n,c), которая выводит на экран квадрат размера n на n, заполненный символами c. Например:

```
square(4,'#');
выведет:
####
####
####
####
```

Входные данные:<br>
Одно целое число и символ заполнитель.

Выходные данные:<br>
Квадрат из символов, указанного формата.

```c
#include <stdio.h>

void square(int x, char c) {
    for (int i = 0; i < x; i++) {
        for (int j = 0; j < x; j++) {
            printf("%c%s", c, j == x - 1 ? "\n" : "");
        }
    }
}

int main() {
    int n;
    char c;
    scanf("%d %c", &n, &c);

    square(n, c);

    return 0;
}
```

[Содержание](#содержание)

<hr>

## Форматирование даты
Написать функцию print_date(int d, int m, int y, int k), которая выводит дату в одном из указанных форматов.
+ при k = 0: dd.mm.yy
+ при k = 1: dd.mm.yyyy
+ при k = 2: yyyy/mm/dd

Входные данные:<br>
Четыре числа:
+ первое число -- номер дня в месяце ,
+ второе число -- номер месяца,
+ третье число -- год,
+ четвёртое число -- формат.

Выходные данные:<br>
Дата в указанном формате.

```c
#include <stdio.h>
void print_date(int d, int m, int y, int k) {
    switch (k) {
        case 0:
            printf("%02d.%02d.%02d", d, m, y % 100);
            break;
        case 1:
            printf("%02d.%02d.%d", d, m, y);
            break;
        case 2:
            printf("%d/%02d/%02d", y, m, d);
            break;

        default:
            printf("error");
            break;
    }
}
int main() {
    int d, m, y, k;

    scanf("%d %d %d %d", &d, &m, &y, &k);
    print_date(d, m, y, k);

    return 0;
}
```

[Содержание](#содержание)

<hr>

## Делители числа.

Задача состояла в том, чтобы написать функцию выводящую все делители числа K, поступившего на вход.

Примечание:<br>
Функция main() с вводом значения и вызовом функции factors() уже реализована

```c
void factors(int k){
    for(int i = 1; i <= k; i++)
        if(k % i == 0)
        printf("%d ", i);
}
```

[Содержание](#содержание)

<hr>

## Переделайте функцию, написанную в прошлом уроке, таким образом, чтобы она возвращала число 1, если число K простое, или 0, если число K не является простым.

```c
int is_prime(int k){
    for(int i = 2; i < k / 2; i++) {
      if(k % i==0)
        return 0;
    }
    return 1;
}
```

[Содержание](#содержание)

<hr>

## В программе имеются две целочисленные переменные a и b. Объявите два указателя с именами p_a и p_b, которые ссылаются на соответствующие переменные.

Здесь и далее напишите именно то, что указано в задании, не используя include, main и т.п.

P.S. Полный исходный код задачи доступен на форуме для решивших задачу.

```c
int *p_a, *p_b;
p_a = &a;
p_b = &b;
```

```c
#include <stdio.h>
int main(void) {

    int a = 0, b = 0;
    scanf("%d %d", &a, &b);

    int * p_a = &a;
    int * p_b = &b;

    printf("%d",*p_a + *p_b);

    return 0;
}
```

[Содержание](#содержание)

<hr>

## В программе имеются символьные переменные ch и inp. Объявите  указатель с именем p_ch, который ссылается на переменную ch, и присвойте ей значение переменной inp.

P.S. Полный исходный код задачи доступен на форуме для решивших задачу.

```c
int *p_ch = &ch;
*p_ch = inp;
```

```c
#include <stdio.h>
int main(void) {
    char ch;
    char inp;
    scanf("%c", &inp);

    char * p_ch = &ch;
    *p_ch = inp;

    printf("%c", *p_ch);

    return 0;
}     
```

[Содержание](#содержание)

<hr>

## В программе объявлены две переменные целого типа. На каждую из них ссылается указатель. На первую ссылается указатель p_1, а на вторую указатель p_2.

Используя указатели, вывести значения этих переменных через пробел. Сначала вторую, потом первую.

Чтобы получить значение переменной, на которую ссылается указатель, необходимо произвести разыменование указателя.

P.S. Полный исходный код задачи доступен на форуме для решивших задачу.

```c
// выше объявлены указатели: 
// int *p_1
// int *p_2
// выведите значения, на которые ссылаются эти указатели
// необходимо написать только вызов printf

printf("%d %d", *p_2, *p_1);
```

```c
#include <stdio.h>
int main(void) {

    int a = 0, b = 0;
    scanf("%d %d", &a, &b);

    int * p_1 = &b;
    int * p_2 = &a;

    printf("%d %d",*p_2, *p_1);

    return 0;
}
```

[Содержание](#содержание)

<hr>

## Даны два указателя по тем же правилам, что и в предыдущей задаче.

Выведите сумму переменных, на которые ссылаются данные указатели.

P.S. Полный исходный код задачи доступен на форуме для решивших задачу.

```c
// выше объявлены указатели: 
// int *p_1
// int *p_2
// выведите значения, на которые ссылаются эти указатели
// необходимо написать только вызов printf

printf("%d", *p_2 + *p_1);
```

```c
// выше объявлены указатели: 
// int *p_1
// int *p_2
// выведите значения, на которые ссылаются эти указатели
// необходимо написать только вызов printf

printf("%d", *p_2 + *p_1);
```

[Содержание](#содержание)

<hr>

## В программе объявлены две переменные целого типа. На каждую из них ссылается указатель. На первую ссылается указатель p_1, а на вторую указатель p_2. Кроме того, объявлена переменная типа double и указатель на неё p_dbl.

Используя указатели, подсчитать частное целых переменных (первую делим на вторую) и сохранить это значение в переменную, на которую ссылается p_dbl.

Чтобы получить значение переменной, на которую ссылается указатель, необходимо произвести разыменование указателя.

P.S. Полный исходный код задачи доступен на форуме для решивших задачу.

```c
// выше объявлены указатели: 
// int *p_1
// int *p_2
// double * p_dbl

*p_dbl = 1.0 * *p_1 / *p_2;
```

```c
#include <stdio.h>
int main(void) {
    int a=0, b=0;
    double f = 0; 
    scanf("%d %d", &a, &b);
    double * p_dbl = &f;
    int * p_1 = &a;
    int * p_2 = &b;
    
    *p_dbl = (double)(*p_1)/(*p_2);    
    printf("%.3f",f);
    return 0;
}
```

[Содержание](#содержание)

<hr>

## В программе объявлены два указателя p_1 и p_2, которые ссылаются на некоторые переменные. Присвойте переменной на которую ссылается указатель p_1, значение переменной c, а переменной, на которую ссылается указатель p_2, значение переменной d.

P.S. Полный исходный код задачи доступен на форуме для решивших задачу.

```c
/* выше объявлены указатели:
    int * p_1
    int * p_2
которые ссылаются на некоторые переменные.
Используя указатели, присвойте этим переменным значения c и d, соответственно
*/
    int c = 0, d = 0;
    scanf("%d %d",&c,&d);
    *p_1 = c;
    *p_2 = d;
```

```c
#include <stdio.h>
int main(void) {

    int a = 0, b = 0;
    int * p_a = &a;
    int * p_a = &b;
    int c = 0, d = 0;
    scanf("%d %d",&c,&d);
    
    *p_1 = c;
    *p_2 = d;

    printf("%d %d",*p_1, *p_2);

    return 0;
}
```

[Содержание](#содержание)

<hr>

## Гилл Байтс написал программу, которая меняет значения двух целочисленных переменных местами. При этом, он поспорил со своим другом Стэном Добсом, что сможет сделать это, используя лишь указатели на данные переменные и дополнительную переменную temp.

Помогите Гиллу выиграть спор. Исправьте следующую программу соответствующим образом.

P.S. Полный исходный код задачи доступен на форуме для решивших задачу.

```c
// int * p_1 ссылается на первую переменную
// int * p_2 ссылается на вторую переменную

int temp;
temp = *p_1;
*p_1 = *p_2;
*p_2 = temp;
```

```c
#include <stdio.h>
int main(void) {

    int a=0, b=0;
    scanf("%d %d", &a, &b);
    int * p_1 = &a;
    int * p_2 = &b;

    int temp;
    temp = *p_1;
    *p_1 = *p_2;
    *p_2 = temp;

    printf("%d %d", a, b);
    return 0;
}
```

[Содержание](#содержание)

<hr>

## В программе объявлены три целочисленные переменные и указатели на них. Используя лишь указатели, найти среди переменных переменную с минимальным значением. Затем остальным переменным присвоить это значение.

```c
/*
Выше в программе объявлены указатели
    int * p_a
    int * p_b
    int * p_c
*/
int min = *p_a;
if (min > *p_b) {min = *p_b;}
if (min > *p_c) {min = *p_c;}
*p_a = *p_b = *p_c = min;
```

```c
#include <stdio.h>
int main(void) {
    int a = 0, b = 0, c = 0;
    scanf("%d %d %d", &a, &b, &c);

    int* p_a = &a;
    int* p_b = &b;
    int* p_c = &c;

    if (*p_a > *p_b) *p_a = *p_b;
    if (*p_a > *p_c) *p_a = *p_c;

    *p_b = *p_a;
    *p_c = *p_a;

    printf("%d %d %d", a, b, c);

    return 0;
}
```

[Содержание](#содержание)

<hr>

## Написать функцию void swap(int * x, int * y), которая меняет значения переменных местами.

Примечание: здесь и в остальных заданиях до конца курса выводить символы и цифры на печать не требуется.

```c
void swap(int * a, int * b){
    int tmp = *a;
    *a = *b;
    *b = tmp;
}
```

[Содержание](#содержание)

<hr>

## Написать функцию void sum_digits(int * x), которая заменяет число x на сумму цифр из которых состоит число x.

```c
void sum_digits(int * x){
    int res = 0;
    while(*x) {
        res += *x % 10;
        *x /= 10;
    }
    *x = res;
}
```

[Содержание](#содержание)

<hr>

## Написать функцию void minmax(int * x, int * y), записывающую в переменную x минимальное из значений x и y, а в переменную y -- максимальное из этих значений.

```c
void minmax(int * x, int * y){
    if (*x > *y) {
        int tmp = *x;
        *x = *y;
        *y = tmp;
    }
}
```

[Содержание](#содержание)

<hr>

## Написать функцию void char_register(char * ch, int fl), которая переводит переданный ей символ ch (символ латинского алфавита) в заданный переменной fl регистр: 0 — нижний, 1 — верхний.

Если переданное в переменной ch значение не является символом латинского алфавита или уже находится в нужном регистре, то делать с ним ничего не нужно.

Преобразованный символ необходимо поместить по тому же указателю, по которому он был считан.

```c
void char_register(char * ch, int fl){
    if (fl && *ch > 96 && *ch < 123) {*ch -= 32;}
    if (!fl && *ch > 64 && *ch < 91) {*ch += 32;}
}
```

```c
void char_register(char * ch, int fl){
    fl ? (*ch = toupper(*ch)) : (*ch = tolower(*ch));
}
```

[Содержание](#содержание)

<hr>

## Шифр Цезаря.
Написать функцию void char_cesar(char * ch, int shift), которая изменяет переданный ей символ ch по алгоритму Цезаря с ключом shift.

Шифр Цезаря заключается в замене текущего символа на тот, который находится в алфавите на k позиций правее. Например, буква a при сдвиге 2 будет заменена на букву c, буква x при сдвиге 4 будет заменена на букву b, т.к. мы считаем алфавит зацикленным.

[Содержание](#содержание)

<hr>

[Содержание курса](/StepikC/README.md)
