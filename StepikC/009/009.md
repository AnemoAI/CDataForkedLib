# Тип данных char

## Содержание

+ [Тип данных char](#тип-данных-char)

[Содержание курса](/StepikC/README.md)

# Тип данных char

Как вы уже знаете, тип данных char используется для хранения отдельных символов. Оказывается, кроме символов, в переменную данного типа можно записать целое число. При этом размер этого типа данных всего 256 значений. В переменной данного типа можно хранить значения от 0 до 255 включительно, либо от -128 до 127. Это зависит от вашего компилятора.

Вот посмотрите:

_Листинг 1._

```c
#include <stdio.h>
int main(void){
  char ch = 97;

  printf("%d = %c\n",ch,ch);
  
  return(0);
}
```

Сейчас поясню, зачем это нужно. В памяти компьютера всё хранится в виде 0 или 1, это нам известно. Чтобы хранить числа, компьютер переводит их в двоичную систему счисления. Но как быть с буквами, знаками препинания? Для этого люди придумали специальные таблицы, которые называются кодировками.

В такой таблице каждому символу сопоставляется определённое число. И уже это число преобразуется в двоичную систему и хранится в памяти компьютера. С кодировками часто бывают проблемы. Они возникают из-за того, что одному числу в разных таблицах могут соответствовать разные символы.

Язык Си использует одну из таких таблиц – таблицу 'ASCII' (аббр. American Standard Code for Information Interchange).

В ней первые числа от 0 до 32 зарезервированы для служебных команд, например, 10 используется для перевода строки. А вот символ с кодом 0 обозначает конец символьной строки. Он нам скоро понадобится.

Вот посмотрите на следующий пример.

_Листинг 2._

```c
#include <stdio.h>
int main(void){
  char ch = 10;

  printf("te%cst\n",ch);
  return(0);
}
```

А вот результат её работы.

```
te
st
Press any key to continue..
```

_Рис.1 Пример вывода служебного символа на экран_

Как видите, символ с кодом `10`, действительно, переводит строку (соответствует escape-последовательности `\n`).

## Исследовательские задачи для хакеров

+ Проверить как в вашей системе работает тип char. Для этого можете использовать следующую программу:

```c
#include <stdio.h>

int main(void){
  
  char k = 0;

  for(int i = 0; i < 255; i++){
    k = i;
    printf("k = %d\n", k);
  }

  return 0;
}
```
+ Найти в интернете таблицу с символами ASCII. Посмотреть каким символам соответствуют числам от 33 до 127.


[Содержание](#содержание)

<hr>

# Ввод и вывод символьных строк в Си

Итак, строки в языке Си. Для них не предусмотрено отдельного типа данных, как это сделано во многих других языках программирования. 

В языке Си строка – это массив символов. 

Чтобы обозначить конец строки, используется символ '\0', о котором мы говорили в прошлой части этого урока. 

На экране он никак не отображается, поэтому посмотреть на него не получится.

## Создание и инициализация строки
Так как строка – это массив символов, то объявление и инициализация строки аналогичны подобным операциям с одномерными массивами.

Следующий код иллюстрирует различные способы инициализации строк.

_Листинг 1._

```c
char str[10];
  char str1[10] = {'Y','o','n','g','C','o','d','e','r','\0'};
  char str2[10] = "Hello!";
  char str3[] = "Hello!";
```

![009](/StepikC/Pictures/009_001.png)

_Рис.1 Объявление и инициализация строк_

В первой строке мы просто объявляем массив из десяти символов. Это даже не совсем строка, т.к. в ней отсутствует нуль-символ `\0`, пока это просто набор символов.

Вторая строка. Простейший способ инициализации в лоб. Объявляем каждый символ по отдельности. Тут главное не забыть добавить нуль-символ `\0`.

Третья строка – аналог второй строки. Обратите внимание на картинку. Т.к. символов в строке справа меньше, чем элементов в массиве, остальные элементы заполнятся `\0`.

Четвёртая строка. Как видите, тут не задан размер. Программа его вычислит автоматически и создаст массив символов нужный длины. При этом последним будет вставлен нуль-символ `\0`.

[Содержание](#содержание)

<hr>

## Как вывести строку
Дополним код выше до полноценной программы, которая будет выводить созданные строки на экран.

_Листинг 2._

```c
#include <stdio.h>

int main(void) {
  
    char str[10];
    char str1[10] = {'Y','o','n','g','C','o','d','e','r','\0'};
    char str2[10] = "Hello!";
    char str3[] = "Hello!";

    for(int i = 0; i < 10; i = i + 1)
        printf("%c\t",str[i]);
    printf("\n");

    puts(str1);
    printf("%s\n",str2);
    puts(str3);

  return 0;
}
```

![009](/StepikC/Pictures/009_002.png)

_Рис.2 Различные способы вывода строки на экран_

Как видите, есть несколько основных способов вывести строку на экран.

+ использовать функцию `printf` со спецификатором `%s`
+ использовать функцию `puts`
+ использовать функцию `fputs`, указав в качестве второго параметра стандартный поток для вывода `stdout`.

Единственный нюанс у функций `puts` и `fputs`. Обратите внимание, что функция `puts` переносит вывод на следующую строку, а функция `fputs` не переносит.

Как видите, с выводом всё достаточно просто.

[Содержание](#содержание)

<hr>

## Ввод строк
С вводом строк всё немного сложнее, чем с выводом. Простейшим способом будет являться следующее:

_Листинг 3._

```c
#include <stdio.h>
int main(void) {
  char str[20];
  gets(str); 
  puts(str);
  return 0;
}
```

Функция `gets` приостанавливает работу программы, читает строку символов, введенных с клавиатуры, и помещает в символьный массив, имя которого передаётся функции в качестве параметра.

Завершением работы функции `gets` будет являться символ, соответствующий клавише ввод и записываемый в строку как нулевой символ.

Заметили опасность? 

Если нет, то о ней вас любезно предупредит компилятор. 

Дело в том, что функция `gets` завершает работу только тогда, когда пользователь нажимает клавишу ввод. 

Это чревато тем, что мы можем выйти за рамки массива, в нашем случае — если введено более 20 символов.

К слову, ранее ошибки переполнения буфера считались самым распространенным типом уязвимости. Они встречаются и сейчас, но использовать их для взлома программ стало гораздо сложнее.

Итак, что мы имеем. У нас есть задача: записать строку в массив ограниченного размера. То есть, мы должны как-то контролировать количество символов, вводимых пользователем. И тут нам на помощь приходит функция `fgets`:

_Листинг 4._

```c
#include <stdio.h>
int main(void) {
  char str[10];
  fgets(str, 10, stdin);
  puts(str);
  return 0;
}
```

Функция `fgets` принимает на вход три аргумента:
+ переменную для записи строки,
+ размер записываемой строки и
+ имя потока, откуда взять данные для записи в строку, <br>
в данном случае — `stdin`. 

Как вы уже знаете из 3 урока, `stdin` – это стандартный поток ввода данных, обычно связанный с клавиатурой. 

Совсем необязательно данные должны поступать именно из потока `stdin`, в дальнейшем эту функцию мы также будем использовать для чтения данных из файлов.

Если в ходе выполнения этой программы мы введем строку длиннее, чем 10 символов, в массив все равно будут записаны только 9 символов с начала и символ переноса строки, `fgets` «обрежет» строку под необходимую длину.

Обратите внимание, функция `fgets` считывает не 10 символов, а 9! 

Как мы помним, в строках последний символ зарезервирован для нуль-символа.

Давайте это проверим. 

Запустим программу из последнего листинга. И введём строку `1234567890`. На экран выведется строка `123456789`.

![009](/StepikC/Pictures/009_003.png)

_Рис.3 Пример работы функции fgets_

Возникает вопрос. А куда делся десятый символ? А я отвечу. Он никуда не делся, он остался в потоке ввода. Выполните следующую программу.

_Листинг 5._

```c
#include <stdio.h>
int main(void) {
  char str[10];
  fgets(str, 10, stdin);
  puts(str);

  int h = 99;

  printf("do %d\n", h);
  scanf("%d",&h);
  printf("posle %d\n", h);

  return 0;
}
```

Вот результат её работы.

![009](/StepikC/Pictures/009_004.png)

_Рис.4 Непустой буфер `stdin`_

Поясню произошедшее. 

Мы вызвали функцию `fgets`. 

Она открыла поток ввода и дождалась пока мы введём данные. 

Мы ввели с клавиатуры `1234567890``\n`(`\n` я обозначаю нажатие клавиша `Enter`). Это отправилось в поток ввода `stdin`. Функция `fgets`, как и полагается, взяла из потока ввода первые 9 символов `123456789`, добавила к ним нуль-символ `\0` и записала это в строку `str`. В потоке ввода осталось ещё `0\n`.

Далее мы объявляем переменную h. 

Выводим её значение на экран. 

После чего вызываем функцию `scanf`. 

Тут-то ожидается, что мы можем что-то ввести, но т.к. в потоке ввода висит `0\n`, то функция `scanf` воспринимает это как наш ввод, и записывается 0 в переменную h. 

Далее мы выводим её на экран.

Это, конечно, не совсем такое поведение, которое мы ожидаем. 

Чтобы справиться с этой проблемой, необходимо очистить буфер ввода после того, как мы считали из него строку, введённую пользователем. 

Для этого используется специальная функция fflush. У неё всего один параметр – поток, который нужно очистить.

Исправим последний пример так, чтобы его работа была предсказуемой.

_Листинг 6._

```c
#include <stdio.h>
int main(void) {
  char str[10];
  fgets(str, 10, stdin);
  fflush(stdin); // очищаем поток ввода
  puts(str);

  int h = 99;
  printf("do %d\n", h);
  scanf("%d",&h);
  printf("posle %d\n", h);

  return 0;
}
```

Теперь программа будет работать так, как надо.

![009](/StepikC/Pictures/009_005.png)

_Рис.4 Сброс буфера `stdin` функцией `fflush`_

Подводя итог, можно отметить два факта. 1
+ Первый. На данный момент использование функции `gets` является небезопасным, поэтому рекомендуется везде использовать функцию `fgets`.
+ Второй. Не забывайте очищать буфер ввода, если используете функцию `fgets`.

На этом разговор о вводе строк закончен. Идём дальше.

[Содержание](#содержание)

<hr>

# Задачи

## Написать программу для перевод символов в верхний регистр.

Входные данные:

Один символ в нижнем регистре.

Выходные данные:

Тот же самый символ, но в верхнем регистре.

```c
#include <stdio.h>
int main(void) {
    char a;

    scanf("%c", &a);

    printf("%c", a - 32);

    return 0;
}
```

[Содержание](#содержание)

<hr>

## Вывести соседние символы в таблице ASCII.

Входные данные:

Один символ латинского алфавита.

Выходные данные:

Два символа, записанные через пробел. 
+ Первый -- символ, предшествующий исходному символу в кодовой таблице `ASCII`, 
+ второй -- символ, следующий за исходным символом в таблице `ASCII`.


```c
#include <stdio.h>
int main(void) {
    char a;

    scanf("%c", &a);

    printf("%c %c", a - 1, a + 1);

    return 0;
}
```

[Содержание](#содержание)

<hr>

## Написать программу для подсчёта различных символов, которые поступают на вход.

Входные данные:

Первая строка одно натуральное число N. 

Далее с новой строки записаны через пробел N символов латинского алфавита (как в верхнем, так и в нижнем регистре).

Выходные данные:

26 чисел, записанных через пробел. 

Первое число -- количество раз, которое во входных данных встречается буквы А или a, второе число -- количество раз, которое во входных данных встречается буквы B или b, и т.д.

[Содержание](#содержание)

<hr>

[Содержание курса](/StepikC/README.md)