# Тип данных char

## Содержание

+ [Тип данных char](#введение)
	+ [Исследовательские задачи для хакеров](#исследовательские-задачи-для-хакеров)
+ [Ввод и вывод символьных строк в Си](#ввод-и-вывод-символьных-строк-в-си)
	+ [Создание и инициализация строки](#создание-и-инициализация-строки)
	+ [Как вывести строку](#как-вывести-строку)
	+ [Ввод строк](#ввод-строк)

+ [Задачи](#задачи)
	+ [Написать программу для перевод символов в верхний регистр](#написать-программу-для-перевод-символов-в-верхний-регистр)
	+ [Вывести соседние символы в таблице ASCII](#вывести-соседние-символы-в-таблице-ascii)
	+ [Написать программу для подсчёта различных символов, которые поступают на вход](#написать-программу-для-подсчёта-различных-символов-которые-поступают-на-вход)
	+ [Определить тип символа](#определить-тип-символа)
	+ [Вывести на экран K символ латинского алфавита в верхнем и нижнем регистре](#вывести-на-экран-k-символ-латинского-алфавита-в-верхнем-и-нижнем-регистре)
	+ [Вывести на экран последние K символов латинского алфавита в верхнем регистре в алфавитном порядке](#вывести-на-экран-последние-k-символов-латинского-алфавита-в-верхнем-регистре-в-алфавитном-порядке)
	+ [Длина строки](#длина-строки)
	+ [Слова](#слова)
	+ [Поиск символа](#поиск-символа)
	+ [Системы счисления](#системы-счисления)
	+ [Лишние пробелы](#лишние-пробелы)
	+ [Расстояние Хэмминга](#расстояние-хэмминга)
	+ [Остров сокровищ](#остров-сокровищ)



[Содержание курса](/StepikC/README.md)

# Введение

Как вы уже знаете, тип данных `char` используется для хранения отдельных символов. Оказывается, кроме символов, в переменную данного типа можно записать целое число. При этом размер этого типа данных всего `256` значений. В переменной данного типа можно хранить значения от `0` до `255` включительно, либо от `-128` до `127`. Это зависит от вашего компилятора.

Вот посмотрите:

_Листинг 1._

```c
#include <stdio.h>
int main(void){
  	char ch = 97;
  	printf("%d = %c\n",ch,ch);
  	return(0);
}
```

Сейчас поясню, зачем это нужно. В памяти компьютера всё хранится в виде $0$ или $1$, это нам известно. Чтобы хранить числа, компьютер переводит их в двоичную систему счисления. Но как быть с буквами, знаками препинания? Для этого люди придумали специальные таблицы, которые называются кодировками.

В такой таблице каждому символу сопоставляется определённое число. И уже это число преобразуется в двоичную систему и хранится в памяти компьютера. С кодировками часто бывают проблемы. Они возникают из-за того, что одному числу в разных таблицах могут соответствовать разные символы.

Язык Си использует одну из таких таблиц – таблицу 'ASCII' (аббр. American Standard Code for Information Interchange).

В ней первые числа от 0 до 32 зарезервированы для служебных команд, например, 10 используется для перевода строки. А вот символ с кодом 0 обозначает конец символьной строки. Он нам скоро понадобится.

Вот посмотрите на следующий пример.

_Листинг 2._

```c
#include <stdio.h>
int main(void){
  	char ch = 10;

  	printf("te%cst\n",ch);
  	return(0);
}
```

А вот результат её работы.

```
te
st
Press any key to continue..
```

![009](/StepikC/Pictures/009_005.png)

_Рис.1 Пример вывода служебного символа на экран_

Как видите, символ с кодом `10`, действительно, переводит строку (соответствует escape-последовательности `\n`).

## Исследовательские задачи для хакеров

+ Проверить как в вашей системе работает тип char. Для этого можете использовать следующую программу:

```c
#include <stdio.h>

int main(void){
  
	char k = 0;

  	for(int i = 0; i < 255; i++){
    	k = i;
    	printf("k = %d\n", k);
  	}

  	return 0;
}
```
+ Найти в интернете таблицу с символами ASCII. Посмотреть каким символам соответствуют числам от 33 до 127.

[Содержание](#содержание)

<hr>

# Ввод и вывод символьных строк в Си

Итак, строки в языке Си. Для них не предусмотрено отдельного типа данных, как это сделано во многих других языках программирования. 

В языке Си строка – это массив символов. 

Чтобы обозначить конец строки, используется символ '\0', о котором мы говорили в прошлой части этого урока. 

На экране он никак не отображается, поэтому посмотреть на него не получится.

## Создание и инициализация строки
Так как строка – это массив символов, то объявление и инициализация строки аналогичны подобным операциям с одномерными массивами.

Следующий код иллюстрирует различные способы инициализации строк.

_Листинг 1._

```c
char str[10];
  char str1[10] = {'Y','o','n','g','C','o','d','e','r','\0'};
  char str2[10] = "Hello!";
  char str3[] = "Hello!";
```

![009](/StepikC/Pictures/009_001.png)

_Рис.1 Объявление и инициализация строк_

В первой строке мы просто объявляем массив из десяти символов. Это даже не совсем строка, т.к. в ней отсутствует нуль-символ `\0`, пока это просто набор символов.

Вторая строка. Простейший способ инициализации в лоб. Объявляем каждый символ по отдельности. Тут главное не забыть добавить нуль-символ `\0`.

Третья строка – аналог второй строки. Обратите внимание на картинку. Т.к. символов в строке справа меньше, чем элементов в массиве, остальные элементы заполнятся `\0`.

Четвёртая строка. Как видите, тут не задан размер. Программа его вычислит автоматически и создаст массив символов нужный длины. При этом последним будет вставлен нуль-символ `\0`.

[Содержание](#содержание)

<hr>

## Как вывести строку
Дополним код выше до полноценной программы, которая будет выводить созданные строки на экран.

_Листинг 2._

```c
#include <stdio.h>

int main(void) {
  
    char str[10];
    char str1[10] = {'Y','o','n','g','C','o','d','e','r','\0'};
    char str2[10] = "Hello!";
    char str3[] = "Hello!";

    for(int i = 0; i < 10; i = i + 1)
        printf("%c\t",str[i]);
    printf("\n");

    puts(str1);
    printf("%s\n",str2);
    puts(str3);

  return 0;
}
```

![009](/StepikC/Pictures/009_002.png)

_Рис.2 Различные способы вывода строки на экран_

Как видите, есть несколько основных способов вывести строку на экран.

+ использовать функцию `printf` со спецификатором `%s`
+ использовать функцию `puts`
+ использовать функцию `fputs`, указав в качестве второго параметра стандартный поток для вывода `stdout`.

Единственный нюанс у функций `puts` и `fputs`. Обратите внимание, что функция `puts` переносит вывод на следующую строку, а функция `fputs` не переносит.

Как видите, с выводом всё достаточно просто.

[Содержание](#содержание)

<hr>

## Ввод строк
С вводом строк всё немного сложнее, чем с выводом. Простейшим способом будет являться следующее:

_Листинг 3._

```c
#include <stdio.h>
int main(void) {
  char str[20];
  gets(str); 
  puts(str);
  return 0;
}
```

Функция `gets` приостанавливает работу программы, читает строку символов, введенных с клавиатуры, и помещает в символьный массив, имя которого передаётся функции в качестве параметра.

Завершением работы функции `gets` будет являться символ, соответствующий клавише ввод и записываемый в строку как нулевой символ.

Заметили опасность? 

Если нет, то о ней вас любезно предупредит компилятор. 

Дело в том, что функция `gets` завершает работу только тогда, когда пользователь нажимает клавишу ввод. 

Это чревато тем, что мы можем выйти за рамки массива, в нашем случае — если введено более 20 символов.

К слову, ранее ошибки переполнения буфера считались самым распространенным типом уязвимости. Они встречаются и сейчас, но использовать их для взлома программ стало гораздо сложнее.

Итак, что мы имеем. У нас есть задача: записать строку в массив ограниченного размера. То есть, мы должны как-то контролировать количество символов, вводимых пользователем. И тут нам на помощь приходит функция `fgets`:

_Листинг 4._

```c
#include <stdio.h>
int main(void) {
  char str[10];
  fgets(str, 10, stdin);
  puts(str);
  return 0;
}
```

Функция `fgets` принимает на вход три аргумента:
+ переменную для записи строки,
+ размер записываемой строки и
+ имя потока, откуда взять данные для записи в строку, <br>
в данном случае — `stdin`. 

Как вы уже знаете из 3 урока, `stdin` – это стандартный поток ввода данных, обычно связанный с клавиатурой. 

Совсем необязательно данные должны поступать именно из потока `stdin`, в дальнейшем эту функцию мы также будем использовать для чтения данных из файлов.

Если в ходе выполнения этой программы мы введем строку длиннее, чем 10 символов, в массив все равно будут записаны только 9 символов с начала и символ переноса строки, `fgets` «обрежет» строку под необходимую длину.

Обратите внимание, функция `fgets` считывает не 10 символов, а 9! 

Как мы помним, в строках последний символ зарезервирован для нуль-символа.

Давайте это проверим. 

Запустим программу из последнего листинга. И введём строку `1234567890`. На экран выведется строка `123456789`.

![009](/StepikC/Pictures/009_003.png)

_Рис.3 Пример работы функции fgets_

Возникает вопрос. А куда делся десятый символ? А я отвечу. Он никуда не делся, он остался в потоке ввода. Выполните следующую программу.

_Листинг 5._

```c
#include <stdio.h>
int main(void) {
  char str[10];
  fgets(str, 10, stdin);
  puts(str);

  int h = 99;

  printf("do %d\n", h);
  scanf("%d",&h);
  printf("posle %d\n", h);

  return 0;
}
```

Вот результат её работы.

![009](/StepikC/Pictures/009_004.png)

_Рис.4 Непустой буфер `stdin`_

Поясню произошедшее. 

Мы вызвали функцию `fgets`. 

Она открыла поток ввода и дождалась пока мы введём данные. 

Мы ввели с клавиатуры `1234567890``\n`(`\n` я обозначаю нажатие клавиша `Enter`). Это отправилось в поток ввода `stdin`. Функция `fgets`, как и полагается, взяла из потока ввода первые 9 символов `123456789`, добавила к ним нуль-символ `\0` и записала это в строку `str`. В потоке ввода осталось ещё `0\n`.

Далее мы объявляем переменную h. 

Выводим её значение на экран. 

После чего вызываем функцию `scanf`. 

Тут-то ожидается, что мы можем что-то ввести, но т.к. в потоке ввода висит `0\n`, то функция `scanf` воспринимает это как наш ввод, и записывается 0 в переменную h. 

Далее мы выводим её на экран.

Это, конечно, не совсем такое поведение, которое мы ожидаем. 

Чтобы справиться с этой проблемой, необходимо очистить буфер ввода после того, как мы считали из него строку, введённую пользователем. 

Для этого используется специальная функция `fflush`. У неё всего один параметр – поток, который нужно очистить.

Исправим последний пример так, чтобы его работа была предсказуемой.

_Листинг 6._

```c
#include <stdio.h>
int main(void) {
  char str[10];
  fgets(str, 10, stdin);
  fflush(stdin); // очищаем поток ввода
  puts(str);

  int h = 99;
  printf("do %d\n", h);
  scanf("%d",&h);
  printf("posle %d\n", h);

  return 0;
}
```

Теперь программа будет работать так, как надо.

![009](/StepikC/Pictures/009_005.png)

_Рис.4 Сброс буфера `stdin` функцией `fflush`_

Подводя итог, можно отметить два факта.
+ Первый. На данный момент использование функции `gets` является небезопасным, поэтому рекомендуется везде использовать функцию `fgets`.
+ Второй. Не забывайте очищать буфер ввода, если используете функцию `fgets`.

На этом разговор о вводе строк закончен. Идём дальше.

[Содержание](#содержание)

<hr>

# Задачи

## Написать программу для перевод символов в верхний регистр.

Входные данные:

Один символ в нижнем регистре.

Выходные данные:

Тот же самый символ, но в верхнем регистре.

```c
#include <stdio.h>
int main(void) {
    char a;

    scanf("%c", &a);

    printf("%c", a - 32);

    return 0;
}
```

[Содержание](#содержание)

<hr>

## Вывести соседние символы в таблице ASCII.

Входные данные:

Один символ латинского алфавита.

Выходные данные:

Два символа, записанные через пробел. 
+ Первый -- символ, предшествующий исходному символу в кодовой таблице `ASCII`, 
+ второй -- символ, следующий за исходным символом в таблице `ASCII`.


```c
#include <stdio.h>
int main(void) {
    char a;

    scanf("%c", &a);

    printf("%c %c", a - 1, a + 1);

    return 0;
}
```

[Содержание](#содержание)

<hr>

## Написать программу для подсчёта различных символов, которые поступают на вход.

Входные данные:

Первая строка одно натуральное число N. 

Далее с новой строки записаны через пробел N символов латинского алфавита (как в верхнем, так и в нижнем регистре).

Выходные данные:

26 чисел, записанных через пробел. 

Первое число -- количество раз, которое во входных данных встречается буквы А или a, второе число -- количество раз, которое во входных данных встречается буквы B или b, и т.д.

```
Sample Input:
10
A d s a a d L e s i
Sample Output:
3 0 0 2 1 0 0 0 1 0 0 1 0 0 0 0 0 0 2 0 0 0 0 0 0 0 
```

```c
#include <stdio.h>
#include <ctype.h>
#define CHARS 26 

int main(void){
    
	int k, dir[CHARS] = {0};
    scanf("%d", &k);
    char ch;

  	for(int i = 0; i < k; i++){
        scanf(" %c", &ch);
        dir[tolower(ch) - 97]++;
  	}

    for (int i = 0; i < CHARS; i++) {
        printf("%d ", dir[i]);
    }

  	return 0;
}
```

[Содержание](#содержание)

<hr>

## Определить тип символа.

Входные данные:<br>
Один символ. Либо буква латинского алфавита, либо цифра.

Выходные данные:<br>
digit -- если это цифра, en -- если это буква латинского алфавита. В иных случаях вывести error.


```c
#include <ctype.h>
#include <stdio.h>

int main(void) {
    char ch;
    scanf("%c", &ch);

    if (tolower(ch) <= 122 && tolower(ch) >= 97) {
        printf("en");
    } else if (ch <= 57 && ch >= 48) {
        printf("digit");
    } else {
        printf("error");
    }

    return 0;
}
```

```c
#include <stdio.h>
#include <ctype.h>
int main() {
    int ch;
    scanf("%c", &ch);
    printf("%s\n", isalpha(ch)?"en":isdigit(ch)?"digit":"error");
    return 0;
}
```

[Содержание](#содержание)

<hr>

## Вывести на экран K символ латинского алфавита в верхнем и нижнем регистре.

Входные данные:<br>
Одно натуральное число $K,(K<27)$.

Выходные данные:<br>
Kый символ латинского алфавита. Сначала в верхнем регистре, потом в нижнем, без пробела между символами.

```c
#include <ctype.h>
#include <stdio.h>

int main(void) {
    int num;
    scanf("%d", &num);

    printf("%c%c", toupper(num + 96), num + 96);

    return 0;
}
```

```c
#include <stdio.h>

int main() {
  int a;
    scanf("%d", &a);
    printf("%c%c", a + 64, a + 96);
  return 0;
}
```

[Содержание](#содержание)

<hr>

## Вывести на экран последние K символов латинского алфавита в верхнем регистре в алфавитном порядке.

Входные данные:<br>
Одно натуральное число $K,(K<27)$.

Выходные данные:<br>
K последних символов латинского алфавита.

```c
#include <stdio.h>
#define CHARS 27

int main(void) {
    int num;
    scanf("%d", &num);

    for (int i = CHARS - num; i < CHARS; i++) {
        printf("%c", i + 64);
    }

    return 0;
}
```

```c
#include <stdio.h>

int main() {
  unsigned k;
  scanf("%u",&k); 
  printf("ABCDEFGHIJKLMNOPQRSTUVWXYZ" + 26 - k);
  //return 0;
}
```

[Содержание](#содержание)

<hr>

## Длина строки.
Подсчитать количество символов в строке, без учёта нуль-символа.

Входные данные:<br>
Символьная строка. Длина строки не превышает 30 символов.

Выходные данные:<br>
Одно целое число -- длина входной символьной строки.

Справка:<br>
Формат входных данных: "YoungCoder.Ru\0\n"

```c
#include <stdio.h>
#include <string.h>

#define MAXLEN 30

int main(void) {
    char str[MAXLEN];
    fgets(str, 30, stdin);
    int res = strlen(str) - 1;
    printf("%d", res);

    return 0;
}
```

```c
#include <stdio.h>

int main() {
    int cnt=0;
    while(getchar())
        cnt++;
    printf("%d", cnt);
    return 0;
}
```

[Содержание](#содержание)

<hr>

## Слова.
Подсчитать количество слов в строке. Под словом будем понимать непустую последовательность символов, разделённую знаками пробела.

Входные данные:<br>
Символьная строка, состоящая из слов, разделённых пробелами. Длина строки не превышает 100 символов.

Выходные данные:<br>
Одно целое число -- количество слов во входной символьной строке.

Справка:<br>
Здесь и далее формат строки такой: "YoungCoder.ru 2014 - 2018\n\0".

```c
#include <stdio.h>

#define MAXLEN 100

int main(void) {
    char str[MAXLEN];
    fgets(str, 100, stdin);
    int res = 0;

    for (int i = 1; i < MAXLEN - 1; i++) {
        if (str[i] == '\n') {
            break;
        } else if (str[i] != ' ' && (str[i + 1] == ' ' || str[i + 1] == '\n')) {
            res++;
        }
    }

    printf("%d", res);

    return 0;
}
```

[Содержание](#содержание)

<hr>

## Поиск символа
Найти в строке заданный символ.

Входные данные:<br>
Первая строка -- символ, который необходимо найти. Затем с новой строки записана символьная строка, в которой нужно осуществить поиск. Длина строки не превышает 100 символов.

Выходные данные:<br>
Одно целое число -- индекс первого вхождения искомого символа в входную строку или число -1, если символ не найден.

```c
#include <stdio.h>

int main(void) {
    char ch, str;
    scanf("%c%c", &ch, &str);
    int res = -1, count = 0;

    while (1) {
        scanf("%c", &str);
        if (str == '\n') {
            break;
        } else if (str == ch) {
            res = count++;
            break;
        } else {
            count++;
        }
    }
    printf("%d", res);
    return 0;
}
```

[Содержание](#содержание)

<hr>

## Системы счисления
Дана строка, изображающая двоичную запись целого положительного числа. Вывести строку, изображающую десятичную запись этого же числа.

Входные данные:<br>
Строка символов, содержащая нули и единицы. Длина строки не превышает 20 символов.

Выходные данные:<br>
Строка, отображающее число, которое соответствует десятичной записи двоичного числа, поступившего на вход.

```c
#include <math.h>
#include <stdio.h>
#include <string.h>

int main(void) {
    char str[21];
    fgets(str, 21, stdin);
    int res = 0, count = 0;

    count = strlen(str);

    for (int i = 0; i < count - 1; i++) {
        res += pow(2, i) * (str[count - i - 2] - 48);
    }

    printf("%d", res);
    return 0;
}
```

[Содержание](#содержание)

<hr>

## Лишние пробелы
Удалить из строки лишние пробелы. Пробел считается лишним, если:
+ стоит в начале строки;
+ стоит в конце строки;
+ ему предшествует пробел.

Входные данные:<br>
Строка символов. Длина строки не превышает 100 символов.

Выходные данные:<br>
Исходная строка без лишних пробелов.

```c
#include <stdio.h>
#include <string.h>

#define MAXLEN 100

int main(void) {
    char str[MAXLEN];
    fgets(str, MAXLEN, stdin);
    int count, flag = 0;
    count = strlen(str);

    for (int i = 0; i < count - 1; i++) {
        if (str[i] == ' ' && flag == 0) {
            continue;
        } else if (str[i] == ' ' && flag == 1) {
            printf("%c", str[i]);
            flag = 0;
        } else if (str[i] != ' ') {
            printf("%c", str[i]);
            flag = 1;
        }
    }
    return 0;
}
```

[Содержание](#содержание)

<hr>

## Расстояние Хэмминга.
Расстояние Хэмминга для двух слов одинаковой длины — это количество позиций, в которых различаются эти слова. Для двух заданных строк найти расстояние между ними.

Входные данные:<br>
Две символьные строки одинаковой длины, записанные каждая на отдельной строке. Длины строк не превышают 13 символов.

Выходные данные:<br>
Одно целое число -- расстояние Хэмминга.

```c
#include <stdio.h>
#include <string.h>

#define MAXLEN 15

int main(void) {
    char str1[MAXLEN];
    char str2[MAXLEN];
    fgets(str1, 15, stdin);
    fgets(str2, 15, stdin);

    int count, res = 0;
    count = strlen(str1);

    for (int i = 0; i < count - 1; i++) {
        if (str1[i] != str2[i]) {
            res++;
        }
    }
    printf("%d", res);
    return 0;
}
```

[Содержание](#содержание)

<hr>

## Остров сокровищ
Капитан Флинт зарыл клад на Острове сокровищ. Есть описание, как найти клад.<br>
Описание состоит из строк вида: "North 5", где первое слово – одно из "North", "South", "East", "West", а второе целое однозначное или двузначное число – количество шагов, которое необходимо пройти в этом направлении.

Напишите программу, которая по описанию пути к кладу определяет точные координаты клада, считая, что начало координат находится в начале пути, ось OX направлена на восток, ось OY – на север.

Входные данные:<br>
В первой строке натуральное число N. Затем с новой строки N строк указанного формата.

Выходные данные:<br>
Вывести координаты клада – два целых числа через пробел. Первое число - координата по Х, второе число - координата по Y.

```c
#include <stdio.h>
#include <string.h>

#define MAXLEN 6

int main(void) {
    int count, arg, x = 0, y = 0;
    char str[MAXLEN];
    scanf("%d", &count);

    for (int i = 0; i < count; i++) {
        scanf("%s %d", str, &arg);
        if (strcmp(str, "North") == 0) {
            y += arg;
        } else if (strcmp(str, "South") == 0) {
            y -= arg;
        } else if (strcmp(str, "East") == 0) {
            x += arg;
        } else {
            x -= arg;
        }
    }

    printf("%d %d", x, y);
    return 0;
}
```

[Содержание](#содержание)

<hr>

[Содержание курса](/StepikC/README.md)