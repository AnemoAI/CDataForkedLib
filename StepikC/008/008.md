# Урок 8. Массивы

## Содержание

+ [Зачем нужны массивы?](#зачем-нужны-массивы)
+ [Одномерные массивы: объявление, инициализация, обращение к элементу](#одномерные-массивы)
    + [Объявление и инициализация массива](#объявление-и-инициализация-массива)
    + [Работа с отдельными элементами массива](#работа-с-отдельными-элементами-массива)
+ [Константы. Директива define](#именованные-константы-директива-define)
+ [Двумерные массивы: объявление, инициализация, обращение к элементу](#двумерные-массивы)
## Задачи. Список
+ [Задачи часть 1](#задачи-часть-1)
    + [Реверс. Переставить элементы массива в обратном порядке.](#реверс-переставить-элементы-массива-в-обратном-порядке)
    + [Палиндром](#палиндром)
    + [Вывести сначала чётные элементы массива, а затем нечётные.](#вывести-сначала-чётные-элементы-массива-а-затем-нечётные)
    + [Напишите программу, выводящую на экран все элементы массива которые меньше последнего.](#напишите-программу-выводящую-на-экран-все-элементы-массива-которые-меньше-последнего)
    + [Напишите программу, выводящую на экран все элементы массива,которые меньше последнего элемента и больше первого элемента массива.](#напишите-программу-выводящую-на-экран-все-элементы-массива-которые-меньше-последнего-элемента-и-больше-первого-элемента-массива)
    + [Найти среднее арифметическое элементов массива.](#найти-среднее-арифметическое-элементов-массива)
    + [Разделить массив на две части, поместив в первую элементы, большие среднего арифметического массива, а во вторую — меньшие.](#разделить-массив-на-две-части-поместив-в-первую-элементы-большие-среднего-арифметического-массива-а-во-вторую--меньшие)
    + [В заданном массиве поменять местами первую и вторую половины.](#в-заданном-массиве-поменять-местами-первую-и-вторую-половины)
    + [В заданном массиве поменять местами наибольший и наименьший элементы.](#в-заданном-массиве-поменять-местами-наибольший-и-наименьший-элементы)
+ [Задачи часть 2](#задачи-часть-2)
    + [Вывести элементы двумерного массива (матрицы) на экран.](#вывести-элементы-двумерного-массива-матрицы-на-экран)
    + [Транспонирование](#транспонирование)
    + []

[Содержание курса](/StepikC/README.md)

# Зачем нужны массивы?

Начнём, как обычно, с задач, которые покажут, что тех инструментов, что у нас есть, недостаточно.

Помните программу для проверки равномерности распределения случайных чисел, генерируемых функцией rand? Я напомню.

_Листинг 1._

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define N 100

int main(void) {   
  srand(time(NULL));
// счётчики для сгенерированных чисел
// если выпадет 1, то увеличим на единицу count_1
  int count_0 = 0, count_1 = 0, count_2 =0;

  int rand_number;
  
  for (int i = 0; i < N; i = i + 1){
    rand_number = rand()%3;  
    switch (rand_number){
      case 0 : count_0 = count_0 + 1; break;
      case 1 : count_1 = count_1 + 1; break;
      case 2 : count_2 = count_2 + 1; break;
    }
  }

  printf("0 - %d\n1 - %d\n2 - %d\n", count_0, count_1, count_2);
  return 0;
}
```
Программа подсчитывает, сколько раз сгенерировано каждое из чисел 0, 1 и 2. Теперь вопрос. А что делать, если нужно провести миллион генераций для чисел от 0 до 100? Не создавать же 100 переменных?

Более общая задача: как сохранить в программе очень много однотипных данных, например, чисел?

Это может потребоваться, если мы ведём историю обращений в поликлинику и должны записывать серию и номер паспорта каждого обратившегося. Или мы хотим хранить данные о доходах и расходах в текущем месяце. Или записывать сумму баллов ЕГЭ для всех абитуриентов вуза. Или динамику курса валюты за сутки/месяц/год.

Для решения подобных задач (хранение большого количества однотипных данных) используются массивы. В этом уроке мы познакомимся с этим понятием.

[Содержание](#содержание)

<hr>

# Одномерные массивы

Массив – это простейший составной тип данных. Когда мы обсуждали переменные, у нас была хорошая аналогия с коробкой. Вернёмся к ней. Если переменная – это один ящик, то массив – это несколько пронумерованных одинаковых ящиков, которые имеют одно и то же имя, а различаются между собой только порядковым номером.

![008](/StepikC/Pictures/008_001.png)

_Рис.1 Переменные и массивы. Аналогия с коробками._

На картинке выше изображено три массива:
+ целочисленный массив из 8 элементов с именем arr_int
+ вещественный массив из 11 элементов с именем arr_float
+ символьный массив из 6 элементов с именем arr_char

У массива, как и у переменной, имеются свои имя и тип данных. Кроме того, у массива ещё есть одна дополнительная характеристика – размер массива. 

Размер массива – количество элементов, которые могут в нём храниться. В нашей аналогии с коробочками это количество коробок.

__Обратите внимание!__

Нумерация элементов массива начинается с нуля, а не с единицы.

[Содержание](#содержание)

<hr>

## Объявление и инициализация массива

Объявление массива очень похоже на объявление переменной. Отличие лишь в том, что следует дополнительно указать размер массива в квадратных скобках. Вот несколько примеров:

_Листинг 1._

```c
int arr_int[8];
double arr_float[11]; 
float number[2000];
```

На имя массива накладываются ограничения, аналогичные тем, которые накладываются на имя переменной.

### Правило именования массивов

__Имя массива__ – любая последовательность символов, цифр и знака нижнего подчеркивания «_», которая начинается с буквы. Регистр букв важен.

Вот ещё несколько примеров объявления массивов:

_Листинг 2._

```c
int grades[50], order[10];
double prices[500];
```

Массиву, как и любой переменной, можно присвоить начальные значения при объявлении. Если элементам массива не присвоить никакого значения, то в них будет храниться мусор, как и в обычных переменных.

_Листинг 3._

```c
int arr_int[5] = {2, 5, 5, 3, 4};
double arr_float[11] = {1.2, -2.3, 4.5, 3.83, 0.01, -0.12, 44.2, 123.7, 23.44, -3.7, 7};
```

Если нужно присвоить нулевые значения всем элементам массива, то можно сделать вот так:

_Листинг 4._

```c
double arr[50] = {0};
```

## Работа с отдельными элементами массива

Чтобы обратиться к отдельному элементу массива, необходимо написать его имя и порядковый номер в квадратных скобках. Не забывайте, что нумерация начинается с нуля, а не с единицы.

Давайте, например, выведем элементы массива из пяти элементов на экран.

_Листинг 5._

```c
#include <stdio.h>

int main(void){
  int arr[5] = {2, 4, 3, 5, 5};
  
  printf("%d %d %d %d %d\n",arr[0], arr[1], arr[2], arr[3], arr[4]);

  return(0);
}
```

Конечно, если массив будет очень большой, то выводить его поэлементно подобным образом то ещё удовольствие. Да и с маленькими массивами так никто не делает. Лучше и правильнее использовать циклы. Например:

_Листинг 6._

```c
#include <stdio.h>

int main(void){
  int arr[100] = {0};
  
  for(int i = 0; i < 100; i = i + 1){
    arr[i] = 2*i;
  }

  for(int i = 0; i < 100; i = i + 1){
    printf("%d\t",arr[i]);
  }

  return(0);
}
```

Программа в первом цикле сохраняет в массив первую сотню чётных чисел, а во втором цикле выводит их на экран.

Вооружившись новыми инструментами, давайте перепишем нашу программу из начала урока так, чтобы она использовала массив для хранения статистики выпадения случайных чисел.

_Листинг 7._

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main(void) {  
  srand(time(NULL));
  int count[3] = {0};
  int rand_number;
  
  for (int i = 0; i < 100000; i = i + 1){
    rand_number = rand()%3;
    count[rand_number] = count[rand_number] + 1;
  }

  for(int i = 0; i < 3; i = i + 1){
    printf("%d - %d\n", i, count[i]);
  }

  return 0;
}
```

Обратите внимание на приём, который используется в этой программе.

В нулевом элементе массива хранится количество выпадений числа 0, в первом элементе – количество выпадений числа 1, во втором элементе – числа 2. То есть само сгенерированное число позволяет определить, к какому элементу массива необходимо добавить единичку. Поэтому необходимость в операторе выбора `switch` отпадает. Удобно, не так ли?

[Содержание](#содержание)

<hr>

# Именованные константы. Директива define

Давайте снова обратимся к программе подсчёта чисел, сгенерированных функцией rand:

_Листинг 1._

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main(void) {  
  srand(time(NULL));
  int count[3] = {0};
  int rand_number;
  
  for (int i = 0; i < 100000; i = i + 1){
    rand_number = rand()%3;
    count[rand_number] = count[rand_number] + 1;
  }

  for(int i = 0; i < 3; i = i + 1){
    printf("%d - %d\n", i, count[i]);
  }

  return 0;
}
```

Допустим, мы хотим расширить диапазон чисел, которые генерируют программа. Вместо чисел от 0 до 2 мы хотим генерировать числа от 0 до 10.

Для того чтобы внести в программу подобное изменение, нам необходимо заменить 3 на 11 в трёх местах в программе: в объявлении массива `count`, в вызове функции `rand` и в цикле, который выводит массив `count` на экран. Не очень-то удобно, особенно если таких мест будет очень много. Легко запутаться и что-нибудь пропустить.

Чтобы как-то автоматизировать подобный процесс, можно использовать директиву препроцессора `#define`. С её помощью можно создавать так называемые именованные константы.

[Содержание](#содержание)

<hr>

## Синтаксис директивы define

_Листинг 2._

```c
#define имя значение
```

__Важное замечание!__

В конце не нужно ставить ;. Между именем и значением не нужно ставить =.

Надеюсь, вы помните, что программа компилируется в машинный код с помощью компилятора?

На самом деле этот процесс довольно сложный, да и компилятор состоит из нескольких частей. 

Одна из частей компилятора – препроцессор. 

Он обрабатывает текст программы и подготавливает его к компиляции. 

Одна из функций препроцессора – подключение файлов, указанных в директивах `include`. Другая функция – это обработка инструкций `define`.

С директивой `define` препроцессор работает следующим образом. В тексте программы находятся все места, где встречается имя, указанное в директиве `define`. После этого вместо этого имени подставляется значение, указанное в директиве `define`.

Подстановка значения не производится, если имя встретилось внутри имени переменной, в строке или в комментарии.

Давайте посмотрим на нашем примере.

_Листинг 3._

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define EXPERIMENTS 1000000
#define NUMBERS 3

int main(void) {

  srand(time(NULL));
  int count[NUMBERS] = {0};
  int rand_number;
  
  for(int i = 0; i < EXPERIMENTS; i = i + 1){ 
    rand_number = rand()%NUMBERS;  
    count[rand_number] = count[rand_number] + 1;
  }

  for(int i = 0; i < NUMBERS; i = i + 1){
    printf("%d - %d\n", i, count[i]);
  }

  return 0;
}
```

Как видите, я добавил в программу две именованные константы.

Программисты на Си обычно называют именованные константы используя буквы в верхнем регистре, чтобы в коде они сразу бросались в глаза и их было легко отличить от переменных.

После того как мы запустим процесс компиляции, над программой начнёт работать препроцессор. Он подключит три заголовочных файла. После этого вместо имён EXPERIMENTS и NUMBERS произойдёт подстановка значений 1000000 и 3, соответственно.

После окончания работы препроцессора этот кусочек программы будет выглядеть вот так:

_Листинг 4._

```c
int main(void) {

  srand(time(NULL));
  int count[3] = {0};
  int rand_number;
  
  for(int i = 0; i < 1000000; i = i + 1){ 
    rand_number = rand()%3;  
    count[rand_number] = count[rand_number] + 1;
  }

  for(int i = 0; i < 3; i = i + 1){
    printf("%d - %d\n", i, count[i]);
  }

  return 0;
}
```

В примере выше мы используем именованные константы в качестве, так сказать, настроек (параметров) программы. 

Меняя значения этих параметров мы изменяем саму программу. 

Например, меняя значение константы NUMBER мы изменяем количество случайных опытов. 

Это стандартный приём в программировании на Си. Использование данного приёма позволяет писать более понятный код, который, кроме того, будет легко изменить под условия конкретной задачи.

## Дополнительные материалы 3

В программировании есть так называемые __антипаттерны__ программирования. 

Это такие приёмы написания программ, которых стоит избегать. 

Один из таких приёмов – __использование магических чисел__.

Подробнее об этом [здесь](https://ru.wikipedia.org/wiki/Магическое_число_(программирование)). 

Использование именованных констант – один из способов борьбы с магическими числами.

[Содержание](#содержание)

<hr>

# Двумерные массивы

Иногда данные гораздо удобнее хранить в таблице, чем в столбике/строке. Например, пишем мы игру-лабиринт. Нам нужно как-то хранить карту, где будут отмечены проходы и стены. Например, она могла бы выглядеть вот так.
|_Рис.1 Карта лабиринта_|
|:-:|
|![008](/StepikC/Pictures/008_002.png)|



И тогда её можно было бы хранить в виде таблицы символов, где стены обозначены 1, проходы 0, начальная точка 3, конечная точка 9.

_Листинг 1._

```
0 9 0 0 0 1 1 1 1 0 0 0 1 1 0
1 1 1 1 0 1 1 1 1 0 1 0 0 1 0
0 0 0 1 0 0 0 1 0 0 1 1 0 0 0
0 1 0 1 0 1 0 1 0 0 1 1 1 1 0
0 1 1 1 0 0 0 0 0 0 0 1 0 0 0
0 1 0 0 0 1 0 1 1 0 0 1 1 0 0
0 1 0 1 1 1 0 0 1 1 0 0 0 1 0
0 1 0 0 1 1 1 0 0 0 0 0 0 0 1
0 0 1 0 1 1 1 1 1 1 0 1 1 1 1
1 1 1 0 0 0 0 0 0 0 0 1 0 0 0
1 0 1 0 1 1 1 1 1 0 0 0 0 1 0
1 0 1 0 0 0 0 0 1 0 1 0 1 1 0
0 0 1 0 0 1 1 0 0 0 1 0 0 1 0
0 1 1 1 0 0 1 0 0 1 1 0 1 1 0
0 0 0 0 0 0 0 3 0 0 1 0 0 0 0
```

Или таблица 12 на 31, где можно было бы хранить температуру в течение года. 

Понятно, что в некоторых месяцах будут заполнены не все клеточки таблицы, но это ничего страшного. 

Договоримся и будем туда записывать, например, число -9999.99, которое будет обозначать, что данные не определены.

Ещё примеры:
+ таблица Пифагора,
+ поле для игры в крестики нолики,
+ поле для игры 2048.

В подобных случаях используют двумерные массивы, т.е. массивы, у которых два измерения (два счётчика).

|_Рис.2 Двумерный массив._|
|:-:|
|![008](/StepikC/Pictures/008_003.png)|


Объявить двумерный массив не сложнее, чем объявить одномерный массив. Просто необходимо указать обе его размерности в квадратных скобках. Первое число – количество строк, второе – количество столбцов.

Например, для массива с картинки объявление выглядело бы вот так:

_Листинг 2._

```c
int arr2[4][8];
```

Нумерация строк и столбцов, как и в одномерных массивах, начинается с нуля.

Имеется возможность инициализировать массив при объявлении.

_Листинг 3._

```c
int arr2[4][8] = {0}; // нулями
int arr [2][4] = {{1,2,4,29},{3,4,6,1}}; //произвольными значениями
```

|_Рис.3 Инициализация двумерного массива произвольными значениями_|
|:-:|
|![008](/StepikC/Pictures/008_004.png)|

Пока элементы массива не инициализированы, они заполнены мусором. Проверьте это самостоятельно.

Обращение к конкретному элементу двумерного массива происходит так же, как и в одномерном массиве. Сначала пишется имя массива, а затем в отдельных квадратных скобках номер строки и номер столбца. Главное тут не перепутать. Сначала пишем номер строки, затем номер столбца. Ну и не забывайте про то, что нумерация начинается с нуля.

|_Рис.4 Обращение к конкретному элементу двумерного массива._|
|:-:|
|![008](/StepikC/Pictures/008_002.png)|

Следующая программа иллюстрирует основные операции для работы с двумерными массивами.

_Листинг 4._

```c
#include <stdio.h>

int main(void) {

  int arr[4][8] = {{2,3,5,5,3,4,3,4},
                   {7,1,-3,2,11,243,0,6},
                   {5,1,-3,5,1,243,-5,-7},
                   {-4,2,15,2,83,22,2,4}};
  
  printf("%d\t%d\n\n", arr[0][3], arr[2][4]);

  for (int i = 0; i < 4; i = i + 1){
    for(int j = 0; j < 8; j = j + 1){
      printf("%d\t", arr[i][j]);
    }
    printf("\n");
  }

  return 0;
}
```

Как видите, если в одномерном массиве мы использовали один цикл для перебора всех элементов массива, то в двумерном два цикла. 

Первый цикл последовательно перебирает строчки, а второй последовательно перебирает элементы строки. 

Индексы массива в цикле будут перебираться в следующей последовательности:

```c
i = 0;
  j = 0; 
  j = 1;
  j = 2; 
  j = 3;
  j = 4; 
  j = 5;
  j = 6; 
  j = 7;
i = 1;
  j = 0; 
  j = 1;
  j = 2; 
  j = 3;
  j = 4; 
  j = 5;
  j = 6; 
  j = 7;
```
и т.д.

Следующая программа заполнит массив числами по порядку, а потом выведет его на экран.

_Листинг 5._

```c
#include <stdio.h>

int main(void) {

  int arr[4][8] = {0};
  int k = 1;

  for (int i = 0; i < 4; i = i + 1){
    for(int j = 0; j < 8; j = j + 1){
      arr[i][j] = k;
      k = k + 1;
    }
  }

  for (int i = 0; i < 4; i = i + 1){
    for(int j = 0; j < 8; j = j + 1){
      printf("%d\t", arr[i][j]);
    }
    printf("\n");
  }

  return 0;
}
```

Вот и всё, что вам необходимо знать на начальном этапе о массивах. Теперь нужно хорошенько потренироваться в их использовании на практике.

[Содержание](#содержание)

<hr>

# Задачи Часть 1

## Реверс. Переставить элементы массива в обратном порядке.

Входные данные:
Первая строка число N,(N>0) -- длина массива. Длина массива не более 100 элементов. Вторая строка N  целых чисел, записанных через пробел

Выходные данные:

Элементы исходного массива, записанные в обратном порядке. Между собой элементы разделяются пробелом.

```c
#include <stdio.h>

int main() {
    int N; scanf("%d", &N);
    int digits[N], revers[N], temp, i, j;

    for (i = 0; i < N; i++) scanf("%d", &digits[i]);
    for (i = 0; i < N; i++) revers[N - 1 - i] = digits[i];
    for (i = 0; i < N; i++) printf("%d%s", revers[i], i == N - 1 ? "\n" : " ");
  return 0;
}
```

```c
#include <stdio.h>

int main() {
    int n;
    scanf("%d", &n); int a[n];
    for (int i = 1; i <= n; i++) {
        scanf("%d", &a[i]);
    } for (int i = n; i >= 1; i--) {
        printf("%d ", a[i]);
    }
}
```

[Содержание](#содержание)

<hr>

## Палиндром
Определить является ли массив палиндромом, т.е. первый элемент равен последнему, второй предпоследнему и т.д.

Входные данные:
Первая строка число N,(N>0) -- длина массива. Длина массива не более 100 элементов. Вторая строка N  целых чисел, записанных через пробел

Выходные данные:
YES -- если массив является палиндромом, NO -- в противном случае.

```c
#include <stdio.h>

int main() {
    int N, i, flag = 0; scanf("%d", &N);
    int digits[N];

    for (i = 0; i < N; i++) scanf("%d", &digits[i]);
    for (i = 0; i < N / 2; i++)
    {
        if (digits[i] != digits[N - 1 - i])
        {
        flag = 1; break;
        }
    }
    printf("%s",  flag ? "NO" : "YES");
    return 0;
}
```

[Содержание](#содержание)

<hr>

## Вывести сначала чётные элементы массива, а затем нечётные.

Входные данные:
Первая строка число N,(N>0) -- длина массива. Длина массива не более 100 элементов. Вторая строка N  натуральных чисел, записанных через пробел

Выходные данные:

Элементы массива, упорядоченные соответствующим образом. Сначала чётные элементы массива в том порядке, как они встречаются в массиве, затем нечётные элементы массива в том порядке, как они встречаются в массиве.

```c
#include <stdio.h>

int main() {
    int N, i, flag = 0; scanf("%d", &N);
    int digits[N];
    for (i = 0; i < N; i++) scanf("%d", &digits[i]);
    for (i = 0; i < N; i++)
        if (digits[i] % 2) {continue;}
        else printf("%d ", digits[i]);
    for (i = 0; i < N; i++)
        if (digits[i] % 2) {printf("%d ", digits[i]);}
        else continue;
    return 0;
  return 0;
}
```

[Содержание](#содержание)

<hr>

## Напишите программу, выводящую на экран все элементы массива, которые меньше последнего.

Входные данные:
Первая строка число N,(N>0) -- длина массива. Длина массива -- не более 100 элементов. Вторая строка -- N  натуральных чисел, записанных через пробел

Выходные данные:

Элементы массива, которые меньше его последнего элемента в том порядке, как они встречаются в массиве, через пробел, или же число 0, если таких элементов не существует.

```c
#include <stdio.h>

int main() {
    int N, i, flag = 0; scanf("%d", &N);
    int digits[N];
    for (i = 0; i < N; i++) scanf("%d", &digits[i]);
    
    for (i = 0; i < N - 1; i++)
        if (digits[i] < digits[N - 1]) {printf("%d ", digits[i]); flag++;}

    if (flag == 0) {printf("%d", 0);}
  return 0;
}
```

[Содержание](#содержание)

<hr>

## Напишите программу, выводящую на экран все элементы массива, которые меньше последнего элемента и больше первого элемента массива.

Входные данные:
Первая строка число N,(N>0) -- длина массива. Длина массива не более 100 элементов. Вторая строка  N  натуральных чисел, записанных через пробел

Выходные данные:

Элементы массива, которые меньше последнего элемента массива и больше первого. Вывод осуществлять в том порядке, в котором элементы встречаются в массиве. Число 0, если таких элементов не существует.

```c
#include <stdio.h>

int main() {
    int N, i, flag = 0; scanf("%d", &N);
    int D[N];
    for (i = 0; i < N; i++) scanf("%d", &D[i]);
    
    for (i = 1; i < N - 1; i++)
        if (D[i] > D[0] && D[i] < D[N - 1]) {printf("%d ", D[i]); flag++;}

    if (flag == 0) {printf("%d", 0);}
  return 0;
}
```

[Содержание](#содержание)

<hr>

## Найти среднее арифметическое элементов массива.

Входные данные:
Первая строка число N,(N>0) -- длина массива. Длина массива не более 100 элементов. Вторая строка N  натуральных чисел, записанных через пробел

Выходные данные:

Одно вещественное число M -- среднее арифметическое элементов массива. Формат вывода -- два знака после запятой.

```c
#include <stdio.h>

int main() {
    int N, i, res = 0; scanf("%d", &N);
    int D[N];
    for (i = 0; i < N; i++)
    {
        scanf("%d", &D[i]);
        res += D[i];
    }
    printf("%.2lf", (double)res / N);
    return 0;
}
```

[Содержание](#содержание)

<hr>

## Разделить массив на две части, поместив в первую элементы, большие среднего арифметического массива, а во вторую — меньшие.

Входные данные:
Первая строка число N,(N>0) -- длина массива. Длина массива не более 100 элементов. Вторая строка N  натуральных чисел, записанных через пробел

Выходные данные:

Новый массив, в котором сначала записаны элементы, большие среднего арифметического массива, а потом -- меньшие либо равные. Внутри частей элементы располагать в том порядке, в котором они встретились в исходном массиве.

```c
#include <stdio.h>

int main() {
    int N, i, res = 0; scanf("%d", &N);
    int digits[N];
    for (i = 0; i < N; i++) {scanf("%d", &digits[i]); res += digits[i]; }

    res = (double)res / N;

    for (i = 0; i < N; i++)
        if (digits[i] > res) { printf("%d ", digits[i]);}
    for (i = 0; i < N; i++)
        if (digits[i] <= res) {printf("%d ", digits[i]);}
    return 0;
}
```
В этом решении выполняется перестановка элементов в самом массиве как того и требует условие задания: " Разделить массив на две части..."!

```c
#include <stdio.h>

int main() {
    int n, m[100], sum = 0;
    scanf("%d", &n);
    for (int i = 0; i < n; ++i)  scanf("%d", &m[i]), sum += m[i];  
    
    int average = sum/n, cnt, k = 0;
    // swaping algorithm - модификация алгоритма пузырьковой сортировки
    do {  
        cnt = 0; ++k; 
        for (int i = 0; i < n-k; ++i)
            if ( m[i] <= average && m[i+1] > average) {
                int tmp = m[i]; m[i] = m[i+1]; m[i+1] = tmp;  // swap
                ++cnt;
            }        
    }  while(cnt);
    for (int i = 0; i < n; ++i)  printf("%d ", m[i]); 
    return 0;
}
```

[Содержание](#содержание)

<hr>

## В заданном массиве поменять местами первую и вторую половины.

Входные данные:
Первая строка число N,(N>0) -- длина массива (чётное число). Длина массива не более 100 элементов. Вторая строка N  натуральных чисел, записанных через пробел.

Выходные данные:

Новый массив, в котором сначала записана вторая половина входной последовательности (элементы от N/2 до N), а потом записана первая половина входной последовательности (элементы от 0 до N/2). Между собой значения разделять одним пробелом.

```c
#include <stdio.h>

int main() {
    int N, i, tmp; scanf("%d", &N);
    int D[N];
    for (i = 0; i < N; i++) {scanf("%d", &D[i]);}

    for (i = 0; i < N / 2; i++)
    {
        tmp = D[i]; D[i] = D[N/2 + i]; D[N/2 + i] = tmp;  // swap
    }
    
    for (i = 0; i < N; i++) {printf("%d ", D[i]);}
    return 0;
}
```

[Содержание](#содержание)

<hr>

## В заданном массиве поменять местами наибольший и наименьший элементы.

Входные данные:

Первая строка число N,(N>0) -- длина массива. Длина массива не более 100 элементов. Вторая строка N  натуральных чисел, записанных через пробел.

Выходные данные:

Новый массив, в котором на месте минимума(ов) стоит максимум, а на месте максимума(ов) стоит минимум. Остальные элементы массива остаются на прежних местах.

```c
#include <stdio.h>

int main() {
    int N, i, tmp, min = 2147483647, max = 0; scanf("%d", &N);
    int D[N];
    for (i = 0; i < N; i++) 
    {
        scanf("%d", &D[i]);
        if (D[i] > max) max = D[i];
        if (D[i] < min) min = D[i];
    }

    for (i = 0; i < N; i++)
    {
        if (D[i] == max) D[i] = min;
        else if (D[i] == min) D[i] = max;
    }
    
    for (i = 0; i < N; i++) {printf("%d ", D[i]);}
    return 0;
}
```

[Содержание](#содержание)

<hr>

# Задачи Часть 2

## Вывести элементы двумерного массива (матрицы) на экран.

Входные данные:
Два целых неотрицательных числа N и M. Далее с новой строки N строк по M целых чисел в каждой. 

N и M не превышают десяти.

Выходные данные:

Вывести матрицу N на M. Числа в строках записывать через пробел.

```c
#include <stdio.h>

int main() {
    int N, M, i, j; scanf("%d%d", &N, &M);

    int D[N][M];
    
    for (i = 0; i < N; i++) 
    {   
        for (j = 0; j < M; j++) scanf("%d", &D[i][j]);  
    }
    
    for (i = 0; i < N; i++) 
    {   
        for (j = 0; j < M; j++) printf("%d%s", D[i][j], j == M-1? "\n" : " ");

    }
  return 0;
}
```

[Содержание](#содержание)

<hr>

## Транспонирование
Для заданной матрицы вывести на экран транспонированную матрицу.

Входные данные:

Два натуральных числа N и M. Далее с новой строки N строк по M целых чисел в каждой. 

N и M не превышают десяти.

Выходные данные:

Вывести матрицу M на N. Числа в строках записывать через пробел.

Справка:

Транспонированная матрица получается из обычной заменой строк на столбики. 

Пример:

```
Исходная матрица:
1 2 3 4
5 6 7 8

Транспонированная матрица:
1 5
2 6
3 7
4 8
```

```c
#include <stdio.h>

int main() {
    
    int N, M, i, j; scanf("%d%d", &N, &M);

    int D[N][M];
    
    for (i = 0; i < N; i++) 
    {   
        for (j = 0; j < M; j++) scanf("%d", &D[i][j]);  
    }
    
    for (j = 0; j < M; j++) 
    {   
        for (i = 0; i < N; i++) printf("%d ", D[i][j]);
        printf("\n");
    }
    
  return 0;
}
```

[Содержание](#содержание)

<hr>

## По заданному числу N сформировать матрицу (N×N) следующего вида:

```
1  2    3   ...  n-1  n
n  n-1  n-2 ...  2    1
1  2    3   ...  n-1  n
n  n-1  n-2 ...  2    1
1  2    3   ...  n-1  n
n  n-1  n-2 ...  2    1
```

Входные данные:

Одно натуральное число N.

Выходные данные:

Вывести на экран массив N на N, указанного вида. Числа разделять пробелами.

```c
#include <stdio.h>

int main() {

    int N, i, j; scanf("%d%d", &N);

    int D[N][N];
    
    for (i = 0; i < N; i++) 
    {   
        for (j = 0; j < N; j++) D[i][j] = i % 2 ? N - j : j + 1;
    }
    
    for (i = 0; i < N; i++) 
    {   
        for (j = 0; j < N; j++) printf("%d ", D[i][j]);
        printf("\n");
    }
    
    return 0;
}
```

```c
#include <stdio.h>

int main() {
    int n; scanf("%d", &n); int a[n][n];
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            printf("%d ", i % 2 == 0 ? j+1 : n-j);
        }
        printf("\n");
    }
}
```

[Содержание](#содержание)

<hr>

## Главная диагональ
По заданному числу N сформировать матрицу (N×N) следующего вида:

```
1    2    3   ...  n-2  n-1  n
2    1    2   ...  n-3  n-2  n-1
3    2    1   ...  n-4  n-3  n-2
...              ...
n-1  n-2  n-3 ...  2    1    2
n    n-1  n-2 ...  3    2    1
```

Входные данные:

Одно натуральное число N.

Выходные данные:

Вывести на экран массив N на N, указанного вида. Числа разделять пробелами.

```c
#include <stdio.h>

int main() {
    int N, i, j; scanf("%d%d", &N);

    int D[N][N];
    
    for (i = 0; i < N; i++) 
    {   
        for (j = 0; j < N; j++)
        D[i][j] = abs(j - i) + 1;
    }
    
    for (i = 0; i < N; i++) 
    {   
        for (j = 0; j < N; j++) printf("%d ", D[i][j]);
        printf("\n");
    }
  return 0;
}
```

Образцовое решение

Не поверете, в разделе двумерные матрицы я чуть ли не единственный который решил задачу используя... правильно, двуверные матрицы. Чтобы вас убедить в том, что ну хоть какая то польза от их использования её в этой задаче всё таки есть, я решил воспользоватся свойством симметричности искомой матрицы относительно главной диагонали. Это позволяет мне обходить только верхний треугольник матрицы а подсчитанное число тут же  копировать в симметричный ему элемент в нижней матрице. Чтобы не заполнять отдельно главную диагональ я захватываю в том же цикле и ее, хотя эффективнее было бы проходить по ней отдельно. Второй плюс - мне теперь не нужно пользоватся функцией abs!

```c
#include <stdio.h>
#define MAX_ARR_SIZE 10
int main() {
  int n, arr[MAX_ARR_SIZE][MAX_ARR_SIZE];
  scanf("%d", &n); 
  for (int i = 0; i < n; ++i) 
      for (int j = i; j < n; ++j) 
          arr[i][j] = arr[j][i] = 1 + (j-i); // использование симметричности матрицы
   
  for (int i = 0; i < n; ++i) {
      for (int j = 0; j < n; ++j)
          printf("%d ", arr[i][j]);         
      printf("\n");
  }
  return 0;
}
```

[Содержание](#содержание)

<hr>

## Диагонали
Для заданной квадратной матрицы A[N][N] посчитать следующие величины:

+ произведение элементов, стоящих на главной диагонали
+ произведение элементов, стоящих на побочной диагонали

Входные данные:

Одно натуральное число N. Далее с новой строки N строк по N целых чисел в каждой. N не превышают десяти.

Выходные данные:

Два целых числа, записанных через пробел. Первым вывести большее из чисел.

![008](/StepikC/Pictures/008_006.png)

```c
#include <stdio.h>

int main() {
    int N, i, j; scanf("%d", &N);

    int D[N][N];
    
    for (i = 0; i < N; i++) 
    {   
        for (j = 0; j < N; j++) scanf("%d", &D[i][j]);
    }
    
    int resA = 1, resB = 1;

    for (i = 0; i < N; i++) 
    {   
        for (j = 0; j < N; j++) 
        {
            if (i == j)
            {
                resA *= D[i][j];
            }
            if (N - i - 1 == j)
            {
                resB *= D[i][j];
            }
        }
    }
    if (resA > resB)
    {
        printf("%d %d", resA, resB);
    }
    else printf("%d %d", resB, resA);
  return 0;
}
```

[Содержание](#содержание)

<hr>

## Для заданной квадратной матрицы A[N] посчитать следующие величины:

+ сумму элементов, находящихся над главной диагональю
+ сумму элементов, расположенных под побочной диагональю

Входные данные:

Одно натуральное число N. Далее с новой строки N строк по N целых чисел в каждой. N не превышают десяти.

Выходные данные:

Два целых числа, записанных через пробел. Первым вывести меньшее из чисел.

```c
#include <stdio.h>

int main() {

    int N, i, j; scanf("%d", &N);

    int D[N][N];
    
    for (i = 0; i < N; i++) 
    {   
        for (j = 0; j < N; j++) scanf("%d", &D[i][j]);
    }
    
    int resA = 0, resB = 0;

    for (i = 0; i < N; i++) 
    {   
        for (j = 0; j < N; j++) 
        {
            if (j > i)
            {
                resA += D[i][j];
            }
            if (N - i - 1 < j)
            {
                resB += D[i][j];
            }
        }
    }
    if (resA < resB)
    {
        printf("%d %d", resA, resB);
    }
    else printf("%d %d", resB, resA);
    return 0;
}
```

[Содержание](#содержание)

<hr>

## Столбцы
Для заданной матрицы посчитать сумму элементов каждого столбца.

Входные данные:

Два натуральных числа N и M. Далее с новой строки N строк по M целых чисел в каждой. 

N и M не превышают десяти.

Выходные данные:

M целых чисел, записанных через пробел. Первой вывести сумму последнего столбца, второй предпоследнего и т.д.

```c
#include <stdio.h>

int main() {
    int N, M, i, j; scanf("%d %d", &N, &M);

    int D[N][M];
    
    for (i = 0; i < N; i++) 
    {   
        for (j = 0; j < M; j++) scanf("%d", &D[i][j]);
    }
    
    int Res[10] = {0};

    for (i = 0; i < N; i++) 
    {   
        for (j = 0; j < M; j++) 
        {
            Res[j] += D[i][j];
        }
    }

    for (j = M - 1; j >= 0; j--)
    {
        printf("%d ", Res[j]);
    }
  return 0;
}
```

[Содержание](#содержание)

<hr>

## Поменять местами столбцы с минимальной и максимальной суммой элементов.

Входные данные:

Два натуральных числа N и M. Далее с новой строки N строк по M целых чисел в каждой. 

N и M не превышают десяти.

Выходные данные:

Вывести исходную матрицу N на M, в которой столбцы с минимальной и максимальной суммой элементов поменяны местами. 

Числа разделять пробелами. 

Если присутствует несколько столбцов с одинаковой минимальной суммой элементов, то использовать первый по порядку. 

Аналогично с максимальной суммой.

```c
#include <stdio.h>

int main() {
    int N, M, i, j, min, max, minJ = 0, maxJ = 0, tmp;
    scanf("%d %d", &N, &M);

    int D[N][M];
    
    for (i = 0; i < N; i++) // заполняем матрицу
    {   
        for (j = 0; j < M; j++) scanf("%d", &D[i][j]);
    }
    
    int Res[10] = {0};

    for (i = 0; i < N; i++) // считаем суммы столбцов
    {   
        for (j = 0; j < M; j++) 
        {
            Res[j] += D[i][j];
        }
    }

    min = max = Res[0];

    for (j = 1; j < M; j++) // находим мин и макс суммы столбцов
    {
        if (min > Res[j]) {min = Res[j]; minJ = j;}
        if (max < Res[j]) {max = Res[j]; maxJ = j;}
    }
    
    for (i = 0; i < N; i++) // перестановка
    {
        tmp = D[i][maxJ]; D[i][maxJ] = D[i][minJ]; D[i][minJ] = tmp;
    }
    
    for (int i = 0; i < N; ++i) // печать
    {
      for (int j = 0; j < M; ++j) printf("%d ", D[i][j]);         
      printf("\n");
    }
    return 0;
}
```

[Содержание](#содержание)

<hr>

## Циклический сдвиг
Произвести циклический сдвиг столбцов квадратной матрицы A[N] на K позиций вправо.

Входные данные:

Одно натуральное число N. Далее с новой строки N строк по N целых чисел в каждой. 

N не превышают десяти. Затем с новой строки записано натуральное число K.

Выходные данные:

Вывести на исходную матрицу N на N, столбцы которой циклически сдвинуты на K позиций вправо. Числа разделять пробелами.

```c
#include <stdio.h>

int main() {
    int N, k, i, j, tmp;
    scanf("%d", &N);

    int D[N][N], res[N][N];
    
    for (i = 0; i < N; i++) // заполняем матрицу
    {   
        for (j = 0; j < N; j++) scanf("%d", &D[i][j]);
    }
    
    scanf("%d", &k);

    for (j = 0; j < N; j++) // перестановка
    {
        for (i = 0; i < N; i++) 
        {
            res[i][(j + k)%N] = D[i][j];
        }
    }

    for (int i = 0; i < N; ++i) // печать
    {
      for (int j = 0; j < N; ++j) printf("%d ", res[i][j]);         
      printf("\n");
    }
  return 0;
}
```

[Содержание](#содержание)

<hr>

## Змейка
Для заданных чисел M и N сформировать матрицу, заполненную по спирали числами от 1 до M⋅N.

![008](/StepikC/Pictures/008_007.PNG)

```c
#include <stdio.h>

int main() {
    
    int N, M, i = 0, j = 0, num = 1, flag = 0;
    scanf("%d%d", &N, &M);

    int D[N][M];
    
    int LL = 0, LR = 0, LU = 0, LD = 0;     // добавляем ограничители
    
    while(num <= M * N)       
    {
        if(flag == 0) {      // идём вправо
            for(int i =  LL; i < M - LR; i++)
            {
                D[LU][i] = ++num;
            }
            flag = 1;
            LU ++;
        }    
        if(flag == 1)       // идем вниз
        {
            for(int i =  LU; i < N - LD; i++)
            {
                D[i][M - LR-1] = num;
                num ++;
            }
            flag = 2;
            LR++;

        }
        if(flag == 2)       // идём влево
        {
            for(int i =  M - LR-1; i >= LL; i--)
            {
                D[N - LD-1][i] = num;
                num ++;
            }
            flag = 3;
            LD++;
        }
        if(flag == 3)       // идем вверх
        {
            for(int i =  N - LD - 1; i >= LU ; i--)
            {
                D[i][LL] = num;
                num ++;
            }
            flag = 0;
            LL++;

        }
    }
    for (int i = 0; i < N; i++) // печать
    {
      for (int j = 0; j < M; j++) printf("%d\t", D[i][j]);         
      printf("\n");
    }

  return 0;
}
```

Решение через `switch`

```c

```

[Содержание](#содержание)

<hr>



[Содержание курса](/StepikC/README.md)