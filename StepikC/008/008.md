# Урок 8. Массивы

## Содержание

+ [Зачем нужны массивы?](#зачем-нужны-массивы)
+ [Одномерные массивы: объявление, инициализация, обращение к элементу](#одномерные-массивы)
    + [Объявление и инициализация массива](#объявление-и-инициализация-массива)
    + [Работа с отдельными элементами массива](#работа-с-отдельными-элементами-массива)
Константы. Директива define
Двумерные массивы: объявление, инициализация, обращение к элементу
## Задачи. Список
+ [Задачи](#задачи)
    + [Реверс. Переставить элементы массива в обратном порядке.](#реверс-переставить-элементы-массива-в-обратном-порядке)


[Содержание курса](/StepikC/README.md)

# Зачем нужны массивы?

Начнём, как обычно, с задач, которые покажут, что тех инструментов, что у нас есть, недостаточно.

Помните программу для проверки равномерности распределения случайных чисел, генерируемых функцией rand? Я напомню.

_Листинг 1._

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define N 100

int main(void) {   
  srand(time(NULL));
// счётчики для сгенерированных чисел
// если выпадет 1, то увеличим на единицу count_1
  int count_0 = 0, count_1 = 0, count_2 =0;

  int rand_number;
  
  for (int i = 0; i < N; i = i + 1){
    rand_number = rand()%3;  
    switch (rand_number){
      case 0 : count_0 = count_0 + 1; break;
      case 1 : count_1 = count_1 + 1; break;
      case 2 : count_2 = count_2 + 1; break;
    }
  }

  printf("0 - %d\n1 - %d\n2 - %d\n", count_0, count_1, count_2);
  return 0;
}
```
Программа подсчитывает, сколько раз сгенерировано каждое из чисел 0, 1 и 2. Теперь вопрос. А что делать, если нужно провести миллион генераций для чисел от 0 до 100? Не создавать же 100 переменных?

Более общая задача: как сохранить в программе очень много однотипных данных, например, чисел?

Это может потребоваться, если мы ведём историю обращений в поликлинику и должны записывать серию и номер паспорта каждого обратившегося. Или мы хотим хранить данные о доходах и расходах в текущем месяце. Или записывать сумму баллов ЕГЭ для всех абитуриентов вуза. Или динамику курса валюты за сутки/месяц/год.

Для решения подобных задач (хранение большого количества однотипных данных) используются массивы. В этом уроке мы познакомимся с этим понятием.

[Содержание](#содержание)

<hr>

# Одномерные массивы

Массив – это простейший составной тип данных. Когда мы обсуждали переменные, у нас была хорошая аналогия с коробкой. Вернёмся к ней. Если переменная – это один ящик, то массив – это несколько пронумерованных одинаковых ящиков, которые имеют одно и то же имя, а различаются между собой только порядковым номером.

![008](/StepikC/Pictures/008_001.png)

_Рис.1 Переменные и массивы. Аналогия с коробками._

На картинке выше изображено три массива:
+ целочисленный массив из 8 элементов с именем arr_int
+ вещественный массив из 11 элементов с именем arr_float
+ символьный массив из 6 элементов с именем arr_char

У массива, как и у переменной, имеются свои имя и тип данных. Кроме того, у массива ещё есть одна дополнительная характеристика – размер массива. 

Размер массива – количество элементов, которые могут в нём храниться. В нашей аналогии с коробочками это количество коробок.

__Обратите внимание!__

Нумерация элементов массива начинается с нуля, а не с единицы.

[Содержание](#содержание)

<hr>

## Объявление и инициализация массива

Объявление массива очень похоже на объявление переменной. Отличие лишь в том, что следует дополнительно указать размер массива в квадратных скобках. Вот несколько примеров:

_Листинг 1._

```c
int arr_int[8];
double arr_float[11]; 
float number[2000];
```

На имя массива накладываются ограничения, аналогичные тем, которые накладываются на имя переменной.

### Правило именования массивов

__Имя массива__ – любая последовательность символов, цифр и знака нижнего подчеркивания «_», которая начинается с буквы. Регистр букв важен.

Вот ещё несколько примеров объявления массивов:

_Листинг 2._

```c
int grades[50], order[10];
double prices[500];
```

Массиву, как и любой переменной, можно присвоить начальные значения при объявлении. Если элементам массива не присвоить никакого значения, то в них будет храниться мусор, как и в обычных переменных.

_Листинг 3._

```c
int arr_int[5] = {2, 5, 5, 3, 4};
double arr_float[11] = {1.2, -2.3, 4.5, 3.83, 0.01, -0.12, 44.2, 123.7, 23.44, -3.7, 7};
```

Если нужно присвоить нулевые значения всем элементам массива, то можно сделать вот так:

_Листинг 4._

```c
double arr[50] = {0};
```

## Работа с отдельными элементами массива

Чтобы обратиться к отдельному элементу массива, необходимо написать его имя и порядковый номер в квадратных скобках. Не забывайте, что нумерация начинается с нуля, а не с единицы.

Давайте, например, выведем элементы массива из пяти элементов на экран.

_Листинг 5._

```c
#include <stdio.h>

int main(void){
  int arr[5] = {2, 4, 3, 5, 5};
  
  printf("%d %d %d %d %d\n",arr[0], arr[1], arr[2], arr[3], arr[4]);

  return(0);
}
```

Конечно, если массив будет очень большой, то выводить его поэлементно подобным образом то ещё удовольствие. Да и с маленькими массивами так никто не делает. Лучше и правильнее использовать циклы. Например:

_Листинг 6._

```c
#include <stdio.h>

int main(void){
  int arr[100] = {0};
  
  for(int i = 0; i < 100; i = i + 1){
    arr[i] = 2*i;
  }

  for(int i = 0; i < 100; i = i + 1){
    printf("%d\t",arr[i]);
  }

  return(0);
}
```

Программа в первом цикле сохраняет в массив первую сотню чётных чисел, а во втором цикле выводит их на экран.

Вооружившись новыми инструментами, давайте перепишем нашу программу из начала урока так, чтобы она использовала массив для хранения статистики выпадения случайных чисел.

_Листинг 7._

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main(void) {  
  srand(time(NULL));
  int count[3] = {0};
  int rand_number;
  
  for (int i = 0; i < 100000; i = i + 1){
    rand_number = rand()%3;
    count[rand_number] = count[rand_number] + 1;
  }

  for(int i = 0; i < 3; i = i + 1){
    printf("%d - %d\n", i, count[i]);
  }

  return 0;
}
```

Обратите внимание на приём, который используется в этой программе.

В нулевом элементе массива хранится количество выпадений числа 0, в первом элементе – количество выпадений числа 1, во втором элементе – числа 2. То есть само сгенерированное число позволяет определить, к какому элементу массива необходимо добавить единичку. Поэтому необходимость в операторе выбора `switch` отпадает. Удобно, не так ли?

[Содержание](#содержание)

<hr>

# Задачи

## Реверс. Переставить элементы массива в обратном порядке.

Входные данные:
Первая строка число N,(N>0) -- длина массива. Длина массива не более 100 элементов. Вторая строка N  целых чисел, записанных через пробел

Выходные данные:

Элементы исходного массива, записанные в обратном порядке. Между собой элементы разделяются пробелом.

```c
#include <stdio.h>

int main() {
    int N; scanf("%d", &N);
    int digits[N], revers[N], temp, i, j;

    for (i = 0; i < N; i++) scanf("%d", &digits[i]);
    for (i = 0; i < N; i++) revers[N - 1 - i] = digits[i];
    for (i = 0; i < N; i++) printf("%d%s", revers[i], i == N - 1 ? "\n" : " ");
  return 0;
}
```

```c
#include <stdio.h>

int main() {
    int n;
    scanf("%d", &n); int a[n];
    for (int i = 1; i <= n; i++) {
        scanf("%d", &a[i]);
    } for (int i = n; i >= 1; i--) {
        printf("%d ", a[i]);
    }
}
```

[Содержание](#содержание)

<hr>



[Содержание курса](/StepikC/README.md)