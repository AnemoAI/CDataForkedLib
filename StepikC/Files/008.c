/*
## Реверс. Переставить элементы массива в обратном порядке.

Входные данные:
Первая строка число N,(N>0) -- длина массива. Длина массива не более 100 элементов. Вторая строка N  целых чисел, записанных через пробел

Выходные данные:

Элементы исходного массива, записанные в обратном порядке. Между собой элементы разделяются пробелом.
*/

// #include <stdio.h>
// #include <conio.h>
// // #include <locale.h>
// // #include <math.h> // подключаем math.h

// int main() {
//     int N; scanf("%d", &N);
//     int digits[N], revers[N], temp, i, j;

//     for (i = 0; i < N; i++) scanf("%d", &digits[i]);
//     for (i = 0; i < N; i++) revers[N - 1 - i] = digits[i];
//     for (i = 0; i < N; i++) printf("%d%s", digits[i], i == N - 1 ? "" : " ");
    
//     getch();  
//     return 0;
// }

/*
## Палиндром
Определить является ли массив палиндромом, т.е. первый элемент равен последнему, второй предпоследнему и т.д.

Входные данные:
Первая строка число N,(N>0) -- длина массива. Длина массива не более 100 элементов. Вторая строка N  целых чисел, записанных через пробел

Выходные данные:
YES -- если массив является палиндромом, NO -- в противном случае
*/

// #include <stdio.h>
// #include <conio.h>
// #include <locale.h>
// #include <math.h> // подключаем math.h

// int main() {
//     int N, i, flag = 0; scanf("%d", &N);
//     int digits[N];

//     for (i = 0; i < N; i++) scanf("%d", &digits[i]);
//     for (i = 0; i < N / 2; i++)
//     {
//         if (digits[i] != digits[N - 1 - i]) {flag = 1; break;}
//     }
//     printf("%s",  flag ? "NO" : "YES");
    
//     getch();  
//     return 0;
// }

/*
## Вывести сначала чётные элементы массива, а затем нечётные.

Входные данные:
Первая строка число N,(N>0) -- длина массива. Длина массива не более 100 элементов. Вторая строка N  натуральных чисел, записанных через пробел

Выходные данные:

Элементы массива, упорядоченные соответствующим образом. Сначала чётные элементы массива в том порядке, как они встречаются в массиве, затем нечётные элементы массива в том порядке, как они встречаются в массиве.
*/

// int main() {
//     int N, i, flag = 0; scanf("%d", &N);
//     int digits[N];

//     for (i = 0; i < N; i++) scanf("%d", &digits[i]);
    
//     for (i = 0; i < N; i++)
//         if (digits[i] % 2) {continue;}
//         else printf("%d ", digits[i]);
//     for (i = 0; i < N; i++)
//         if (digits[i] % 2) {printf("%d ", digits[i]);}
//         else continue;
//     getch();  
//     return 0;
// }

/*
## Напишите программу, выводящую на экран все элементы массива, которые меньше последнего.

Входные данные:
Первая строка число N,(N>0) -- длина массива. Длина массива -- не более 100 элементов. Вторая строка -- N  натуральных чисел, записанных через пробел

Выходные данные:

Элементы массива, которые меньше его последнего элемента в том порядке, как они встречаются в массиве, через пробел, или же число 0, если таких элементов не существует.
*/

// int main() {
//     int N, i, flag = 0; scanf("%d", &N);
//     int digits[N];
//     for (i = 0; i < N; i++) scanf("%d", &digits[i]);
    
//     for (i = 0; i < N - 1; i++)
//         if (digits[i] < digits[N - 1]) {printf("%d ", digits[i]); flag++;}

//     if (flag == 0) {printf("%d", 0);}
    
//     getch();  
//     return 0;
// }

/*
## Напишите программу, выводящую на экран все элементы массива, которые меньше последнего элемента и больше первого элемента массива.

Входные данные:
Первая строка число N,(N>0) -- длина массива. Длина массива не более 100 элементов. Вторая строка  N  натуральных чисел, записанных через пробел

Выходные данные:

Элементы массива, которые меньше последнего элемента массива и больше первого. Вывод осуществлять в том порядке, в котором элементы встречаются в массиве. Число 0, если таких элементов не существует.
*/

// int main() {
//     int N, i, flag = 0; scanf("%d", &N);
//     int D[N];
//     for (i = 0; i < N; i++) scanf("%d", &D[i]);
    
//     for (i = 1; i < N - 1; i++)
//         if (D[i] > D[0] && D[i] < D[N - 1]) {printf("%d ", D[i]); flag++;}

//     if (flag == 0) {printf("%d", 0);}
    
//     getch();  
//     return 0;
// }

/*
## Найти среднее арифметическое элементов массива.

Входные данные:
Первая строка число N,(N>0) -- длина массива. Длина массива не более 100 элементов. Вторая строка N  натуральных чисел, записанных через пробел

Выходные данные:

Одно вещественное число M -- среднее арифметическое элементов массива. Формат вывода -- два знака после запятой.
*/

// #include <stdio.h>
// #include <conio.h>

// int main() {
//     int N, i, res = 0; scanf("%d", &N);
//     int D[N];
//     for (i = 0; i < N; i++)
//     {
//         scanf("%d", &D[i]);
//         res += D[i];
//     }
//     printf("%.2lf", (double)res / N);
    
//     getch();  
//     return 0;
// }

/*
## Разделить массив на две части, поместив в первую элементы, большие среднего арифметического массива, а во вторую — меньшие.

Входные данные:
Первая строка число N,(N>0) -- длина массива. Длина массива не более 100 элементов. Вторая строка N  натуральных чисел, записанных через пробел

Выходные данные:

Новый массив, в котором сначала записаны элементы, большие среднего арифметического массива, а потом -- меньшие либо равные. Внутри частей элементы располагать в том порядке, в котором они встретились в исходном массиве.
*/

// #include <stdio.h>
// #include <conio.h>

// int main() {
//     int N, i, res = 0; scanf("%d", &N);
//     int digits[N];
//     for (i = 0; i < N; i++) {scanf("%d", &digits[i]); res += digits[i]; }

//     res = (double)res / N;

//     for (i = 0; i < N; i++)
//         if (digits[i] > res) { printf("%d ", digits[i]);}
//     for (i = 0; i < N; i++)
//         if (digits[i] <= res) {printf("%d ", digits[i]);}
    
//     getch();  
//     return 0;
// }

/*
## В заданном массиве поменять местами первую и вторую половины.

Входные данные:
Первая строка число N,(N>0) -- длина массива (чётное число). Длина массива не более 100 элементов. Вторая строка N  натуральных чисел, записанных через пробел.

Выходные данные:

Новый массив, в котором сначала записана вторая половина входной последовательности (элементы от N/2 до N), а потом записана первая половина входной последовательности (элементы от 0 до N/2). Между собой значения разделять одним пробелом.
*/

// #include <stdio.h>
// #include <conio.h>

// int main() {
//     int N, i, tmp; scanf("%d", &N);
//     int D[N];
//     for (i = 0; i < N; i++) {scanf("%d", &D[i]);}

//     for (i = 0; i < N / 2; i++)
//     {
//         tmp = D[i]; D[i] = D[N/2 + i]; D[N/2 + i] = tmp;  // swap
//     }
    
//     for (i = 0; i < N; i++) {printf("%d ", D[i]);}
    
//     getch();  
//     return 0;
// }

/*
## В заданном массиве поменять местами наибольший и наименьший элементы.

Входные данные:

Первая строка число N,(N>0) -- длина массива. Длина массива не более 100 элементов. Вторая строка N  натуральных чисел, записанных через пробел.

Выходные данные:

Новый массив, в котором на месте минимума(ов) стоит максимум, а на месте максимума(ов) стоит минимум. Остальные элементы массива остаются на прежних местах.
*/

#include <stdio.h>
#include <conio.h>

int main() {
    int N, i, tmp, min = 2147483647, max = 0; scanf("%d", &N);
    int D[N];
    for (i = 0; i < N; i++) 
    {
        scanf("%d", &D[i]);
        if (D[i] > max) max = D[i];
        if (D[i] < min) min = D[i];
    }
    printf("%d%d", min, max);
    for (i = 0; i < N; i++)
    {
        if (D[i] = max)
        {
            D[i] = min;
        }
        else if (D[i] = min)
        {
            D[i] = max;
        }
    }
    
    for (i = 0; i < N; i++) {printf("%d ", D[i]);}
    
    getch();  
    return 0;
}