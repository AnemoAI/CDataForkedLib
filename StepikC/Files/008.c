/*
## Реверс. Переставить элементы массива в обратном порядке.

Входные данные:
Первая строка число N,(N>0) -- длина массива. Длина массива не более 100 элементов. Вторая строка N  целых чисел, записанных через пробел

Выходные данные:

Элементы исходного массива, записанные в обратном порядке. Между собой элементы разделяются пробелом.
*/

// #include <stdio.h>
// #include <conio.h>
// // #include <locale.h>
// // #include <math.h> // подключаем math.h

// int main() {
//     int N; scanf("%d", &N);
//     int digits[N], revers[N], temp, i, j;

//     for (i = 0; i < N; i++) scanf("%d", &digits[i]);
//     for (i = 0; i < N; i++) revers[N - 1 - i] = digits[i];
//     for (i = 0; i < N; i++) printf("%d%s", digits[i], i == N - 1 ? "" : " ");
    
//     getch();  
//     return 0;
// }

/*
## Палиндром
Определить является ли массив палиндромом, т.е. первый элемент равен последнему, второй предпоследнему и т.д.

Входные данные:
Первая строка число N,(N>0) -- длина массива. Длина массива не более 100 элементов. Вторая строка N  целых чисел, записанных через пробел

Выходные данные:
YES -- если массив является палиндромом, NO -- в противном случае
*/

// #include <stdio.h>
// #include <conio.h>
// #include <locale.h>
// #include <math.h> // подключаем math.h

// int main() {
//     int N, i, flag = 0; scanf("%d", &N);
//     int digits[N];

//     for (i = 0; i < N; i++) scanf("%d", &digits[i]);
//     for (i = 0; i < N / 2; i++)
//     {
//         if (digits[i] != digits[N - 1 - i]) {flag = 1; break;}
//     }
//     printf("%s",  flag ? "NO" : "YES");
    
//     getch();  
//     return 0;
// }

/*
## Вывести сначала чётные элементы массива, а затем нечётные.

Входные данные:
Первая строка число N,(N>0) -- длина массива. Длина массива не более 100 элементов. Вторая строка N  натуральных чисел, записанных через пробел

Выходные данные:

Элементы массива, упорядоченные соответствующим образом. Сначала чётные элементы массива в том порядке, как они встречаются в массиве, затем нечётные элементы массива в том порядке, как они встречаются в массиве.
*/

// int main() {
//     int N, i, flag = 0; scanf("%d", &N);
//     int digits[N];

//     for (i = 0; i < N; i++) scanf("%d", &digits[i]);
    
//     for (i = 0; i < N; i++)
//         if (digits[i] % 2) {continue;}
//         else printf("%d ", digits[i]);
//     for (i = 0; i < N; i++)
//         if (digits[i] % 2) {printf("%d ", digits[i]);}
//         else continue;
//     getch();  
//     return 0;
// }

/*
## Напишите программу, выводящую на экран все элементы массива, которые меньше последнего.

Входные данные:
Первая строка число N,(N>0) -- длина массива. Длина массива -- не более 100 элементов. Вторая строка -- N  натуральных чисел, записанных через пробел

Выходные данные:

Элементы массива, которые меньше его последнего элемента в том порядке, как они встречаются в массиве, через пробел, или же число 0, если таких элементов не существует.
*/

// int main() {
//     int N, i, flag = 0; scanf("%d", &N);
//     int digits[N];
//     for (i = 0; i < N; i++) scanf("%d", &digits[i]);
    
//     for (i = 0; i < N - 1; i++)
//         if (digits[i] < digits[N - 1]) {printf("%d ", digits[i]); flag++;}

//     if (flag == 0) {printf("%d", 0);}
    
//     getch();  
//     return 0;
// }

/*
## Напишите программу, выводящую на экран все элементы массива, которые меньше последнего элемента и больше первого элемента массива.

Входные данные:
Первая строка число N,(N>0) -- длина массива. Длина массива не более 100 элементов. Вторая строка  N  натуральных чисел, записанных через пробел

Выходные данные:

Элементы массива, которые меньше последнего элемента массива и больше первого. Вывод осуществлять в том порядке, в котором элементы встречаются в массиве. Число 0, если таких элементов не существует.
*/

// int main() {
//     int N, i, flag = 0; scanf("%d", &N);
//     int D[N];
//     for (i = 0; i < N; i++) scanf("%d", &D[i]);
    
//     for (i = 1; i < N - 1; i++)
//         if (D[i] > D[0] && D[i] < D[N - 1]) {printf("%d ", D[i]); flag++;}

//     if (flag == 0) {printf("%d", 0);}
    
//     getch();  
//     return 0;
// }

/*
## Найти среднее арифметическое элементов массива.

Входные данные:
Первая строка число N,(N>0) -- длина массива. Длина массива не более 100 элементов. Вторая строка N  натуральных чисел, записанных через пробел

Выходные данные:

Одно вещественное число M -- среднее арифметическое элементов массива. Формат вывода -- два знака после запятой.
*/

// #include <stdio.h>
// #include <conio.h>

// int main() {
//     int N, i, res = 0; scanf("%d", &N);
//     int D[N];
//     for (i = 0; i < N; i++)
//     {
//         scanf("%d", &D[i]);
//         res += D[i];
//     }
//     printf("%.2lf", (double)res / N);
    
//     getch();  
//     return 0;
// }

/*
## Разделить массив на две части, поместив в первую элементы, большие среднего арифметического массива, а во вторую — меньшие.

Входные данные:
Первая строка число N,(N>0) -- длина массива. Длина массива не более 100 элементов. Вторая строка N  натуральных чисел, записанных через пробел

Выходные данные:

Новый массив, в котором сначала записаны элементы, большие среднего арифметического массива, а потом -- меньшие либо равные. Внутри частей элементы располагать в том порядке, в котором они встретились в исходном массиве.
*/

// #include <stdio.h>
// #include <conio.h>

// int main() {
//     int N, i, res = 0; scanf("%d", &N);
//     int digits[N];
//     for (i = 0; i < N; i++) {scanf("%d", &digits[i]); res += digits[i]; }

//     res = (double)res / N;

//     for (i = 0; i < N; i++)
//         if (digits[i] > res) { printf("%d ", digits[i]);}
//     for (i = 0; i < N; i++)
//         if (digits[i] <= res) {printf("%d ", digits[i]);}
    
//     getch();  
//     return 0;
// }

/*
## В заданном массиве поменять местами первую и вторую половины.

Входные данные:
Первая строка число N,(N>0) -- длина массива (чётное число). Длина массива не более 100 элементов. Вторая строка N  натуральных чисел, записанных через пробел.

Выходные данные:

Новый массив, в котором сначала записана вторая половина входной последовательности (элементы от N/2 до N), а потом записана первая половина входной последовательности (элементы от 0 до N/2). Между собой значения разделять одним пробелом.
*/

// #include <stdio.h>
// #include <conio.h>

// int main() {
//     int N, i, tmp; scanf("%d", &N);
//     int D[N];
//     for (i = 0; i < N; i++) {scanf("%d", &D[i]);}

//     for (i = 0; i < N / 2; i++)
//     {
//         tmp = D[i]; D[i] = D[N/2 + i]; D[N/2 + i] = tmp;  // swap
//     }
    
//     for (i = 0; i < N; i++) {printf("%d ", D[i]);}
    
//     getch();  
//     return 0;
// }

/*
## В заданном массиве поменять местами наибольший и наименьший элементы.

Входные данные:

Первая строка число N,(N>0) -- длина массива. Длина массива не более 100 элементов. Вторая строка N  натуральных чисел, записанных через пробел.

Выходные данные:

Новый массив, в котором на месте минимума(ов) стоит максимум, а на месте максимума(ов) стоит минимум. Остальные элементы массива остаются на прежних местах.
*/

// #include <stdio.h>
// #include <conio.h>

// int main() {
//     int N, i, tmp, min = 2147483647, max = 0; scanf("%d", &N);
//     int D[N];
//     for (i = 0; i < N; i++) 
//     {
//         scanf("%d", &D[i]);
//         if (D[i] > max) max = D[i];
//         if (D[i] < min) min = D[i];
//     }
//     printf("%d%d", min, max);
//     for (i = 0; i < N; i++)
//     {
//         if (D[i] = max)
//         {
//             D[i] = min;
//         }
//         else if (D[i] = min)
//         {
//             D[i] = max;
//         }
//     }
    
//     for (i = 0; i < N; i++) {printf("%d ", D[i]);}
    
//     getch();  
//     return 0;
// }

/*
## Вывести элементы двумерного массива (матрицы) на экран.

Входные данные:
Два целых неотрицательных числа N и M. Далее с новой строки N строк по M целых чисел в каждой. 

N и M не превышают десяти.

Выходные данные:

Вывести матрицу N на M. Числа в строках записывать через пробел.
*/

// #include <stdio.h>
// #include <conio.h>

// int main() {

//     int N, M, i, j; scanf("%d%d", &N, &M);

//     int D[N][M];
    
//     for (i = 0; i < N; i++) 
//     {   
//         for (j = 0; j < M; j++) scanf("%d", &D[i][j]);  
//     }
    
//     for (i = 0; i < N; i++) 
//     {   
//         for (j = 0; j < M; j++) printf("%d%s", D[i][j], j == M-1? "\n" : " ");

//     }
    
//     getch();  
//     return 0;
// }

/*
## Транспонирование
Для заданной матрицы вывести на экран транспонированную матрицу.

Входные данные:

Два натуральных числа N и M. Далее с новой строки N строк по M целых чисел в каждой. 

N и M не превышают десяти.

Выходные данные:

Вывести матрицу M на N. Числа в строках записывать через пробел.

Справка:

Транспонированная матрица получается из обычной заменой строк на столбики. 

Пример:

```
Исходная матрица:
1 2 3 4
5 6 7 8

Транспонированная матрица:
1 5
2 6
3 7
4 8
```
*/

// #include <stdio.h>
// #include <conio.h>

// int main() {

//     int N, M, i, j; scanf("%d%d", &N, &M);

//     int D[N][M];
    
//     for (i = 0; i < N; i++) 
//     {   
//         for (j = 0; j < M; j++) scanf("%d", &D[i][j]);  
//     }
    
//     for (j = 0; j < M; j++) 
//     {   
//         for (i = 0; i < N; i++) printf("%d ", D[i][j]);
//         printf("\n");
//     }
    
//     getch();  
//     return 0;
// }

/*
## По заданному числу N сформировать матрицу (N×N) следующего вида:

```
1  2    3   ...  n-1  n
n  n-1  n-2 ...  2    1
1  2    3   ...  n-1  n
n  n-1  n-2 ...  2    1
1  2    3   ...  n-1  n
n  n-1  n-2 ...  2    1
```

Входные данные:

Одно натуральное число N.

Выходные данные:

Вывести на экран массив N на N, указанного вида. Числа разделять пробелами.
*/

// #include <stdio.h>
// #include <conio.h>

// int main() {

//     int N, i, j; scanf("%d%d", &N);

//     int D[N][N];
    
//     for (i = 0; i < N; i++) 
//     {   
//         for (j = 0; j < N; j++) D[i][j] = i % 2 ? N - j : j + 1;
//     }
    
//     for (i = 0; i < N; i++) 
//     {   
//         for (j = 0; j < N; j++) printf("%d ", D[i][j]);
//         printf("\n");
//     }
    
//     getch();  
//     return 0;
// }

/*
## По заданному числу N сформировать матрицу (N×N) следующего вида:

```
1    2    3   ...  n-2  n-1  n
2    1    2   ...  n-3  n-2  n-1
3    2    1   ...  n-4  n-3  n-2
...              ...
n-1  n-2  n-3 ...  2    1    2
n    n-1  n-2 ...  3    2    1
```

Входные данные:

Одно натуральное число N.

Выходные данные:

Вывести на экран массив N на N, указанного вида. Числа разделять пробелами.
*/

// #include <stdio.h>
// #include <conio.h>

// int main() {

//     int N, i, j; scanf("%d%d", &N);

//     int D[N][N];
    
//     for (i = 0; i < N; i++) 
//     {   
//         for (j = 0; j < N; j++) D[i][j] = i % 2 ? N - j : j + 1;
//     }
    
//     for (i = 0; i < N; i++) 
//     {   
//         for (j = 0; j < N; j++) printf("%d ", D[i][j]);
//         printf("\n");
//     }
    
//     getch();  
//     return 0;
// }

/*
## Главная диагональ
По заданному числу N сформировать матрицу (N×N) следующего вида:

```
1    2    3   ...  n-2  n-1  n
2    1    2   ...  n-3  n-2  n-1
3    2    1   ...  n-4  n-3  n-2
...              ...
n-1  n-2  n-3 ...  2    1    2
n    n-1  n-2 ...  3    2    1
```

Входные данные:

Одно натуральное число N.

Выходные данные:

Вывести на экран массив N на N, указанного вида. Числа разделять пробелами.
*/

// #include <stdio.h>
// #include <conio.h>
// #include <math.h>

// int main() {

//     int N, i, j; scanf("%d%d", &N);

//     int D[N][N];
    
//     for (i = 0; i < N; i++) 
//     {   
//         for (j = 0; j < N; j++) D[i][j] = abs(j - i) + 1;
//     }
    
//     for (i = 0; i < N; i++) 
//     {   
//         for (j = 0; j < N; j++) printf("%d ", D[i][j]);
//         printf("\n");
//     }
    
//     getch();  
//     return 0;
// }

/*
## Диагонали
Для заданной квадратной матрицы A[N][N] посчитать следующие величины:

+ произведение элементов, стоящих на главной диагонали
+ произведение элементов, стоящих на побочной диагонали

Входные данные:

Одно натуральное число N. Далее с новой строки N строк по N целых чисел в каждой. N не превышают десяти.

Выходные данные:

Два целых числа, записанных через пробел. Первым вывести большее из чисел.
*/

// #include <stdio.h>
// #include <conio.h>
// #include <math.h>

// int main() {

//     int N, i, j; scanf("%d", &N);

//     int D[N][N];
    
//     for (i = 0; i < N; i++) 
//     {   
//         for (j = 0; j < N; j++) scanf("%d", &D[i][j]);
//     }
    
//     int resA = 1, resB = 1;

//     for (i = 0; i < N; i++) 
//     {   
//         for (j = 0; j < N; j++) 
//         {
//             if (i == j)
//             {
//                 resA *= D[i][j];
//             }
//             if (N - i - 1 == j)
//             {
//                 resB *= D[i][j];
//             }
//         }
//     }
//     if (resA > resB)
//     {
//         printf("%d %d", resA, resB);
//     }
//     else printf("%d %d", resB, resA);
    
//     getch();  
//     return 0;
// }

// #include <stdio.h>
// #include <conio.h>
// #include <math.h>

// int main() {

//     int N, i, j; scanf("%d", &N);

//     int D[N][N];
    
//     for (i = 0; i < N; i++) 
//     {   
//         for (j = 0; j < N; j++) scanf("%d", &D[i][j]);
//     }
    
//     int resA = 0, resB = 0;

//     for (i = 0; i < N; i++) 
//     {   
//         for (j = 0; j < N; j++) 
//         {
//             if (j > i)
//             {
//                 resA += D[i][j];
//             }
//             if (N - i - 1 < j)
//             {
//                 resB += D[i][j];
//             }
//         }
//     }
//     if (resA < resB)
//     {
//         printf("%d %d", resA, resB);
//     }
//     else printf("%d %d", resB, resA);
    
//     getch();  
//     return 0;
// }

/*
## Столбцы
Для заданной матрицы посчитать сумму элементов каждого столбца.

Входные данные:

Два натуральных числа N и M. Далее с новой строки N строк по M целых чисел в каждой. 

N и M не превышают десяти.

Выходные данные:

M целых чисел, записанных через пробел. Первой вывести сумму последнего столбца, второй предпоследнего и т.д.
*/

// #include <stdio.h>
// #include <conio.h>
// #include <math.h>

// int main() {

//     int N, M, i, j; scanf("%d %d", &N, &M);

//     int D[N][M];
    
//     for (i = 0; i < N; i++) 
//     {   
//         for (j = 0; j < M; j++) scanf("%d", &D[i][j]);
//     }
    
//     int Res[10] = {0};

//     for (i = 0; i < N; i++) 
//     {   
//         for (j = 0; j < M; j++) 
//         {
//             Res[j] += D[i][j];
//         }
//     }

//     for (j = M - 1; j >= 0; j--)
//     {
//         printf("%d ", Res[j]);
//     }
        
//     getch();  
//     return 0;
// }

/*
## Поменять местами столбцы с минимальной и максимальной суммой элементов.

Входные данные:

Два натуральных числа N и M. Далее с новой строки N строк по M целых чисел в каждой. 

N и M не превышают десяти.

Выходные данные:

Вывести исходную матрицу N на M, в которой столбцы с минимальной и максимальной суммой элементов поменяны местами. 

Числа разделять пробелами. 

Если присутствует несколько столбцов с одинаковой минимальной суммой элементов, то использовать первый по порядку. 

Аналогично с максимальной суммой.
*/

// #include <stdio.h>
// #include <conio.h>
// #include <math.h>

// int main() {

//     int N, M, i, j, min, max, minJ = 0, maxJ = 0, tmp;
//     scanf("%d %d", &N, &M);

//     int D[N][M];
    
//     for (i = 0; i < N; i++) // заполняем матрицу
//     {   
//         for (j = 0; j < M; j++) scanf("%d", &D[i][j]);
//     }
    
//     int Res[10] = {0};

//     for (i = 0; i < N; i++) // считаем суммы столбцов
//     {   
//         for (j = 0; j < M; j++) 
//         {
//             Res[j] += D[i][j];
//         }
//     }

//     min = max = Res[0];

//     for (j = 1; j < M; j++) // находим мин и макс суммы столбцов
//     {
//         if (min > Res[j]) {min = Res[j]; minJ = j;}
//         if (max < Res[j]) {max = Res[j]; maxJ = j;}
//     }
    
//     for (i = 0; i < N; i++) // перестановка
//     {
//         tmp = D[i][maxJ]; D[i][maxJ] = D[i][minJ]; D[i][minJ] = tmp;
//     }
    
//     for (int i = 0; i < N; ++i) // печать
//     {
//       for (int j = 0; j < M; ++j) printf("%d ", D[i][j]);         
//       printf("\n");
//     }

//     getch();  
//     return 0;
// }

/*
## Циклический сдвиг
Произвести циклический сдвиг столбцов квадратной матрицы A[N] на K позиций вправо.

Входные данные:

Одно натуральное число N. Далее с новой строки N строк по N целых чисел в каждой. 

N не превышают десяти. Затем с новой строки записано натуральное число K.

Выходные данные:

Вывести на исходную матрицу N на N, столбцы которой циклически сдвинуты на K позиций вправо. Числа разделять пробелами.
*/

// #include <stdio.h>
// #include <conio.h>
// #include <math.h>

// int main() {

//     int N, k, i, j, tmp;
//     scanf("%d", &N);

//     int D[N][N], res[N][N];
    
//     for (i = 0; i < N; i++) // заполняем матрицу
//     {   
//         for (j = 0; j < N; j++) scanf("%d", &D[i][j]);
//     }
    
//     scanf("%d", &k);

//     for (j = 0; j < N; j++) // перестановка
//     {
//         for (i = 0; i < N; i++) // перестановка
//         {
//             res[i][(j + k)%N] = D[i][j];
//         }
//     }

//     for (int i = 0; i < N; ++i) // печать
//     {
//       for (int j = 0; j < N; ++j) printf("%d ", res[i][j]);         
//       printf("\n");
//     }

//     getch();  
//     return 0;
// }

/*
## Змейка
Для заданных чисел M и N сформировать матрицу, заполненную по спирали числами от 1 до M⋅N.
*/

#include <stdio.h>
#include <conio.h>
#include <math.h>

int main() {

    int N, M, i = 0, j = 0, num = 1, flag = 0;
    scanf("%d%d", &N, &M);

    int D[N][M];
    
    int LL = 0, LR = 0, LU = 0, LD = 0;     // добавляем ограничители
    
    while(num <= M * N)       
    {
        switch (flag)
        {
        // идём направо
        case 0:     
            for(int i =  LL; i < M - LR; i++) D[LU][i] = ++num;
            flag = 1; LU ++; break;
        // идем вниз
        case 1:     
            for(int i =  LU; i < N - LD; i++) D[i][M - LR-1] = ++num;
            flag = 2; LR++; break;
        // идём влево
        case 2:     
            for(int i =  M - LR-1; i >= LL; i--) D[N - LD-1][i] = ++num;
            flag = 3; LD++; break;
        // идем вверх
        case 3:     
            for(int i =  N - LD - 1; i >= LU ; i--) D[i][LL] = ++num;
            flag = 0; LL++; break;
        }
    }
    for (int i = 0; i < N; i++) // печать
    {
      for (int j = 0; j < M; j++) printf("%d\t", D[i][j]);         
      printf("\n");
    }

    getch();  
    return 0;
}