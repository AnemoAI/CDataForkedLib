# Ветвление

## Содержание

+ [Операторы ветвления в Си](#операторы-ветвления)
+ [Оператор выбора switch (переключатель). Оператор выхода break](#оператор-выбора-переключатель-switch)
    + [Задача на оператор `switch`. Программа-тест.](#задача-на-оператор-switch-программа-тест)
    + [Шаблон оператора switch](#шаблон-оператора-switch)
    + [Оператор break](#оператор-break)
    + [Сквозное выполнение](#сквозное-выполнение)
    + [Ветка default необязательная](#ветка-default-необязательная)
+ [Операции отношения и логические операции](#операции-отношения-и-логические-операции)
    + [Логические операции](#логические-операции)
    + [Приоритет логических операций](#приоритет-логических-операций)
+ [Условный оператор if--else. Составной оператор {}](#условный-оператор-if----else)
    + [Шаблон оператора if -- else](#шаблон-оператора-if----else)
    + [Нюанс 1. В каждой ветке условного оператора может быть записан лишь ОДИН оператор.](#нюанс-1-в-каждой-ветке-условного-оператора-может-быть-записан-лишь-один-оператор)
    + [Нюанс 2. Внутри управляющей конструкций if-else можно использовать любые конструкции языка, в том числе ещё одну конструкцию if-else.](#нюанс-2-внутри-управляющей-конструкций-if-else-можно-использовать-любые-конструкции-языка-в-том-числе-ещё-одну-конструкцию-if-else)
    + [Нюанс 3. else всегда относится к ближайшему if, у которого нет своего else](#нюанс-3-else-всегда-относится-к-ближайшему-if-у-которого-нет-своего-else)
    + [Дополнительные материалы](#дополнительные-материалы)
+ [Задачи](#задачи)
    + [Сказка о богатыре](#сказка-о-богатыре)
    + [Написать программу, позволяющую получить словесное описание школьных отметок (1 — «плохо», 2 — «неудовлетворительно», 3 — «удовлетворительно», 4 — «хорошо», 5 — «отлично»).](#написать-программу-позволяющую-получить-словесное-описание-школьных-отметок-1--«плохо»-2--«неудовлетворительно»-3--«удовлетворительно»-4--«хорошо»-5--«отлично»)
    + [Гадание](#гадание)
    + [Напишите программу-калькулятор для четырёх основных арифметических действий.](#напишите-программу-калькулятор-для-четырёх-основных-арифметических-действий)

[Содержание курса](/StepikC/README.md)

# Операторы ветвления

Как вы уже знаете из прошлого урока, в структурном программировании используется три основных конструкции:
+ следование
+ ветвление
+ цикл

В этом уроке будем разбираться, как реализовано ветвление в языке Си. Как и во многих других языках программирования, для реализации ветвления в Си используется две основных конструкции:
+ оператор выбора `switch`
+ условный оператор `if – else`

Оператор выбора `switch` позволяет выбрать один из нескольких заранее определённых вариантов. В этом случае у каждого варианта должна иметься своя отличительная черта, по которой можно один вариант отличить от другого.

Условный оператор `if – else` позволяет выполнять те или иные команды в зависимости от выполнения некоторого условия, которое программист может задать самостоятельно.

[Содержание](#содержание)

<hr>

# Оператор выбора (переключатель) switch

Начнём, как обычно, с примера задачи, которую поможет решить данный оператор.

## Задача на оператор `switch`. Программа-тест.

Написать программу, которая проверяет знание начала и конца Второй мировой войны. 

Выберите правильный вариант ответа. 

Начало и конец Второй мировой войны:

a. 01.09.1939 -- 2.09.1945<br>
b. 01.09.1939 -- 9.05.1945<br>
c. 22.06.1941 -- 9.05.1945<br>
d. 22.06.1941 -- 2.09.1945<br>

При выборе правильного варианта вывести GOOD, при выборе неправильного BAD. 

Если выбран вариант, которого нет в ответах, вывести ERROR.

Сделаем заготовку.

_Листинг 1._

```c
#include <stdio.h>
#include <locale.h> // для функции setlocale

int main(void) { 
  setlocale(LC_ALL, ""); // чтобы использовать русские символы
  
  printf("Выберите правильный вариант ответа. Начало и конец Второй мировой войны:\n");
  printf("  a. 1 сентября 1939 -- 2 сентября 1945\n");
  printf("  b. 1 сентября 1939 -- 9 мая 1945\n");
  printf("  c. 22 июня 1941 -- 9 мая 1945\n");
  printf("  d. 22 июня 1941 -- 2 сентября 1945\n");
  
  char answer; 
  printf("Введите ваш вариант ответа: ");
  scanf("%c",&answer);

  return 0;
}
```		
Посмотрите на эту заготовку. Там есть две строчки, которые вам пока неизвестны. В комментариях я кратко подписал, для чего эти строчки нужны.

Используйте заголовочный файл `locale.h` и функцию `setlocale` в своих программах, если хотите использовать русские символы.

## Шаблон оператора switch

Общий шаблон для оператора switch.

_Листинг 2._

```c
switch (выражение) {
  case ключ_1: операторы_1 
  case ключ_2: операторы_2
  case ключ_3: операторы_3
  case ключ_4: операторы_4

  default: операторы_стандарт
}   
```

Работает он следующим образом.

Вычисляется, если необходимо, выражение, записанное в скобках. Именно от значения этого выражения зависит, какая из ветвей программы будет выполняться. 

Сразу же отметим первое ограничение, которое накладывается на это выражение.

В качестве выражения может использоваться переменная типа `int`, переменная типа `char` или любое выражение, результат которого будет иметь данные типы.

Примеры правильных и неправильных выражений:

```c
int i,k;
char c;
double g;

switch (i)        //Правильно (целая переменная)
switch ((i+k)+6)  //Правильно (выражение целого типа)
switch (g)        //Неправильно (вещественная переменная)
switch (c)        //Правильно (символьная переменная)
```

После того как выражение вычислено, его результат проверяется на соответствие с ключ_1, потом с ключ_2, потом с ключ_3 и т.д.

Если выражение и какой-нибудь ключ совпали, то выполняются операторы, которые расположены после данного ключа.

Внимательно следите за тем, чтобы у каждый ветки `case` был свой уникальный ключ.

Если совпадений не обнаружено, то выполняются операторы, записанные в ветке `default`.

Надеюсь, общий принцип работы оператора `switch` ясен. А если не ясен, посмотрите на следующую картинку. На ней я нарисовал условную блок-схему для этого оператора и нашей задачки.

![006](/StepikC/Pictures/006_001.png)

_Рис.1 Условная схема оператора выбора switch_

Теперь давайте дополним нашу программу. В качестве выражения-переключателя у нас будет выступать переменная answer. В качестве ключей буквы a, b, c и d. Получится вот такой код.

_Листинг 3._

```c
#include <stdio.h>
#include <locale.h> // для функции setlocale

int main(void) { 
  setlocale(LC_ALL, ""); // чтобы использовать русские символы
  
  printf("Выберите правильный вариант ответа. Начало и конец Второй мировой войны:\n");
  printf("  a. 1 сентября 1939 -- 2 сентября 1945\n");
  printf("  b. 1 сентября 1939 -- 9 мая 1945\n");
  printf("  c. 22 июня 1941 -- 9 мая 1945\n");
  printf("  d. 22 июня 1941 -- 2 сентября 1945\n");
  
  char answer; 
  printf("Введите ваш вариант ответа: ");
  scanf("%c",&answer);

  switch (answer) {
    case 'a': printf("GOOD!\n");
    case 'b': printf("BAD!\n");
    case 'c': printf("BAD!\n");
    case 'd': printf("BAD!\n");
    default: printf("ERROR!\n");
  }

  return 0;
}
```	

## Оператор break

Теперь давайте потестируем нашу программу. Запустим её и введём правильный ответ. Результат работы:

![006](/StepikC/Pictures/006_002.png)

_Рис.2 Результат работы программы Листинг 3._

Ууппс… Не ожидали? А я ожидал. Это одна из особенностей оператора switch, о которой я вам пока не рассказал. Эта особенность называется сквозное выполнение. Поясню, как это работает.

После того как нашлось совпадение в одной из веток case, если явно не указан выход из оператора `switch`, то выполнятся последовательно все остальные ветки, записанные в коде после той, в которой произошло совпадение. Если в какой-то из них будет оператор выхода, то выполнение оператора `switch` завершится.

В нашем случае мы ввели символ a, программа выполнила первую ветку, и т.к. нет оператора выхода, то стали выполняться остальные ветки. При этом проверка на совпадение с ключами этих веток игнорируются. Чуть ниже я покажу, как можно использовать эту особенность для пользы дела.

А теперь собственно об операторе безусловного выхода. Наверное вы уже догадались, что это оператор `break`. Данный оператор завершает выполнение ближайшего к нему оператора `switch`, в котором он расположен.

Давайте добавим этот оператор в нашу программу.

_Листинг 4._

```c
#include <stdio.h>
#include <locale.h> // для функции setlocale

int main(void) { 
  setlocale(LC_ALL, ""); // чтобы использовать русские символы
  
  printf("Выберите правильный вариант ответа. Начало и конец Второй мировой войны:\n");
  printf("  a. 1 сентября 1939 -- 2 сентября 1945\n");
  printf("  b. 1 сентября 1939 -- 9 мая 1945\n");
  printf("  c. 22 июня 1941 -- 9 мая 1945\n");
  printf("  d. 22 июня 1941 -- 2 сентября 1945\n");
  
  char answer; 
  printf("Введите ваш вариант ответа: ");
  scanf("%c",&answer);

  switch (answer) {
    case 'a': printf("GOOD!\n"); break;
    case 'b': printf("BAD!\n"); break;
    case 'c': printf("BAD!\n"); break;
    case 'd': printf("BAD!\n"); break;
    default: printf("ERROR!\n"); break;
  }

  return 0;
}
```

Теперь всё работает как надо. Теперь пара нюансов.

Ветви case оператора switch можно разместить в любом порядке.

Например, так:

_Листинг 5._

```c
switch (answer) {
  case 'a': printf("GOOD!\n"); break;
  default: printf("ERROR!\n"); break;
  case 'd': printf("BAD!\n"); break;   
  case 'b': printf("BAD!\n"); break;
  case 'c': printf("BAD!\n"); break;
 }
``` 

## Сквозное выполнение.

Обратим сквозное выполнение себе на пользу.

Обратите внимание, что у нас имеется три ветки, которые выполняют по сути один и тот же код. Не важно, ввёл пользователь b, c или d, программа должна вывести BAD!. Тогда можно сделать, например, так:

_Листинг 6._

```c
switch (answer) {
  case 'a': printf("GOOD!\n"); break;
  case 'b': 
  case 'c':
  case 'd': printf("BAD!\n"); break;   
  default: printf("ERROR!\n"); break;
}
``` 
 
Поняли трюк? Пользователь выбирает, например, ответ b. Сначала выполняются операторы этой ветки. Там их нет. При этом нет и оператора `break`. А значит, идёт сквозное выполнение. Выполняется ветка c. Там тоже нет `break`. Выполняется ветка d. Выводится строчка BAD!. Дальше следует оператор `break`. Выходим из оператора `switch`. Удобно, не правда ли?

## Ветка default необязательная.

В нашей программе данная ветвь присутствует только для того, чтобы выполнить одно из условий задачи. Мы вполне могли бы её удалить. Но тогда мы не смогли бы выводить сообщение об ошибке при вводе каких-либо символов, кроме a, b, c и d.

Как я писал выше, операторы ветки `default` выполняются в том случае, если выражение-переключатель не совпало ни с одним ключом в ветках `case`. Если бы данной ветки не было, то программа просто завершила бы выполнение оператора `switch`. Ни одна из его веток так и не была бы выполнена.

И последнее. Операторы `switch` могут быть вложенными. В любой ветке оператора `switch` вы снова можете использовать новый оператор `switch`. 

Вот небольшой пример. 

Следующая программа определяет делится ли введённое число на 6.

_Листинг 7. Проверка делимости на 6_

```c
#include <stdio.h>

int main(void) {  
  printf("Enter the number: "); 
  
  int num = 0;  
  scanf("%d",&num);

  switch (num%3) {
    case 0 : 
      switch (num%2) {
        case 0 : printf("GOOD!\n"); break;
        case 1 : printf("BAD!\n"); break;
      }
      break;
    case 1 :
    case 2 : printf("BAD!\n"); break;
  }

  return 0;
}
```	

Итоговая программа, которая решает задачу предложенную в начале урока после всех улучшений и дополнений:

_Листинг 8._

```c
#include <stdio.h>
#include <locale.h> // для функции setlocale

int main(void) { 
  setlocale(LC_ALL, ""); // чтобы использовать русские символы
  
  printf("Выберите правильный вариант ответа. Начало и конец Второй мировой войны:\n");
  printf("  a. 1 сентября 1939 -- 2 сентября 1945\n");
  printf("  b. 1 сентября 1939 -- 9 мая 1945\n");
  printf("  c. 22 июня 1941 -- 9 мая 1945\n");
  printf("  d. 22 июня 1941 -- 2 сентября 1945\n");
  
  char answer; 
  printf("Введите ваш вариант ответа: ");
  scanf("%c",&answer);

  switch (answer) {
    case 'a': printf("GOOD!\n"); break;
    case 'b': 
    case 'c': 
    case 'd': printf("BAD!\n"); break;
    default:  printf("ERROR!\n"); break;
  }

  return 0;
}
``` 

В комментариях к одному из практических заданий моё внимание обратили на тот факт, что во всех примерах урока в качестве операторов в ветках case используется вызов функции `printf`. 

У некоторых учеников сложилось впечатление, что там можно использовать только функцию вывода. Нет, это не так. 

В любой ветке `case` вы можете производить любые действия:
+ вычислять значения,
+ объявлять переменные,
+ использовать другие переключатели и управляющие конструкции и пр. 

Приведу наглядный пример.

_Листинг 9._

```c
#include <stdio.h>
int main(void){
  int a = 2;
  int value = 1;
  scanf("%d", &value);
  
  switch (value){
    case 2 : a = a*value; break;
    case 3 : a = a + value; break;
  }
  printf("result = %d\n", a);  

return(0);
}
```

[Содержание](#содержание)

<hr>

# Операции отношения и логические операции

## Логические операции
Как я уже писал ранее, условный оператор выполняет те или иные действия в зависимости от выполнения условия, заданного программистом. Давайте обсудим, какие условия можно задать в языке Си.

Сразу же напомню, что компьютер не очень-то сообразительный. В данном случае это проявляется в том, что он понимает только простые условия на да/нет. Но обо всём по порядку.

Самое простое, что умеет делать компьютер, – это сравнивать между собой числа и значения числовых выражений. Для этого предназначены операции отношения.

_Листинг 1._

|||
|-|-|
|> | больше |
|>= | больше либо равно |
|< | меньше |
|<= | меньше либо равно |
|== | равно |
|!= | не равно  |

Вот посмотрите на некоторые примеры:

_Листинг 2._

```c
#include <stdio.h>

int main(void) { 
  
  int a = 10, b = 5, c = 2;
  char ch = 'a';
  
  printf("%d\n", b > c );
  printf("%d\n", a == b*c );
  printf("%d\n", a != b*c );
  printf("%d\n", a < c );
  printf("%d\n", b >= c + 3 );
  printf("%d\n", -1 <= 2 );
  printf("%d\n", ch == 'a');
  printf("%d\n", ch != 'a');
    
  return 0;
}
```

Вы ещё помните, что компьютер понимает только нули и единицы? Так вот, как вы уже догадались:

_Правило!_

>нуль это ложь, а единица – истина.

Вообще, любое число, кроме нуля, интерпретируется как истина. Думаю, дополнительных пояснений эти операции не требуют. 

Хотя на операцию сравнения обратите особое внимание. Т.к. один знак равно = используется для оператора присваивания, то для операции сравнения используется два знака равенства ==. 

Будьте внимательны и не забывайте об этом. Это частая ошибка, которую совершают начинающие программисты.

Кроме операций отношения есть ещё и логические операции. Они используются для того, чтобы из простых условий создавать сложные. Уже немного испугались? Да не, на самом деле ничего сложного. Сейчас разберёмся.

Логических операций всего три штуки:

_Листинг 3._

|||
|-|-|
|! | логическое НЕ. |
|&& | логическое И. |
|\|\| | логическое ИЛИ. |

Давайте объясню, как они работают.

Оператор логическое НЕ !(условие) отрицает выражение, к которому он был применён. Если условие было истиной, оно становится ложью, а если было ложью, то становится истиной. Вот пример:

_Листинг 4._

```c
#include <stdio.h>

int main(void) { 
  
  int a = 10, b = 5, c = 2;
    
  printf("%d\n", a == b*c );
  printf("%d\n", !(a == b*c) );
  printf("%d\n", a != b*c );
  printf("%d\n", !(a != b*c) );
    
  return 0;
}
```
(условие1) && (условие2) - оператор логическое И. Возвращает истину, если оба условия истинны. Иначе возвращает ложь.

Примеры:

_Листинг 5._

```c
#include <stdio.h>

int main(void) { 

  printf("%d\n", 1 && 1 );
  printf("%d\n", 1 && 0 );
  printf("%d\n", 0 && 1 );
  printf("%d\n", 0 && 0 );
    
  return 0;
}
```

(условие1) || (условие2) - оператор логическое ИЛИ. Возвращает истину, если хотя бы одно из условий истина или оба условия сразу истинны. Иначе возвращает ложь.

Примеры:

_Листинг 6._

```c
#include <stdio.h>

int main(void) { 

  printf("%d\n", 1 || 1 );
  printf("%d\n", 1 || 0 );
  printf("%d\n", 0 || 1 );
  printf("%d\n", 0 || 0 );
    
  return 0;
}
```

## Приоритет логических операций

Для логических операций тоже есть определённая очерёдность выполнения.
+ Операции в скобках
+ Логическая операция НЕ
+ Логическая операция И
+ Логическая операция ИЛИ

Включим логические операции в общий список приоритетов операций, который мы составляли для арифметических операций и математических функций.
+ Операции в скобках
+ вычисляются функции (например, sqrt(), cos() и др.)
+ Логическая операция НЕ
+ умножение, деление, остаток от деления (слева направо)
+ сложение, вычитание
+ Логическая операция И
+ Логическая операция ИЛИ
+ выполняется присваивание

[Содержание](#содержание)

<hr>

# Условный оператор if -- else

Теперь, когда с условными выражениями разобрались, можно переходить к основной теме урока – условному оператору.

## Шаблон оператора if -- else

Тут возможны два основных варианта:

_Листинг 1._

```c
// первый вариант
if (условное_выражение)
  оператор_1;
  
// второй вариант
if (условное_выражение)
  оператор_1;
else
  оператор_2;
```
Ну и картинки, конечно. Куда же без картинок?

![006](/StepikC/Pictures/006_004.png)

_Рис.1 Блок-схемы оператора if-else._

Работает этот оператор так. Вычисляется значение условного выражения. Если получается истина, то выполняется оператор_1 из основной ветки, а если ложь, то либо ничего не происходит (в первом варианте), либо выполняется оператор_2 из побочной ветки (во втором варианте).

Предлагаю сразу на примерах разбираться. Например, как вы думаете, что выведет на экран следующий код? Проверьте свою догадку.

_Листинг 2._

```c
#include <stdio.h>

int main(void) { 

  if ( 1 ) 
    printf("TRUE!\n");
  else
    printf("FALSE!\n");
 
  return 0;
}
```

Ну да, правильно, он выведет TRUE!. Условие же истинно. Вы же ещё не забыли, что единица – это истина? Я сейчас страшное скажу. Любое ненулевое число воспринимается как истина. Проверьте это самостоятельно.

Ну ладно, а теперь вот такой пример. Что по-вашему выведет данная программа?

_Листинг 3._

```c
#include <stdio.h>

int main(void) { 

  if ( 0 ) 
    printf("FALSE!\n"); 
 
  return 0;
}
```

Надеюсь, вы дали правильный ответ и вас не смутила строчка с выводом FALSE!, которое я специально добавил, чтобы запутать вас. Да, эта программа ничего не выведет. Условие в скобах ложно, а значит, оператор не будет выполнен. Всё по правилам.

Давайте ещё один примерчик, для закрепления. Будьте предельно внимательны, я там подготовил для вас всякого. Итак, что выведет данный код?

_Листинг 4._

```c
#include <stdio.h>

int main(void) { 

  int x = 12; 

  if ( !( !( x%3 == 0) && !( x%2 == 0 ) ) ) 
    printf("kratno\n");
  else 
    printf("ne kratno\n");

  return 0;
}
```

Верю, что у вас всё получилось! Если не получилось, не расстраивайтесь – ещё будет время потренироваться.

Ну а сейчас давайте о нюансах – они, как обычно, имеются.

## Нюанс 1. В каждой ветке условного оператора может быть записан лишь ОДИН оператор.
Вот, посмотрите на пример.

_Листинг 5._

```c
#include <stdio.h>

int main(void) { 

  int x = 0; 
  scanf("%d", &x);

  if ( x < 0 )
    printf("x = %d\n", x);
    x = (-1)*x;

  printf("%d\n", x);

  return 0;
}
```

Кажется, что программа должна работать следующим образом. Пользователь вводит целое число. Если число меньше нуля, то меняем его знак на противоположный. В противном случае ничего не делаем. После этого выводим число на экран консоли.

А теперь внимание на экран.

![006](/StepikC/Pictures/006_005.png)

_Рис.2 Результат работы программы Листинг 11_

Но решение есть! 

И это решение – составной оператор {}. 

Если мы заключим несколько операторов в фигурные скобки, то они будут восприниматься как один единый оператор. Поэтому, чтобы программа заработала правильно, добавим в неё составной оператор:

_Листинг 6._

```c
#include <stdio.h>

int main(void) { 

  int x = 0; 
  scanf("%d", &x);

  if ( x < 0 ){
    printf("x = %d\n", x);
    x = (-1)*x;
  }

  printf("%d\n", x);

  return 0;
}
```

Ну вот, теперь всё как надо. 
Проверьте самостоятельно. 

Кстати, из опыта. Я вам настоятельно советую всегда использовать фигурные скобки, даже если внутри них будет один оператор. Очень часто это позволяет избежать глупых ошибок.

## Нюанс 2. Внутри управляющей конструкций if-else можно использовать любые конструкции языка, в том числе ещё одну конструкцию if-else.

Вот так например:

_Листинг 7._

```c
#include <stdio.h>

int main(void) { 

  int x = 0; 
  scanf("%d", &x);

  if ( x < 0 ) {
    printf("Negative!\n");
  } else {
    if ( x == 0 ){
      printf("Zero!\n");
    } else {
      printf("Positive!\n");
    }
  }
  return 0;
}
```

Думаю, понятно, что используя вложенные условные операторы, вы можете сделать конструкцию аналогичную оператору выбора `switch`.

Использование вложенных условных операторов порождает ещё одну особенность.

## Нюанс 3. else всегда относится к ближайшему if, у которого нет своего else

Для примера:

_Листинг 8._

```c
if ( n > 0 )
  if ( а > b )
    z = a;
  else
    z = b;
```

Согласно нашему правилу, `else` относится к внутреннему (второму) if. Если хотим, чтобы `else` относился к внешнему (первому) `if`, то можно воспользоваться составным оператором.

_Листинг 9._

```c
if ( n > 0 ) {
  if (а > b)
    z = a;
} else
  z = b;
```

Как я уже упоминал, лучше всегда использовать фигурные скобки, дабы избежать случаев неправильного толкования записи. Искать подобные ошибки в программах очень тяжело. Обратите внимание также на расстановку отступов. Я использую их, чтобы по коду сразу стало ясно, какая ветвь к какому if относится.

## Исследовательские задачи для хакеров:

+ В языке Си существует ещё одна конструкция, работающая с условными выражениями. Это тернарная условная операция ?:. (Тернарный оператор)

Самостоятельно найдите в интернете описание этой конструкции и изучите, как она работает.

## Дополнительные материалы
[Задачи на условный оператор от Яндекса](https://stepik.org/lesson/13022/step/3)

[Содержание](#содержание)

<hr>

# Задачи

## Не компилируя и не запуская программу, установите соответствие между входными данными и текстом, который выведет следующий кусок программы на экран консоли.

```c 
#include <stdio.h> 
int main(void){
  
  int k = 0, last = 0;

  scanf("%d",&k);

  last = k%10;
  
  switch (last) {
    default:
      printf("0\n");
      break;
    case 1 :
    case 9 : 
      printf("1\n");
      break;
    case 2 :
    case 8 :
      printf("4\n");
      break;
    case 5 : 
      printf("5\n");
      break;
    case 4 :
    case 6 : 
      printf("6\n");
      break;
    case 3 :
    case 7 : 
      printf("9\n");
      break;
  }
  
  return 0;
}
```
Данная программа выводит последнюю цифру числа $k^2$. Число k вводится пользователем. 

Интересно, что в коде нет как такового возведения числа в квадрат.

![006](/StepikC/Pictures/006_006.PNG)

[Содержание](#содержание)

<hr>

## Сказка о богатыре

Гилл Байт с прошлого раза чуть-чуть поднаторел в программировании. Поверив в себя, он решил написать эмулятор сказки о богатыре. Но, конечно, он был слишком самонадеян, плохо изучил теоретические основы урока, а потому всё напутал. Помогите ему исправить код, который он написал.

Входные данные:
Либо один из трёх символов f, l, r, либо любой другой символ

Выходные данные:

Одна из строк в зависимости от входных данных:<br>
l -- коня потеряешь, себя спасёшь! <br>
f -- и себя и коня потеряешь!<br>
r -- себя потеряешь, коня спасёшь!<br>
Если поступает любой другой символ, то ничего выводить не требуется.

```c
#include <stdio.h>
#include <locale.h>
int main(void) {

  setlocale(LC_ALL, "");
  char s;  
  scanf("%c",&s);

  switch (s) {
    case 'l' : printf("коня потеряешь, себя спасёшь!\n"); break;
    case 'f' : printf("и себя и коня потеряешь!\n"); break;
    case 'r' : printf("себя потеряешь, коня спасёшь!\n"); break;
    default  : break;
  } 

  return 0;
}
```

## Написать программу, позволяющую получить словесное описание школьных отметок (1 — «плохо», 2 — «неудовлетворительно», 3 — «удовлетворительно», 4 — «хорошо», 5 — «отлично»).

Входные данные: Одно целое число k от 1 до 5.

Выходные данные:
Соответствующая k текстовое описание отметки.

```c
#include <stdio.h>
#include <locale.h>
int main(void) {

  setlocale(LC_ALL, "");
  int N;  
  scanf("%d",&N);

  switch (N) {
    case 1 : printf("плохо\n"); break;
    case 2 : printf("неудовлетворительно\n"); break;
    case 3 : printf("удовлетворительно\n"); break;
    case 4 : printf("хорошо\n"); break;
    case 5 : printf("отлично\n"); break;
    default  : break;
  }   

  return 0;
}
```

[Содержание](#содержание)

<hr>

## Гадание.

Написать программу, определяющую результат гадания на ромашке по количеству лепестков на ней.

Входные данные:
Одно целое число k -- количество лепестков на ромашке.

Выходные данные:

Одна строка в зависимости от результата: Любит или Не любит. Отрывая первый лепесток, произносится фраза Любит, второй -- Не любит.

```c
#include <stdio.h>
#include <locale.h>

int main() {
    setlocale(LC_ALL, "");
    int N;  
    scanf("%d",&N);
    if (N % 2)
    {
        printf("Любит\n");
    }
    else
    {
        printf("Не любит\n");
    }
    return 0;
}
```

[Содержание](#содержание)

<hr>

## Напишите программу-калькулятор для четырёх основных арифметических действий.

Входные данные:
Символ действия c и два целых числа a, b (b!=0)

Выходные данные:
Одно вещественное число, либо строку ERROR!, если введено недопустимое действие. Формат вывода чисел: два знака после запятой.

```c
#include <stdio.h>

int main() {
    char c;  
    int a, b;

    scanf("%c %d %d", &c, &a, &b);
      
    switch (c) {
        case '+' : printf("%.2lf\n", (double)(a + b)); break;
        case '-' : printf("%.2lf\n", (double)(a - b)); break;
        case '*' : printf("%.2lf\n", (double)(a * b)); break;
        case '/' : printf("%.2lf\n", (double)(a / b)); break;
        default : printf("ERROR!\n"); break;
    }
  return 0;
}
```

[Содержание](#содержание)

<hr>

## Усовершенствуйте программу, написанную на прошлом шаге. Теперь она должна работать для любых целых чисел, включая случай, когда b=0.

Входные данные:
Два целых числа a, b и символ действия c.

Выходные данные:
Одно вещественное число, либо строку ERROR!, если введено недопустимое действие или действие выполнить невозможно (деление на ноль). Формат вывода чисел: два знака после запятой.

```c
#include <stdio.h>

int main() {
    char c;  
    int a, b;

    scanf("%d %d %c", &a, &b, &c);
      
    switch (c) {
        case '+' : printf("%.2lf\n", (double)(a + b)); break;
        case '-' : printf("%.2lf\n", (double)(a - b)); break;
        case '*' : printf("%.2lf\n", (double)(a * b)); break;
        case '/' : b == 0? printf("ERROR!\n") : printf("%.2lf\n", (double)(a / b)); break;
        default : printf("ERROR!\n"); break;
    }
    return 0;
}
```

[Содержание](#содержание)

<hr>

## Уровень базового обмена веществ

В [третьем уроке](http://youngcoder.ru/lessons/3/vvod_dannyh_scanf.php) был приведён код программы, которая подсчитывает уровень базового обмена веществ по формуле Миффлина-Сан Жеора исходя из данных, которые вы введёте (возраст, рост и вес). Модифицируйте данную программу так, чтобы она дополнительно принимала и учитывала сведения о половой принадлежности человека.

Входные данные:<br>
Один символ и три целых числа.<br>
Символ f (female) или m(male), обозначающий половую принадлежность.<br>
Первое число a -- целое, возраст человека<br>
Второе число ℎ -- целое, рост человека в сантиметрах<br>
Третье число w -- целое, вес человека в килограммах.<br>

Выходные данные:

Вывести уровень базового обмена веществ в таблице, оформленной в соответствии примером ниже. 

Если первый аргумент не является символом f или m, то необходимо вывести одно слово ERROR!

```c
#include <stdio.h> 
int main(void){

    char sex;
    int age, height, weight;
    double bov;
    
    scanf("%c %d %d %d", &sex, &age, &height, &weight); 
    switch (sex)
    {
    case 'f':
        bov = 10*weight + 6.25*height - 5*age - 161;
        break;
    case 'm':
        bov = 10*weight + 6.25*height - 5*age + 5;
        break;
    default:
        printf("ERROR!\n"); return 0;
    }
  
    printf("|  BMR  |\n");
    printf("|%7.2f|\n",bov);
    
    return 0;
}
```

[Содержание](#содержание)

<hr>

## Високосный год

Вычислить номер дня в невисокосном году по заданным числу и месяцу.

Входные данные:

Два целых числа. Первое число m -- номер месяца. 1≤m≤12

Второе число d -- номер дня в месяце. 1≤d≤31

Выходные данные:

Одно целое число -- порядковый номер дня в невисокосном году.

![006](/StepikC/Pictures/006_007.png)

```c
#include <stdio.h>

int main() {

    int m, d, res, D[12] = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};
    
    scanf("%d%d", &m, &d);

    res = D[m-1] + d;
    
    printf("%d\n", res);
    return 0;
}
```

```c
#include <stdio.h>
int main() {
    const int year[]={31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    int mn, day, i;
    scanf("%d %d", &mn, &day);
    for(i=0; i<mn-1; i++)
        day+=year[i];
    printf("%d", day);
    return 0;
}
```

```c
#include <stdio.h>

int main() {
  int m, d;
  scanf("%d%d", &m, &d);

  printf("%d\n", (m + m / 9) / 2  + 30 * --m - 2 * (m > 1) + d);
  
  return 0;
}
```

[Содержание](#содержание)

<hr>

## Напишите программу считающую произведение цифр заданного k-значного числа X.

Входные данные: Два целых числа.

Первое число k -- количество цифр в числе X. 1≤k≤4

Второе число X. Некоторое k-значное число.

Выходные данные:

Целое число. Произведение цифр числа X.

```c
#include <stdio.h>

int main() {
    int k, x, res = 1;
    
    scanf("%d%d", &k, &x);

    while (x>0)
    {
        res *= x % 10;
        x /= 10;
    }
    
    printf("%d\n", res);
  return 0;
}
```

[Содержание](#содержание)

<hr>

## Мне K лет

Для целого числа K (от 1 до 99 включительно) напечатать фразу «Мне K лет», учитывая при этом, что при некоторых значениях K слово «лет» надо заменить на слово «год» или «года». Например, 11 лет, 22 года, 51 год.

Входные данные: Одно целое число K, 1≤k≤99

Выходные данные: Фраза с правильным окончанием

![006](/StepikC/Pictures/006_008.png)

```c
#include <stdio.h>
#include <locale.h>

int main() {

    setlocale(LC_ALL, "");
    int K, d;
    
    scanf("%d", &K);
    d = K % 10;

    switch (K)
    {
    case 11 :
    case 12 :
    case 13 :
    case 14 :            
        printf("Мне %d лет\n", K);
        return 0;
    default:
        switch (d)
        {
        case 1 :
            printf("Мне %d год\n", K);
            break;
        case 2 :
        case 3 :
        case 4 :
            printf("Мне %d года\n", K);
            break;
        default:
            printf("Мне %d лет\n", K);
            break;
        }    
    }
  return 0;
}
```

```c
#include <stdio.h>

int main() {
    
    int k = 20;
    scanf("%d", &k);
      
    if (k % 10 == 1 && k != 11) {
          printf("Мне %d год", k);
    } else if (k % 10 != 0 && k % 10 < 5 && (k < 10 || k > 14)) { 
          printf("Мне %d года", k);
    } else {
          printf("Мне %d лет", k);
    }

  return 0;
}
```

[Содержание](#содержание)

<hr>

## Тесты

### Отметьте все логические выражения, значения которых истина.

![006](/StepikC/Pictures/006_009.png)

### Отметьте все логические выражения, значения которых ложь.

![006](/StepikC/Pictures/006_010.png)

### Отметьте все логические выражения, значения которых истина.

![006](/StepikC/Pictures/006_011.png)

### Отметьте все логические выражения, значения которых ложь.

![006](/StepikC/Pictures/006_012.png)

### Дано следующее логическое отношение:

!(a&&b)||(!a&&b)
Выберите вариант(ы), в котором(ых) значения переменных a и b такие, что значение данного логического выражения истина.

Для того что бы условие стало истинно, а или b должны быть ложным

![006](/StepikC/Pictures/006_013.png)

### Задана следующая таблица истинности:

| a | b | c | X |
| 1 | 0 | 0 | 1 |
| 0 | 0 | 0 | 0 |
| 1 | 1 | 1 | 0 |

Выберите логическое выражение, которое удовлетворяет данной таблице истинности.

![006](/StepikC/Pictures/006_014.png)

[Содержание](#содержание)

<hr>

## Сравнение чисел
Напишите программу, сравнивающую два целых числа.

Входные данные:

Два целых числа x, y 

Выходные данные:
1 -- если x=y
0 -- если x≠y

```c
#include <stdio.h>

int main() {
    int x, y;
    
    scanf("%d %d", &x, &y);

    printf("%d", x == y);
  return 0;
}
```

[Содержание](#содержание)

<hr>

## Квадранты

На координатной плоскости $O_{xy}$ задана точка A(x,y). Необходимо указать квадрант, в котором она расположена. Номера квадрантов представлены на рисунке ниже.

 ![006](/StepikC/Pictures/006_015.jpg)

|||
-|-
2|1
3|4

Входные данные:

Два вещественных числа x, y, которые не равны нулю.

Выходные данные:
Вывести одно целое -- номер квадранта.

```c
#include <stdio.h>

int main() {
  double x, y;
  scanf("%lf%lf", &x, &y);
  printf("%d\n", (x > 0) + 3 * (y < 0) + (x < 0) * 2 * (y > 0));
  return 0;
}
```

```c
#include <stdio.h>

int main() {
    double x, y;
    int res;
    
    scanf("%lf %lf", &x, &y);

    if (x > 0 && y > 0)
    {
        res = 1;
    }
    else if (x < 0 && y > 0)
    {
        res = 2;
    }
    else if (x < 0 && y < 0)
    {
        res = 3;
    }
    else
    {
        res = 4;
    }
    
    printf("%d", res);
  return 0;
}
```

[Содержание](#содержание)

<hr>

[Содержание курса](/StepikC/README.md)
