# Урок 4. Математика в Си

## Содержание

+ [Арифметические действия в языке Си](#арифметические-действия-в-языке-си)
+ [Стандартные математические функции. Заголовочный файл math.h](#стандартные-математические-функции-в-языке-си)
  + [Неявное преобразование типов](#неявное-преобразование-типов)
+ [Приоритет операций. Сложные математические выражения](#приоритет-операций-cложные-математические-выражения)
+ [Псевдослучайные числа](#генерация-случайных-чисел-в-языке-си)



[Содержание курса](/StepikC/README.md)

# Арифметические действия в языке Си

Программы работают с данными. Зачастую данные представляют собой числа. В этом уроке, как вы наверное догадались, мы будем заниматься изучением того, как и что в языке Си можно делать с числами. 

Начнём с арифметики.

Компилятор языка Си понимает все основные арифметические операции, которые вам известны со школы. Плюс есть несколько дополнительных.

### Основные арифметические операторы языка Си.
|||
|-|-|
|`+`| оператор сложения
|`-`| оператор вычитания
|`*`| оператор умножения
|`%`| оператор взятия остатка от деления
|`/`| оператор деления

Следующая программа иллюстрирует использование первых четырёх из них. Кстати, обратите внимание на то, как с помощью функции printf вывести на экран символ %.

_Листинг 1._

```c
#include <stdio.h>
int main(void){
  int a=7, b=2;
  int res;

  res = a+b;
  printf("%d + %d = %d\n",a,b,res);
  res = a-b;
  printf("%d - %d = %d\n",a,b,res);
  res = a*b;
  printf("%d * %d = %d\n",a,b,res);
  res = a%b;
  printf("%d %% %d = %d\n",a,b,res);
  
  return 0;
}
```

Результат работы этой программы представлен на следующем рисунке.

![004](/StepikC/Pictures/004_001.gif)

_Рис.5 Использование арифметических действий в Си._

Всё чётко и понятно. Никаких неожиданностей. А теперь попробуем получить частное двух чисел. Т.к. результат должен получиться 3.5, то res объявим как float.

_Листинг 2._

```c
#include <stdio.h>
int main(void){
  int a=7, b=2;
  float res;

  res = a/b;
  printf("%d / %d = %f\n",a,b,res);

  return 0;
}
```
```c
7 / 2 = 3.000000
```

Как видите, результат получился не тот, что мы ожидали. Это одна из особенностей оператора деления в языке Си.

### Целочисленное деление.

При делении значение целого типа на значение целого типа результат тоже получается целого типа.

Так уж устроен язык Си. 

Поэкспериментируйте, попробуйте любые другие целые числа.

Вычислить результат целочисленного деления легко. Поделите числа и отбросьте всё, что получилось в дробной части.

Пример: Как получить результат целочисленного деления

```
7/2 = 3.5 → 3
11/3 = 3.66 → 3
2/5 = 0.4 → 0
```

Для того чтобы получить тот результат, который мы в данном случае ожидаем, одно из значений нужно сделать вещественным. 

Сделать это проще простого. Для этого необходимо рядом с ним в скобках записать float.

Посмотрим на нашем примере:

_Листинг 3._

```c
#include <stdio.h>
int main(void){
  int a=7, b=2;
  float res;

  res = (float)a/b;
  printf("%d / %d = %f\n",a,b,res);

  return 0;
}
```
```c
7 / 2 = 3.500000
```

Теперь результат будет тот, что мы ожидали. Проделанный нами трюк называется явным преобразованием типа.

### Явное преобразование (приведение) типа.

Если какое-то значение нужно привести к другому типу, нужно перед этим значением в скобках написать название требуемого типа.

_Листинг 4. Примеры явного преобразования типа_

```c
int a=7, b;
float g= 9.81,v;

b = (int) g; //приводим значение 9.81 к типу int, получим 9
v= (float)a; // приводим значение 7 к типу float, получим 7.0
```

Важный момент: преобразуется не тип исходной переменной, а только лишь значение, которое используется в выражении. В следующем видео-фрагменте об этом говорится подробнее.

[Явное преобразование (приведение) типов.](https://youtu.be/9jLdsrF8iF8)

Обратите внимание, что, когда мы преобразовываем целое значение в вещественное, ничего особенного не происходит, т.к. вещественные числа включают в себя целые.

Совсем иная ситуация, когда мы от вещественного переходим к целому. При этом переходе у нас теряется вся дробная часть. Не забывайте об этом.

Картинка, показывающая различия между операциями взятие остатка, целочисленного деления и обычного деления.

![004](/StepikC/Pictures/004_002.png)

_Рис.2 Деление, целочисленное деление и остаток от деления._

## Исследовательские задачи для хакеров

+ Подумайте и приведите примеры, когда обычное деление не имеет смысла. <br>
Например, деление трёх лицензионных ключей от программы между двумя людьми. <br>
Зачем кому-то нужна половина лицензионного ключа? (если, конечно, он не занимается reverse engineering).
+ Что происходит при делении на ноль в вашей системе?

## Дополнительные материалы

[Дополнительные задачи](https://stepik.org/lesson/Целые-числа-13021/step/3) с автоматической проверкой решения из курса " Введение в программирование (C++) " от компании Яндекс. <br>
Не беспокойтесь, что курс по С++. Удаляйте заготовку из поля для решения и спокойно вставляйте код на Си. Проверяющая система его будет нормально воспринимать.

[Содержание](#содержание)

<hr>

# Стандартные математические функции в языке Си

![004](/StepikC/Pictures/004_005.PNG)

[Wiki](/https://ru.wikipedia.org/wiki/Math.h)

Математические вычисления не ограничиваются лишь арифметическими действиями. Кроме них, можно ещё встретить корни, модули, логарифмы, тригонометрические функции и пр. 

Научимся же использовать подобные функции в своих программах.

Для использования математических функций нужно подключить заголовочный файл `math.h`. В ней определено много различных функций, но мы пока рассмотрим следующие:

Некоторые математические функции
|||
|-|-|
| fabs(x) | модуль числа x  |
| sqrt(x) | квадратный корень из числа x  |
| sin(x)  | синус числа x (х в радианах)  |
| cos(x)  | косинус числа x (х в радианах)  |
| pow(x,y)|  вычисление $x^y$  |
| exp(x)  | вычисление $e^x$ |
| log(x)  | натуральный логарифм числа x  |
| log10(x)| десятичный логарифм числа x |

Два важных момента.

Все функции возвращают значение типа double.

__Параметры функций__ – вещественные числа(double), но можно передавать и целые числа. 

При этом произойдёт неявное преобразование типа. Компилятор из целого числа, например 3, сделает вещественное 3.0.

## Примеры.

Даны длины катетов прямоугольного треугольника. Вычислить длину гипотенузы. Простая задачка на знание теоремы Пифагора.

_Листинг 1._

```c
#include <stdio.h>
#include <math.h> // подключаем math.h
int main (void) {
  int a, b, c2;

  scanf("%d",&a);
  scanf("%d",&b);
	
  c2 =  a*a + b*b;
  printf("c = %.2f\n", sqrt(c2)); 

  return 0;
}
```

Вычислить синус угла ввёденного с клавиатуры. Угол вводится в градусах.

_Листинг 2._

```c
#include <stdio.h>
#include <math.h> // подключаем math.h
int main (void) {
  double alpha, sin_a, pi = 3.1415926;
 
  scanf("%lf",&alpha);
  alpha =  alpha*pi/180; 
  sin_a = sin(alpha);
  printf("%.2f\n", sin_a); 

  return 0;
}
```

В этой программе есть о чём поговорить. 

Тригонометрические функции, которые определены в `math.h` работают с радианной мерой угла. Людям же привычнее работать с градусами. Поэтому в данной программе мы предварительно перевели значение из градусов в радианы. Если этого не сделать, результат получится неправильным. Проверьте это самостоятельно.

[Содержание](#содержание)

<hr>

## Неявное преобразование типов

При явном преобразовании типа мы в скобках перед значением указывали тип, к которому нужно привести данное значение. В неявном преобразовании этого делать не нужно. Компилятор автоматически подберёт необходимый тип.

Неявное преобразование типов осуществляется в следующих случаях:
+ перед передачей аргументов в функцию (как в нашем примере с корнем. Листинг 1.)
+ выполнение арифметических операций с разными типами аргументов
+ перед выполнением присваивания

### Правила неявного преобразования типов
+ если выполняются арифметические операции с разными типами аргументов. <br>
Оба аргумента приводятся к большему типу.<br>
Порядок типов: int < float < double
+ при присваивании. <br>
Значение справа от оператора присваивания приводится к типу переменной слева от оператора присваивания. <br>
При этом, если больший тип присваивается меньшему, то может произойти потеря точности.

## Примеры 3:

```c
int+float будет автоматически преобразовано к float+float
float/int будет автоматически преобразовано к float/float
double*float будет преобразовано к double*double
int = double double будет преобразовано к int с потерей дробной части
float = int int будет преобразовано к float
```
[Содержание](#содержание)

<hr>

# Приоритет операций. Сложные математические выражения

В математических вычислениях важную роль играет порядок, в котором выполняются действия. Чему, например, равно значение выражения 2+2*2? Конечно же шесть, т.к. сначала выполняется умножение.

В C используется знакомый нам со школы порядок выполнения операций. Но т.к. в программировании есть свои особенности, то кое-какие отличия всё же есть. Выпишем приоритет для тех операций, которые мы уже знаем.

вычисляются функции (например, sqrt(), cos() и др.)
умножение, деление, остаток от деления (слева направо)
сложение, вычитание
выполняется присваивание
А каково значение переменной x после выполнения следующего кода int x = 8 / 4 / 2;

Правильный ответ 1. Т.к в случае одинакового приоритета операций, команды выполняются слева направо. Другими словами данный код эквивалентен коду int x = (8 / 4) / 2;

Если нам нужно изменить порядок выполнения действий, то мы можем использовать для этого круглые скобки.

Листинг 1.

2+2*2 = 6
(2+2)*2 = 8 // действие в скобках будет выполнено прежде умножения
	
На следующем рисунке над каждым действием отмечено, каким оно выполнится по счёту.

![004](/StepikC/Pictures/004_006.png)

_Рис.1 Приоритет операций в языке С. Пример._

Если в вашей программе вы написали довольно сложное выражение, в котором не сразу ясен порядок операций, то лучше добавить лишние скобки, чтобы явно задать последовательность операций. Это поможет избежать ошибок в вычислениях, которые потом будет сложно отловить.

[Содержание](#содержание)

<hr>


## Сложные математические выражения
Иногда формулы, по которым нужно что-то вычислять, в программе могут принимать довольно ужасный вид.

При этом когда мы пишем программу, любая формула должна быть записана в одну строку. 

На начальном этапе это может вызвать у вас некоторые затруднения. 

Чтобы избавиться от этих затруднений, нужно овладеть навыком переводить формулу из стандартной математической записи в ту, которая используется в программировании и обратно.

И небольшой [видео-фрагмент](https://youtu.be/Gx6KUtmRmHs), в котором я попытался на простом примере показать, как можно поступать при записи сложных математических выражений.

[Содержание](#содержание)

<hr>

# Генерация случайных чисел в языке Си

Иногда может возникнуть необходимость в генерации случайных чисел. Простой пример.

### Пример: Определение победителя в конкурсе репостов.

Имеется список из 53 человек. Необходимо выбрать из них победителя. Если вы выберете его самостоятельно, то вас могут обвинить в предвзятости. 

Поэтому вы решили написать программу. 

Она будет работать следующим образом. Вы вводите количество участников $N$, после чего программа выводит одно число – номер победителя.

Как получить число от игрока, вам уже известно. А вот как заставить компьютер загадать случайное число? В этом уроке вы этому научитесь.

## Функция rand().

Данная функция возвращает случайное целое число в диапазоне от нуля до RAND_MAX. RAND_MAX это специальная константа языка Си, в которой содержится максимальное целое число, которое может быть возвращено функцией rand().

Функция rand() определена в заголовочном файле `stdlib.h`.

Поэтому, если хотите использовать rand в своей программе, не забудьте подключить этот заголовочный файл. Константа RAND_MAX тоже определена в этом файле. Вы можете найти этот файл у себя на компьютере и посмотреть её значение.

Давайте посмотрим на эту функцию в действии. Запустим следующий код:

_Листинг 1._

```c
#include <stdio.h>   // чтобы пользоваться функцией printf
#include <stdlib.h>  // чтобы пользоваться функцией rand
 
int main(void) {
/* генерируем пять случайных целых чисел */
  printf("%d\n", rand());
  printf("%d\n", rand());
  printf("%d\n", rand());
  printf("%d\n", rand());
  printf("%d\n", rand());
}
```

Должно получиться что-то вроде этого.

![004](/StepikC/Pictures/004_007.png)

_Рис.1 Пять случайных чисел, сгенерированных функцией rand_

Но нам бы хотелось получить числа от 1 до 53, а не всё подряд. Ниже описано несколько трюков, позволяющих наложить ограничения на функцию `rand()`.

### Ограничить случайные числа сверху.

Кто в школе ждал момента, когда ему пригодится математика, приготовьтесь. Этот момент наступил. Чтобы ограничить сверху случайные числа, можно воспользоваться операцией получения остатка от деления, которую вы изучили в прошлом уроке. Наверное вы знаете, что остаток от деления на число $K$ всегда меньше числа $K$. 
Например, при делении на 4 могут получиться остатки 0, 1, 2 и 3. 

Поэтому если вы хотите ограничить сверху случайные числа числом K, то просто возьмите остаток от деления на K. Вот так:

_Листинг 2._

```c
#include <stdio.h>
#include <stdlib.h>
 
int main(void) {
/* генерируем пять случайных целых чисел меньших 100 */
  printf("%d\n", rand()%100);
  printf("%d\n", rand()%100);
  printf("%d\n", rand()%100);
  printf("%d\n", rand()%100);
  printf("%d\n", rand()%100);
}
```
![004](/StepikC/Pictures/004_008.png)

_Рис.2 Пять случайных чисел меньше 100_

### Ограничить числа снизу.

Функция rand возвращает случайные числа из отрезка [0, RAND_MAX]. А что если нам нужны только числа большие числа $M$ (например, 1000)? Как быть? 

Всё просто. Просто прибавим к тому, что вернула функция rand, наше значение M. 
Тогда если функция вернёт 0, итоговый ответ будет M, если 2394, то итоговый ответ будет M + 2394. 

Этим действием мы как бы сдвигаем все числа на M единиц вперёд.

## Задать границы функции rand сверху и снизу.

Например, получить числа от 80 до 100. Кажется, нужно просто объединить два способа, которые приведены выше. Получим что-то вроде этого:

_Листинг 3._

```c
#include <stdio.h>
#include <stdlib.h>
 
int main(void) {
/* генерируем пять случайных целых чисел больших 80 и меньших 100 */
  printf("%d\n", 80 + rand()%100);
  printf("%d\n", 80 + rand()%100);
  printf("%d\n", 80 + rand()%100);
  printf("%d\n", 80 + rand()%100);
  printf("%d\n", 80 + rand()%100);
}
```
Попробуйте запустить эту программу. Удивлены?

Да, такой способ работать не будет. 

Давайте прокрутим эту программу руками, чтобы убедиться в том, что мы допустили ошибку. 

Допустим rand() вернула число 143. Остаток от деления на 100 равен 43. Дальше 80 + 43 = 123. Значит такой способ не работает. Подобная конструкция выдаст числа от 80 до 179.

Давайте разберём по действиям наше выражение. 

rand()%100 может выдать числа от 0 до 99 включительно. Т.е. из отрезка [0; 99].

Операция + 80 сдвигает наш отрезок на 80 единиц вправо. Получаем [80; 179].

Как видим, проблема у нас заключается в правой границе отрезка, она сдвинута вправо на 79 единиц. Это наше исходное число 80 минус 1. 

Давайте наведём порядок и сдвинем правую границу назад: 80 + rand()%(100 - 80 + 1). Тогда всё должно сработать как надо.

В общем случае если нам нужно получить числа из отрезка [A;B], то необходимо воспользоваться следующей конструкцией:

$A + rand()\%(B-A+1)$.

Согласно этой формуле перепишем нашу последнюю программу:

_Листинг 4._

```c
#include <stdio.h>
#include <stdlib.h>
 
int main(void) {
/* генерируем пять случайных целых чисел из отрезка [80; 100] */
  printf("%d\n", 80 + rand()%(100 - 80 + 1));
  printf("%d\n", 80 + rand()%(100 - 79));
  printf("%d\n", 80 + rand()%21);
  printf("%d\n", 80 + rand()%21);
  printf("%d\n", 80 + rand()%21);
}
```

Результат работы:

![004](/StepikC/Pictures/004_009.png)

_Рис.3 Случайные числа из диапазона [80;100]_

Ну вот, теперь вы можете решить исходную задачу урока. Сгенерировать число из отрезка [1; N]. Или не можете?

Но прежде ещё немного полезной информации. Запустите последнюю программу три раза подряд и записывайте себе случайные числа, которые она генерирует. 

Заметили?

## Функция srand().

Да, каждый раз появляются одни и те же одинаковые числа. «Так себе генератор!» – скажете вы. 

И будете не совсем правы. Действительно, генерируются всё время одинаковые числа. 

Но мы можем на это повлиять, для этого используется функция `srand()`, которая также определена в заголовочном файле `stdlib.h`. 

Она инициализирует генератор случайных чисел начальным числом.

Скомпилируйте и запустите несколько раз вот эту программу:

_Листинг 5._

```c
#include <stdio.h>
#include <stdlib.h>
 
int main(void) {
  srand(2);
/* генерируем пять случайных целых чисел из отрезка [80;100] */
  printf("%d\n", 80 + rand()%(100 - 80 + 1));
  printf("%d\n", 80 + rand()%(100 - 79));
  printf("%d\n", 80 + rand()%21);
  printf("%d\n", 80 + rand()%21);
  printf("%d\n", 80 + rand()%21);
}
```

Теперь поменяйте аргумент функции `srand()` на другое число (надеюсь вы ещё не забыли, что такое аргумент функции?) и снова скомпилируйте и запустите программу. 

Последовательность чисел должна измениться. Как только мы меняем аргумент в функции `srand()` – меняется и последовательность. 

Не очень практично, не правда ли? 

Чтобы изменить последовательность, нужно перекомпилировать программу. Вот бы это число туда подставлялось автоматически.

И это можно сделать. 

Например, воспользуемся функцией `time()`, которая определена в заголовочном файле `time.h`. 

Данная функция, если ей в качестве аргумента передать NULL, возвращает количество секунд, прошедших c 1 января 1970 года. Вот посмотрите, как это делается.

_Листинг 6._

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h> // чтобы использовать функцию time()
 
int main(void) {
  srand(time(NULL));
/* генерируем пять случайных целых чисел из отрезка [80;100] */
  printf("%d\n", 80 + rand()%(100 - 80 + 1));
  printf("%d\n", 80 + rand()%(100 - 79));
  printf("%d\n", 80 + rand()%21);
  printf("%d\n", 80 + rand()%21);
  printf("%d\n", 80 + rand()%21);
}
```
Вы спросите, а что такое `NULL`? 

Резонный вопрос. 

А я вам пока отвечу, что это специальное зарезервированное слово такое. 

Могу ещё сказать, что им обозначает нулевой указатель, но т.к. это для вас никакой информации не несёт, то на данный момент рекомендую об этом не думать. А просто запомнить как некоторый хитрый трюк. В будущих уроках мы остановимся на этой штуке поподробнее.

## Исследовательские задачи для хакеров 4:

+ В каких ситуациях ещё может пригодиться генерация случайных чисел? <br>
Напишите ваши варианты в комментарии к этому уроку.
+ Напишите программу, которая выводит на экран значение целочисленной константы RAND_MAX. <br>
Найдите файл stdlib.h на вашем компьютере, найдите значение этой константы в этом файле.
+ Найдите в интернете описание функций, которые определены в заголовочном файле `time.h` <br>
Вы, конечно, ещё не сможете ими пользоваться, но знать, что такие функции есть, всё равно нужно. Ведь когда-то настанет момент, когда ваших знаний будет достаточно для их использования.
+ Числа, генерируемые функцией rand(), имеют равномерное распределение. 

Это значит, что если запускать функцию rand очень много раз и каждый раз записывать, какое число выпало, то количество выпадения различных чисел будет одинаковым. <br>
Например, если генерировать только числа 0 и 1, то через 100 запусков примерно 50 раз выпадет ноль и 50 раз единичка. <br>
Обратите внимание, что я говорю примерно. Может быть, например, 49 и 51, или 53 и 47. Если рассматривать это в отношении к общему числу запусков, получим (49/100 и 51/100 или 53/100 и 47/100 соответственно). 

Но чем больше экспериментов мы проведём, тем ближе отношение количество единичек к количеству испытаний будет стремиться к 1/2. 

Проведите самостоятельно эксперимент с 10, 50 и 100 запусками. Это муторно и долго, если делать руками, но что поделать? В будущем мы напишем программу, чтобы проверить свойство равномерности распределения наших случайных чисел.

## Дополнительные материалы 4

+ [Другие функции](https://ru.wikipedia.org/wiki/Stdlib.h), определённые в заголовочном файле `stdlib.h`
+ Хотя я и употребляю везде словосочетание «случайные числа», но на самом деле получить действительно случайные числа – сложная задача. И в компьютерах обычно используются псевдослучайные числа. Подробнее об этом можно прочитать [здесь](https://ru.wikipedia.org/wiki/Генератор_псевдослучайных_чисел).
+ Если не терпится узнать хоть что-то про NULL, то почитайте вот [этот урок](http://www.youngcoder.net/2013/08/ukazateli.html).
Дата 1 января 1970 года особенная. С неё начинается отсчёт эры UNIX. [Подробнее об этом](https://ru.wikipedia.org/wiki/UNIX-время) и проблемах, которые нас ожидают.



[Содержание](#содержание)

<hr>


# Задания

## Чему равны значения переменных x и y после выполнения следующего куска кода:

```c
int x = 13, y = 45;

y = y/x; 
x = y*x;
```

Проделайте без использования компилятора, примерно так, как показано  в [видео](http://youngcoder.ru/less4/#razbor). 

![004](/StepikC/Pictures/004_003.PNG)

## Сопоставьте операцию и соответствующий ей результат.

![004](/StepikC/Pictures/004_004.PNG)

## Расчет числа $\pi$

Гилл Байтс на одном из уроков математики узнал, что если знать диаметр окружности и её длину, то можно вычислить приблизительное значение числа $π$. 

Найдя дома небольшую тарелку, Гилл аккуратно измерил диаметр и длину окружности в её верхней части в миллиметрах. 

После чего он составил программу на языке Си, которая должна была вычислить приблизительное значение числа $π$. 

Но, видимо, в программу закралась ошибка, потому что она утверждала, что число $π=3$. 

Помогите Гиллу исправить его программу.

```c
#include <stdio.h>
int main(void){
  int diameter=113, length=355;
  float pi=0;
  pi = length/(float)diameter;
  printf("pi = %.5f\n",pi);

  return 0;
}
```

## На вход программы поступают два целых числа — длины сторон прямоугольника. Посчитайте и выведите периметр этого прямоугольника.

Периметр — сумма длин всех сторон.

```c
#include <stdio.h>

int main() {
  int a, b;
  scanf("%d", &a);
  scanf("%d", &b);

  printf("%d", (a + b) * 2);
  return 0;
}
```

## На вход программы поступает целое трёхзначное число. Напишите программу, которая выводит сумму цифр этого числа.

```c
#include <stdio.h>

int main() {
  int a, res = 0;
    scanf("%d", &a);
    while(a > 0) {
        res += a % 10;
        a = a / 10;
    }
    printf("%d\n", res);
  return 0;
}
```

```c
#include <stdio.h>

int main() {
    int n, sum = 0;
    scanf("%d", &n);
    do {
        sum += n%10;
        n /= 10;
    }
        while(n);
    printf("%d", sum);
  return 0;
}
```

```c
#include <stdio.h>

int main() {
  int a, b, c;
    scanf("%1d%1d%1d", &a,&b,&c);
    printf("%d\n",a+b+c);
  return 0;
}
```

## Подсчет размера оплаты

Составьте программу подсчёта размера оплаты за электроэнергию по показаниями счётчика и тарифу. На вход поступают 3 числа.
+ Первое число -- целое число. Показания счётчика в кВт*ч на начало месяца.
+ Второе число -- целое число. Показания счётчика в кВт*ч на конец месяца.
+ Третье число -- вещественное число. Стоимость одного кВт*ч в рублях.

Программа должны вывести на экран размер оплаты за электроэнергию. 

Результат выведите с двумя знаками после запятой.

#include <stdio.h>

```c
int main() {
    int a, b;
    double c;
        scanf("%d", &a);
        scanf("%d", &b);
        scanf("%lf", &c);
        printf("%.02lf\n", c * (double)(b-a));
        
    return 0;
}
```

## Угол в радиантах

Напишите программу переводящую угол из градусной меры в радианную.

Формат входных данных:

одно целое число A — угол, измеренный в градусах.

Формат выходных данных:

вещественное число R — угол, измеренный в радианах. Точность — два знака после запятой.

Указание:

Для числа π использовать следующее значение π=3.1415926

```c
#include <stdio.h>

int main() {
    int A;
    double pi = 3.1415926;
        scanf("%d", &A);
        printf("%.02lf\n", pi * (double)(A) / 180);
    return 0;
}
```
## Напишите программу, определяющую нечётные числа.

На вход программы поступает одно целое неотрицательное число. Программа должна вывести 1, если число нечётное, и 0, если число чётное.

```c
#include <stdio.h>

int main() {
    int A;
        scanf("%d", &A);
        printf("%d\n", A % 2);
    return 0;
}
```

## Напишите программу, определяющую чётные числа.

На вход программы поступает одно целое неотрицательное число. Программа должна вывести 1, если число чётное, и 0, если число нечётное.
```c
#include <stdio.h>

int main() {
    int A;
        scanf("%d", &A);
        printf("%d\n", (A + 1) % 2);
  return 0;
}
```

## Напишите команду для подключения заголовочного файла math.h

```c
#include <math.h>
```

## Напишите вызов функции pow для возведения числа 2 в степень 5.  Результат присвойте переменной с именем res.

Объявлять эту переменную заранее не нужно, она уже объявлена. Выводить на консоль также ничего не требуется.

```c
res = pow(2,5);
```

## Проверим, как вы усвоили неявное преобразование типов. Какое значение будет записано в переменную $y$ после выполнения этого кода? Не используйте компилятор. 

```c
int x = 0.14;
float y = 0;
x = 3.14/2;
y = x + 3.14;
``` 
Ответ введите с точностью до сотых.

Пройдёмся по коду:

>x = 3.14/2

В числителе вещественное число, в знаменателе целое. Дробь будет приведена неявно к вещественному типу.  

Следовательно, справа будет 1.57. Но переменная, в которую мы присваиваем результат, целочисленная, а значит результат, полученный справа, будет приведён неявно к целому числу. 

В итоге в x будет 1.

>y = 1+ 3.14 = 4.14

## Написать программу, вычисляющую расстояние между двумя точками на оси координат.

Формат входных данных:
На вход программы поступают два числа 
$x_1$, $x_2$ — координаты двух точек на оси координат. <br>
$x_1$, $x_2$  — целые числа.

Формат выходных данных:

Одно целое число — расстояние между точками $x_1$, $x_2$.

Формула для расчета расстояний 

$S = |x_1 - x_2|$

```c
#include <stdio.h>
#include <math.h>

int main() {
    int x, y, res;
    scanf("%d", &x);
    scanf("%d", &y);
    res = fabs(x - y);
    printf("%d\n", res); 
    return 0;
}
```

## Написать программу, вычисляющую расстояние между двумя точками на плоскости.

Формат входных данных:

На вход программы поступают четыре числа 
$x_1$, $y_1$, $x_2$ ,$y_2$ — координаты двух точек на плоскости.<br>
$x_1$, $y_1$, $x_2$ ,$y_2$ — вещественные числа.

Формат выходных данных:

Одно число -- расстояние между точками 

$(x_1, y_1)$ и $(x_2, y_2)$. 

Точность — два знака после запятой.

```c
#include <stdio.h>
#include <math.h>

int main() {
    double x_1, y_1, x_2, y_2, res;
    scanf("%lf %lf %lf %lf", &x_1, &y_1, &x_2, &y_2);
    res = sqrt(pow((x_2 - x_1), 2) + pow((y_2 - y_1), 2));
    printf("%.2lf\n", res); 
    return 0;
}
```
## Написать программу, вычисляющую площадь треугольника по двум сторонам и углу между ними.

Формат входных данных: <br>
На вход программы поступают три числа $a,b,γ$.<br>
$a, b$ — вещественные числа, длины сторон треугольника.<br>
$γ$ — угол между сторонами $a$ и $b$, записанный в градусах, вещественное число.

Формат выходных данных:

Одно число -- площадь треугольника со сторонами $a,b$ и углом $γ$. 

Точность — два знака после запятой.

Число $π$ считать равным $3.141593$.

Формула площади:

$S = \dfrac{1}{2} ab \sin{\alpha}$

```c
#include <stdio.h>
#include <math.h>

int main() {
    const double pi = 3.141593;
    double a, b, alpha, res;
    scanf("%lf %lf %lf", &a, &b, &alpha);
    alpha = alpha * pi / 180;
    res = a * b * sin(alpha) / 2;
    printf("%.2lf\n", res);
  return 0;
}
```
## Количество целых чисел, которые можно записать используя N двоичных битов вычисляется по формуле $2^N$.  Напишите программу, вычисляющую количество целых чисел, которые можно записать используя $N$ битов.

 Формат входных данных:

На вход программы поступает одно целое число $N$ — количество двоичных битов. 

Формат выходных данных:

Одно целое число — количество целых чисел, которые можно записать, используя $N$ битов.

```c
#include <stdio.h>
#include <math.h>

int main() {
    int N, res;
    scanf("%d", &N);
    res = pow(2, N);
    printf("%d\n", res); 
  return 0;
}
```

## Расположите элементы списка в правильном порядке

Можно найти таблицу приоритетов языка Си в данной статье: [Ссылка](https://ru.wikipedia.org/wiki/Синтаксис_и_семантика_языка_Си#Приоритет_выполнения_операций)

![04](/StepikC/Pictures/004_010.PNG)

## Дано уравнение $y=ax^3+7$

Среди указанных выражений отметьте те, которые соответствуют верной записи этого выражения на языке Си.

Источник: Х. Дейтл, П. Дейтл "Как программировать на С"

![04](/StepikC/Pictures/004_011.PNG)

## Какое значение будет сохранено в переменной $x$ после выполнения следующего кода:

>int x = 7 + 3 * 6 / 2 - 1; 

Источник: Х. Дейтл, П. Дейтл "Как программировать на С"

>15

## Какое значение будет сохранено в переменной $x$ после выполнения следующего кода:

>int x = 2 % 2 + 2 * 2 - 2/2;

Источник: Х. Дейтл, П. Дейтл "Как программировать на С"

>3

## Какое значение будет сохранено в переменной $x$ после выполнения следующего кода:

>int x = (3 * 9 * (3 + (9 * 3 / 3)));

Источник: Х. Дейтл, П. Дейтл "Как программировать на С"

>324

## Написать программу, вычисляющую площадь треугольника по трём сторонам.

Формат входных данных:

На вход программы поступают три числа $a,b,c$ — длины сторон треугольника.

$a,b,c$ — вещественные числа.

Формат выходных данных:

Одно число — площадь треугольника со сторонами 
$a,b,c$. 

Точность — два знака после запятой.

формула:

$S=\sqrt{p\cdot(p-a)\cdot(p-b)\cdot(p-c)}$,

$p = \dfrac{a+b+c}{2}$

## В выражении

>a/b*c/d*e/f*h

расставить скобки так, чтобы выражению со скобками соответствовала дробь

![04](/StepikC/Pictures/004_012.PNG)

Входные данные: семь целых чисел $a,b,c,d,e,f$ и $ℎ$ соответственно.

Выходные данные: результат выражения. Точность  2 знака после запятой.

Источник: С.А. Абрамов, Е.В. Зима "Начало программирования на языке Паскаль"

```c
#include <stdio.h>
int main(void){

    double a, b, c, d, e, f, h, res;
    scanf("%lf %lf %lf %lf %lf %lf %lf", &a, &b, &c, &d, &e, &f, &h);
    res = (a * d * e)/(b * c * f * h);
    printf("%.2lf\n", res); 

  return 0;
}
```

## Сопоставьте функцию и заголовочный файл.

![04](/StepikC/Pictures/004_013.PNG)

## В программе используются только следующие функции:

+ `sin()`
+ `time()`
+ `fabs()`
+ `rand()`
+ `srand()`

Выберите заголовочные файлы, которые необходимо подключить в программе?

![04](/StepikC/Pictures/004_014.PNG)

## Введите максимальное число, которое может быть сгенерировано следующей конструкцией:

> int rand_a = 66 + rand()%601; 

>666

## Введите минимальное число, которое может быть сгенерировано следующей конструкцией:

>int rand_a = rand(); 

>0

## Вычислите нижнюю и верхнюю границу диапазона, сгенерированного следующей конструкцией:

>int rand_a = 100 + rand()%100;

В ответ запишите число, равное сумме этих двух чисел.

>299

## Вычислите нижнюю и верхнюю границу диапазона, сгенерированного следующей конструкцией:

>int rand_a = -50 + rand()%101;

В ответ запишите число, равное сумме этих двух чисел.

>0

## Перепишите программу так, чтобы она выдавала случайно одно из чисел $0$, $1$ или $2$.

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
int main(void){
    srand(time(NULL));
    int rand_digit = rand();
    printf("%d\n",rand_digit % 3);
    return 0;
}
```

## Рулетка

Поле для игры в рулетку состоит из ячеек от 0 до N.  На вход программе подаётся одно натуральное число N.

Программа должна выдать случайное число от нуля до N включительно.

```c
#include <stdio.h>

int main() {
    int N, rand_digit;
    scanf("%d", &N);
    srand(time(NULL));
    rand_digit = rand()%(N + 1);
    printf("%d\n",rand_digit);
  return 0;
}
```

## На вход программе подаётся два числа S и E, записанных через пробел. При этом гарантируется, что S≤E. Программа должна выводить одно случайное число из промежутка [S;E]

```c
#include <stdio.h>

int main() {
    int S, E, rand_digit;
    scanf("%d%d", &S, &E);
    srand(time(NULL));
    rand_digit = S + rand()%(E - S + 1);
    printf("%d\n",rand_digit);
  return 0;
}
```

[Содержание](#содержание)

<hr>

[Содержание курса](/StepikC/README.md)