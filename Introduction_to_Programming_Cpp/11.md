Сегодня мы поговорим о множествах. Множества — это математические структуры, которые могут хранить в себе уникальные элементы (то есть, каждый элемент может входить в множество только один раз).

# 1.11 Словари и множества

## Содержание

+ [Работа с элементами множества](#работа-с-элементами-множества)
+ [Вывод всех элементов множества](#вывод-всех-элементов-множества)
+ [Сортировка с помощью множества](#сортировка-с-помощью-множества)
+ [Количество разных элементов](#количество-разных-элементов)
+ [Подсчет количества вхождений элемента в последовательность](#подсчет-количества-вхождений-элемента-в-последовательность)
+ [Словари](#словари)
+ [Проход по элементам словаря](#проход-по-элементам-словаря)
+ [Сопоставление нескольких значений](#сопоставление-нескольких-значений)
+ [Задачи](#задачи)
    + [Дан список целых чисел, который может содержать до 100000 чисел. Определите, сколько в нем встречается различных чисел](#дан-список-целых-чисел-который-может-содержать-до-100000-чисел-определите-сколько-в-нем-встречается-различных-чисел)
    + [Во входной строке записана последовательность чисел через пробел. Для каждого числа выведите слово YES (в отдельной строке), если это число ранее встречалось в последовательности или NO, если не встречалось](#во-входной-строке-записана-последовательность-чисел-через-пробел-для-каждого-числа-выведите-слово-yes-в-отдельной-строке-если-это-число-ранее-встречалось-в-последовательности-или-no-если-не-встречалось)
    + [Даны два списка чисел, которые могут содержать до 100000 чисел каждый. Посчитайте, сколько чисел содержится одновременно как в первом списке, так и во втором](#даны-два-списка-чисел-которые-могут-содержать-до-100000-чисел-каждый-посчитайте-сколько-чисел-содержится-одновременно-как-в-первом-списке-так-и-во-втором)
    + [Даны два списка чисел, которые могут содержать до 100000 чисел каждый.  Выведите все числа, которые входят как в первый, так и во второй список в порядке возрастания](#даны-два-списка-чисел-которые-могут-содержать-до-100000-чисел-каждый--выведите-все-числа-которые-входят-как-в-первый-так-и-во-второй-список-в-порядке-возрастания)
    + [Вам дан словарь, состоящий из пар слов. Каждое слово является синонимом к парному ему слову. Все слова в словаре различны. Для одного данного слова определите его синоним.](#вам-дан-словарь-состоящий-из-пар-слов-каждое-слово-является-синонимом-к-парному-ему-слову-все-слова-в-словаре-различны-для-одного-данного-слова-определите-его-синоним)
    + [Однажды, разбирая старые книги на чердаке, школьник Вася нашёл англо-латинский словарь. Английский он к тому времени знал в совершенстве, и его мечтой было изучить латынь. Поэтому попавшийся словарь был как раз кстати](#однажды-разбирая-старые-книги-на-чердаке-школьник-вася-нашёл-англо-латинский-словарь-английский-он-к-тому-времени-знал-в-совершенстве-и-его-мечтой-было-изучить-латынь-поэтому-попавшийся-словарь-был-как-раз-кстати)
    + [Учительница задала Пете домашнее задание — в заданном тексте расставить ударения в словах, после чего поручила Васе проверить это домашнее задание. Вася очень плохо знаком с данной темой, поэтому он нашел словарь, в котором указано, как ставятся ударения в словах. К сожалению, в этом словаре присутствуют не все слова. Вася решил, что в словах, которых нет в словаре, он будет считать, что Петя поставил ударения правильно, если в этом слове Петей поставлено ровно одно ударение](#учительница-задала-пете-домашнее-задание--в-заданном-тексте-расставить-ударения-в-словах-после-чего-поручила-васе-проверить-это-домашнее-задание-вася-очень-плохо-знаком-с-данной-темой-поэтому-он-нашел-словарь-в-котором-указано-как-ставятся-ударения-в-словах-к-сожалению-в-этом-словаре-присутствуют-не-все-слова-вася-решил-что-в-словах-которых-нет-в-словаре-он-будет-считать-что-петя-поставил-ударения-правильно-если-в-этом-слове-петей-поставлено-ровно-одно-ударение)

[Оглавление](/Introduction_to_Programming_Cpp/README.MD)

## Работа с элементами множества

Решим следующую задачу: даны `N` запросов трёх типов:
+ добавить элемент во множество;
+ проверить, входит ли элемент во множество;
+ удалить элемент из множества.

Сначала задается число `N`, а затем сами запросы. Каждый из них состоит из двух чисел. Первое обозначает тип запроса, а второе — элемент, с которым нужно произвести операцию.

Решать эту задачу удобнее всего с помощью типа `set` (множество). Для начала нужно подключить одноимённую библиотеку `set`. Давайте напишем программу, а потом я объясню новые понятия:

```c++
#include <iostream>
#include <set>

using namespace std;

int main() {
    set <int> s;
    int n;
    cin >> n;
    for (int i = 0; i < n; i++) {
        int type, x;
        cin >> type >> x;
        if (type == 1) { // добавление
            s.insert(x);
        } else if (type == 2) { // проверка
            if (s.find(x) == s.end()) {
                  cout << "NO\n";
            } else {
                cout << "YES\n";
            }
        } else { // удаление
              s.erase(x);
        }
    }
    return 0;
} 
```

Множества создаются по аналогии с векторами. Пишем ключевое слово `set`, за ним — название типа каждого из элементов множества (в треугольных скобках), а после этого указываем имя для нового множества. Так мы получаем пустое множество. Добавление элементов в него происходит с помощью метода `insert`. Чтобы проверить, входит ли элемент во множество, используется метод `find`. Если элемент в множестве не нашелся, то он выдает то же значение, что и метод `end`. Удаление отдельного элемента из множества выполняется с помощью метода `erase`.

<hr>

[Содержание](#содержание)

## Вывод всех элементов множества

Вот как можно пройти по всем элементам, которые есть во множестве. Сначала посчитаем `N` чисел и «положим» их во множество `S`:

```c++
set <int> s;
int n;
cin >> n;
for (int i = 0; i < n; i++) {
    int x;
    cin >> x;
    s.insert(x);
}
```

Вывести всё содержимое множества можно двумя способами. Первый из них новый:

```c++
for (auto now = s.begin(); now != s.end(); now++) {
    cout << *now << ' ';
}
```

В данном случае `now` — это не очередной элемент, а указатель на него. Метод `begin` возвращает указатель на самый маленький элемент множества, `end` — это конец множества (он идёт после самого большого элемента), а операция `++` осуществляет переход к указателю на следующий элемент. Чтобы посмотреть, что за элемент хранится по указателю, нужно перед его именем написать символ `*`.
Второй способ позволяет выводить элементы множества аналогично выводу всех элементов в векторе:

```c++
for (auto now : s) {    
    cout << now << ' ';
}
```

Если ввести одинаковые элементы, то каждый из них окажется во множестве (и будет выведен) только один раз.

<hr>

[Содержание](#содержание)

## Сортировка с помощью множества

Поскольку проход по элементам множества осуществляется в возрастающем порядке, то велик соблазн использовать его для сортировки последовательностей. Увы, всё портит тот факт, что с одинаковыми элементами множество работает иначе.

Тем не менее, задачу сортировки решить можно и с их помощью. В C++ есть структура `multiset`, которая может хранить в себе одинаковые элементы. `Multiset` умеет все то же самое, что и обычный `set`, и лежит в той же библиотеке. Если в предыдущей программе вывода всех элементов заменить `set` на `multiset`, то мы как раз и получим элементы по возрастанию.

<hr>

[Содержание](#содержание)

## Количество разных элементов

С помощью `set` очень легко подсчитать число различных элементов в последовательности. Для этого нужно просто добавить все элементы последовательности во множество, а затем посмотреть на его размер. Вот как решить эту задачу с помощью того, что мы уже знаем. При обработке очередного элемента последовательности нужно сначала проверить, есть ли элемент во множестве. Если его там нет — увеличиваем счётчик на единицу, а затем добавляем элемент во множество. Но есть и более простой способ. У `set` есть метод `size()`, который возвращает количество элементов во множестве. Достаточно просто добавить в него все элементы подряд, а затем вывести `size()` от этого множества.

<hr>

[Содержание](#содержание)

## Подсчет количества вхождений элемента в последовательность

Поскольку во множестве все элементы упорядочены, с его помощью легко подсчитать количество вхождений элемента в последовательность. Например, мы хотим посчитать, сколько раз встречается единица. Для решения этой задачи мы будем использовать `multiset`.

```c++
multiset <int> s;
int n;
cin >> n;
for (int i = 0; i < n; i++) {
    int x;
    cin >> x;
    s.insert(x);
}
int cnt = 0;
for (auto now = s.lower_bound(1); now != s.upper_bound(1); now++) {
    cnt++;
}
cout << cnt;
```

Здесь появилось два новых метода: `lower_bound` и `upper_bound`. `Lower_bound` возвращает указатель на первый элемент, значение которого больше либо равно переданному параметру. `Upper_bound` — на первый элемент, который строго больше. Так мы пробежим от первой единицы до первого элемента (или `end’а` нашего `set’а`), на каждом шаге увеличивая значение счётчика вхождений. Если ни одной единицы в последовательности нет, оба метода вернут указатели на больший элемент; будет выполнено `0` шагов.

<hr>

[Содержание](#содержание)

## Словари

В C++ есть ещё одна структура, похожая на множество, которая называется «словарь». Она ставит в соответствие ключу значение, совсем как в обычном словаре, где каждому русскому слову ставится в соответствие иностранное.

Рассмотрим такую задачу: на телефон поступает входящий звонок с известного номера телефона. Нужно проверить, есть ли он в телефонной книге. Для этого понадобится словарь, в котором числу (номеру) соответствует строка (имя абонента).

```c++
#include <iostream>
#include <map>
#include <string>

using namespace std;

int main() {
      map <int, string> s;
      s[112] = "sos";
      if (s.find(112) != s.end()) {
            cout << "YES\n";
      }
      return 0;
}
```

Словарь в C++ называется `map` (карта). Чтобы пользоваться словарями, нужно подключить библиотеку `map`. Чтобы создать словарь, мы пишем `map`, затем в треугольных скобках через запятую указываем тип ключа и значения. После этого идёт имя нового словаря.

Создавать элементы в словаре очень просто. Достаточно написать имя словаря, а затем в квадратных скобках указать ключ. Нужно сразу приравнять этот элемент к какому-либо значению. Тогда к нему можно будет обращаться, просто указав имя словаря и ключ в квадратных скобках. Проверка существования элемента делается с помощью метода `find`, как и во множествах.

<hr>

[Содержание](#содержание)

## Проход по элементам словаря

Проход по всем элементам в словаре делается почти так же, как и во множестве. Рассмотрим первый способ:

```c++
map <int, string> s;
s[112] = "sos";
s[102] = "emergency";
for (auto now : s) {
    cout << now.first << " " << now.second << "\n";
}
```

В отличие от множества, в словаре на место `now` подставляются пары «ключ-значение». Пара — это особый тип данных, состоящий из двух элементов. Обратиться к первому из них можно как к `now.first` (где `now` — название пары), а ко второму — `now.second`. Это обращение к полям очень похоже на вызов метода, но после него не нужно писать скобок. Отдельные элементы пары также можно менять как обычные переменные.

Как и во множестве, ключи в словаре упорядочены по возрастанию. Для поиска ключей можно также пользоваться методами `find`, `lower_bound` и `upper_bound`.

<hr>

[Содержание](#содержание)

## Сопоставление нескольких значений

Часто требуется сопоставить одному ключу несколько значений. Например, в словаре иностранных слов может быть несколько переводов для одного слова, а в телефонной книге — несколько номеров у одного и того же человека. Чтобы решить задачу такого сопоставления, мы будем использовать в качестве значения вектор.

Вернёмся к примеру с телефонной книгой. Допустим, нам нужно сохранить для одного абонента все телефонные номера (их мы тоже будем хранить в строке).

```c++
#include <iostream>
#include <map>
#include <string>
#include <vector>

using namespace std;

int main() {
    map <string, vector <string>> s;
    s["Vasya"] = { "112133", "12341" };
    for (auto now : s["Vasya"]) {
        cout << now << " ";
    }
    return 0;
}
```

В этой программе мы сразу инициализировали вектор конкретными значениями, используя фигурные скобки. В принципе, можно создать пустой вектор и добавлять в него элементы с помощью метода `push_back`. Это удобно в том случае, если мы не знаем заранее, сколько номеров в нашей телефонной книге может быть сопоставлено человеку. Если ключ ещё не встречался, нужно создать пустой вектор, а при каждом его обнаружении просто добавлять элемент в вектор.

# Задачи

<hr>

[Содержание](#содержание)

## Дан список целых чисел, который может содержать до 100000 чисел. Определите, сколько в нем встречается различных чисел.
Входные данные<br>
Вводится число N - количество элементов списка, а затем N чисел.<br>
Выходные данные<br>
Выведите ответ на задачу.<br>
Sample Input:<br>
5<br>
1 2 3 2 1<br>
Sample Output:<br>
3<br>

```c++
#include <iostream>
#include <set>

int main() {
    std::set<int> Digits;
    int digit;
    size_t count;
    std::cin >> count;

    for (size_t i = 0; i < count; i++) {
        std::cin >> digit;
        Digits.insert(digit);
    }
    int result = Digits.size();
    std::cout << result << std::endl;
    return 0;
}
```

<hr>

[Содержание](#содержание)

## Во входной строке записана последовательность чисел через пробел. Для каждого числа выведите слово YES (в отдельной строке), если это число ранее встречалось в последовательности или NO, если не встречалось.

Входные данные<br>
Вводится число N - количество элементов списка, а затем N чисел.<br>
Выходные данные<br>
Выведите ответ на задачу.<br>
Sample Input:<br>
6<br>
1 2 3 2 3 4<br>
Sample Output:<br>
NO<br>
NO<br>
NO<br>
YES<br>
YES<br>
NO<br>

```c++
#include <iostream>
#include <set>

int main() {
    std::set<int> Digits;
    int digit;
    size_t count;
    std::cin >> count;

    for (size_t i = 0; i < count; i++) {
        std::cin >> digit;
        if (Digits.find(digit) == Digits.end()) {
            std::cout << "NO\n";
            Digits.insert(digit);
        } else {
            std::cout << "YES\n";
        }
    }
    return 0;
}
```

<hr>

[Содержание](#содержание)

## Даны два списка чисел, которые могут содержать до 100000 чисел каждый. Посчитайте, сколько чисел содержится одновременно как в первом списке, так и во втором.

Входные данные<br>
Вводится число N - количество элементов первого списка, а затем N чисел первого списка. <br>
Затем вводится число M - количество элементов второго списка, а затем M чисел второго списка.<br>
Выходные данные<br>
Выведите ответ на задачу.<br>
Sample Input:<br>
3<br>
1 3 2<br>
3<br>
4 3 2<br>
Sample Output:<br>
2<br>

```c++
#include <iostream>
#include <set>

int main() {
    std::set<int> First, Second;
    int digit;
    size_t count;
    std::cin >> count;
    for (size_t i = 0; i < count; i++) {
        std::cin >> digit;
        First.insert(digit);
    }
    int result = 0;
    std::cin >> count;
    for (size_t i = 0; i < count; i++) {
        std::cin >> digit;
        Second.insert(digit);
        if (First.find(digit) != First.end()) {
            result++;
        }
    }
    std::cout << result << std::endl;
    return 0;
}
```

<hr>

[Содержание](#содержание)

## Даны два списка чисел, которые могут содержать до 100000 чисел каждый.  Выведите все числа, которые входят как в первый, так и во второй список в порядке возрастания.

Входные данные<br>
Вводится число N - количество элементов первого списка, а затем N чисел первого списка.<br>
Затем вводится число M - количество элементов второго списка, а затем M чисел второго списка.<br>
Выходные данные<br>
Выведите ответ на задачу.<br>
Sample Input:<br>
3<br>
1 3 2<br>
3<br>
4 3 2<br>
Sample Output:<br>
2 3<br>

```c++
#include <iostream>
#include <set>

int main() {
    std::set<int> First, Second, result;
    int digit;
    size_t count;
    std::cin >> count;
    for (size_t i = 0; i < count; i++) {
        std::cin >> digit;
        First.insert(digit);
    }
    std::cin >> count;
    for (size_t i = 0; i < count; i++) {
        std::cin >> digit;
        Second.insert(digit);
        if (First.find(digit) != First.end()) {
            result.insert(digit);
        }
    }
    for (int number : result) {
        std::cout << number << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

<hr>

[Содержание](#содержание)

## Вам дан словарь, состоящий из пар слов. Каждое слово является синонимом к парному ему слову. Все слова в словаре различны. Для одного данного слова определите его синоним.

Входные данные<br>
Программа получает на вход количество пар синонимов N. Далее следует N строк, каждая строка содержит ровно два слова-синонима. После этого следует одно слово.<br>
Выходные данные<br>
Программа должна вывести синоним к данному слову.<br>
Sample Input:<br>
3<br>
Hello Hi<br>
Bye Goodbye<br>
List Array<br>
Goodbye<br>
Sample Output:<br>
Bye<br>

```c++
#include <iostream>
#include <map>

int main() {
    using namespace std;
    map<string, string> Dict;
    size_t count;
    std::cin >> count;
    for (size_t i = 0; i < count; i++) {
        string key, value;
        std::cin >> key >> value;
        Dict.insert({key, value});
        Dict.insert({value, key});
    }
    string word;
    std::cin >> word;
    word = Dict[word];
    std::cout << word << std::endl;

    return 0;
}
```

<hr>

[Содержание](#содержание)

## Однажды, разбирая старые книги на чердаке, школьник Вася нашёл англо-латинский словарь. Английский он к тому времени знал в совершенстве, и его мечтой было изучить латынь. Поэтому попавшийся словарь был как раз кстати.

К сожалению, для полноценного изучения языка недостаточно только одного словаря: кроме англо-латинского необходим латинско-английский. За неимением лучшего он решил сделать второй словарь из первого.

Как известно, словарь состоит из переводимых слов, к каждому из которых приводится несколько слов-переводов. Для каждого латинского слова, встречающегося где-либо в словаре, Вася предлагает найти все его переводы (то есть все английские слова, для которых наше латинское встречалось в его списке переводов), и считать их и только их переводами этого латинского слова.

Помогите Васе выполнить работу по созданию латинско-английского словаря из англо-латинского.

Входные данные

В первой строке содержится единственное целое число N — количество английских слов в словаре. Далее следует N описаний. Каждое описание содержится в отдельной строке, в которой записано сначала английское слово, затем отделённый пробелами дефис (символ номер 45), затем разделённые запятыми с пробелами переводы этого английского слова на латинский. Переводы отсортированы в лексикографическом порядке. Порядок следования английских слов в словаре также лексикографический.

Все слова состоят только из маленьких латинских букв, длина каждого слова не превосходит 15 символов. Общее количество слов на входе не превышает 100000.

Выходные данные

В первой строке программа должна вывести количество слов в соответствующем данному латинско-английском словаре. Со второй строки выведите сам словарь, в точности соблюдая формат входных данных. В частности, первым должен идти перевод лексикографически минимального латинского слова, далее — второго в этом порядке и т.д. Внутри перевода английские слова должны быть также отсортированы лексикографически.

Sample Input:<br>
3<br>
apple - malum, pomum, popula<br>
fruit - baca, bacca, popum<br>
punishment - malum, multa<br>
Sample Output:<br>
7<br>
baca - fruit<br>
bacca - fruit<br>
malum - apple, punishment<br>
multa - punishment<br>
pomum - apple<br>
popula - apple<br>
popum - fruit<br>

```c++
#include <iostream>
#include <map>
#include <set>
#include <string>
#include <vector>

int main() {
    using namespace std;
    map<string, set<string>> /*Dict,*/ Result;
    size_t count;
    std::cin >> count >> ws;
    string str;
    set<string> value;
    for (size_t j = 0; j < count; j++) {
        vector<string> parser;
        getline(cin, str);
        str += ',';
        string word = "";
        for (size_t i = 0; i < str.length(); i++) {
            char ch = str.data()[i];
            if (isalpha(ch)) {
                word += ch;
            } else if (word != "") {
                parser.push_back(word);
                word = "";
            }
        }
        for (size_t i = 1; i < parser.size(); i++) {
            // value.insert(parser[i]);
            if (Result.find(parser[i]) != Result.end()) {
                Result[parser[i]].insert(parser[0]);
            } else {
                Result.insert({parser[i], {parser[0]}});
            }
        }
        // Dict.insert({parser[0], value});
    }
    cout << Result.size() << "\n";
    for (auto d : Result) {
        cout << d.first << " - ";
        int n = d.second.size();
        for (auto w : d.second) cout << w << (--n ? ", " : "\n");
    }

    return 0;
}
```

<hr>

[Содержание](#содержание)

## Учительница задала Пете домашнее задание — в заданном тексте расставить ударения в словах, после чего поручила Васе проверить это домашнее задание. Вася очень плохо знаком с данной темой, поэтому он нашел словарь, в котором указано, как ставятся ударения в словах. К сожалению, в этом словаре присутствуют не все слова. Вася решил, что в словах, которых нет в словаре, он будет считать, что Петя поставил ударения правильно, если в этом слове Петей поставлено ровно одно ударение.

Оказалось, что в некоторых словах ударение может быть поставлено больше, чем одним способом. Вася решил, что в этом случае если то, как Петя поставил ударение, соответствует одному из приведенных в словаре вариантов, он будет засчитывать это как правильную расстановку ударения, а если не соответствует, то как ошибку.

Вам дан словарь, которым пользовался Вася и домашнее задание, сданное Петей. Ваша задача — определить количество ошибок, которое в этом задании насчитает Вася.

Входные данные

Вводится сначала число N — количество слов в словаре (0 ≤ N ≤ 20000).

Далее идет N строк со словами из словаря. Каждое слово состоит не более чем из 30 символов. Все слова состоят из маленьких и заглавных латинских букв. В каждом слове заглавная ровно одна буква — та, на которую попадает ударение. Слова в словаре расположены в алфавитном порядке. Если есть несколько возможностей расстановки ударения в одном и том же слове, то эти варианты в словаре идут в произвольном порядке.

Далее идет упражнение, выполненное Петей. Упражнение представляет собой строку текста, суммарным объемом не более 300000 символов. Строка состоит из слов, которые разделяются между собой ровно одним пробелом. Длина каждого слова не превышает 30 символов. Все слова состоят из маленьких и заглавных латинских букв (заглавными обозначены те буквы, над которыми Петя поставил ударение). Петя мог по ошибке в каком-то слове поставить более одного ударения или не поставить ударения вовсе.

Выходные данные

Выведите количество ошибок в Петином тексте, которые найдет Вася.

Примечание к примеру


1. В слове cannot, согласно словарю возможно два варианта расстановки ударения. Эти варианты в словаре могут быть перечислены в любом порядке (т.е. как сначала cAnnot, а потом cannOt, так и наоборот).
Две ошибки, совершенные Петей — это слова be (ударение вообще не поставлено) и fouNd (ударение поставлено неверно). Слово thE отсутствует в словаре, но поскольку в нем Петя поставил ровно одно ударение, признается верным.

2. Неверно расставлены ударения во всех словах, кроме The (оно отсутствует в словаре, в нем поставлено ровно одно ударение). В остальных словах либо ударные все буквы (в слове PAGE), либо не поставлено ни одного ударения.

Sample Input 1:<br>
4<br>
cAnnot<br>
cannOt<br>
fOund<br>
pAge<br>
thE pAge cAnnot be fouNd<br>
Sample Output 1:<br>
2<br>
Sample Input 2:<br>
4<br>
cAnnot<br>
cannOt<br>
fOund<br>
pAge<br>
The PAGE cannot be found<br>
Sample Output 2:<br>
4<br>

```c++
#include <iostream>
#include <map>
#include <set>
#include <string>
#include <vector>

std::string to_lower(const std::string str) {
    std::string result;
    for (char ch : str) {
        result += tolower(ch);
    }
    return result;
}
int upper_count(const std::string str) {
    int result = 0;
    for (char ch : str) {
        if(isupper(ch)) result++;
    }
    return result;
}

int main() {
    std::map<std::string, std::set<std::string>> Dict;
    size_t count;
    std::cin >> count >> std::ws;
    std::string str;
    for (size_t j = 0; j < count; j++) {
        std::string word;
        std::cin >> word;
        std::string lower_word = to_lower(word);
        if (Dict.find(lower_word) != Dict.end()) {
            Dict[lower_word].insert(word);
        } else {
            Dict.insert({lower_word, {word}});
        }
    }
    std::cin >> std::ws;
    std::vector<std::string> parser;
    getline(std::cin, str);
    str += ' ';
    std::string word = "";
    for (size_t i = 0; i < str.length(); i++) {
        char ch = str.data()[i];
        if (isalpha(ch)) {
            word += ch;
        } else if (word != "") {
            parser.push_back(word);
            word = "";
        }
    }
    // for (auto d : Dict) {
    //     std::cout << d.first << " - ";
    //     int n = d.second.size();
    //     for (auto w : d.second) std::cout << w << (--n ? ", " : "\n");
    // }

    int result = 0;
    for (auto d : parser) {
        std::string l_d = to_lower(d);
        if (Dict.find(l_d) != Dict.end()) {
            if (Dict[l_d].find(d) != Dict[l_d].end()) {
                continue;
            } else
                result++;
        } else

            if (upper_count(d) != 1) {
            result++;
        }
    }
    std::cout << result << std::endl;
    return 0;
}
```

<hr>

[Содержание](#содержание)