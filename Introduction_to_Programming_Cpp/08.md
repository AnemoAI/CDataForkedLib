На сегодняшнем занятии мы будем изучать двумерные массивы — те самые таблицы, которые очень часто возникают в реальной жизни. Иногда их также называют «матрицами», как в алгебре.

# 1.8 Двумерные массивы

## Содержание

+ [Создание и заполнение двумерных массивов](#создание-и-заполнение-двумерных-массивов)
+ [Поле для сапера](#поле-для-сапера)
+ [Задачи](#задачи)
    + [Найдите индексы первого вхождения максимального элемента](#найдите-индексы-первого-вхождения-максимального-элемента)
    + [Дано нечетное число n, не превосходящее 15. Снежинка.](#дано-нечетное-число-n-не-превосходящее-15-снежинка)
    + [Дано число n, не превышающее 100. Диагонали.](#дано-число-n-не-превышающее-100-диагонали)
    + [Дан двумерный массив и два числа: i и j. Поменяйте в массиве столбцы с номерами i и j](#дан-двумерный-массив-и-два-числа-i-и-j-поменяйте-в-массиве-столбцы-с-номерами-i-и-j)
    + [Дано число n, не превосходящее 10, и массив размером n × n. Симметрия.](#дано-число-n-не-превосходящее-10-и-массив-размером-n--n-симметрия)
    + [Дан квадратный двумерный массив размером n × n и число k. Числа диагонали.](#дан-квадратный-двумерный-массив-размером-n--n-и-число-k-числа-диагонали)
    + [Дан двумерный массив размером n×m (n и m не превосходят 1000). Транспонирование.](#дан-двумерный-массив-размером-nm-n-и-m-не-превосходят-1000-транспонирование)
    + [В кинотеатре n рядов по m мест в каждом (n и m не превосходят 20). Свободные места.](#в-кинотеатре-n-рядов-по-m-мест-в-каждом-n-и-m-не-превосходят-20-свободные-места)
    + [Дан прямоугольный массив размером n×m. Поворот.](#дан-прямоугольный-массив-размером-nm-поворот)
    + [По данным числам n и m заполните двумерный массив размером n×m числами от 1 до n×m “змейкой”, как показано в примере.](#по-данным-числам-n-и-m-заполните-двумерный-массив-размером-nm-числами-от-1-до-nm-змейкой-как-показано-в-примере)
    + [По данным числам n и m заполните двумерный массив размером n×m числами от 1 до n×m “диагоналями”, как показано в примере.](#по-данным-числам-n-и-m-заполните-двумерный-массив-размером-nm-числами-от-1-до-nm-диагоналями-как-показано-в-примере)
    + [Даны числа n и m. Форматированный вывод массива.](#даны-числа-n-и-m-форматированный-вывод-массива)
    + [По данным числам n и m заполните двумерный массив размером n×m числами от 1 до n×m по спирали.](#по-данным-числам-n-и-m-заполните-двумерный-массив-размером-nm-числами-от-1-до-nm-по-спирали)

[Оглавление](/Introduction_to_Programming_Cpp/README.MD)

## Создание и заполнение двумерных массивов

Решим такую задачу: нарисовать на экране квадратный флаг Туапсинского района, где цвета обозначены разными цифрами. Точнее, задача формулируется так: по заданному числу `N` вывести на экран квадратную таблицу размером `N` на `N`, где главная диагональ (идущая из левого верхнего угла в правый нижний) заполнена единицами, в верхней правой половине таблицы стоят нули, а в левой нижней – двойки.

Если при работе с векторами мы сначала считывали размер, а затем создавали вектор нужного размера, то при работе с двумерными массивами мы воспользуемся другим способом. Нам заранее нужно будет создать массив максимально допустимого по условию задачи размера. В этой задаче — `100` на `100`.

Чтобы создать двумерный массив размером `100` на `100` чисел нужно написать

```c
int a[100][100];
```

Здесь `a` — это название массива, число в первых квадратных скобках задает количество строк, а во вторых — столбцов в этом массиве. Нумерация строк и столбцов начинается с нуля, `a[0][0]` — это верхний левый элемент таблицы. Обращение к конкретному элементу матрицы делается почти так же, как к элементу одномерного массива. Только в матрице индекса два: номер строки и номер столбца. Каждый из индексов указывается в отдельных квадратных скобках.

Как и на предыдущем занятии, программу удобно разбить на три логических блока: чтение, обработка и вывод данных. В этой задаче ввод очень простой, достаточно считать число N — размер таблицы. Обработка будет выглядеть следующим образом: мы сделаем цикл по строкам (счетчик `i`), а внутри него – цикл по отдельным элементам очередной строки (этот счетчик будет называться `j`). Для элементов, лежащих на диагонали, индексы `i` и `j` будут совпадать. В правой верхней части массива номер строки будет меньше номера столбца, а в левой нижней — наоборот, номер строки будет больше номера столбца.

```c++
for (int i = 0; i < n; i++) { //перебор строк
    for (int j = 0; j < n; j++) { //перебор столбцов
        if (i == j) {
            a[i][j] = 1;
        } else if (i < j) {
            a[i][j] = 0;
        } else {
            a[i][j] = 2;
        }
    }
}
//вывод
for (int i = 0; i < n; i++) { //перебор строк
    for (int j = 0; j < n; j++) { //вывод одной строки
        cout << a[i][j] << " ";
    }
    cout << endl; //перевод строки после того, как выведены все элементы
}
```

<hr>

[Содержание](#содержание)

## Поле для сапера

Игра «Сапер» известна многим. В некоторых клетках на прямоугольном поле лежат мины, а в остальных клетках — числа, обозначающие количество мин, которые окружают клетку (от `0` до `8`). В нашей задаче по известному расположению мин на поле необходимо расставить числа во все свободные клетки, а на месте мин выводить «звездочку».

Как обычно, разделим задачу на стандартные части: чтение, обработка и вывод.

Пусть данные задаются в таком виде: в первой строке задаются два числа `N` и `M` — количество строк и столбцов соответственно. Оба этих числа не превосходят `100`. После этого идет описание поля, состоящее из `N` строк. В каждой из строк содержится `M` чисел. Если очередное число равно `1`, то в этой клетке стоит мина, а если `0` — мины нет.

В нашей программе мы считаем все поле в двумерный массив. Вот так будет выглядеть чтение:

```c++
int n, m;
cin >> n >> m;
int mines[100][100];
// чтение
for (int i = 0; i < n; i++) {
    for (int j = 0; j < m; j++) {
        cin >> mines[i][j];
    }
}
```

Следующий этап — обработка массива. В нашем случае основная обработкасостоит в том, чтобы для каждой свободной клетки посмотреть на `8` соседних и посчитать, в скольких из них есть мины. Это количество мы запомним в таком же по размеру массиве ответа.

Сразу подумаем о возможных проблемах. Смотря на соседей угловой или находящейся у края поля клетки, мы можем вылезти за пределы поля (то есть выйти за границы массива). Можно при просмотре каждого соседа писать условие с проверкой, лежит ли этот сосед в пределах поля. Но тогда нам придется писать `8` `if`’ов, в которых легко ошибиться. 

Поэтому можно поступить по-другому: окружить поле рамкой из свободных клеток. Они не повлияют на числа в клетках, а выхода за пределы массива не будет. Для этого нужно увеличить размеры массива по каждому из измерений на `2` (амка сверху и снизу, слева и справа от поля) и сразу заполнить его нулями. Входные данные тогда записываются, начиная с ячейки `[1][1]`, а не `[0][0]`.

Лучше произвести все эти действия на этапе чтения. После всех изменений чтение будет выглядеть так:

```c++
int n, m;
cin >> n >> m;
int mines[102][102]
for (int i = 0; i <= n + 1; i++) {
    for (int j = 0; j <= m + 1; j++) {
        mines[i][j] = 0;
    }
}
// чтение
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
        cin >> mines[i][j];
    }
}
```

Перейдем к реализации обработки массива. Для каждой клетки поля нужно посмотреть на 8 соседей. Можно описать координаты каждого соседа отдельно, тогда у нас будет 8 почти одинаковых строк, а можно сделать очень классную вещь, чтобы писать меньше букв и допускать меньше ошибок. Пусть наша клетка имеет координаты `[i][j]`. 

Тогда ее соседями будут 8 клеток с координатами
+ `[i + 1][j - 1]`,
+ `[i + 1][j]`,
+ `[i + 1][j + 1]`,
+ `[i][j - 1]`,
+ `[i][j - 1]`,
+ `[i - 1][j - 1]`,
+ `[i - 1][j]`,
+ `[i - 1][j + 1].` 

Мы можем описать смещения относительно текущей клетки по каждой из координат в виде двух массивов `dx` и `dy`, каждый из которых состоит из `8` элементов, а возможные значения каждого из элементов это `0`, `1` и `-1`. Тогда можно будет для каждой клетки поля пройти еще одним циклом по `8` соседям и просто посчитать сумму в них. Запишем это в виде программы:

```c++
int ans[102][102];
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
        // координаты соседей (сдвиги)
        int dx[8] = {1, 1, 1, 0, 0, -1, -1, -1};
        int dy[8] = {-1, 0, 1, -1, 1, -1, 0, 1};
        // перебор соседей
        int temp = 0;
        for (int k = 0; k < 8; k++)
            temp += mines[i + dy[k]][j + dx[k]];
        ans[i][j] = temp;
    }
}
```

Из новых языковых конструкций в этом коде у нас появилась инициализация массива конкретными значениями. Так заполняются массивы `dx` и `dy`.

В программе осталось написать только вывод. Он очень похож на предыдущую задачу, только нужно не забыть про вывод звездочки для тех клеток, где стоит мина.

```c++
// вывод
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
        if (mines[i][j] == 1) {
            cout << "*";
        } else {
            cout << ans[i][j];
        }
    }
    cout << endl;
}
```

Эта программа получилась очень длинной и достаточно трудной для понимания и отладки. Чтобы писать программу по кусочкам, каждый из которых остается коротким и понятным, нужны функции, которые мы изучим на следующем занятии.

<hr>

[Содержание](#содержание)

## Задачи

## Найдите индексы первого вхождения максимального элемента.

Формат входных данных<br>
Программа получает на вход размеры массива n и m, затем n строк по m чисел в каждой. n и m не превышают 100.<br>
Формат выходных данных<br>
Выведите два числа: номер строки и номер столбца, в которых стоит наибольший элемент в двумерном массиве. Если таких элементов несколько, то выводится тот, у которого меньше номер строки, а если номера строк равны то тот, у которого меньше номер столбца.

```c++
#include <iostream>

int main() {
    int n, m, n_max = 0, m_max = 0;
    std::cin >> n >> m;
    int a[n][m];
    int max = INT32_MIN;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            std::cin >> a[i][j];
            if (a[i][j] > max) {
                max = a[i][j];
                n_max = i;
                m_max = j;
            }
        }
    }

    std::cout << n_max << " " << m_max << std::endl;
    return 0;
}
```

```c++
#include <iostream>

int main() {
    using namespace std;
    int x, y; 
    cin >> x >> y;
    int n; 
    cin >> n;
    int max = n;
    int index = 0;
    for (int i = 1; i < x * y; i++) {
        cin >> n;
        if (n > max) { 
        max = n; 
        index = i; 
        }
    }
    cout << index / y << " " << index % y << endl;
    return 0;
}
```

<hr>

[Содержание](#содержание)

## Дано нечетное число n, не превосходящее 15. Снежинка.
Создайте двумерный массив из n×n элементов, заполнив его символами `.` (каждый элемент массива является строкой из одного символа). Затем заполните символами `*` среднюю строку массива, средний столбец массива, главную диагональ и побочную диагональ. В результате `*` в массиве должны образовывать изображение звездочки. Выведите полученный массив на экран, разделяя элементы массива пробелами.

Sample Input:

```
5
```

Sample Output:

```
* . * . *
. * * * .
* * * * *
. * * * .
* . * . *
```

```c++
#include <iostream>

int main() {
    int n;
    std::cin >> n;
    int a[n][n] = {};

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (i == j || n - i - 1 == j || i == n / 2 || j == n / 2) {
                a[i][j] = 1;
            }
        }
    }
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            std::cout << (a[i][j] ? "*" : ".") << (j == n - 1 ? "\n" : " ");
        }
    }
    std::cout << std::endl;
    return 0;
}
```

<hr>

[Содержание](#содержание)

## Дано число n, не превышающее 100. Диагонали.
Создайте массив размером n×n и заполните его по следующему правилу. На главной диагонали должны быть записаны числа 0. На двух диагоналях, прилегающих к главной, числа 1. На следующих двух диагоналях числа 2, и т.д. Выведите полученный массив на экран, разделяя элементы массива пробелами.

Sample Input:
```
5
```
Sample Output:
```
0 1 2 3 4
1 0 1 2 3
2 1 0 1 2
3 2 1 0 1
4 3 2 1 0
```

```c++
#include <iostream>

enum { max = 100 };

int main() {
    int n;
    std::cin >> n;
    int a[max][max] = {};

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (i < j) {
                a[i][j] = (n - i + j) % n;
                a[j][i] = a[i][j];
            }
        }
    }
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            std::cout << a[i][j] << (j == n - 1 ? "\n" : " ");
        }
    }
    return 0;
}
```

```c++
#include <iostream>

int main() {
    using namespace std;
    int n;
    cin >> n;
    int a[100][100];
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            a[i][j] = abs(i - j);
            cout << a[i][j] << " ";
        }
        cout << endl;
    }
    return 0;
}
```

```c++
#include <iostream>
using namespace std;
int main() {
    int n;
    cin >> n;
    int i = n * n;
    while (i-- > 0) cout << abs(i / n - i % n) << (i % n ? " " : "\n");
}
```

<hr>

[Содержание](#содержание)

## Дан двумерный массив и два числа: i и j. Поменяйте в массиве столбцы с номерами i и j
Формат входных данных<br>
Программа получает на вход размеры массива n и m, не превосходящие 100, затем элементы массива, затем числа i и j.<br>
Формат выходных данных<br>
Выведите результат.

Sample Input:
```
3 4
11 12 13 14
21 22 23 24
31 32 33 34
0 1
```
Sample Output:
```
12 11 13 14
22 21 23 24
32 31 33 34
```

```c
#include <iostream>

enum { max = 100 };

void swap(int& a, int& b) {
    int tmp = a;
    a = b;
    b = tmp;
}

int main() {
    int n, m;
    std::cin >> n >> m;
    int a[max][max] = {};

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            std::cin >> a[i][j];
        }
    }

    int b, c;
    std::cin >> b >> c;

    for (int i = 0; i < n; i++) {
        swap(a[i][b], a[i][c]);
    }

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            std::cout << a[i][j] << (j == m - 1 ? "\n" : " ");
        }
    }
    return 0;
}
```

<hr>

[Содержание](#содержание)

## Дано число n, не превосходящее 10, и массив размером n × n. Симметрия.

Проверьте, является ли этот массив симметричным относительно главной диагонали. Выведите слово “YES”, если массив симметричный, и слово “NO” в противном случае.

```c++
#include <iostream>

enum { max = 100 };

int main() {
    int n;
    std::cin >> n;
    int a[max][max] = {};

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            std::cin >> a[i][j];
        }
    }
    int result = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (i == j) continue;
            if (a[i][j] != a[j][i]) result++;
        }
    }

    std::cout << (result ? "NO" : "YES");
    return 0;
}
```

<hr>

[Содержание](#содержание)

## Дан квадратный двумерный массив размером n × n и число k. Числа диагонали.
Выведите элементы k-й по счету диагонали ниже главной диагонали (т.е. если k = 1, то нужно вывести элементы первой диагонали, лежащей ниже главной, если k = 2, то второй диагонали и т.д.).

Значение k может быть отрицательным, например, если k = −1, то нужно вывести значение первой диагонали лежащей выше главной. Если k = 0, то нужно вывести элементы главной диагонали.

Программа получает на вход число n, не превосходящие 10, затем массив размером n × n, затем число k.
Sample Input 1:
```
4
1 2 3 4
5 6 7 8
0 1 2 3
4 5 6 7
1
```
Sample Output 1:
```
5 1 6
```
Sample Input 2:
```
4
1 2 3 4
5 6 7 8
0 1 2 3
4 5 6 7
-2
```
Sample Output 2:
```
3 8
```

```c++
#include <iostream>

enum { max = 100 };

int main() {
    int n;
    std::cin >> n;
    int a[max][max] = {};

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            std::cin >> a[i][j];
        }
    }
    int k;
    std::cin >> k;

    for (int i = 0; i < n; i++) {
        int row = i + k;
        if (row < 0 || row > n - 1)
            continue;
        else
            std::cout << a[row][i] << " ";
    }
    std::cout << std::endl;
    return 0;
}
```

<hr>

[Содержание](#содержание)

## Дан двумерный массив размером n×m (n и m не превосходят 1000). Транспонирование.
Симметричный ему относительно главной диагонали массив называется транспонированным к данному. Он имеет размеры m×n: строки исходного массива становятся столбцами транспонированного, столбцы исходного массива становятся строками транспонированного.

Для данного массива постройте транспонированный массив и выведите его на экран.
Sample Input:
```
3 4
11 12 13 14
21 22 23 24
31 32 33 34
```
Sample Output:
```
11 21 31 
12 22 32 
13 23 33 
14 24 34
```

```c++
#include <iostream>

enum { max = 1000 };

int main() {
    int n, m;
    std::cin >> n >> m;
    int a[max][max] = {};

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            std::cin >> a[i][j];
        }
    }

    for (int j = 0; j < m; j++) {
        for (int i = 0; i < n; i++) {
            std::cout << a[i][j] << (i == n - 1 ? "\n" : " ");
        }
    }
    std::cout << std::endl;
    return 0;
}
```

<hr>

[Содержание](#содержание)

## В кинотеатре n рядов по m мест в каждом (n и m не превосходят 20). Свободные места.
В двумерном массиве хранится информация о проданных билетах, число 1 означает, что билет на данное место уже продан, число 0 означает, что место свободно. Поступил запрос на продажу k билетов на соседние места в одном ряду. Определите, можно ли выполнить такой запрос.<br>
Формат входных данных<br>
Программа получает на вход числа n и m. Далее идет n строк, содержащих m чисел (0 или 1), разделенных пробелами. Затем дано число k.<br>
Формат выходных данных<br>
Программа должна вывести номер ряда, в котором есть k подряд идущих свободных мест. Если таких рядов несколько, то выведите номер наименьшего подходящего ряда. Если подходящего ряда нет, выведите число 0.

Sample Input:
```
3 4
0 1 0 1
1 0 0 1
1 1 1 1
2
```
Sample Output:
```
2
```

```c++
#include <iostream>

enum { max = 20 };

int main() {
    int n, m;
    std::cin >> n >> m;
    int a[max][max] = {};

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            std::cin >> a[i][j];
        }
    }
    int k;
    std::cin >> k;

    for (int i = 0; i < n; i++) {
        int count = 0;
        for (int j = 0; j < m; j++) {
            if (a[i][j] == 0) {
                count++;
                if (count == k) {
                    std::cout << i + 1 << std::endl;
                    return 0;
                }
            } else
                count = 0;
        }
    }
    std::cout << 0 << std::endl;
    return 0;
}
```

<hr>

[Содержание](#содержание)

## Дан прямоугольный массив размером n×m. Поворот.
Поверните его на 90 градусов по часовой стрелке, записав результат в новый массив размером m×n.<br>
Формат входных данных<br>
Вводятся два числа n и m, не превосходящие 100, затем массив размером n×m.<br>
Формат выходных данных<br>
Выведите получившийся массив. Числа при выводе разделяйте одним пробелом.

Sample Input:
```
3 4
11 12 13 14
21 22 23 24
31 32 33 34
```
Sample Output:
```
31 21 11 
32 22 12 
33 23 13 
34 24 14
```

```c++
#include <iostream>

enum { max = 100 };

int main() {
    int n, m;
    std::cin >> n >> m;
    int a[max][max] = {};

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            std::cin >> a[i][j];
        }
    }

    for (int j = 0; j < m; j++) {
        for (int i = 0; i < n; i++) {
            std::cout << a[n - 1 - i][j] << (i == n - 1 ? "\n" : " ");
        }
    }
    std::cout << std::endl;
    return 0;
}
```

<hr>

[Содержание](#содержание)

## По данным числам n и m заполните двумерный массив размером n×m числами от 1 до n×m “змейкой”, как показано в примере.
Формат входных данных<br>
Вводятся два числа n и m, каждое из которых не превышает 30.<br>
Формат выходных данных<br>
Выведите полученный массив, отводя на вывод каждого элемента ровно 4 символа.

Sample Input:
```
3 5
```
Sample Output:
```
   1   2   3   4   5
  10   9   8   7   6
  11  12  13  14  15
```

```c++
#include <iostream>

enum { max = 100 };

int main() {
    int n, m;
    std::cin >> n >> m;
    int a[max][max] = {};
    int count = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            int column = i % 2 ? m - 1 - j : j;
            a[i][column] = ++count;
        }
    }
    
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            printf("%4d%s", a[i][j], (j == m - 1 ? "\n" : ""));
        }
    }
    return 0;
}
```

<hr>

[Содержание](#содержание)

## По данным числам n и m заполните двумерный массив размером n×m числами от 1 до n×m “диагоналями”, как показано в примере.
Формат входных данных
Вводятся два числа n и m, не превышающие 100.<br>
Формат выходных данных<br>
Выведите полученный массив, отводя на вывод каждого элемента ровно 4 символа.

Sample Input:
```
3 5
```
Sample Output:
```
   1   2   4   7  10
   3   5   8  11  13
   6   9  12  14  15
```

```c++
#include <iostream>

enum { max = 100 };

int main() {
    int n, m;
    std::cin >> n >> m;
    int a[max][max] = {};
    int count = 0;

    for (int k = 0; k < n + m; k++) {
        for (int i = 0; i < n + m; i++) {
            int j = k - i;
            if (j >= 0 && i >= 0 && j < m && i < n) {
                a[i][j] = ++count;
            }
        }
    }

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            printf("%4d%s", a[i][j], (j == m - 1 ? "\n" : ""));
        }
    }
    return 0;
}
```

```c++
#include <iostream>

enum { max = 100 };

int main() {
    int n, m;
    std::cin >> n >> m;
    int a[max][max] = {};
    int count = 0;
    for (int k = 0; k < n + m - 1; k++) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (i == k - j || j == k - i) {
                    a[i][j] = ++count;
                }
            }
        }
    }

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            printf("%4d%s", a[i][j], (j == m - 1 ? "\n" : ""));
        }
    }
    return 0;
}
```

<hr>

[Содержание](#содержание)

## Даны числа n и m. Форматированный вывод массива.
Заполните массив размером n × m в шахматном порядке: клетки одного цвета заполнены нулями, а другого цвета - заполнены числами натурального ряда сверху вниз, слева направо. В левом верхнем углу записано число 1.<br>
Формат входных данных<br>
Вводятся два числа n и m, не превышающие 100.<br>
Формат выходных данных<br>
Выведите полученный массив, отводя на вывод каждого элемента ровно 4 символа.

Sample Input:
```
3 5
```
Sample Output:
```
   1   0   2   0   3
   0   4   0   5   0
   6   0   7   0   8
```

```c++
#include <iostream>

enum { max = 100 };

int main() {
    int n, m;
    std::cin >> n >> m;
    int a[max][max] = {};
    int count = 0;

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if ((i + j) % 2 == 0) {
                a[i][j] = ++count;
            }
        }
    }

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            printf("%4d%s", a[i][j], (j == m - 1 ? "\n" : ""));
        }
    }
    return 0;
}
```

<hr>

[Содержание](#содержание)

## По данным числам n и m заполните двумерный массив размером n×m числами от 1 до n×m по спирали,
выходящей из левого верхнего угла и закрученной по часовой стрелке, как показано в примере.
Формат входных данных<br>
Вводятся два числа n и m, не превышающие 100.<br>
Формат выходных данных<br>
Выведите полученный массив, отводя на вывод каждого элемента ровно 4 символа.

Sample Input:
```
4 5
```
Sample Output:
```
   1   2   3   4   5
  14  15  16  17   6
  13  20  19  18   7
  12  11  10   9   8
```

```c++
#include <iostream>

enum { max = 100 };

int main() {
    int N, M;
    std::cin >> N >> M;
    int a[max][max] = {};
    int left, right, up, down, flag, counter;
    left = right = up = down = flag = counter = 0;

    while (counter < N * M) {
        if (flag == 0) {  // >
            for (int i = left; i < M - right; i++) {
                a[up][i] = ++counter;
            }
            flag = 1;
            up++;
        } else if (flag == 1) {  // v
            for (int i = up; i < N - down; i++) {
                a[i][M - right - 1] = ++counter;
            }
            flag = 2;
            right++;
        } else if (flag == 2) {  // <
            for (int i = M - right - 1; i > left - 1; i--) {
                a[N - down - 1][i] = ++counter;
            }
            flag = 3;
            down++;
        } else if (flag == 3) {  // ^
            for (int i = N - down - 1; i > up - 1; i--) {
                a[i][left] = ++counter;
            }
            flag = 0;
            left++;
        }
    }
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
            printf("%4d%s", a[i][j], (j == M - 1 ? "\n" : ""));
        }
    }

    return 0;
}
```

<hr>

[Содержание](#содержание)