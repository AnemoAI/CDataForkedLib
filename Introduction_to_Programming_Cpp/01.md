# 1. Введение в программирование (C++)

# 1.1 Вводное занятие

Всем привет!

Меня зовут Михаил Густокашин. Я работаю в Яндексе и научу вас программировать.

Зачем изучать программирование

Во-первых, это очень интересно.

Во-вторых, программирование здорово облегчает жизнь во многих профессиях. Математик, физик, химик, биолог, социолог, экономист, лингвист и любой другой специалист может взять готовую библиотеку функций, написать на её основе несложную программу и быстро решить свою задачу. И пока коллеги ведут подсчёты в Excel или на калькуляторе, специалист с навыками программирования уже будет отдыхать или думать над новой проблемой.

Ну и в-третьих, изучив программирование, можно стать программистом. Эти люди хорошо зарабатывают, их любят, о них заботятся, они работают в тёплых уютных офисах и занимаются разными интересными вещами.

Работать программистом не только приятно и прибыльно, но и полезно для общества. Компьютерные программы используются, например, для создания лекарств. А ещё — для фундаментальных исследований: так, разработчики из Яндекса помогают с расчётами для большого адронного коллайдера. Пока всё это чистая теория, но может быть, уже через несколько лет благодаря открытиям в ядерной физике под каждой раковиной появится маленькая чёрная дыра, и никому из нас больше не придётся выносить мусор.

Как изучать программирование

Самое сложное в нашей области — это первые шаги. Можно, конечно, взяться сначала за какую-нибудь большую серьёзную книгу — например, «Искусство программирования» Дональда Кнута. Но это тяжело, хоть книга и хорошая. Чтобы не получилось как в анекдоте — «вы сначала плавать научитесь, а потом мы вам воду в бассейн нальём» — начинать лучше с практики. Именно ей и будет посвящён наш курс. Мы напишем сотни несложных программ, не углубляясь в теорию. С таким опытом вы сможете потом самостоятельно справиться и с более сложными задачами.

Чему учит курс

Мы будем изучать практические основы языка C++. Научимся работать с числами, их последовательностями, таблицами, а также освоим несложные структуры данных и алгоритмы: сортировку, ассоциативные массивы, множества. У нас нет цели глубоко погрузиться во внутреннее устройство языка, поэтому даже после окончания курса в наших программах для вас останется немного необъяснимой «магии». Это нормально.

Сразу предупрежу: я не научу вас писать культовые игры для iPhone, взламывать сеть Пентагона или предсказывать биржевые курсы — хотя в в любом из этих дел вам обязательно пригодятся те базовые знания, которые вы получите. Но чтобы решить задачи по программированию на ЕГЭ или выиграть какую-нибудь несложную олимпиаду по информатике, наших занятий вполне хватит.

Почему C++

Это один из самых популярных языков программирования. Он хорош своей быстротой и универсальностью. Почти все высоконагруженные сервисы Яндекса написаны на C++, как и браузер, в котором вы, возможно, читаете этот текст, и многие другие программы. С языка C++ легко перейти на любой другой — все они в целом очень похожи. Можно заняться чистым C, чтобы писать операционные системы, драйвера и распределенные программы. Можно перейти на Java или C# и писать софт для организаций. Или можно выучить немного другой вариант Java или Objective-C и писать приложения для Android и iPhone. В любом случае после C++ осваивать новые языки вам будет гораздо легче.

Мы изучим C++11 — стандарт языка 2011 года. Из всех нынешних стандартов он самый удобный.

## Как построен курс

Он состоит из 12 видеолекций, к каждой из которых есть конспект и набор задач — их вам предстоит решать в тестирующей системе. Задачи будут проверяться автоматически и сразу. К этому занятию задач нет, к следующему будет всего две, а затем их станет больше. Если решить задачу не получается, вы всегда сможете задать вопрос. Двигаться дальше можно только когда решены все предыдущие задачи (хотя бы без «звёздочки»).

На первых занятиях мы познакомимся со средой программирования MS Visual C++ Express Edition 2013 и тестирующей системой. Затем вас ждёт первая программа, переменные и арифметические операции. После этого изучим конструкции «если», «иначе» и «пока». Следующий этап — методика отладки программ. Это важная тема, которой часто уделяют мало внимания. Отладка позволяет понять, где именно программа работает неправильно, и исправить ошибку. Потом перейдём к массивам, в том числе двумерным (таблицам), вещественным числам, функциям и строкам. Затем поговорим об  увлекательнейшем математическом явлении — рекурсии. Мы подойдём к нему с чисто программистской точки зрения, и всё будет понятно. Последние два занятия посвящены использованию готовых алгоритмов и структур данных. Всегда приятно пользоваться чужим трудом в своем деле.

## Домашнее задание 1.1

Заполните, пожалуйста, небольшую анкету, чтобы мы с вами познакомились. Ее вопросы в следующих степах. Спасибо!

# 1.2 Знакомство со средой разработки

Сегодня мы приступим к программированию, но к этому надо подготовиться.

## Установка Visual Studio

Мы будем писать программы в Microsoft Visual C++ 2017 ﻿Community ﻿Edition. Это бесплатный инструмент для некоммерческого использования, удобный и красивый. Пример на видео сделаны в Microsoft Visual C++ 2013 Express Edition, однако отличия версий невелики

Перейдите по ссылке https://www.visualstudio.com/ru/thank-you-downloading-visual-studio/?sku=Community&rel=15﻿ и скачивание начнется автоматически. ﻿Когда откроется окно выбора компонентов, то единственный флажок нужно поставить у компонента "Разработка классических приложений на C++".

Если у вас Linux или OS X, то вместо Visual Studio используйте бесплатную программу Code::Blocks. Не забудьте включить поддержку C++11 по этой инструкции https://stackoverflow.com/questions/18174988/how-can-i-add-c11-support-to-codeblocks-compiler. ﻿Если у вас есть лицензия или вы студент, то можете работать в среде CLion (производитель — JetBrains). Также лицензию можно получить в процессе успешного прохождения курса. ﻿Процесс создания проекта и запуска программ в этих средах почти аналогичен процессам в Visual Studio.

## Создание проекта

Теперь у вас есть среда разработки. Процесс написания программы называется разработкой, а среда делает его удобным. Далее необходимо создать проект, в котором вы будете писать программы. Он включает в себя файл с исходным кодом программы (собственно, инструкции, которые будет выполнять компьютер) и ненужные файлы.

Чтобы создать проект, нажмите «Файл», а затем «Создать проект». В появившемся меню выберите ﻿«Консольное приложение win32», а затем назовите как-нибудь свой проект в поле «Имя решения» в самом низу открывшегося окна.

Нажмите «Далее», а в следующем окне поставьте флажок «Пустой проект». Теперь в окне «Обозреватель решений» правой кнопкой мыши кликните на «Файлы исходного кода», затем выберите «Добавить», «Создать элемент», «Файл C++ (.cpp)» — и введите имя файла (оно может совпадать с названием проекта). Запомните, где хранится файл – потом это вам пригодится. Теперь можно начинать писать программы. Можно создать проект один раз, а затем просто писать новые программы поверх старых.

## Первая программа

Перед вами чистый лист. Ниже приведён исходный код программы, которая не делает ничего:

```c++
#include <iostream>

using namespace std;

int main() {
    // это комментарий, здесь можно писать пояснения
    return 0;
} 
```

Не углубляясь в подробности, посмотрим, из чего состоит программа. В первой строке написана команда `#include <iostream>`. Команда `#include` означает, что мы хотим обратиться к библиотеке, содержащей разные функции и разные полезные вещи, которые написали за нас другие программисты. После `#include` в треугольных скобках (знаках «<» и «>») идёт название библиотеки, в нашем случае — `iostream`. Оно расшифровывается как `«input/output stream»`, то есть «потоки ввода и вывода». С помощью этой библиотеки наша программа сможет общаться с внешним миром.

Следующая строка, `using namespace std`, говорит, что программа использует стандартное пространство имён (оно называется `std`). В C++ есть большая стандартная библиотека, и в ней содержится много разных функций, у каждой из которых есть название. Может оказаться, что мы напишем свою функцию, название которой будет совпадать со стандартной, и тогда всё сломается. Если не подключать пространство имен `std`, то ломаться ничего не будет, но тогда для вызова стандартной функции придётся писать много лишних букв. Но мы не будем называть функции теми же именами, что и стандартные, поэтому нас эта проблема не коснётся.

Если вы не поняли предыдущий абзац — это нормально и не повредит обучению, просто не забывайте писать в коде `using namespace std`.

Дальше идет `int main()`. Это основная функция нашей программы, она будет запускаться автоматически. Первое слово `int` означает, что функция будет возвращать число. В нормальной ситуации это будет `0`: другое число возвращается автоматически, если в программе что-то сломалось. Например, если она произвела деление на ноль.

Следующее слово, `main`, зарезервировано для основной функции. Когда-нибудь в наших программах будет несколько функций и тогда первой из них будет запускаться `main`. Пока же это основная и единственная наша функция. Пустые скобки означают, что она не принимает параметров от операционной системы. После круглых скобок стоит открывающая фигурная скобка — это начало блока команд, которые относятся к функции `main`.

Следующая строка содержит комментарий. Он начинается с двух знаков «/», после которых до конца строки можно писать пояснения к программе. На этом месте мы будем писать осмысленную программу, вместо комментария.

Предпоследняя строка содержит `return 0;` — команду завершения работы с кодом 0. Это значит, что программа сделала все нужные действия и успешно завершилась.

В последней строке содержится только закрывающая фигурная скобка — это окончание блока команд функции `main`.

Обратите внимание, что сейчас мы используем только маленькие латинские буквы — это не случайно. Язык C++ зависит от регистра, и слова `Main` и `main` в нём считаются разными. Пока мы будем использовать только маленькие буквы, чтобы не возникло путаницы.

```
Hello, World!
```

Итак, программа, которая не делает ничего, у нас уже есть. Теперь напишем программу, которая будет здороваться с миром:

```c++
#include <iostream>

using namespace std;

int main() {
    cout << "Hello, World!";
    return 0;
}
```

У нас появилась новая строка: `cout << “Hello, World!”`. Она выводит на экран текст `«Hello, World!»`. Разберем её подробнее.

`cout` – это объект, поток вывода, который расшифровывается как `«console output»`, то есть «вывод на экран». Если мы хотим показать на экране какой-нибудь текст, то должны поместить его в этот поток. Операция `«<<»` как раз и означает «поместить». Она похожа на стрелку, это мнемоническое правило легко запомнить. Наконец, следом идет текст в кавычках — тот, который выводится на экран. Не забывайте ставить точку с запятой там, где она есть в примерах кода.

## Запуск программы

Теперь научимся запускать программу. Для этого нажмите на зеленую стрелку рядом с надписью «Локальный отладчик Windows» или на кнопку `F5`. Если в программе есть ошибка, система сообщит вам, что запуск не удался. Ошибки будут перечислены в окне «Список ошибок». Если же всё правильно, то появится и тут же исчезнет чёрное окно консоли. Чтобы оно не исчезало, нужно поставить точку остановки на строке с командой `«return 0;»`. Для этого кликните по серой полоске в левой части экрана рядом с этой строкой. Там появится красный кружок – это и есть ваша точка остановки. Теперь при запуске программа будет останавливаться в этом месте и мы сможем посмотреть на её вывод. Чтобы окно консоли исчезло, нужно ещё раз нажать зеленую стрелочку или F5 – то есть продолжить выполнение программы.

## Сдача программ

Просто перейдите к следующим степам и скопируйте свою программу в окно ввода. Или выберите сохраненный файл с программой.

## Напишите программу, выводящую "Hello, World!". Можно скопировать ее из конспекта.

```c++
#include <iostream>

int main() {
  std::cout << "Hello, World!" << std::endl;
  return 0;
}
```

А теперь нужно поздороваться с нашей тестирующей системой. Исправьте предыдущую программу и выведите "Hello, Stepik!". 

```c++
#include <iostream>

int main() {
  puts("Hello, Stepik!");
  return 0;
}
```

# 1.3 Целые числа

На этом занятии мы научимся читать, писать и считать (в целых числах). Как первоклассники, только на компьютере, с помощью С++.

## Арифметические выражения

Сначала научимся считать. Мы уже знаем, что выводить строки можно с помощью команды `cout`. Точно так же можно выводить числа и результат вычисления выражений. Например, вот так выглядит программа, которая считает, чему равно `(2 + 3) * 5`:

```c++
#include <iostream>

using namespace std;

int main() {
    cout << (2 + 3) * 5;
    return 0;
}
```

Если запустить эту программу, то она выведет `25`. Сначала посчитается результат вычисления арифметического выражения, а затем он будет выведен. Посмотрим, какие арифметические операции умеет выполнять C++:

Обозначение операции | Что она выполняет
-|-
`+` | сложение
`−` | вычитание
`*` | умножение
`/` | деление нацело
`%` | вычисление остатка от деления

У операций на C++ тот же приоритет, что и в обычной математике. Сначала выполняется умножение, деление и вычисление остатка, затем сложение и вычитание. Влиять на порядок операций можно с помощью скобок. Минус бывает бинарный (это число минус число) и унарный (это просто минус число). Например, можно написать (−2 + 3) * 4 — это будет корректным выражением с результатом 4.

Гораздо интереснее операции деления и взятия остатка. С помощью операции деления можно узнать целую часть от деления одного числа на другое. Например, 7 / 3 будет равно 2. А с помощью операции взятия остатка от деления можно узнать остаток от деления первого числа на второе. 7 % 3 будет равен 1. Если число делится нацело, то остаток будет равен нулю, например, 8 % 4 даст 0.

Математикам стоит обратить внимание на то, что деление и подсчёт остатка для отрицательных чисел работает в C++ «неправильно». Если в C++ мы разделим отрицательное число на положительное, например, посчитаем результат операции −7 / 3, то получим −2. Фактически в C++ отрицательное число берётся по модулю, делится, а затем к результату приписывается минус.

В C++ операция взятия остатка от деления отрицательного числа на положительное, так же как и деление нацело, берёт делимое по модулю, затем происходит подсчёт остатка от деления, и к результату приписывается минус. Например, −10 % 3 будет равно −1.

## Переменные

Программа, которая всегда считает результат вычисления одного и того же выражения, довольно скучная и бестолковая. Полезная программа должна оперировать с различными данными без внесения изменений в код.

Можно представить себе, что программа сидит в кабинете, в который входит конвейер с входными значениями, а выходит конвейер с выводом (это поток cout). В кабинете стоят коробки с хламом, оставшемся от предыдущих жильцов, но мы можем ими воспользоваться, чтобы хранить в этих коробках свои вещи. Переменная, по сути, и является такой коробкой.  «Объявить переменную x» — это как взять какую-нибудь из коробочек и подписать её буквой x. «Присвоить значение переменной x» — это вытряхнуть содержимое из коробочки x и положить в неё новое значение.

Пока мы будем работать только с целочисленными переменными. Пусть мы хотим взять из горы неподписанных специальных коробочек для целых чисел две штуки и назвать их x и y. На языке C++ это будет записано как:

```
int x, y;
```

Слово int означает, что переменные будут целочисленные, затем перечисляются имена создаваемых переменных через запятую. В конце ставится точка с запятой.

Если мы хотим присвоить значение переменной, то слева следует написать имя присваиваемой переменной, затем знак равно, а справа — арифметическое выражение, в котором могут использоваться числа и другие переменные. Например:

```
x = 2 + 3;
y = x * 4;
```

В результате выполнения этих операций в переменной x окажется число 5, а в переменной y — число 20.
Переменные также можно считывать с клавиатуры. Для этого по аналогии с потоком вывода cout используется поток cin (console input). Этот как раз тот конвейер, по которому к нам приезжают числа. Как и в случае cout, вводимые значения разделяются стрелочками, только теперь они направлены вправо, так как мы забираем данные из потока cin. Вот пример программы, которая считывает два числа a и b и выводит их сумму:

```c++
#include <iostream>

using namespace std;

int main() {
    int a, b;
    cin >> a >> b;
    cout << a + b;
    return 0;
}
```

Обратите внимание, что при чтении из cin стрелочки направлены в противоположную по сравнению с cout сторону. Мы «забираем» данные из потока ввода cin и «кладём» в cout. Если мы хотим считать несколько переменных, то при перечислении их следует разделять стрелочками. Строку

```c++
cin >> a >> b;
```
можно заменить строками

```c++
cin >> a;
cin >> b;
```

которые будут делать то же самое.

В C++ на целые числа типа int отводится 4 байта (32 бита). А это значит, что различных целых чисел может быть только 232. Числа могут принимать значения от −231 до 231−1 (это примерно от минус двух миллиардов до двух миллиардов). Если в процессе вычислений произойдёт выход за эти пределы, то результат будет посчитан неверно. Использование принципиально больших чисел требует ухищрений, поэтому в наших задачах все числа и все правильные промежуточные вычисления не будут выходить за эти пределы.

## Изощрённый вывод

В cout также можно класть несколько значений, причём числа и строки могут идти вперемешку. Рассмотрим это на примере. Пусть нам нужно считать два числа и вывести их сумму и разность в виде арифметического выражения, каждое в отдельной строке. Решение этой задачи выглядит так:

```c++
#include <iostream>

using namespace std;

int main() {
      int a, b;
      cin >> a >> b;
      cout << a << " + " << b << " = " << a + b << endl;
      cout << a << " - " << b << " = " << a - b;
      return 0;
}
```

Если ввести числа 1 и 2, то на экран будет выведено:

```
1 + 2 = 3
1 − 2 = -1
```

Все различные значения, которые мы хотим вывести с помощью cout, следует разделять стрелочками <<. На место переменных и арифметических выражений будет подставлено их значение, а всё, что выводится в кавычках, останется без изменения. Особого внимания заслуживает слово `endl` — так в C++ делается переход на новую строку.

Если вы выводите несколько чисел, то обязательно добавляйте между ними пробел, иначе они склеятся и ответ будет неправильным.

## Пример решения задачи

Предположим, пассажир самолёта перепутал дверь туалета с выходом и случайно вышел на высоте. Приземлился он через t секунд, и нужно определить, на какой высоте летел самолёт.

Эту задачу можно решать так, как обычно решаются задачи по физике. Ускорение свободного падения нам известно (поскольку наши числа целые, то мы возьмём его равным 10). Мы посчитаем скорость (v), на которой пассажир достиг земли, затем среднюю скорость (vm, это конечная скорость, поделенная на 2) и, зная среднюю скорость и время, легко рассчитаем расстояние.

```c
#include <iostream>

using namespace std;

int main() {
    int t, v, g = 10;
    cin >> t;
    v = g * t;
    int vm = v / 2;
    int s = vm * t;
    cout << s;
    return 0;
}
```

В этом решении мы заводили переменные там, где они нам понадобились впервые, а также сразу клали в переменную заданное число при её создании.

## Пример решения сложной задачи на арифметику

Рассмотрим, как решить совсем простую на первый взгляд задачу, которая превращается в достаточно сложную из-за того, что мы мало что умеем и знаем. Задача формулируется так. Даны два числа a и b, причём `b > 0`. Надо посчитать целую часть от деления a на b, округлённую вверх. Напомню, что при делении C++ округляет результат вниз, не так, как нам нужно.

Первая идея — разделить с округлением вниз и прибавить к результату единицу. Эта идея неправильная: она не работает, если одно число делится на другое нацело. Так 8 / 2 + 1 будет равно 5, хотя правильный ответ 4.

Следующая идея, правильная, — прибавить к числу что-нибудь и затем разделить его с округлением вниз. Осталось понять, что же нужно прибавлять к числу. Если число a делится на b нацело, то результат не должен изменяться, значит, нельзя прибавлять к числу a что-либо большее b − 1 (если прибавить больше, то результат деления получится уже больше правильного). Можно ли прибавить что-нибудь меньшее b − 1? Рассмотрим «худший» случай, когда остаток от деления a на b равен единице, например, a = 11, b = 5. Тогда мы сложим a и b − 1 (получим 15) и разделим на 5 — получится правильный ответ 3.

Наше решение будет работать и для отрицательных чисел за счёт особенностей деления на C++. Полный код решения выглядит так:

```c++
#include <iostream>

using namespace std;

int main() {
     int a, b;
     cin >> a >> b;
     cout << (a + b - 1) / b;
     return 0;
}
```

## Как решать задачи

У каждой задачи в вашем домашнем задании есть условие, формат входных и выходных данных и примеры. В условии содержится описание задачи, которую нужно решить. В формате входных данных сказано, какие числа вводятся и в каком порядке они даны, а также указаны ограничения на эти числа. Гарантируется, что чисел будет столько, сколько нужно, и они будут удовлетворять ограничениям. Вам нужно решить задачу только для указанных ограничений. Как программа будет работать для чисел, не удовлетворяющих ограничениям — абсолютно неважно, таких тестов не будет. В формате выходных данных указывается, что и в каком порядке программа должна выводить — ничего, кроме этого, в решении быть не должно.

Примеры к задаче нужны для лучшего понимания условия и первоначальной самопроверки. Естественно, программа должна работать не только на примерах, но и на любых других допустимых входных данных.

Если программа работает правильно, то она получит статус OK. Если программа получила другой статус — вам следует придумать тесты, удовлетворяющие ограничениям, и проверить работу своей программы. Обязательно найдётся ошибка. Наша тестирующая система работает правильно. Наши тесты правильные. Правильные ответы к нашим тестам правильные. Это точно. Мы проверяли много раз. И не только мы.

## Правила оформления кода

Программы нужно писать красиво, иначе их будет неудобно читать. На реальной работе программы много раз читаются и переписываются другими людьми, поэтому соблюдать правила оформления кода очень важно. Если в общем, то главное правило — «делайте как в образце». Если конкретно:

1. После открывающейся фигурной скобки добавляется отступ в начале строки, на строке с закрывающейся фигурной скобкой отступ убирается.

2. Все бинарные операции (+,−, *, /, %, =, <<, >>) окружаются пробелами.

3. После унарного минуса пробел не ставится (−5 нужно писать слитно).

4. Перед знаками препинания (запятая и точка с запятой) пробел не ставится, после — ставится.

5. После открывающейся и перед закрывающейся круглой скобкой пробел не ставится.

6. Если в условии задачи сказано «на вход даются два числа A и B», то переменные, в которые считываются эти числа, должны называться так же, но маленькими буквами (a и b соответственно).

Мы будем очень благодарны вам, если вы будете соблюдать правила оформления кода. 

## Задачи 1.3

## Белочки и орешки - 1

N белочек нашли K орешков и решили разделить их поровну. Определите, сколько орешков достанется каждой белочке.

Формат входных данных

На вход дается два целых положительных числа N и K, каждое из которых не превышает 10000.

Формат выходных данных

Выведите одно целое число - ответ на задачу.

```c++
#include <iostream>

int main() {
    int n, k;
    std::cin >> n >> k;
    int result = k / n;
    std::cout << result << std::endl;
    return 0;
}
```

## Белочки и орешки - 2

N белочек нашли K орешков и решили разделить их поровну. Определите, сколько орешков останется после того, как все белочки возьмут себе равное количество орешков.

Формат входных данных

На вход дается два целых положительных числа N и K, каждое из которых не превышает 10000.

Формат выходных данных

Выведите одно целое число - ответ на задачу.

```c++
#include <iostream>

int main() {
    int n, k;
    std::cin >> n >> k;
    int result = k - (k / n) * n;
    std::cout << result << std::endl;
    return 0;
}
```

## Последняя цифра

Дано натуральное число, выведите его последнюю цифру.

Формат входных данных

На вход дается натуральное число N, не превосходящее 10000.

Формат выходных данных

Выведите одно целое число - ответ на задачу.

```c++
#include <iostream>

int main() {
    int n;
    std::cin >> n;
    int result = n % 10;
    std::cout << result << std::endl;
    return 0;
}
```

## Первая цифра двузначного числа

Дано двузначное число. Выведите его первую цифру (число десятков)

Формат входных данных

На вход дается натуральное двузначное число N.

Формат выходных данных

Выведите одно целое число - ответ на задачу.

```c++
#include <iostream>

int main() {
    int n;
    std::cin >> n;
    int result = n / 10;
    std::cout << result << std::endl;
    return 0;
}
```

## Число десятков

Дано целое неотрицательное число N, определите число десятков в нем (предпоследнюю цифру числа). Если предпоследней цифры нет, то можно считать, что число десятков равно нулю.

Формат входных данных

На вход дается целое положительное число N (0 ≤ N ≤ 1000000).

Формат выходных данных

Выведите одно целое число - ответ на задачу.

```c++
#include <iostream>

int main() {
    int n;
    std::cin >> n;
    int result = (n % 100) / 10;
    std::cout << result << std::endl;
    return 0;
}
```

## Сумма цифр трехзначного числа

Дано целое трехзначное число. Найдите сумму его цифр.

Формат входных данных

На вход дается число от 100 до 999.

Формат выходных данных

Выведите одно целое число - ответ на задачу.

```c++
#include <iostream>

int main() {
    int n;
    std::cin >> n;
    int result = 0;
    while (n > 0) {
        result += n % 10;
        n /= 10;
    }
    std::cout << result << std::endl;
    return 0;
}
```

## Следующее четное

На вход дается натуральное число N. Выведите следующее за ним четное число

Формат входных данных

На вход дается целое положительное число N, не превышающее 10000.

Формат выходных данных

Выведите одно целое число - ответ на задачу.

```c++
#include <iostream>

int main() {
    int n;
    std::cin >> n;
    int result = ((n / 2) + 1) * 2;
    std::cout << result << std::endl;
    return 0;
}
```

## Парты

В некоторой школе решили набрать три новых математических класса и оборудовать кабинеты для них новыми партами. За каждой партой может сидеть два учащихся. Известно количество учащихся в каждом из трех классов. Выведите наименьшее число парт, которое нужно приобрести для них. Каждый класс сидит в своем кабинете.

Формат входных данных

Программа получает на вход три целых неотрицательных числа: количество учащихся в каждом из трех классов (числа не превышают 1000).


Формат выходных данных

Выведите одно целое число - ответ на задачу.

```c++
#include <iostream>

int main() {
    int p[3];
    std::cin >> p[0] >> p[1] >> p[2];
    int result = 0;
    for (int x : p) {
        result += x / 2 + x % 2;
    }
    std::cout << result << std::endl;
    return 0;
}
```

```c++
#include <iostream>

using namespace std::cin;
using namespace std::cout;

int main() {
    int a, b, c;
    cin >> a >> b >> c;
    cout << (++a / 2) + (++b / 2) + (++c / 2);
    return 0;
}
```

## Покупка пирожков

Пирожок в столовой стоит A рублей и B копеек. Определите, сколько рублей и копеек нужно заплатить за N пирожков.

Формат входных данных

Программа получает на вход три числа: A, B, N - целые, положительные, не превышают 10000.

Формат выходных данных

Программа должна вывести два числа через пробел: стоимость покупки в рублях и копейках.

```c++
#include <iostream>

int main() {
    int a, b, n;
    std::cin >> a >> b >> n;
    const int result[2]{a * n + b * n / 100, b * n % 100};
    printf("%d %d\n", result[0], result[1]);
    return 0;
}
```

## Электронные часы

Электронные часы показывают время в формате h:mm:ss (от 0:00:00 до 23:59:59), то есть сначала записывается количество часов, потом обязательно двузначное количество минут, затем обязательно двузначное количество секунд. Количество минут и секунд при необходимости дополняются до двузначного числа нулями.

С начала суток прошло N секунд. Выведите, что покажут часы.

Формат входных данных

На вход дается натурально число N, не превосходящее $10^7(10000000)$.

Формат выходных данных

Выведите ответ на задачу.

```c
#include <iostream>

int main() {
    int n;
    std::cin >> n;
    const int result[3]{(n / 3600) % 24, (n / 60) % 60, n % 60};
    printf("%02d:%02d:%02d\n", result[0], result[1], result[2]);
    return 0;
}
```

## Разность времен

Даны значения двух моментов времени, принадлежащих одним и тем же суткам: часы, минуты и секунды для каждого из моментов времени. Известно, что второй момент времени наступил не раньше первого. Определите, сколько секунд прошло между двумя моментами времени.

Формат входных данных

Программа на вход получает три целых числа: часы, минуты, секунды, задающие первый момент времени и три целых числа, задающих второй момент времени.

Формат выходных данных

Выведите число секунд между этими моментами времени.

```c
#include <iostream>

struct TIME {
   private:
    int hours;
    int minutes;
    int seconds;

   public:
    TIME(int hours = 0, int minutes = 0, int seconds = 0) {
        this->hours = hours;
        this->minutes = minutes;
        this->seconds = seconds;
    };
    int total_seconds(TIME a) {
        int res = a.hours * 3600 + a.minutes * 60 + a.seconds;
        return res;
    };
    TIME difference(TIME a, TIME b) {
        int n = total_seconds(b) - total_seconds(a);
        TIME c;
        c.hours = (n / 3600) % 24;
        c.minutes = (n / 60) % 60;
        c.seconds = n % 60;
        return c;
    };
};

int main() {
    int h, m, s;
    std::cin >> h >> m >> s;
    TIME a(h, m, s);
    std::cin >> h >> m >> s;
    TIME b(h, m, s);

    TIME result = result.difference(a, b);

    printf("%d\n", result.total_seconds(result));
    return 0;
}
```

```c
#include <iostream>

struct Timemoment {
    int hrs;
    int mins;
    int secs;
    int ttlTime() {
        return 3600 * hrs + 60 * mins + secs;
    }
};

int main() {
    Timemoment t1, t2;
    std::cin >> t1.hrs >> t1.mins >> t1.secs 
             >> t2.hrs >> t2.mins >> t2.secs;
    std::cout << t2.ttlTime() - t1.ttlTime();
    return 0;
}
```

## МКАД

Длина Московской кольцевой автомобильной дороги —109 километров. Байкер Вася стартует с нулевого километра МКАД и едет со скоростью V километров в час. На какой отметке он остановится через T часов?

Формат входных данных

Программа получает на вход целые числа V и T. Если V > 0, то Вася движется в положительном направлении по МКАД, если же значение V < 0, то в отрицательном. 0 ≤ T ≤ 1000, -1000 ≤ V ≤ 1000

Формат выходных данных

Программа должна вывести целое число от 0 до 108 — номер отметки, на которой остановится Вася.

```c++
#include <iostream>

enum { mkad = 109 };

int main() {
    int v, t;
    std::cin >> v >> t;
    int result = ((v * t) % mkad + mkad) % mkad;
    printf("%d\n", result);
    return 0;
}
```

## Симметричное число


Дано четырехзначное число. Определите, является ли его десятичная запись симметричной. Если число симметричное, то выведите 1, иначе выведите любое другое целое число. Число может иметь меньше четырех знаков, тогда нужно считать, что его десятичная запись дополняется слева незначащими нулями.

Формат входных данных

Вводится единственное число.

Формат выходных данных

Выведите одно целое число - ответ на задачу.

```c++
#include <iostream>

int main() {
    int n;
    std::cin >> n;
    int n1 = n / 1000;
    int n2 = n / 100 % 10;
    int n3 = n / 10 % 10;
    int n4 = n % 10;
    
    int result = (n1 == n4) * (n2 == n3);
    // int result = !(n1 - n4) * !(n2 - n3);

    printf("%d\n", result);
    return 0;
}
```

```c++
#include <iostream>
using namespace std;

int main(){
	int n, a, b, c, d, reverse_n;
	cin >> n;
	a = n / 1000;
	b = n / 100 % 10;
	c = n / 10 % 10;
	d = n % 10;
	reverse_n = d * 1000 + c * 100 + b * 10 + a;
	cout << n - reverse_n + 1;
    return 0;
}
```

## Улитка

Улитка ползет по вертикальному шесту высотой H метров, поднимаясь за день на A метров, а за ночь спускаясь на B метров. На какой день улитка доползет до вершины шеста?


Формат входных данных

Программа получает на вход целые неотрицательные числа H, A, B, причем H > B. Числа не превосходят 100.

Формат выходных данных

Программа должна вывести одно натуральное число. Гарантируется, что A > B.

```c++
#include <iostream>

int main() {
    int h, a, b;
    std::cin >> h >> a >> b;

    int result = 0, count = 0;

    while (result + a < h) {
        result += a - b;
        count++;
    }

    printf("%d\n", count + 1);
    return 0;
}
```

```c++
#include <iostream>

/* bydlo language */
#define sprosi std::cin 
#define skazhi std::cout
#define op << std::endl
#define v >>
#define na <<
#define iz <<
#define _i_ &&
#define ili ||
#define poka while(
#define ne !
#define dumai {}
#define verni return
#define uhodi return
#define ravno ==
#define ne_ravno !=
#define esli if(
#define to )
#define inache else
#define glavnoe main()
#define nachni {
#define konchi }
#define chetno % 2 == 0
#define nechetno %2 != 0
#define bolshe >
#define menshe <
#define delai )
#define dlya for (
#define nakin ++
#define otozhmi --
#define cho_tam_v *
#define dalshe continue
#define zabei break
#define dai new
#define zabirai delete
/* types */
#define fakt bool
#define bukva char
#define chislo int
#define bez_znaka unsigned
#define veshch double
#define stroka char*
#define fraza const char*
#define nichego void
#define v_fakt (bool)
#define v_chislo (int)
#define v_bez_znaka (unsigned)
#define v_veshch (double)
#define da true
#define net false

chislo glavnoe 
nachni
    chislo h, a, b;
    sprosi v h v a v b;
    skazhi iz ((h-b)+(a-b)-1)/(a-b) op;
    verni 0;
konchi
```

# 1.4 Условный оператор

Сегодня мы изучим условный оператор. Он соответствует естественным понятиям «если» и «иначе».

## Пример программы с условным оператором

Что такое условный оператор? Это очень просто: если выполнено условие, то нужно выполнять одно действие, а иначе — другое. По-английски «если» звучит как “if”, а «иначе» как “else”. Пусть перед нами стоит задача вывести модуль числа, не пользуясь функцией abs, с помощью конструкции if-else. В сегодняшних примерах мы будем писать не программы полностью, а только те команды, которые непосредственно выполняются — остальное вы можете дописать сами. Итак, решение задачи:

```c++
int a;
cin >> a;
if (a > 0) {
    cout << a;
} else {
    cout << -a;
}
```

Что можно понять из этой программы? Первые две строки мы уже хорошо понимаем — это создание переменной и её считывание. В следующей строке записано «если a больше нуля». Если это условие выполнено, то будут выполняться действия, заключённые в фигурные скобки после if. Если же условие не выполнено, то будут выполняться команды, заключённые в фигурные скобки после слова else (иначе). Таким образом, выполнение программы разветвляется, и будет выполнена только одна из двух ветвей. После окончания блока else выполнение программы будет продолжаться.

Можно попробовать решить задачу без использования команды else:

```c++
int a;
cin >> a;
if (a > 0) {
    cout << a;
}
if (a < 0) {
    cout << -a;
}
```

Но эта программа не будет работать, если ввести число 0. Не выполнится ни один из условных операторов.

## Логические выражения

Рассмотрим подробнее, как работает условный оператор. Он должен выглядеть как if (<логическое выражение>) { … }. Сначала пишется слово if, затем в круглых скобках пишется логическое выражение, а затем в фигурных скобках перечисляются команды, которые должны быть выполнены.

Что такое логическое выражение? Это выражение, которое может принимать значения «истина» (“true”) и «ложь» (“false”). Логическое выражение имеет вид <арифметическое выражение> <сравнение> <арифметическое выражение>. Например, если у нас есть переменные x и y с какими-то значениями, то логическое выражение x + y < 3 * y в качестве первого арифметического выражения имеет x + y, в качестве знака сравнения < (меньше), а второе арифметическое выражение в нём 3 * y.

В логических выражениях допустимы следующие знаки сравнений:

Знак сравнения |Описание
-|-
`==` | равно
`!=` | не равно
`<`  | меньше
`>`  | больше
`<=` | меньше или равно
`>=` | больше или равно

Очень часто при использовании сравнения на равенство (==) возникает ошибка: вместо двух значков «равно» можно написать один, и это будет корректная программа, но делать она будет совсем не то, чего мы от нее ждём. Например, попробуем написать программу, которая считывает два числа и выводит Yes, если они одинаковые, и No в противном случае:

```c
int a, b;
cin >> a >> b;
if (a = b) {
    cout << "Yes";
} else {
    cout << "No";
}
```
 
Эта программа будет выводить Yes, даже если числа различны (и b не равно нулю). Чтобы отловить эту ошибку, нужно внимательно читать предупреждения, которые выдаёт компилятор. Если переменная сравнивается с каким-то арифметическим выражением, можно использовать приём, облегчающий борьбу с ошибкой: достаточно писать выражение слева от сравнения, а переменную — справа. Например, команда a * 2 = b внутри if просто выдаст ошибку (а b = a * 2 ошибку не выдаст и будет работать неправильно).
Вложенные инструкции

Внутри блока инструкций могут находиться другие ветвления программы. Посмотрим сразу на примере. По заданному количеству глаз и ног нужно научиться отличать кошку, паука, морского гребешка и жучка. У морского гребешка бывает более сотни глаз, а у пауков их восемь. Также у пауков восемь ног, а у морского гребешка их нет совсем. У кошки четыре ноги (и длинный хвост), а у жучка — шесть ног, но глаз у обоих по два. Решение:

```c++
int eyes, legs;
cin >> eyes >> legs;
if (eyes >= 8) {
      if (legs == 8) {
            cout << "spider";
      } else {
            cout << "scallop";
      }
} else {
      if (legs == 6) {
            cout << "bug";
      } else {
            cout << "cat";
      }
}
```

Если вложенных условных операторов несколько, то, к какому из них относится `else`, компилятор понимает по количеству закрывшихся фигурных скобок. Обратите внимание, как красиво выглядит пример: в нем правильно расставлены отступы. Напомню правило: если открылась фигурная скобка, то со следующей строки добавляется один отступ (если вы его случайно удалили, то можно поставить новый с помощью кнопки `tab`), а в строке, где есть закрывающаяся фигурная скобка, один отступ убирается. Программы с правильно расставленными отступами приятнее читать и понимать, а программы с неправильно расставленными отступами тестирующая система не примет на проверку.
Ещё в нашей программе очень красиво названы переменные. Нужно стараться называть переменные так, чтобы был понятен их смысл. Лучше всего использовать английские слова (не транслит!), их стандартные аббревиатуры и сокращения. Если переменная, например, означает «количество слов», то её подойдёт название `“word_cnt”`. Здесь `cnt` — сокращение от слова `“count”` (количество), а `word` — «слово». Отдельные слова следует разделять символом подчёркивания. Длина названия переменной не должна превышать 10–12 символов. Если вы знаете английский язык недостаточно хорошо, вам поможет сервис Яндекс.Перевод.

## Логические операторы

Иногда возникает необходимость проверить более сложное условие, чем просто сравнение между собой двух чисел. Для этого можно воспользоваться логическими операторами. Посмотрим на примере. Задача похожа на предыдущую: программе на вход дается количество глаз и ног у животного, и она должна пугаться, если это паук (с 8 глазами и 8 ногами). Решение:

```c
int eyes, legs;
cin >> eyes >> legs;
if (eyes == 8 && legs == 8) {
      cout << "AAAAA!!!";
}
```

Логический оператор `&&` — это «и». То есть условие будет верным, если и левое, и правое логические выражения истинны одновременно.

Также существует логическая связка «или», которая обозначается символами `«||»`, и унарная операция «отрицание» — её знак `«!»` ставится перед выражением.

В логических выражениях также существует порядок действий. Сначала выполняются отрицания, затем все арифметические операции, затем все «и», только потом все «или». На порядок действий также можно влиять с помощью скобок.

Рассмотрим ещё один пример. Как известно, в России есть Новый год и старый Новый год. Новый год отмечается по григорианскому календарю, а старый Новый год — по юлианскому. В юлианском календаре високосность года проверяется очень легко: если номер года делится на 4, то он является високосным. Напишем программу, которая определяет количество дней в году по его номеру:

```c++
int year;
cin >> year;
if (year % 4 == 0) {
      cout << 366;
} else {
      cout << 365;
}
```

Чтобы проверить любое число на делимость, необходимо посчитать остаток от деления и сравнить его с нулём. Теперь решим более сложную задачу: посчитать количество дней в году по григорианскому календарю. Правила определения високосности года в григорианском календаре такие: год является високосным, если его номер делится на 4, но не делится на 100 или делится на 400.

В этой задаче логическое выражение получается очень длинным, и его можно разбить на части, сохранив некоторые промежуточные значения в переменных. Для хранения результата логического выражения используется переменная типа bool. Переменные такого типа могут хранить лишь два возможных значения: «истина» и «ложь». Они обозначаются, соответственно, true и false.

```c++
int year;
cin >> year;
bool mod400 = year % 400 == 0;
if (year % 4 == 0 && year % 100 != 0 || mod400) {
    cout << 366;
} else {
    cout << 365;
}
```

Здесь в переменной `mod400` хранится «истина», если остаток от деления номера года был равен нулю, и «ложь» в противном случае. Если логическое выражение получилось слишком длинным и не помещается на экран, то можно разбить его на несколько строк — программа продолжит работать нормально.

Если вы боитесь перепутать приоритеты логических операций, то можно для уверенности поставить скобки. Наше выражение можно записать так: `((year % 4 == 0 && year % 100 != 0) || mod400)`.

## Конструкция «иначе-если»

В некоторых ситуациях нужно выбрать больше чем из двух вариантов. Пусть нам звонит кто-то из друзей и предлагает заняться чем-нибудь. Числом 1 обозначим друга Ваню, который зовет нас играть в футбол, числом 2 — друга Сашу, который зовет нас вместе учить C++. А если нам звонит кто-нибудь другой, то мы сидим дома и смотрим сериал. Нужно по введенному числу сказать, чем мы будем заниматься. Решение этой задачи, использующее два оператора if, выглядит так:

```c++
int who_call;
cin >> who_call;
if (who_call == 1) {
      cout << "Football!!";
} else if (who_call == 2) {
      cout << "C++!!!!!11";
} else {
      cout << "Show";
}
```

Конструкция `else if` имеет смысл «иначе-если». Дойти до сравнения цифры с двойкой можно только в случае, если уже произошло сравнение с единицей и мы пошли по ветви «иначе». Последний `else`, таким образом, выполнится только после того, как число сравнилось и с единицей, и с двойкой и ни одно из этих сравнений не было верным.
Благодаря таким конструкциям можно обработать большое количество различных вариантов поведения программы.

## Вредные советы

Советы из этой рубрики принесут много ошибок в программе, но мы обязаны сказать правду.

Первый вредный совет касается логических выражений. C++ умеет рассматривать арифметические выражения как логические, при этом 0 рассматривается как «ложь», а любое другое число как «истина». Например, задачу про високосный год можно решить так:

```c++
int year;
cin >> year;
if (year % 4) {
    cout << 365;
} else {
    cout << 366;
}
```
 
Пользоваться этим очень нежелательно, так как это ухудшает читаемость программы и повышает вероятность ошибки.

Второй вредный совет похож на первый, только в обратную сторону. Мы можем использовать результат вычисления логических выражений в арифметических. При этом считается, что «ложь» соответствует нулю, а «истина» — единице. Посмотрим на такой пример: пусть нужно вывести 1, если число чётное, и ноль в противном случае.

```c++
int a;
cin >> a;
cout << (a % 2 == 0);
```

Употреблять такие конструкции — плохой тон.

## Задачи 1.4

## Даны два целых числа. Выведите значение наибольшего из них. Если числа равны, выведите любое из них.

```c++
#include <iostream>

int main() { 
    int a, b;

    std::cin >> a >> b;

    std::cout << (a > b ? a : b) << std::endl;

    return 0; 
}
```

## Даны два целых числа. Программа должна вывести единицу, если первое число больше второго, двойку, если второе больше первого, или ноль, если они равны.

```c++
#include <iostream>

int main() {
    int a, b;

    std::cin >> a >> b;

    std::cout << (a > b ? 1 : 2) * (a != b) << std::endl;

    return 0;
}
```

## Даны три целых числа. Найдите наибольшее из них (программа должна вывести ровно одно целое число). Под наибольшим в этой задаче понимается число, которое не меньше, чем любое другое.

```c++
#include <iostream>

int max (int a, int b) {
    return a > b ? a : b;
}

int main() {
    int a, b, c;

    std::cin >> a >> b >> c;

    int result = max(a, max(b,c));

    std::cout << result << std::endl;

    return 0;
}
```

```c++
#include <iostream>

int main() {
    int a, b, c;
    std::cin >> a >> b >> c;
    if (a < b) a = b;
    if (a < c) a = c;
    std::cout << a;
    return 0;
}
```

## Даны три натуральных числа A, B, C. Определите, существует ли треугольник с такими сторонами. Если треугольник существует, выведите строку YES, иначе выведите строку NO.
Треугольник — это три точки, не лежащие на одной прямой.

```c++
#include <iostream>

int main() {
    int a, b, c;

    std::cin >> a >> b >> c;

    int result = ((a + b) > c) && ((a + c) > b) && ((c + b) > a);

    std::cout << (result ? "YES" : "NO") << std::endl;

    return 0;
}
```

## Даны три целых числа. Определите, сколько среди них совпадающих. Программа должна вывести одно из чисел: 3 (если все совпадают), 2 (если два совпадает) или 0 (если все числа различны).

```c++
#include <iostream>

int main() {
    int a, b, c;

    std::cin >> a >> b >> c;

    int result = (a == b) + (a == c) + (c == b);

    std::cout << (result == 1 ? 2 : result) << std::endl;

    return 0;
}
```

## Шахматная ладья ходит по горизонтали или вертикали. Даны две различные клетки шахматной доски, определите, может ли ладья попасть с первой клетки на вторую одним ходом.

```c++
#include <iostream>

int main() {
    int a, b, c, d;

    std::cin >> a >> b >> c >> d;

    int result = (a == c) || (b == d);

    std::cout << (result ? "YES" : "NO") << std::endl;

    return 0;
}
```

## Шахматный король ходит по горизонтали, вертикали и диагонали, но только на 1 клетку. Даны две различные клетки шахматной доски, определите, может ли король попасть с первой клетки на вторую одним ходом.

```c++
#include <cmath>
#include <iostream>

int main() {
    int a, b, c, d;

    std::cin >> a >> b >> c >> d;

    int result = abs(a - c) <= 1 && abs(b - d) <= 1;

    std::cout << (result ? "YES" : "NO") << std::endl;

    return 0;
}
```

## Шахматный слон ходит по диагонали. Даны две различные клетки шахматной доски, определите, может ли слон попасть с первой клетки на вторую одним ходом.

```c++
#include <cmath>
#include <iostream>

int main() {
    int a, b, c, d;

    std::cin >> a >> b >> c >> d;

    int result = abs(a - c) == abs(b - d);

    std::cout << (result ? "YES" : "NO") << std::endl;

    return 0;
}
```

## Шахматный ферзь ходит по диагонали, горизонтали или вертикали. Даны две различные клетки шахматной доски, определите, может ли ферзь попасть с первой клетки на вторую одним ходом.

```c++
#include <cmath>
#include <iostream>

int main() {
    int a, b, c, d;

    std::cin >> a >> b >> c >> d;

    int result = abs(a - c) == abs(b - d) || (a == c) || (b == d);

    std::cout << (result ? "YES" : "NO") << std::endl;

    return 0;
}
```

## Шахматный конь ходит буквой “Г” — на две клетки по вертикали в любом направлении и на одну клетку по горизонтали, или наоборот. Даны две различные клетки шахматной доски, определите, может ли конь попасть с первой клетки на вторую одним ходом.

```c++
#include <cmath>
#include <iostream>

int main() {
    int a, b, c, d;

    std::cin >> a >> b >> c >> d;

    int result = abs(a - c) == 1 && abs(b - d) == 2 || abs(a - c) == 2 && abs(b - d) == 1;

    std::cout << (result ? "YES" : "NO") << std::endl;

    return 0;
}
```

## Шоколадка имеет вид прямоугольника, разделенного на N×M долек. Шоколадку можно один раз разломить по прямой на две части. Определите, можно ли таким образом отломить от шоколадки ровно K долек.

```c++
#include <cmath>
#include <iostream>

int main() {
    int a, b, c;

    std::cin >> a >> b >> c;

    int result = (c % a == 0 || c % b == 0) && a * b > c;

    std::cout << (result ? "YES" : "NO") << std::endl;

    return 0;
}
```

## Яша плавал в бассейне размером N×M метров и устал. В этот момент он обнаружил, что находится на расстоянии X метров от одного из длинных бортиков (не обязательно от ближайшего) и Y метров от одного из коротких бортиков. Какое минимальное расстояние должен проплыть Яша, чтобы выбраться из бассейна на бортик?

```c++
#include <cmath>
#include <iostream>

int min(int a, int b) { return a < b ? a : b; }
void swap(int* a, int* b) {
    int tmp = *a;
    *a = *b;
    *b = tmp;
}

int main() {
    int a, b, c, d;

    std::cin >> a >> b >> c >> d;

    if (a > b) swap(&a, &b);

    int result = min(c, min(d, min(abs(a - c), abs(b - d))));

    std::cout << result << std::endl;

    return 0;
}
```

## Дано три числа. Упорядочите их в порядке неубывания.

```c++
#include <iostream>

void swap(int* a, int* b) {
    int tmp = *a;
    *a = *b;
    *b = tmp;
}

int main() {
    int a, b, c;

    std::cin >> a >> b >> c;

    if (a > b) swap(&a, &b);
    if (a > c) swap(&c, &a);
    if (b > c) swap(&c, &b);

    printf("%d %d %d", a, b, c);

    return 0;
}
```

### Есть две коробки, первая размером A1×B1×C1, вторая размером A2×B2×C2. Определите, можно ли разместить одну из этих коробок внутри другой, при условии, что поворачивать коробки можно только на 90 градусов вокруг ребер.

Формат входных данных<br>
Программа получает на вход числа A1, B1, C1, A2, B2, C2.<br>
Формат выходных данных<br>
Программа должна вывести одну из следующих строчек:<br>
Boxes are equal, если коробки одинаковые,<br>
The first box is smaller than the second one, если первая коробка может быть положена во вторую,<br>
The first box is larger than the second one, если вторая коробка может быть положена в первую,<br>
Boxes are incomparable, во всех остальных случаях.<br>


```c++
#include <iostream>

void swap(int& a, int& b) {
    int tmp = a;
    a = b;
    b = tmp;
}

void sort_three(int& a, int& b, int& c) {
    if (a > b) swap(a, b);
    if (a > c) swap(c, a);
    if (b > c) swap(c, b);
}

int main() {
    int a, b, c;
    std::cin >> a >> b >> c;
    int a1, b1, c1;
    std::cin >> a1 >> b1 >> c1;

    sort_three(a, b, c);
    sort_three(a1, b1, c1);

    int result = 0;
    if (a == a1 && b == b1 && c == c1)
        result = 3;
    else if (a <= a1 && b <= b1 && c <= c1)
        result = 1;
    else if (a >= a1 && b >= b1 && c >= c1)
        result = 2;

    switch (result) {
        case 1:
            puts("The first box is smaller than the second one");
            break;
        case 2:
            puts("The first box is larger than the second one");
            break;
        case 3:
            puts("Boxes are equal");
            break;
        default:
            puts("Boxes are incomparable");
            break;
    }
    return 0;
}
```

# 1.5 Цикл while

Сегодня мы научимся писать код, который позволяет автоматически повторять одни и те же действия несколько раз. В программировании повторение действий называется циклом.

## Цикл while

«While» переводится как «пока» и в программировании означает «пока условие верно, нужно выполнять следующие действия». В жизни цикл «пока» встречается очень часто. Например, вам срочно понадобились фиолетовые кроссовки для вечеринки. Как описать ваши действия для их получения? «Пока не найдёшь фиолетовые кроссовки – ходи по магазинам. Как только найдёшь – покупай». `While` очень похож на `if`, но если `if` выполняет действия один раз, то `while` будет делать их до тех пор, пока выполнено условие.

Рассмотрим этот цикл на примере. Есть число `N`. Необходимо вывести все числа по возрастанию от `1` до `N`. Как решить эту задачу? Нужно завести счётчик (переменную `i`), который будет равен текущему числу. Вначале это единица. Пока значение счетчика не превысит `N`, необходимо выводить его текущее значение и каждый раз увеличить его на единицу. В виде программы это записывается так:

```c++
int i, n;
cin >> n;
i = 1;
while (i <= n) {
    cout << i << " ";
    i = i + 1;
} 
```

Когда выполнение программы доходит до закрывающей фигурной скобки, то происходит возврат к строке с `while` и проверка условия. Если оно верно, то блок команд выполняется ещё раз, а если нет, исполнение программы продолжается для команд, находящихся после блока команд `while`.

Рассмотрим ещё один пример. Например, компания друзей хочет купить пиццу. Чтобы не платить за доставку, нужно послать кого-нибудь в пиццерию. Кого? Самого младшего! Более формальная постановка задачи такая: среди последовательности чисел нужно найти и вывести минимальное. Последовательность состоит из положительных чисел и оканчивается нулём.

Как такую задачу будет решать человек? Каждый раз когда ему называют число, он сравнивает его с тем минимумом, который встречался раньше, и, если новое число ещё меньше, то запоминает его. Такие действия нужно продолжать пока числа в последовательности не закончатся. Вначале ему нужно запомнить самое первое названное число. В конце — назвать последнее, которое запомнил.

```c++
int min, now;
cin >> now;
min = now;
while (now != 0) {
    if (now < min) {
        min = now;
    }
    cin >> now;
}
cout << min; 
```

## Подсчёт суммы последовательности чисел

Решим ещё одну задачу: те же друзья, которые покупали пиццу, решили посчитать, хватит ли у них денег? Каждый говорит, сколько у него есть, и нужно посчитать, сколько их в сумме. Последовательность состоит из положительных чисел и оканчивается нулём, нужно вывести сумму всех элементов в последовательности.

Эта задача также очень легко решается человеком: достаточно помнить сумму уже названных чисел и каждое следующее число просто прибавлять к этой сумме. Сначала нужно запомнить ноль (числа ещё не заданы). Программа будет выглядеть так:

```c++
int sum = 0, now;
cin >> now;
while (now != 0) {
    sum = sum + now;
    cin >> now;
}
cout << sum;
```

## Цифры числа

Задачи на подсчёт суммы, минимумов и максимумов встречаются в жизни очень часто. Например, задача по выявлению счастливого билетика. Если сумма цифр в первой половине номера совпадает с суммой цифр во второй половине, то билет считается счастливым (и его нужно съесть).

Научимся решать эту задачу по двум заданным половинам номера билета.

Мы легко можем научиться узнавать последнюю цифру числа — для этого достаточно посчитать остаток от его деления на 10. Также мы можем отбросить последнюю цифру числа — для этого нужно поделить число на 10 нацело. Таким образом мы сможем поочередно рассмотреть все цифры числа справа налево и остановиться тогда, когда цифры в числе закончатся (оно станет равным нулю). Сумму цифр можно посчитать так же, как и в предыдущей задаче. И сделать это нужно для каждой из половинок номера билета.

```c++
int part1, part2;
cin >> part1 >> part2;
int sum1 = 0, sum2 = 0;
while (part1 != 0) {
    sum1 = sum1 + part1 % 10;
    part1 = part1 / 10;
}
while (part2 != 0) {
    sum2 = sum2 + part2 % 10;
    part2 = part2 / 10;
}
if (sum1 == sum2) {
    cout << "Lucky ticket";
} else {
    cout << "unlucky :(";
}
```

## Отладка программ

Мы дошли уже до достаточно сложных программ.

Если программа работает неправильно, то найти ошибку методом пристального взгляда иногда бывает непросто. Для облегчения поиска ошибок можно воспользоваться средствами отладки программ. На самом деле, на втором занятии мы уже пользовались такими средствами — когда устанавливали точку остановки (`breakpoint`) на команде `return 0`. Когда программа доходит до точки остановки, её выполнение прерывается и можно посмотреть текущие значения всех переменных.

Таким образом, если мы хотим понять, чему равны значения переменных в какой-то момент исполнения нашей программы, то можем установить breakpoint на той строке, где хотим прерваться. При запуске программы по `F5` будут выполнены все команды до этой строки, а сама строка выделится красным. Если навести курсор на название любой переменной в программе, то будет показано её значение в момент до выполнения текущей строки. Чтобы продолжить выполнение программы нужно нажать `F5` ещё раз — выполнение будет идти до очередного `breakpoint`.

Также можно выполнять программу пошагово, строку за строкой. Для этого нужно нажимать клавишу `F10`. При нажатии клавиши выполнится одна строка, выделенная в этот момент красным, и произойдёт переход к следующей команде.

Чаще всего отладка кода состоит в том, чтобы поставить `breakpoint` в начале потенциально ошибочного кода, запустить программу, проверить, что всё считалось правильно, а затем выполнять программу пошагово, смотреть на значения переменных и ловить момент, когда что-то пойдёт не так.

## Вечный цикл

С помощью цикла `while` очень легко сделать вечный цикл: для этого достаточно написать условие, которое никогда не будет выполнено. Лет 30 назад, когда все работали в DOS, этого было достаточно, чтобы намертво повесить систему. Сейчас, к сожалению, можно просто нажать на крестик.

Например, можно взять задачу про вывод всех чисел от 1 до 100 и забыть об увеличении счётчика.

```c++
int i;
i = 1;
while (i <= 100) {
      cout << i << " ";
}
```

Эта программа будет работать вечно, потому что счётчик всегда будет равен единице. Чтобы прекратить работу программы можно нажать `shift+F5` (одновременно) в окне Visual Studio. Лучше не закрывать чёрное окошко крестиком – так может что-нибудь сломаться.

## Инструкции break и continue

Для управления поведением цикла можно использовать две инструкции, которые позволяют досрочно прерывать выполнение цикла или начинать выполнение инструкций цикла сначала.

Первая команда называется `break`. После её выполнения работа цикла прекращается (как будто не было выполнено условие цикла). Осмысленное использование конструкции `break` возможно, только если выполнено какое-то условие, то есть `break` должен вызываться только внутри `if` (находящегося внутри цикла). Использование `break` – плохой тон, по возможности, следует обходиться без него. Рассмотрим пример вечного цикла, выход из которого осуществляется с помощью `break`. Для этого решим задачу о выводе всех целых чисел от `1` до `N`. Использовать `break` таким образом ни в коем случае не нужно, это просто пример:

```c++
int n, i;
i = 1;
while (1) {
    cout << i;
    i = i + 1;
    if (i > 100)
        break;
}
```

Команда `continue` начинает исполнение тела цикла заново, начиная с проверки условия. Её нужно использовать, если начиная с какого-то места в теле цикла и при выполнении каких-то условий дальнейшие действия нежелательны. В задаче о покупке фиолетовых кроссовок использование `continue` может выглядеть так: мы заходим в очередной магазин в поисках фиолетовых кроссовок и продолжаем эти действия пока не найдём то, что нужно. Но если в магазине очередь в сто человек, то мы сразу же идём в следующий — независимо от того, есть ли в этом магазине кроссовки.

Приведём пример использования `continue` (хотя при решении этой задачи можно и нужно обходиться без него): дана последовательность чисел, оканчивающаяся нулём. Необходимо вывести все положительные числа из этой последовательности. Решение:

```c
int now;
now = -1;
while (now != 0) {
    cin >> now;
    if (now <= 0)
        continue;
    cout << now << " ";
}
```

В этом решении есть интересный момент: перед циклом переменная инициализируется заведомо подходящим значением. Команда вывода будет выполняться только в том случае, если не выполнится условие в `if`.

## Задачи 1.5

## По данному целому числу N распечатайте все квадраты натуральных чисел, не превосходящие N, в порядке возрастания.

```c++
#include <iostream>

int main() {
    int n, i = 1;
    std::cin >> n;

    while (i * i <= n) {
        printf("%d ", i * i);
        i++;
    }

    return 0;
}
```

## Дано целое число, не меньшее 2. Выведите его наименьший натуральный делитель, отличный от 1.

```c++
#include <iostream>

int main() {
    int n, i = 2;
    std::cin >> n;

    while (i <= n) {
        if (n % i == 0) {
            printf("%d", i);
            break;
        }
        i++;
    }
    return 0;
}
```

## По данному числу N распечатайте все целые степени двойки, не превосходящие N, в порядке возрастания.

```c++
#include <iostream>

int main() {
    int n, i = 1;
    std::cin >> n;

    while (i <= n) {
        printf("%d ", i);
        i *= 2;
    }
    return 0;
}
```

## Дано натуральное число N. Выведите слово YES, если число N является точной степенью двойки, или слово NO в противном случае.

```c++
#include <iostream>

int main() {
    int n, i = 1, res = 1;
    std::cin >> n;

    while (i <= n) {
        res = i;
        i *= 2;
    }
    printf("%s", res == n ? "YES" : "NO");
    return 0;
}
```

## Программа получает на вход последовательность целых неотрицательных чисел, каждое число записано в отдельной строке. Последовательность завершается числом 0, при считывании которого программа должна закончить свою работу и вывести количество членов последовательности (не считая завершающего числа 0).
Числа, следующие за числом 0, считывать не нужно.

```c++
#include <iostream>

int main() {
    int n, count = 0;

    while (std::cin >> n && n != 0) count++;

    printf("%d", count);
    return 0;
}
```

## Определите сумму всех элементов последовательности, завершающейся числом 0.

```c
#include <iostream>

int main() {
    int n, sum = 0;

    while (std::cin >> n && n != 0) sum += n;

    printf("%d", sum);
    return 0;
}
```

## Последовательность состоит из натуральных чисел и завершается числом 0. Определите значение наибольшего элемента последовательности.

```c++
#include <iostream>

int main() {
    int n, max = 0;

    while (std::cin >> n && n != 0) {
        if (n > max) max = n;
    }
    printf("%d", max);
    return 0;
}
```

## Последовательность состоит из натуральных чисел и завершается числом 0. Определите, какое количество элементов этой последовательности, равны ее наибольшему элементу.

```c++
#include <iostream>

int main() {
    int n, max = 0, count = 0;

    while (std::cin >> n && n != 0) {
        if (n > max) {
            max = n;
            count = 0;
        }
        if (n == max) count++;
    }
    printf("%d", count);
    return 0;
}
```

## Последовательность состоит из натуральных чисел и завершается числом 0. Определите значение второго по величине элемента в этой последовательности, то есть элемента, который будет наибольшим, если из последовательности удалить наибольший элемент.

```c++
#include <iostream>

int main() {
    int n, max = 0, sec_max = 0;

    while (std::cin >> n && n != 0) {
        if (n >= max) {
            sec_max = max;
            max = n;
        } else if (sec_max < n)
            sec_max = n;
    }
    printf("%d", sec_max);
    return 0;
}
```

## Последовательность Фибоначчи определяется так:

$F(0) = 0, F(1) = 1, …, F(n) = F(n−1) + F(n−2).$

По данному числу N определите N-е число Фибоначчи F(N).

```c++
#include <iostream>

int main() {
    size_t count;
    int f0 = 0, f1 = 1, res = 1;

    std::cin >> count;

    for (size_t i = 1; i < count; i++) {
        res = f0 + f1;
        f0 = f1;
        f1 = res;
    }

    printf("%d", res);
    return 0;
}
```

## Последовательность Фибоначчи определяется так: 

$F(0) = 0, F(1) = 1, …, F(n) = F(n−1) + F(n−2).$

Дано натуральное число A. Определите, каким по счету числом Фибоначчи оно является, то есть выведите такое число N, что F(N) = A. Если А не является числом Фибоначчи, выведите число -1.

```c++
#include <iostream>

int main() {
    int f0 = 0, f1 = 1, res = 1, number, count = 1;

    std::cin >> number;

    for (; res < number; count++) {
        res = f0 + f1;
        f0 = f1;
        f1 = res;
    }

    printf("%d", f1 == number ? count : -1);
    return 0;
}
```

## Дана последовательность натуральных чисел, завершающаяся числом 0. Определите, какое наибольшее число подряд идущих элементов этой последовательности равны друг другу. Если не нашлось ни одной пары, тройки и т.д. элементов, равных друг другу, то программа должна вывести число 1.

```c++
#include <iostream>

int main() {
    int n, mem = 0, count = 0, max_count = 1;

    while (std::cin >> n && n != 0) {
        if (n != mem) {
            count = 0;
            mem = n;
        }
        if (n == mem) count++;
        if (max_count < count) max_count = count;
    }

    printf("%d", max_count);
    return 0;
}
```

## Элемент последовательности называется локальным максимумом, если он строго больше предыдущего и последующего элемента последовательности. Первый и последний элемент последовательности не являются локальными максимумами.

Дана последовательность натуральных чисел, завершающаяся числом 0. Определите количество строгих локальных максимумов в этой последовательности.

```c++
#include <iostream>

int main() {
    int n, n0 = 0, n1 = 0, n2 = 0, count = 0;

    while (std::cin >> n && n != 0) {
        n0 = n1;
        n1 = n2;
        n2 = n;
        if (n0 < n1 && n1 > n2 && n0 != 0) count++;
    }

    printf("%d", count);
    return 0;
}
```

## Определите наименьшее расстояние между двумя локальными максимумами последовательности натуральных чисел, завершающейся числом 0. Если в последовательности нет двух локальных максимумов, выведите число 0.

Начальное и конечное значение при этом локальными максимумами не считаются.

Расстоянием считается количество пробелов между элементами. В качестве примера смотрите первый тест.

```c++
#include <iostream>

int main() {
    int n, n0 = 0, n1 = 0, n2 = 0;
    int max_count = 0, len = 0, min_len = 0;

    while (std::cin >> n && n != 0) {
        n0 = n1;
        n1 = n2;
        n2 = n;
        if (n0 < n1 && n1 > n2 && n0 != 0) {
            if (min_len == 0) min_len = len;
            if (len < min_len) min_len = len;
            max_count++;
            len = 0;
        }
        if (max_count) len++;
    }

    printf("%d", min_len);
    return 0;
}
```

# 1.6 Действительные числа

Сегодняшнее занятие достаточно простое — мы научимся работать с числами с плавающей точкой (то есть с действительными числами).

## Как хранятся действительные числа в компьютере

Для хранения действительных чисел в памяти компьютера отводится определённое количество бит. Действительное число хранится в виде знака (плюс или минус), мантиссы и экспоненты. Что такое мантисса и экспонента лучше объяснить на примере: масса Земли равна $5.972*10^{24}$ килограмм. Здесь $5.972$ — мантисса, а $24$ — экспонента.

При выводе больших (или очень маленьких) чисел в программе на C++ можно увидеть на экране запись типа `5.972E23`. Сначала выводится мантисса, затем — буква `E`, а затем — экспонента. Запись представлена в десятичной системе счисления. В таком же формате можно вводить большие или очень маленькие действительные числа. Этот формат называется экспоненциальной записью числа. 

Мы будем работать с типом `double` (с числами двойной точности), который занимает `8` байт. Один бит отводится под знак числа, `11` под экспоненту и `52` под мантиссу. С помощью `52` бит можно хранить числа длиной до `15-16` десятичных цифр. Таким образом, независимо от того, какая у числа экспонента, правильные значения будут иметь только первые `15` цифр. В примере с массой Земли точно заданы первые `4` цифры, таким образом, погрешность составляет $10^{20}$ килограмм. Это довольно большая погрешность. Чтобы масса Земли с точностью до первых четырёх знаков изменилась, на неё нужно дополнительно поселить миллиард миллиардов довольно упитанных людей.

Таким образом, можно сказать, что числа в компьютере хранятся не с абсолютной, а с относительной погрешностью (то есть погрешность зависит от значения хранимого числа).

То, что числа хранятся неточно, создаёт нам множество проблем.

Создание, ввод и вывод действительных переменных

Работа с действительными переменными очень похожа на работу с целыми числами, только вместо типа int мы используем тип double. Чтобы создать две действительные переменные x и y, нужно написать:

```c
double x, y;
```

Если мы хотим использовать действительные числа в коде программы, то в качестве разделителя целой и дробной части нужно использовать точку:

```
y = 3.1415;
```

Считываются действительные переменные так же, как целые:

```c++
std::cin >> x;
```
При выводе действительных чисел нужно помнить о некоторых особенностях. В большинстве задач требуется выводить числа с заданной точностью. Например, если от нас требуется вывести число с точностью $10^{-3}$, значит, необходимо вывести три знака после десятичной точки. Числа с заданным количеством знаков после точки выводятся так:

```c++
#include <iomanip>
using namespace std;
cout << setprecision(3) << fixed;
```

Первая команда устанавливает точность, а вторая сообщает, что все числа нужно выводить с точкой (а не в экспоненциальной форме). После выполнения этой команды все действительные числа будут выводиться с точностью до 3 знаков после точки. Чтобы эти команды работали, необходимо подключить библиотеку `iomanip`.

## Операции с действительными числами

Описывая эти операции, мы будем считать, что все числа в арифметических выражениях действительные. Случай, когда в выражении используются целые и действительные числа вперемешку, будет рассмотрен в следующем разделе.

Над действительными числами можно выполнять те же операции, что и над целыми (кроме взятия остатка). При этом деление действительных чисел даёт уже настоящий, не округлённый результат.

Также для действительных чисел определена функция `abs`, которая возвращает модуль числа.

Целые и действительные числа в одном арифметическом выражении

Если мы хотим сохранить в действительной переменной целое число, то достаточно присвоить переменной типа `double` значение целочисленного арифметического выражения. 

Есть одна неприятность: если оба операнда (те, что стоят слева и справа от знака операции) целые, то операция будет выполняться в целых числах. Например, если `x` – действительное число, `а`, `k` и `m` – целые и равны 2 и 3, то после выполнения строки `x = k/m` в переменной `x` окажется число `0.0`. Деление будет выполнено в целых числах, а уже после этого результат будет преобразован в действительное число. 

Чтобы избавиться от этой проблемы, необходимо явно привести один из операндов к типу `double`. Чтобы привести переменную к другому типу в C++ имя типа записывается в круглых скобках перед именем переменной. Чтобы в x оказался правильный результат, можно написать `x = (double) k/m`. Таким образом, у нас будет происходить вычисление выражения 2.0/3, а если один из операндов будет типа `double`, то второй также приведётся к этому типу.

## Из действительных в целые

При переводе из действительных чисел в целые дробная часть теряется. Есть несколько способов потерять дробную часть. Чтобы использовать эти функции, необходимо подключить библиотеку cmath. В нашей программе, кроме `#include <iostream>`, нужно в следующей строке написать `#include <cmath>`.

### Способ 1

Функция `trunc`, которая просто отбрасывает дробную часть числа и выглядит так: `n = trunc(x);`

### Способ 2

Функция `floor`, которая округляет число в меньшую сторону и выглядит так: `n = floor(x);`

### Способ 3

Функция `ceil`, которая округляет число в большую сторону и выглядит так: `n = ceil(x);`

### Способ 4

Функция `round`, которая округляет число по математическим правилам и выглядит так: `n = round(x);`

Чтобы разница между способами была понятнее, приведём таблицу с примерами:

![01](/Introduction_to_Programming_Cpp/img/01_01.png)

## Полезные функции библиотеки cmath

Все функции библиотеки cmath принимают параметры типа double и возвращают значения типа double. Разобьём их по типам.

![01](/Introduction_to_Programming_Cpp/img/01_02.png)

В C++ нет стандартного имени для константы `π`. Самый универсальный способ посчитать её, который будет работать во всех версиях компилятора, это взять арктангенс единицы и умножить его на `4`. Записывается это как `atan(1) * 4`.

__Во всех задачах этого занятия следует выводить числа с шестью знаками после точки.__

## Задачи 1.6

## Дано положительное действительное число X. Выведите его дробную часть.

```c++
#include <cmath>
#include <iostream>

int main() {
    double n;

    std::cin >> n;

    double result = n - trunc(n);

    std::cout << result;
    return 0;
}
```

```c++
#include <iostream>

int main() {
    double n;

    std::cin >> n;

    double result = n - (int)n;

    std::cout << result;
    return 0;
}
```

## Дано положительное действительное число X. Выведите его первую цифру после десятичной точки.

```c++
#include <iostream>

int main() {
    double n;

    std::cin >> n;

    double result = (int)(n * 10) % 10;

    std::cout << result;
    return 0;
}
```

## Даны длины сторон треугольника. Вычислите площадь треугольника.

```c++
#include <iostream>
#include <cmath>

int main() {
    double a, b, c;

    std::cin >> a >> b >> c;

    double p = (a + b + c) / 2;
    double result = sqrt(p * (p - a) * (p - b) * (p - c));

    std::cout << result;
    return 0;
}
```

## Процентная ставка по вкладу составляет P процентов годовых, которые прибавляются к сумме вклада в конце года. Вклад составляет X рублей Y копеек. Определите размер вклада через год.


При решении этой задачи нельзя пользоваться условными инструкциями и циклами.

```c++
#include <iostream>

int main() {
    double p, x, y;

    std::cin >> p >> x >> y;

    double rub = x * (1 + p / 100);
    int res_rub = (int)rub;
    double cop = y * (1 + p / 100) + rub * 100 - res_rub * 100;
    res_rub += (int)cop / 100;
    int res_cop = (int)cop % 100;

    printf("%d %d", res_rub, res_cop);
    return 0;
}
```

```c++
#include <iostream>

int main() {
    int p, x, y;
	std::cin >> p >> x >> y;
	x = (x * 100 + y) * (p + 100) / 100;
	std::cout << x / 100 << " " << x % 100;
  return 0;
}
```

## Процентная ставка по вкладу составляет P процентов годовых, которые прибавляются к сумме вклада через год. Вклад составляет X рублей Y копеек. Определите размер вклада через K лет.

```c++
#include <iostream>

int main() {
    int p, x, y, k;
    std::cin >> p >> x >> y >> k;

    for (int i = 0; i < k; i++) {
        int res = (x * 100 + y) * (p + 100) / 100;
        x = res / 100;
        y = res % 100;
    }
    printf("%d %d", x, y);

    return 0;
}
```

```c++
#include <iostream>

int main() {
    double p, x, y;
    int k;
    std::cin >> p >> x >> y >> k;
    
    double sum = (x * 100 + y);
    
    while (k--) sum = int(sum + (sum * p) / 100);
    
    std::cout << int(sum / 100) << " " << sum - int(sum/100)*100;
}
```

## Определите среднее значение всех элементов последовательности, завершающейся числом 0.

```c++
#include <iostream>

int main() {
    int n, count = 0;
    double result = 0;
    while (std::cin >> n && n != 0) {
        result += n;
        count++;
    }
    std::cout.precision(9);
    std::cout << result / count;
    return 0;
}
```

## Дана последовательность натуральных чисел x1, x2, ..., xn. Стандартным отклонением называется величина

![01](/Introduction_to_Programming_Cpp/img/01_03.png)

где

![01](/Introduction_to_Programming_Cpp/img/01_04.png)

среднее значение последовательности.

Определите стандартное отклонение для данной последовательности натуральных чисел, завершающейся числом 0.

```c++
#include <cmath>
#include <iostream>
#include <vector>

int main() {
    int n, count = 0;
    std::vector<int> a;
    double mean = 0;
    while (std::cin >> n && n != 0) {
        a.push_back(n);
        mean += n;
        count++;
    }
    mean /= count;

    double result = 0;

    for (int i = 0; i < count; i++) {
        result += (a[i] - mean) * (a[i] - mean);
    }

    result = sqrt(result / --count);

    printf("%.11lf\n", result);

    return 0;
}
```

```c++
#include <cmath>
#include <iomanip>
#include <iostream>

int main() {
    using namespace std;
    // входное число, счетчик чисел, сумма чисел, сумма квадратов чисел
    int n, cnt = 0, sum = 0, sum2 = 0;
    // результат - стандартное отклонение
    double res;
    while (cin >> n && n != 0) {
        cnt++;
        // находим сумму и сумму квадратов
        sum += n;
        sum2 += n * n;
    }
    // для увеличения точности все возможные операции до
    // деления выполняем над целыми
    res = sqrt((double)(cnt * sum2 - sum * sum) / (cnt * (cnt - 1)));  // средне квадратичное отклонение
    cout << setprecision(11) << fixed;
    cout << res;
    return 0;
}
```

## Дан многочлен 

$P(x)=a_n \cdot x^n + a_{n−1} \cdot x^{n−1} + … + a_1 \cdot x + a_0$ и число x. Вычислите значение этого многочлена, воспользовавшись схемой Горнера:

$P(x)=(…(((a_nx + a_{n−1})x + a_{n−2})x + a_{n−3}) … )x+ a_0$

Формат входных данных

Сначала программе подается на вход целое неотрицательное число n ≤ 20, затем действительное число x, затем следует n+1 вещественное число — коэффициенты многочлена от старшего к младшему.

```c++
#include <iomanip>
#include <iostream>

int main() {
    using namespace std;
    size_t count;
    double n, x, result = 0;
    cin >> count >> x;

    for (size_t i = 0; i <= count; i++) {
        cin >> n;
        result *= x;
        result += n;
    }
    cout << result;
    return 0;
}
```

## Даны действительные коэффициенты a, b, c, при этом a ≠ 0 . Решите квадратное уравнение ax2 + bx + c = 0 и выведите все его корни.

Формат входных данных<br>
Вводятся три действительных числа.<br>
Формат выходных данных<br>
Если уравнение имеет два корня, выведите два корня в порядке возрастания, если один корень — выведите одно число, если нет корней — не выводите ничего.

